<?php
/**
 * ======================================================================
 * SKAI SINGLE-FILE MAP (Ctrl+F these tags)
 * ----------------------------------------------------------------------
 * [BOOT]        Joomla guards, imports, app/input/doc init, security headers
 * [ACCESS]      Membership & public-game gating
 * [CONFIG]      JSON config load/normalize/validate + lottery_id resolution
 * [DATA]        DB fetch: draws, saved sets, meta, user history
 * [LOGIC]       Pure computation (Skip/Hit, MCMC, AI helpers) - no HTML/DB
 * [SCORING]     Backtest + optimizer scoring + ranking
 * [SAVE]        Save predictions / save templates
 * [STATE]       Build UI-ready variables + safe escaping
 * [JS-INJECT]   window.lottoConfig and other PHP?JS bridges
 * [CSS]         Consolidated in-file style block
 * [HTML]        Page markup / cards / Sorcerer output
 * [JS]          Main frontend logic + event wiring
 * ======================================================================
 */

// ========================================================================
// [BOOT] JOOMLA SETUP + BASE SECURITY
// ========================================================================

defined('_JEXEC') or die;

use Joomla\CMS\Factory;
use Joomla\CMS\Uri\Uri;
use Joomla\CMS\Session\Session;
use Joomla\CMS\HTML\HTMLHelper;
use Joomla\Database\ParameterType;
use Joomla\CMS\Date\Date;

/* Ensure per-block $app / $in (each source is isolated) */
$app = Factory::getApplication();
$in  = $app->getInput();

/* Register SKAI assets into the real <head> (non-blocking) */
$doc = Factory::getDocument();

// Set canonical URL for SEO (Google picks up this as the authoritative URL)
// Includes all query parameters as they represent different content/games
try {
    $uri = Uri::getInstance();
    // Ensure HTTPS for canonical URL to match security policy
    $uri->setScheme('https');
    $canonicalUrl = $uri->toString();
    $doc->addHeadLink($canonicalUrl, 'canonical');
} catch (\Throwable $e) {
    // Canonical URL is optional - continue if it fails
}

// Only register CSS/JS if the physical files exist, to avoid 404s on missing assets.
$skaiCssPath = JPATH_ROOT . '/media/com_lottoexpert/css/skai-consolidated.css';
if (is_file($skaiCssPath)) {
    $doc->addStyleSheet('/media/com_lottoexpert/css/skai-consolidated.css', ['version' => 'auto']);
}

$skaiJsPath = JPATH_ROOT . '/media/com_lottoexpert/js/skai-ui-init.js';
if (is_file($skaiJsPath)) {
$doc->addScript('/media/com_lottoexpert/js/skai-ui-init.js', ['version' => 'auto'], ['defer' => true]);
}

// A11y: visually-hidden utility and live region updater (head-safe)
$doc->addStyleDeclaration(
    '.skai-visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0;}'
);
$doc->addScriptDeclaration(
    "(function(){if(typeof window.setLive!=='function'){window.setLive=function(msg){try{var el=document.getElementById('skai-live');if(el){el.textContent=String(msg||'');}}catch(_){}};}})();"
);

// Enable detailed error reporting only when site debug is enabled
try {
    $isDebug = Factory::getConfig()->get('debug');
} catch (\Throwable $e) { $isDebug = false; }
if ($isDebug) {
    ini_set('display_errors', '1');
    ini_set('display_startup_errors', '1');
    error_reporting(E_ALL);
}

ini_set('error_log', '/home/oscara/web/lottoexpert.net/public_html/administrator/logs/skai_error.log');

// Content-Security-Policy header (safe assembly; origins only, no paths)
$cspParts = [
    "default-src 'self'",
    "base-uri 'self'",
    "object-src 'none'",
    "frame-ancestors 'self'",
    // Keep inline/eval allowances for Sorcerer & current inline scripts (feature preservation)
    "script-src 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval' blob: data: https://code.jquery.com https://cdn.datatables.net https://www.googletagmanager.com https://www.gstatic.com https://cdn.jsdelivr.net https://www.google.com https://www.google-analytics.com https://pagead2.googlesyndication.com https://securepubads.g.doubleclick.net https://googleads.g.doubleclick.net https://fundingchoicesmessages.google.com",
    "script-src-elem 'self' 'unsafe-inline' 'unsafe-eval' 'wasm-unsafe-eval' blob: data: https://code.jquery.com https://cdn.datatables.net https://www.googletagmanager.com https://www.gstatic.com https://cdn.jsdelivr.net https://www.google.com https://www.google-analytics.com https://pagead2.googlesyndication.com https://securepubads.g.doubleclick.net https://googleads.g.doubleclick.net https://fundingchoicesmessages.google.com",
    "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://cdn.datatables.net",
    "font-src 'self' https://fonts.gstatic.com",
    "img-src 'self' data: https://cdn.datatables.net https://www.google.com https://www.googletagmanager.com https://www.google-analytics.com https://www.gstatic.com https://pagead2.googlesyndication.com https://tpc.googlesyndication.com https://securepubads.g.doubleclick.net https://googleads.g.doubleclick.net",
    "connect-src 'self' blob: data: https://cdn.jsdelivr.net https://storage.googleapis.com https://www.google.com https://www.gstatic.com https://www.google-analytics.com https://region1.google-analytics.com https://analytics.google.com https://www.googletagmanager.com https://pagead2.googlesyndication.com https://tpc.googlesyndication.com https://securepubads.g.doubleclick.net https://googleads.g.doubleclick.net https://fundingchoicesmessages.google.com",
    "worker-src 'self' blob:",
    "frame-src 'self' https://www.google.com https://www.gstatic.com https://pagead2.googlesyndication.com https://securepubads.g.doubleclick.net https://googleads.g.doubleclick.net",
];

if ($app->isClient('site')) {
    $app->setHeader('Content-Security-Policy', implode('; ', $cspParts) . ';', true);
}

// GET-side success notice after PRG (?ok=saved&src=...&rid=...)
try {
    if ((string)$in->getString('ok', '') === 'saved') {
        $src = preg_replace('/[^a-z0-9_\-]/i', '', (string)$in->getString('src', 'skip_hit')) ?: 'skip_hit';
        $app->enqueueMessage('Saved to your dashboard - (' . $src . ')', 'message'); // cleaned separator
    }
} catch (\Throwable $__) { /* ignore */ }



// ========================================================================
// [ACCESS] MEMBERSHIP / PUBLIC-GAME GATING
// ========================================================================
/* SKAI: Access-control helper - determine if current user is allowed for this game */


// [ADDED] Additional non-breaking security headers
$app->setHeader('X-Content-Type-Options', 'nosniff', true); // prevent MIME sniffing
$app->setHeader('Referrer-Policy', 'strict-origin-when-cross-origin', true); // privacy-friendly referrers
$app->setHeader('Permissions-Policy', "geolocation=(), camera=(), microphone=(), fullscreen=(self)", true); // restrict powerful features explicitly (modern syntax)

// Secure session cookies (will only apply if PHP session not started; Joomla often starts it earlier)
if (session_status() === PHP_SESSION_NONE) {
    session_set_cookie_params([
        'lifetime' => 0,
        'path'     => '/',
        'domain'   => '',
        'secure'   => true,   // requires HTTPS; OK for lottoexpert.net
        'httponly' => true,
        'samesite' => 'Lax',
    ]);
}

// A11y live region (polite). Output AFTER headers so CSP/etc always send cleanly.
echo '<div id="skai-live" class="skai-visually-hidden" aria-live="polite" aria-atomic="true"></div>';


/* SKAI: Access-control helper - determine if current user is allowed for this game */
$currUser   = Factory::getUser();
$userGroups = $currUser->groups ?? [];

// Current lottery game ID (e.g. 113 = Mega Millions).
$gameIdRaw = $in->getString('game_id', '');
$gameId    = (int) $gameIdRaw;


// Public games where guests can use SKAI (game IDs as strings for strict compare)
$publicGameIds = [];

// Master switch:
//   true  = SKAI is members-only (group 14 only, no public games for guests)
//   false = Guests can use SKAI on games in $publicGameIds, members on all.
$skaiMembersOnly = false;

// Is this game publicly accessible for guests?
$isPublicGame = in_array((string) $gameId, $publicGameIds, false);

// Configure which Joomla groups are allowed to use SKAI for *any* game.
// 14 = LottoExpert paid / full member group.
$allowedGroups = [14];

if ($currUser->guest) {
    if ($skaiMembersOnly) {
        // Members-only mode: guests are never allowed.
        $userIsInAllowedGroup = false; // FIX: guests blocked when members-only is enabled
    } else {
        // Mixed mode: guests allowed only on explicitly public games.
        $userIsInAllowedGroup = $isPublicGame;
    }
} else {

    if ($skaiMembersOnly) {
        // Members-only mode: user must be in allowed group(s) (e.g. 14).
        $userIsInAllowedGroup = !empty(array_intersect($allowedGroups, $userGroups));
    } else {
        // Mixed mode: allowed if game is public OR user is in allowed group(s).
        $userIsInAllowedGroup =
            $isPublicGame || !empty(array_intersect($allowedGroups, $userGroups));
    }
}


// Flag: who can USE SKAI features on this page (run analysis, see results)
$skaiUsable = (bool) $userIsInAllowedGroup;

// Flag: who can SAVE to "My LottoExpert" (only group 14 members)
$saveable = !$currUser->guest && !empty(array_intersect($allowedGroups, $userGroups));


// Load config JSON (APCu-cached with auto-invalidation by filemtime)
$masterJsonPath = '/home/oscara/web/lottoexpert.net/public_html/lottery_skip_config.json';

// Daily digit-based lotteries live in a separate catalog JSON (do NOT merge schemas).
$dailyJsonPath  = '/home/oscara/web/lottoexpert.net/public_html/dailylotteries.json';

// Daily bridge (normalizes daily rows into SKAI canonical config shape)
$dailyBridgePath = '/home/oscara/web/lottoexpert.net/public_html/skai_daily_bridge.php';
if (is_file($dailyBridgePath)) {
    require_once $dailyBridgePath;
} else {
    // Non-fatal: SKAI can still operate on master config-only.
    if (!empty($isDebug)) {
        error_log('[SKAI] Missing daily bridge include: ' . $dailyBridgePath);
    }
}

// Daily helpers are loaded via skai_daily_bridge.php (Option 2).
// Do not duplicate the functions inline here; it increases merge risk and can trigger parse errors.

// ========================================================================
// [CONFIG] LOAD / NORMALIZE / VALIDATE CONFIG + RESOLVE IDS

// =====================================================================
// [EVALUATION] SKAI EVALUATION SYSTEM - FULLY INTEGRATED
// =====================================================================
// Complete evaluation-driven ranking system built directly into SKAI
// NO EXTERNAL FILES NEEDED - Everything in this single file
//
// QUICK START:
//   1. Replace your old SKAI file with this integrated version
//   2. Access: http://yoursite.com/path/to/skai?install_eval=1
//   3. Follow on-screen instructions to create 7 database tables
//   4. Remove ?install_eval=1 from URL and use SKAI normally
//
// FEATURES (All Built-In):
//   ✓ Instrumentation - Per-number score breakdowns logged to DB
//   ✓ Backtest - Walk-forward validation (Recall@20, NDCG@20, MWR)
//   ✓ Attribution - Miss analysis with reason codes and sensitivity
//   ✓ Calibration - Monotonic probability mapping for better ranking
//   ✓ Pairwise - Co-occurrence lift statistics (set-aware inference)
//   ✓ Gibbs - Optional MCMC sampling (enabled via flag)
//   ✓ Tuning - Auto-parameter optimization via grid search
//   ✓ Reports - Aggregate evaluation metrics and insights
//
// DATABASE TABLES (Created by installer):
//   1. skai_run_logs - Complete prediction runs with score_parts
//   2. skai_backtest_metrics - Per-draw validation metrics
//   3. skai_miss_attribution - Analysis of missed winners
//   4. skai_tuned_params - Optimal parameters per game
//   5. skai_pairwise_stats - Co-occurrence lift scores
//   6. skai_evaluation_reports - Aggregate summaries
//   7. skai_calibration_curves - Monotonic calibration mappings
//
// USAGE (After Installation):
//   All SKAI_* functions are available throughout this file:
//   - SKAI_logPredictionRun() - Log predictions with score breakdowns
//   - SKAI_runWalkForwardBacktest() - Run time-split validation
//   - SKAI_generateEvaluationReport() - Generate performance reports
//   - And ~80 more functions (see QUICK_REFERENCE.txt)
//
// Built on probabilities - not promises.
// =====================================================================



/**
 * SKAI_Evaluation_Install - Create 7 database tables for evaluation system
 * 
 * Run this once after uploading the integrated SKAI file:
 *   Method 1 (Browser): Add ?install_eval=1 to URL
 *   Method 2 (CLI): php -r "require 'thisfile.php'; print_r(SKAI_Evaluation_Install());"
 * 
 * @return array {success: bool, message: string, tables_created: int, errors: array}
 */
function SKAI_Evaluation_Install() {
    try {
        $db = Joomla\CMS\Factory::getDbo();
        $prefix = $db->getPrefix();
        $tablesCreated = 0;
        $errors = [];
        
        $tables = [
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_run_logs` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `game_id` VARCHAR(50) NOT NULL,
                `run_date` DATETIME NOT NULL,
                `draw_date` DATE NULL,
                `model_version` VARCHAR(20) NOT NULL DEFAULT 'v1.0',
                `params_json` TEXT NULL,
                `ranked_list` MEDIUMTEXT NOT NULL,
                `top20_nums` VARCHAR(200) NOT NULL,
                `extras_json` TEXT NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                INDEX `idx_game_run` (`game_id`, `run_date`),
                INDEX `idx_draw_date` (`draw_date`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci",
            
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_backtest_metrics` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `game_id` VARCHAR(50) NOT NULL,
                `test_draw_date` DATE NOT NULL,
                `train_window_start` DATE NULL,
                `train_window_end` DATE NULL,
                `window_size` INT UNSIGNED NOT NULL,
                `recall_at_20` DECIMAL(5,4) NOT NULL DEFAULT 0.0000,
                `mean_winner_rank` DECIMAL(8,2) NOT NULL DEFAULT 0.00,
                `ndcg_at_20` DECIMAL(5,4) NOT NULL DEFAULT 0.0000,
                `winners_json` VARCHAR(500) NOT NULL,
                `missing_winners_json` VARCHAR(500) NULL,
                `params_hash` VARCHAR(64) NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                UNIQUE KEY `uniq_game_draw_params` (`game_id`, `test_draw_date`, `params_hash`),
                INDEX `idx_game_date` (`game_id`, `test_draw_date`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci",
            
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_miss_attribution` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `backtest_metric_id` INT UNSIGNED NOT NULL,
                `game_id` VARCHAR(50) NOT NULL,
                `test_draw_date` DATE NOT NULL,
                `missed_number` TINYINT UNSIGNED NOT NULL,
                `rank_in_full_list` INT UNSIGNED NOT NULL,
                `score_total` DECIMAL(10,6) NOT NULL,
                `score_parts_json` TEXT NOT NULL,
                `reason_codes` VARCHAR(500) NULL,
                `sensitivity_json` TEXT NULL,
                `top20_median_json` TEXT NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                INDEX `idx_backtest` (`backtest_metric_id`),
                INDEX `idx_game_draw_num` (`game_id`, `test_draw_date`, `missed_number`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci",
            
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_tuned_params` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `game_id` VARCHAR(50) NOT NULL,
                `tuned_at` DATETIME NOT NULL,
                `validation_window_start` DATE NULL,
                `validation_window_end` DATE NULL,
                `num_validation_draws` INT UNSIGNED NOT NULL,
                `objective_value` DECIMAL(10,6) NOT NULL,
                `recall_at_20` DECIMAL(5,4) NOT NULL DEFAULT 0.0000,
                `ndcg_at_20` DECIMAL(5,4) NOT NULL DEFAULT 0.0000,
                `mean_winner_rank` DECIMAL(8,2) NOT NULL DEFAULT 0.00,
                `params_json` TEXT NOT NULL,
                `is_active` TINYINT(1) NOT NULL DEFAULT 1,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                INDEX `idx_game_active` (`game_id`, `is_active`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci",
            
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_pairwise_stats` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `game_id` VARCHAR(50) NOT NULL,
                `ball_type` ENUM('main', 'extra') NOT NULL DEFAULT 'main',
                `computed_at` DATETIME NOT NULL,
                `window_size` INT UNSIGNED NOT NULL,
                `num_i` TINYINT UNSIGNED NOT NULL,
                `num_j` TINYINT UNSIGNED NOT NULL,
                `p_i` DECIMAL(10,8) NOT NULL,
                `p_j` DECIMAL(10,8) NOT NULL,
                `p_ij` DECIMAL(10,8) NOT NULL,
                `lift` DECIMAL(10,6) NOT NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                UNIQUE KEY `uniq_game_type_pair` (`game_id`, `ball_type`, `num_i`, `num_j`),
                INDEX `idx_game_type` (`game_id`, `ball_type`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci",
            
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_evaluation_reports` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `game_id` VARCHAR(50) NOT NULL,
                `report_date` DATE NOT NULL,
                `evaluation_period_start` DATE NOT NULL,
                `evaluation_period_end` DATE NOT NULL,
                `num_draws_evaluated` INT UNSIGNED NOT NULL,
                `avg_recall_at_20` DECIMAL(5,4) NOT NULL DEFAULT 0.0000,
                `avg_ndcg_at_20` DECIMAL(5,4) NOT NULL DEFAULT 0.0000,
                `avg_mean_winner_rank` DECIMAL(8,2) NOT NULL DEFAULT 0.00,
                `top_miss_reasons_json` TEXT NULL,
                `before_after_json` TEXT NULL,
                `summary_text` TEXT NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                UNIQUE KEY `uniq_game_report` (`game_id`, `report_date`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci",
            
            "CREATE TABLE IF NOT EXISTS `{$prefix}skai_calibration_curves` (
                `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
                `game_id` VARCHAR(50) NOT NULL,
                `computed_at` DATETIME NOT NULL,
                `window_size` INT UNSIGNED NOT NULL,
                `num_bins` TINYINT UNSIGNED NOT NULL DEFAULT 10,
                `calibration_map_json` TEXT NOT NULL,
                `is_active` TINYINT(1) NOT NULL DEFAULT 1,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                PRIMARY KEY (`id`),
                INDEX `idx_game_active` (`game_id`, `is_active`)
            ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci"
        ];
        
        foreach ($tables as $sql) {
            try {
                $db->setQuery($sql);
                $db->execute();
                $tablesCreated++;
            } catch (Exception $e) {
                $errors[] = $e->getMessage();
            }
        }
        
        return [
            'success' => (count($errors) === 0),
            'message' => count($errors) === 0 
                ? "Successfully created $tablesCreated evaluation tables" 
                : "Created $tablesCreated tables with " . count($errors) . " errors",
            'tables_created' => $tablesCreated,
            'errors' => $errors
        ];
        
    } catch (Exception $e) {
        return [
            'success' => false,
            'message' => 'Installation failed: ' . $e->getMessage(),
            'tables_created' => 0,
            'errors' => [$e->getMessage()]
        ];
    }
}

// Auto-installer: Add ?install_eval=1 to URL to create tables
if (isset($_GET['install_eval']) && $_GET['install_eval'] == '1') {
    $installResult = SKAI_Evaluation_Install();
    echo '<!DOCTYPE html><html><head><title>SKAI Evaluation System Installation</title>';
    echo '<style>body{font-family:Arial,sans-serif;max-width:800px;margin:50px auto;padding:20px;}';
    echo '.success{color:green;font-weight:bold;}.error{color:red;font-weight:bold;}</style></head><body>';
    echo '<h1>SKAI Evaluation System Installation</h1>';
    
    if ($installResult['success']) {
        echo '<p class="success">SUCCESS!</p>';
        echo '<p>' . htmlspecialchars($installResult['message']) . '</p>';
        echo '<p>Tables created: ' . $installResult['tables_created'] . '</p>';
        echo '<h3>Next Steps:</h3>';
        echo '<ol>';
        echo '<li>Remove <code>?install_eval=1</code> from the URL</li>';
        echo '<li>Refresh the page to use SKAI normally</li>';
        echo '<li>All evaluation functions are now available</li>';
        echo '</ol>';
    } else {
        echo '<p class="error">ERROR!</p>';
        echo '<p>' . htmlspecialchars($installResult['message']) . '</p>';
        if (!empty($installResult['errors'])) {
            echo '<h3>Errors:</h3><ul>';
            foreach ($installResult['errors'] as $error) {
                echo '<li>' . htmlspecialchars($error) . '</li>';
            }
            echo '</ul>';
        }
    }
    
    echo '</body></html>';
    exit;
}



// === EVALUATION SYSTEM FUNCTIONS (ALL 8 MODULES) ===
// Includes: Instrumentation, Backtest, Attribution, Calibration,
//           Pairwise, Gibbs, Tuning, Reports

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - INSTRUMENTATION MODULE
 * =====================================================================
 * Purpose: Log per-number score breakdowns for each prediction run
 * Dependencies: Joomla 5.1.2, skai_evaluation_schema.sql
 * Usage: Call SKAI_logPredictionRun() after computing top 20
 * =====================================================================
 */



/**
 * Log a complete prediction run with score breakdowns
 * 
 * @param string $gameId         Lottery game identifier
 * @param array  $rankedList     Array of candidate objects: [{num, score_total, score_parts, rank}]
 * @param array  $top20Nums      Top 20 numbers (for quick evaluation)
 * @param array  $params         Parameters used: weights, window, etc.
 * @param string $drawDate       Target draw date (YYYY-MM-DD) or null
 * @param array  $extrasRanked   Extra ball predictions (optional)
 * @return int|false             Inserted log ID or false on failure
 */
function SKAI_logPredictionRun($gameId, $rankedList, $top20Nums, $params, $drawDate = null, $extrasRanked = []) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        // Ensure ranked list has at least top 50 candidates
        $fullRankedList = array_slice($rankedList, 0, 50);
        
        // Validate and enrich score_parts for each candidate
        foreach ($fullRankedList as &$candidate) {
            if (!isset($candidate['score_parts'])) {
                $candidate['score_parts'] = [
                    'freq' => 0.0,
                    'recency' => 0.0,
                    'window' => 0.0,
                    'ml' => 0.0,
                    'penalties' => 0.0,
                    'pairwise' => 0.0
                ];
            } else {
                // Ensure all parts exist (set to 0 if missing)
                $parts = &$candidate['score_parts'];
                $parts['freq'] = $parts['freq'] ?? 0.0;
                $parts['recency'] = $parts['recency'] ?? 0.0;
                $parts['window'] = $parts['window'] ?? 0.0;
                $parts['ml'] = $parts['ml'] ?? 0.0;
                $parts['penalties'] = $parts['penalties'] ?? 0.0;
                $parts['pairwise'] = $parts['pairwise'] ?? 0.0;
            }
            
            // Add metadata
            if (!isset($candidate['meta'])) {
                $candidate['meta'] = [
                    'gameId' => $gameId,
                    'drawDate' => $drawDate,
                    'modelVersion' => 'v1.0',
                    'params' => $params
                ];
            }
        }
        unset($candidate);
        
        // Prepare insert
        $now = new Date('now');
        $columns = [
            'game_id',
            'run_date',
            'draw_date',
            'model_version',
            'params_json',
            'ranked_list',
            'top20_nums',
            'extras_json',
            'created_at'
        ];
        
        $values = [
            $db->quote($gameId),
            $db->quote($now->toSql()),
            $drawDate ? $db->quote($drawDate) : 'NULL',
            $db->quote('v1.0'),
            $db->quote(json_encode($params, JSON_UNESCAPED_UNICODE)),
            $db->quote(json_encode($fullRankedList, JSON_UNESCAPED_UNICODE)),
            $db->quote(implode(',', $top20Nums)),
            !empty($extrasRanked) ? $db->quote(json_encode($extrasRanked, JSON_UNESCAPED_UNICODE)) : 'NULL',
            $db->quote($now->toSql())
        ];
        
        $query->insert($db->quoteName('#__skai_run_logs'))
            ->columns($db->quoteName($columns))
            ->values(implode(',', $values));
        
        $db->setQuery($query);
        $db->execute();
        
        return $db->insertid();
        
    } catch (\Exception $e) {
        error_log('[SKAI] logPredictionRun error: ' . $e->getMessage());
        return false;
    }
}

/**
 * Build score_parts breakdown from existing SKAI scoring components
 * 
 * @param int   $num            Number being scored
 * @param float $freqScore      Frequency component
 * @param float $recencyScore   Recency/skip component
 * @param float $windowScore    Window-based component
 * @param float $mlScore        Machine learning component
 * @param float $penalty        Penalty adjustments
 * @param float $pairwiseBonus  Pairwise lift bonus (from set-aware inference)
 * @return array                Score parts structure
 */
function SKAI_buildScoreParts($num, $freqScore, $recencyScore, $windowScore, $mlScore, $penalty, $pairwiseBonus = 0.0) {
    return [
        'freq' => (float)$freqScore,
        'recency' => (float)$recencyScore,
        'window' => (float)$windowScore,
        'ml' => (float)$mlScore,
        'penalties' => (float)$penalty,
        'pairwise' => (float)$pairwiseBonus
    ];
}

/**
 * Create score breakdown metadata
 * 
 * @param string $gameId       Game identifier
 * @param string $drawDate     Target draw date
 * @param array  $params       Parameters used
 * @return array               Metadata structure
 */
function SKAI_buildScoreMeta($gameId, $drawDate, $params) {
    return [
        'gameId' => $gameId,
        'drawDate' => $drawDate,
        'modelVersion' => 'v1.0',
        'params' => $params
    ];
}

/**
 * Get recent prediction runs for a game
 * 
 * @param string $gameId  Game identifier
 * @param int    $limit   Number of recent runs to retrieve
 * @return array          Array of run log records
 */
function SKAI_getRecentRuns($gameId, $limit = 10) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_run_logs'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->order($db->quoteName('run_date') . ' DESC')
            ->setLimit($limit);
        
        $db->setQuery($query);
        $results = $db->loadAssocList();
        
        // Decode JSON fields
        foreach ($results as &$row) {
            $row['params_json'] = json_decode($row['params_json'], true);
            $row['ranked_list'] = json_decode($row['ranked_list'], true);
            $row['top20_nums'] = explode(',', $row['top20_nums']);
            if ($row['extras_json']) {
                $row['extras_json'] = json_decode($row['extras_json'], true);
            }
        }
        
        return $results;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getRecentRuns error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Get a specific run by ID
 * 
 * @param int $runId  Run log ID
 * @return array|null Run record or null if not found
 */
function SKAI_getRunById($runId) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_run_logs'))
            ->where($db->quoteName('id') . ' = ' . (int)$runId);
        
        $db->setQuery($query);
        $row = $db->loadAssoc();
        
        if ($row) {
            // Decode JSON fields
            $row['params_json'] = json_decode($row['params_json'], true);
            $row['ranked_list'] = json_decode($row['ranked_list'], true);
            $row['top20_nums'] = explode(',', $row['top20_nums']);
            if ($row['extras_json']) {
                $row['extras_json'] = json_decode($row['extras_json'], true);
            }
        }
        
        return $row;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getRunById error: ' . $e->getMessage());
        return null;
    }
}

/**
 * Clean up old run logs (maintenance)
 * 
 * @param int $daysToKeep  Keep logs from last N days
 * @return int             Number of rows deleted
 */
function SKAI_cleanupOldLogs($daysToKeep = 180) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $cutoffDate = new Date('-' . $daysToKeep . ' days');
        
        $query->delete($db->quoteName('#__skai_run_logs'))
            ->where($db->quoteName('created_at') . ' < ' . $db->quote($cutoffDate->toSql()));
        
        $db->setQuery($query);
        $db->execute();
        
        return $db->getAffectedRows();
        
    } catch (\Exception $e) {
        error_log('[SKAI] cleanupOldLogs error: ' . $e->getMessage());
        return 0;
    }
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - BACKTEST MODULE
 * =====================================================================
 * Purpose: Walk-forward time-split backtest with evaluation metrics
 * Metrics: Recall@20, MeanWinnerRank, NDCG@20
 * Dependencies: Joomla 5.1.2, skai_evaluation_schema.sql
 * =====================================================================
 */



/**
 * Run walk-forward backtest on historical draws
 * 
 * @param string $gameId         Lottery game identifier  
 * @param array  $drawHistory    Historical draws (chronological): [{date, numbers, extras}]
 * @param int    $windowSize     Training window size (number of draws)
 * @param int    $startIndex     Start index for backtesting
 * @param int    $endIndex       End index for backtesting (null = all)
 * @param array  $params         Prediction parameters
 * @param callable $predictFn    Prediction function($trainWindow, $params) => $rankedList
 * @return array                 Backtest results summary
 */
function SKAI_runWalkForwardBacktest($gameId, $drawHistory, $windowSize, $startIndex, $endIndex, $params, $predictFn) {
    try {
        $db = Factory::getDbo();
        $results = [];
        
        if ($endIndex === null || $endIndex > count($drawHistory)) {
            $endIndex = count($drawHistory);
        }
        
        // Walk forward through historical draws
        for ($t = $startIndex; $t < $endIndex; $t++) {
            // Training window: draws before t
            $trainStart = max(0, $t - $windowSize);
            $trainWindow = array_slice($drawHistory, $trainStart, $t - $trainStart);
            
            if (empty($trainWindow)) {
                continue;
            }
            
            // Generate prediction using training window
            $rankedList = $predictFn($trainWindow, $params);
            
            if (empty($rankedList)) {
                continue;
            }
            
            // Actual winners for this draw
            $actualDraw = $drawHistory[$t];
            $winners = $actualDraw['numbers'] ?? [];
            
            if (empty($winners)) {
                continue;
            }
            
            // Top 20 prediction
            $top20 = array_slice(array_column($rankedList, 'num'), 0, 20);
            
            // Calculate metrics
            $metrics = SKAI_calculateBacktestMetrics($rankedList, $winners, $top20);
            
            // Store metrics in database
            $metricsId = SKAI_storeBacktestMetrics(
                $gameId,
                $actualDraw['date'],
                $trainWindow[0]['date'] ?? null,
                $trainWindow[count($trainWindow) - 1]['date'] ?? null,
                $windowSize,
                $metrics,
                $winners,
                $params
            );
            
            // Store miss attribution for winners not in top 20
            if ($metricsId && !empty($metrics['missing_winners'])) {
                SKAI_storeMissAttribution(
                    $metricsId,
                    $gameId,
                    $actualDraw['date'],
                    $metrics['missing_winners'],
                    $rankedList,
                    $top20
                );
            }
            
            $results[] = array_merge($metrics, [
                'test_date' => $actualDraw['date'],
                'metrics_id' => $metricsId
            ]);
        }
        
        // Calculate aggregate statistics
        $aggregate = SKAI_aggregateBacktestResults($results);
        
        return [
            'per_draw' => $results,
            'aggregate' => $aggregate,
            'game_id' => $gameId,
            'window_size' => $windowSize,
            'num_tests' => count($results)
        ];
        
    } catch (\Exception $e) {
        error_log('[SKAI] runWalkForwardBacktest error: ' . $e->getMessage());
        return ['error' => $e->getMessage()];
    }
}

/**
 * Calculate backtest metrics for a single draw
 * 
 * @param array $rankedList  Full ranked candidate list
 * @param array $winners     Actual winning numbers
 * @param array $top20       Top 20 predictions
 * @return array             Metrics: {recall_at_20, mean_winner_rank, ndcg_at_20, missing_winners}
 */
function SKAI_calculateBacktestMetrics($rankedList, $winners, $top20) {
    // Recall@20: fraction of winners in top 20
    $winnersInTop20 = array_intersect($winners, $top20);
    $recallAt20 = count($winners) > 0 ? count($winnersInTop20) / count($winners) : 0.0;
    
    // Build rank lookup map
    $rankMap = [];
    foreach ($rankedList as $idx => $item) {
        $rankMap[$item['num']] = $idx + 1; // 1-based rank
    }
    
    // Mean Winner Rank: average rank of winners (use 999 if not found)
    $winnerRanks = [];
    $missingWinners = [];
    foreach ($winners as $w) {
        if (isset($rankMap[$w])) {
            $winnerRanks[] = $rankMap[$w];
        } else {
            $winnerRanks[] = 999;
            $missingWinners[] = $w;
        }
    }
    $meanWinnerRank = count($winnerRanks) > 0 ? array_sum($winnerRanks) / count($winnerRanks) : 999.0;
    
    // NDCG@20: relevance=1 for winners, 0 for non-winners
    $ndcgAt20 = SKAI_calculateNDCG($rankedList, $winners, 20);
    
    return [
        'recall_at_20' => $recallAt20,
        'mean_winner_rank' => $meanWinnerRank,
        'ndcg_at_20' => $ndcgAt20,
        'winners_in_top20' => $winnersInTop20,
        'missing_winners' => $missingWinners,
        'total_winners' => count($winners)
    ];
}

/**
 * Calculate NDCG@k (Normalized Discounted Cumulative Gain)
 * 
 * @param array $rankedList  Ranked predictions
 * @param array $winners     Actual winners (relevance = 1)
 * @param int   $k           Cutoff (e.g., 20)
 * @return float             NDCG score [0, 1]
 */
function SKAI_calculateNDCG($rankedList, $winners, $k) {
    $topK = array_slice($rankedList, 0, $k);
    $winnerSet = array_flip($winners);
    
    // DCG: sum of rel_i / log2(i+1)
    $dcg = 0.0;
    foreach ($topK as $i => $item) {
        $rel = isset($winnerSet[$item['num']]) ? 1.0 : 0.0;
        $dcg += $rel / log($i + 2, 2); // i is 0-based, so position is i+1, log2(i+1+1)
    }
    
    // IDCG: ideal DCG (all winners at top)
    $numWinners = count($winners);
    $idcg = 0.0;
    for ($i = 0; $i < min($k, $numWinners); $i++) {
        $idcg += 1.0 / log($i + 2, 2);
    }
    
    return $idcg > 0 ? $dcg / $idcg : 0.0;
}

/**
 * Store backtest metrics in database
 */
function SKAI_storeBacktestMetrics($gameId, $testDrawDate, $trainStart, $trainEnd, $windowSize, $metrics, $winners, $params) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $paramsHash = md5(json_encode($params));
        
        $columns = [
            'game_id',
            'test_draw_date',
            'train_window_start',
            'train_window_end',
            'window_size',
            'recall_at_20',
            'mean_winner_rank',
            'ndcg_at_20',
            'winners_json',
            'missing_winners_json',
            'params_hash',
            'created_at'
        ];
        
        $now = new Date('now');
        $values = [
            $db->quote($gameId),
            $db->quote($testDrawDate),
            $trainStart ? $db->quote($trainStart) : 'NULL',
            $trainEnd ? $db->quote($trainEnd) : 'NULL',
            (int)$windowSize,
            (float)$metrics['recall_at_20'],
            (float)$metrics['mean_winner_rank'],
            (float)$metrics['ndcg_at_20'],
            $db->quote(json_encode($winners)),
            $db->quote(json_encode($metrics['missing_winners'] ?? [])),
            $db->quote($paramsHash),
            $db->quote($now->toSql())
        ];
        
        $query->insert($db->quoteName('#__skai_backtest_metrics'))
            ->columns($db->quoteName($columns))
            ->values(implode(',', $values));
        
        $db->setQuery($query);
        $db->execute();
        
        return $db->insertid();
        
    } catch (\Exception $e) {
        error_log('[SKAI] storeBacktestMetrics error: ' . $e->getMessage());
        return false;
    }
}

/**
 * Aggregate backtest results across multiple draws
 */
function SKAI_aggregateBacktestResults($results) {
    if (empty($results)) {
        return [
            'avg_recall_at_20' => 0.0,
            'avg_ndcg_at_20' => 0.0,
            'avg_mean_winner_rank' => 0.0,
            'num_draws' => 0
        ];
    }
    
    $totalRecall = 0.0;
    $totalNDCG = 0.0;
    $totalMWR = 0.0;
    $count = count($results);
    
    foreach ($results as $r) {
        $totalRecall += $r['recall_at_20'];
        $totalNDCG += $r['ndcg_at_20'];
        $totalMWR += $r['mean_winner_rank'];
    }
    
    return [
        'avg_recall_at_20' => $totalRecall / $count,
        'avg_ndcg_at_20' => $totalNDCG / $count,
        'avg_mean_winner_rank' => $totalMWR / $count,
        'num_draws' => $count
    ];
}

/**
 * Get backtest metrics for a game
 * 
 * @param string $gameId      Game identifier
 * @param string $paramsHash  Optional: filter by params hash
 * @param int    $limit       Number of results to return
 * @return array              Backtest metrics
 */
function SKAI_getBacktestMetrics($gameId, $paramsHash = null, $limit = 100) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_backtest_metrics'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->order($db->quoteName('test_draw_date') . ' DESC')
            ->setLimit($limit);
        
        if ($paramsHash) {
            $query->where($db->quoteName('params_hash') . ' = ' . $db->quote($paramsHash));
        }
        
        $db->setQuery($query);
        $results = $db->loadAssocList();
        
        // Decode JSON fields
        foreach ($results as &$row) {
            $row['winners_json'] = json_decode($row['winners_json'], true);
            $row['missing_winners_json'] = json_decode($row['missing_winners_json'], true);
        }
        
        return $results;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getBacktestMetrics error: ' . $e->getMessage());
        return [];
    }
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - MISS ATTRIBUTION MODULE
 * =====================================================================
 * Purpose: Analyze why winners were missed (not in top 20)
 * Features: Reason codes, sensitivity analysis, comparison to top 20
 * Dependencies: Joomla 5.1.2, skai_evaluation_schema.sql
 * =====================================================================
 */



/**
 * Store miss attribution for winners not in top 20
 * 
 * @param int    $backtestMetricId  FK to backtest metrics
 * @param string $gameId            Game identifier
 * @param string $testDrawDate      Draw date
 * @param array  $missingWinners    Winners not in top 20
 * @param array  $rankedList        Full ranked candidate list
 * @param array  $top20             Top 20 numbers
 * @return int                      Number of rows inserted
 */
function SKAI_storeMissAttribution($backtestMetricId, $gameId, $testDrawDate, $missingWinners, $rankedList, $top20) {
    try {
        $db = Factory::getDbo();
        $inserted = 0;
        
        // Build rank map and score map
        $rankMap = [];
        $scoreMap = [];
        foreach ($rankedList as $idx => $item) {
            $rankMap[$item['num']] = $idx + 1;
            $scoreMap[$item['num']] = $item;
        }
        
        // Calculate median score_parts of top 20
        $top20ScoreParts = SKAI_getTop20ScoreParts($rankedList, $top20);
        $top20Median = SKAI_calculateMedianScoreParts($top20ScoreParts);
        
        // Process each missing winner
        foreach ($missingWinners as $missedNum) {
            if (!isset($rankMap[$missedNum]) || !isset($scoreMap[$missedNum])) {
                continue;
            }
            
            $rank = $rankMap[$missedNum];
            $candidate = $scoreMap[$missedNum];
            $scoreParts = $candidate['score_parts'] ?? [];
            
            // Compute reason codes
            $reasonCodes = SKAI_computeReasonCodes($scoreParts, $top20Median);
            
            // Compute sensitivity (minimal delta needed to reach top 20)
            $top20CutoffScore = isset($scoreMap[$top20[19]]) ? $scoreMap[$top20[19]]['score_total'] : 0.0;
            $sensitivity = SKAI_computeSensitivity($candidate, $top20CutoffScore);
            
            // Insert attribution record
            $query = $db->getQuery(true);
            $now = new Date('now');
            
            $columns = [
                'backtest_metric_id',
                'game_id',
                'test_draw_date',
                'missed_number',
                'rank_in_full_list',
                'score_total',
                'score_parts_json',
                'reason_codes',
                'sensitivity_json',
                'top20_median_json',
                'created_at'
            ];
            
            $values = [
                (int)$backtestMetricId,
                $db->quote($gameId),
                $db->quote($testDrawDate),
                (int)$missedNum,
                (int)$rank,
                (float)($candidate['score_total'] ?? 0.0),
                $db->quote(json_encode($scoreParts)),
                $db->quote(implode(',', $reasonCodes)),
                $db->quote(json_encode($sensitivity)),
                $db->quote(json_encode($top20Median)),
                $db->quote($now->toSql())
            ];
            
            $query->insert($db->quoteName('#__skai_miss_attribution'))
                ->columns($db->quoteName($columns))
                ->values(implode(',', $values));
            
            $db->setQuery($query);
            $db->execute();
            $inserted++;
        }
        
        return $inserted;
        
    } catch (\Exception $e) {
        error_log('[SKAI] storeMissAttribution error: ' . $e->getMessage());
        return 0;
    }
}

/**
 * Get score_parts for top 20 numbers
 */
function SKAI_getTop20ScoreParts($rankedList, $top20) {
    $scoreParts = [];
    $top20Set = array_flip($top20);
    
    foreach ($rankedList as $item) {
        if (isset($top20Set[$item['num']])) {
            $scoreParts[] = $item['score_parts'] ?? [];
        }
    }
    
    return $scoreParts;
}

/**
 * Calculate median score_parts across multiple candidates
 */
function SKAI_calculateMedianScoreParts($scorePartsArray) {
    if (empty($scorePartsArray)) {
        return [];
    }
    
    $parts = ['freq', 'recency', 'window', 'ml', 'penalties', 'pairwise'];
    $median = [];
    
    foreach ($parts as $part) {
        $values = [];
        foreach ($scorePartsArray as $sp) {
            $values[] = $sp[$part] ?? 0.0;
        }
        sort($values);
        $count = count($values);
        if ($count > 0) {
            $mid = (int)($count / 2);
            $median[$part] = $count % 2 == 0 
                ? ($values[$mid - 1] + $values[$mid]) / 2.0 
                : $values[$mid];
        } else {
            $median[$part] = 0.0;
        }
    }
    
    return $median;
}

/**
 * Compute reason codes by comparing to top 20 median
 * 
 * @param array $scoreParts   Score parts for missed number
 * @param array $top20Median  Median score parts of top 20
 * @return array              Reason codes (e.g., ['FREQ_LOW', 'ML_LOW'])
 */
function SKAI_computeReasonCodes($scoreParts, $top20Median) {
    $reasons = [];
    $threshold = 0.3; // If component is 30%+ below median, flag it
    
    $partNames = [
        'freq' => 'FREQ',
        'recency' => 'RECENCY',
        'window' => 'WINDOW',
        'ml' => 'ML',
        'penalties' => 'PENALTY',
        'pairwise' => 'PAIRWISE'
    ];
    
    foreach ($partNames as $part => $name) {
        $value = $scoreParts[$part] ?? 0.0;
        $median = $top20Median[$part] ?? 0.0;
        
        if ($part === 'penalties') {
            // Penalties are negative; high penalty is bad
            if ($value < $median - abs($median * $threshold)) {
                $reasons[] = $name . '_HIGH';
            }
        } else {
            // Other parts are positive; low value is bad
            if ($value < $median - abs($median * $threshold)) {
                $reasons[] = $name . '_LOW';
            }
        }
    }
    
    // If no specific reason, use generic
    if (empty($reasons)) {
        $reasons[] = 'OVERALL_LOW';
    }
    
    return $reasons;
}

/**
 * Compute sensitivity: minimal delta needed to reach top 20
 * 
 * @param array $candidate      Missed candidate
 * @param float $cutoffScore    Score of 20th place
 * @return array                [{part, current_val, needed_delta, contribution}] top 3
 */
function SKAI_computeSensitivity($candidate, $cutoffScore) {
    $currentScore = $candidate['score_total'] ?? 0.0;
    $scoreParts = $candidate['score_parts'] ?? [];
    
    $gap = $cutoffScore - $currentScore;
    if ($gap <= 0) {
        return []; // Already above cutoff
    }
    
    $sensitivity = [];
    
    foreach ($scoreParts as $part => $value) {
        if ($part === 'penalties') {
            // For penalties, reducing magnitude helps
            $contribution = abs($value);
            $neededDelta = min($gap, $contribution);
            $sensitivity[] = [
                'part' => $part,
                'current_val' => $value,
                'needed_delta' => $neededDelta,
                'contribution' => $contribution,
                'actionable' => 'reduce penalty by ' . number_format($neededDelta, 4)
            ];
        } else {
            // For positive parts, increasing helps
            $contribution = abs($value);
            $neededDelta = $gap;
            $sensitivity[] = [
                'part' => $part,
                'current_val' => $value,
                'needed_delta' => $neededDelta,
                'contribution' => $contribution,
                'actionable' => 'increase ' . $part . ' by ' . number_format($neededDelta, 4)
            ];
        }
    }
    
    // Sort by contribution (largest first)
    usort($sensitivity, function($a, $b) {
        return $b['contribution'] <=> $a['contribution'];
    });
    
    // Return top 3 actionable parts
    return array_slice($sensitivity, 0, 3);
}

/**
 * Get miss attribution records for a game
 * 
 * @param string $gameId  Game identifier
 * @param int    $limit   Number of records to retrieve
 * @return array          Miss attribution records
 */
function SKAI_getMissAttributions($gameId, $limit = 100) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_miss_attribution'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->order($db->quoteName('test_draw_date') . ' DESC, ' . $db->quoteName('rank_in_full_list') . ' ASC')
            ->setLimit($limit);
        
        $db->setQuery($query);
        $results = $db->loadAssocList();
        
        // Decode JSON fields
        foreach ($results as &$row) {
            $row['score_parts_json'] = json_decode($row['score_parts_json'], true);
            $row['sensitivity_json'] = json_decode($row['sensitivity_json'], true);
            $row['top20_median_json'] = json_decode($row['top20_median_json'], true);
            $row['reason_codes'] = explode(',', $row['reason_codes']);
        }
        
        return $results;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getMissAttributions error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Get top recurring miss reasons for a game
 * 
 * @param string $gameId  Game identifier
 * @param int    $limit   Number of top reasons to return
 * @return array          [{reason, count, pct}]
 */
function SKAI_getTopMissReasons($gameId, $limit = 10) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('reason_codes')
            ->from($db->quoteName('#__skai_miss_attribution'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId));
        
        $db->setQuery($query);
        $results = $db->loadColumn();
        
        // Count reasons
        $reasonCounts = [];
        $total = 0;
        
        foreach ($results as $reasonStr) {
            $reasons = explode(',', $reasonStr);
            foreach ($reasons as $reason) {
                $reason = trim($reason);
                if (!empty($reason)) {
                    $reasonCounts[$reason] = ($reasonCounts[$reason] ?? 0) + 1;
                    $total++;
                }
            }
        }
        
        // Sort by count descending
        arsort($reasonCounts);
        
        // Format output
        $output = [];
        $count = 0;
        foreach ($reasonCounts as $reason => $cnt) {
            $output[] = [
                'reason' => $reason,
                'count' => $cnt,
                'pct' => $total > 0 ? ($cnt / $total) * 100 : 0.0
            ];
            if (++$count >= $limit) {
                break;
            }
        }
        
        return $output;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getTopMissReasons error: ' . $e->getMessage());
        return [];
    }
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - SCORE CALIBRATION MODULE
 * =====================================================================
 * Purpose: Monotonic calibration of raw scores to empirical hit rates
 * Method: Bin-based quantile approach with isotonic smoothing
 * Dependencies: Joomla 5.1.2, skai_evaluation_schema.sql
 * =====================================================================
 */



/**
 * Build calibration curve from training data
 * 
 * @param string $gameId         Game identifier
 * @param array  $trainWindow    Training draws: [{date, numbers}]
 * @param callable $scoreFn      Scoring function($num, $history) => $score
 * @param int    $numBins        Number of quantile bins
 * @return array                 Calibration map
 */
function SKAI_buildCalibrationCurve($gameId, $trainWindow, $scoreFn, $numBins = 10) {
    try {
        // For each historical draw, score all candidates and check which were winners
        $allScores = [];
        
        foreach ($trainWindow as $idx => $draw) {
            // Use history before this draw for scoring
            $history = array_slice($trainWindow, 0, $idx);
            if (empty($history)) {
                continue;
            }
            
            $winners = $draw['numbers'] ?? [];
            $winnerSet = array_flip($winners);
            
            // Score all possible candidates
            $domain = SKAI_getDomain($gameId);
            for ($num = $domain['min']; $num <= $domain['max']; $num++) {
                $score = $scoreFn($num, $history);
                $isWinner = isset($winnerSet[$num]);
                
                $allScores[] = [
                    'score' => $score,
                    'is_winner' => $isWinner
                ];
            }
        }
        
        if (empty($allScores)) {
            return [];
        }
        
        // Sort by score
        usort($allScores, function($a, $b) {
            return $a['score'] <=> $b['score'];
        });
        
        // Create quantile bins
        $binSize = (int)ceil(count($allScores) / $numBins);
        $bins = [];
        
        for ($i = 0; $i < $numBins; $i++) {
            $start = $i * $binSize;
            $end = min(($i + 1) * $binSize, count($allScores));
            $binScores = array_slice($allScores, $start, $end - $start);
            
            if (empty($binScores)) {
                continue;
            }
            
            // Calculate empirical hit rate for this bin
            $hits = 0;
            $total = count($binScores);
            foreach ($binScores as $item) {
                if ($item['is_winner']) {
                    $hits++;
                }
            }
            $hitRate = $total > 0 ? $hits / $total : 0.0;
            
            $bins[] = [
                'bin' => $i,
                'score_min' => $binScores[0]['score'],
                'score_max' => $binScores[count($binScores) - 1]['score'],
                'hit_rate' => $hitRate,
                'count' => $total
            ];
        }
        
        // Apply isotonic smoothing (monotonic increasing)
        $bins = SKAI_applyIsotonicSmoothing($bins);
        
        return $bins;
        
    } catch (\Exception $e) {
        error_log('[SKAI] buildCalibrationCurve error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Apply isotonic regression to ensure monotonic increasing hit rates
 * 
 * @param array $bins  Bins with hit rates
 * @return array       Smoothed bins
 */
function SKAI_applyIsotonicSmoothing($bins) {
    $n = count($bins);
    if ($n <= 1) {
        return $bins;
    }
    
    // Simple pool-adjacent-violators algorithm
    $smoothed = $bins;
    $changed = true;
    
    while ($changed) {
        $changed = false;
        for ($i = 0; $i < $n - 1; $i++) {
            if ($smoothed[$i]['hit_rate'] > $smoothed[$i + 1]['hit_rate']) {
                // Merge bins and average hit rates
                $count1 = $smoothed[$i]['count'];
                $count2 = $smoothed[$i + 1]['count'];
                $totalCount = $count1 + $count2;
                
                $avgHitRate = ($smoothed[$i]['hit_rate'] * $count1 + $smoothed[$i + 1]['hit_rate'] * $count2) / $totalCount;
                
                $smoothed[$i]['hit_rate'] = $avgHitRate;
                $smoothed[$i]['count'] = $totalCount;
                $smoothed[$i]['score_max'] = $smoothed[$i + 1]['score_max'];
                
                array_splice($smoothed, $i + 1, 1);
                $n--;
                $changed = true;
                break;
            }
        }
    }
    
    // Assign calibrated scores (use cumulative smoothed hit rate)
    foreach ($smoothed as &$bin) {
        $bin['calibrated_score'] = $bin['hit_rate'];
    }
    
    return $smoothed;
}

/**
 * Apply calibration to a score
 * 
 * @param float $score           Raw score
 * @param array $calibrationMap  Calibration bins
 * @return float                 Calibrated score
 */
function SKAI_applyCalibration($score, $calibrationMap) {
    if (empty($calibrationMap)) {
        return $score; // No calibration available
    }
    
    // Find the bin this score falls into
    foreach ($calibrationMap as $bin) {
        if ($score >= $bin['score_min'] && $score <= $bin['score_max']) {
            return $bin['calibrated_score'];
        }
    }
    
    // If score is below first bin, use first bin's calibrated score
    if ($score < $calibrationMap[0]['score_min']) {
        return $calibrationMap[0]['calibrated_score'];
    }
    
    // If score is above last bin, use last bin's calibrated score
    return $calibrationMap[count($calibrationMap) - 1]['calibrated_score'];
}

/**
 * Store calibration curve in database
 * 
 * @param string $gameId          Game identifier
 * @param array  $calibrationMap  Calibration bins
 * @param int    $windowSize      Training window size
 * @param int    $numBins         Number of bins
 * @return int|false              Inserted ID or false
 */
function SKAI_storeCalibrationCurve($gameId, $calibrationMap, $windowSize, $numBins) {
    try {
        $db = Factory::getDbo();
        
        // Deactivate previous calibration curves
        $query = $db->getQuery(true);
        $query->update($db->quoteName('#__skai_calibration_curves'))
            ->set($db->quoteName('is_active') . ' = 0')
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId));
        $db->setQuery($query);
        $db->execute();
        
        // Insert new calibration curve
        $query = $db->getQuery(true);
        $now = new Date('now');
        
        $columns = [
            'game_id',
            'computed_at',
            'window_size',
            'num_bins',
            'calibration_map_json',
            'is_active',
            'created_at'
        ];
        
        $values = [
            $db->quote($gameId),
            $db->quote($now->toSql()),
            (int)$windowSize,
            (int)$numBins,
            $db->quote(json_encode($calibrationMap)),
            1, // is_active
            $db->quote($now->toSql())
        ];
        
        $query->insert($db->quoteName('#__skai_calibration_curves'))
            ->columns($db->quoteName($columns))
            ->values(implode(',', $values));
        
        $db->setQuery($query);
        $db->execute();
        
        return $db->insertid();
        
    } catch (\Exception $e) {
        error_log('[SKAI] storeCalibrationCurve error: ' . $e->getMessage());
        return false;
    }
}

/**
 * Get active calibration curve for a game
 * 
 * @param string $gameId  Game identifier
 * @return array|null     Calibration map or null
 */
function SKAI_getActiveCalibration($gameId) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('calibration_map_json')
            ->from($db->quoteName('#__skai_calibration_curves'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('is_active') . ' = 1')
            ->order($db->quoteName('computed_at') . ' DESC')
            ->setLimit(1);
        
        $db->setQuery($query);
        $result = $db->loadResult();
        
        if ($result) {
            return json_decode($result, true);
        }
        
        return null;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getActiveCalibration error: ' . $e->getMessage());
        return null;
    }
}

/**
 * Get domain (min/max numbers) for a game
 * Helper function to determine number range
 * 
 * @param string $gameId  Game identifier
 * @return array          {min, max}
 */
function SKAI_getDomain($gameId) {
    // This should be loaded from config; default to common range
    // TODO: Load from lottery_skip_config.json or database
    return [
        'min' => 1,
        'max' => 70 // Common for many lotteries
    ];
}

/**
 * Calibrate a list of scored candidates
 * 
 * @param array $candidates       Array of {num, score_total, score_parts}
 * @param array $calibrationMap   Calibration bins
 * @return array                  Candidates with calibrated_score added
 */
function SKAI_calibrateList($candidates, $calibrationMap) {
    foreach ($candidates as &$candidate) {
        $rawScore = $candidate['score_total'] ?? 0.0;
        $candidate['calibrated_score'] = SKAI_applyCalibration($rawScore, $calibrationMap);
        $candidate['raw_score'] = $rawScore; // Keep original for logging
    }
    
    return $candidates;
}

/**
 * Sort candidates by calibrated score (descending)
 * 
 * @param array $candidates  Candidates with calibrated_score
 * @return array             Sorted candidates
 */
function SKAI_sortByCalibrated($candidates) {
    usort($candidates, function($a, $b) {
        $scoreA = $a['calibrated_score'] ?? $a['score_total'] ?? 0.0;
        $scoreB = $b['calibrated_score'] ?? $b['score_total'] ?? 0.0;
        
        if ($scoreA === $scoreB) {
            return $a['num'] <=> $b['num']; // Tie-break by number
        }
        
        return $scoreB <=> $scoreA; // Descending
    });
    
    return $candidates;
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - PAIRWISE STATISTICS MODULE
 * =====================================================================
 * Purpose: Build and cache pairwise co-occurrence lift scores
 * Formula: lift(i,j) = log(P(i,j) / (P(i) * P(j)))
 * Dependencies: Joomla 5.1.2, skai_evaluation_schema.sql
 * =====================================================================
 */



/**
 * Build pairwise co-occurrence statistics from training window
 * 
 * @param string $gameId        Game identifier
 * @param array  $trainWindow   Training draws: [{date, numbers}]
 * @param string $ballType      'main' or 'extra'
 * @param int    $domain        Max number in range (e.g., 70)
 * @return array                Pairwise stats: {num_i, num_j, p_i, p_j, p_ij, lift}
 */
function SKAI_buildPairwiseStats($gameId, $trainWindow, $ballType = 'main', $domain = 70) {
    try {
        $numDraws = count($trainWindow);
        if ($numDraws == 0) {
            return [];
        }
        
        $eps = 1e-8; // Epsilon for smoothing
        
        // Count individual occurrences
        $counts = array_fill(1, $domain, 0);
        
        // Count pairwise co-occurrences
        $pairCounts = [];
        
        foreach ($trainWindow as $draw) {
            $numbers = $draw['numbers'] ?? [];
            
            // Count singles
            foreach ($numbers as $num) {
                if ($num >= 1 && $num <= $domain) {
                    $counts[$num]++;
                }
            }
            
            // Count pairs (i < j)
            $n = count($numbers);
            for ($a = 0; $a < $n; $a++) {
                for ($b = $a + 1; $b < $n; $b++) {
                    $i = min($numbers[$a], $numbers[$b]);
                    $j = max($numbers[$a], $numbers[$b]);
                    
                    if ($i >= 1 && $i <= $domain && $j >= 1 && $j <= $domain && $i < $j) {
                        $key = $i . '_' . $j;
                        $pairCounts[$key] = ($pairCounts[$key] ?? 0) + 1;
                    }
                }
            }
        }
        
        // Calculate probabilities and lift
        $stats = [];
        
        foreach ($pairCounts as $key => $pairCount) {
            list($i, $j) = explode('_', $key);
            $i = (int)$i;
            $j = (int)$j;
            
            $p_i = ($counts[$i] + $eps) / ($numDraws + $eps);
            $p_j = ($counts[$j] + $eps) / ($numDraws + $eps);
            $p_ij = ($pairCount + $eps) / ($numDraws + $eps);
            
            $lift = log($p_ij / ($p_i * $p_j));
            
            $stats[] = [
                'num_i' => $i,
                'num_j' => $j,
                'p_i' => $p_i,
                'p_j' => $p_j,
                'p_ij' => $p_ij,
                'lift' => $lift
            ];
        }
        
        return $stats;
        
    } catch (\Exception $e) {
        error_log('[SKAI] buildPairwiseStats error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Store pairwise statistics in database
 * 
 * @param string $gameId       Game identifier
 * @param array  $stats        Pairwise stats array
 * @param string $ballType     'main' or 'extra'
 * @param int    $windowSize   Training window size
 * @return int                 Number of rows inserted
 */
function SKAI_storePairwiseStats($gameId, $stats, $ballType, $windowSize) {
    try {
        $db = Factory::getDbo();
        
        // Clear old stats for this game/ball type
        $query = $db->getQuery(true);
        $query->delete($db->quoteName('#__skai_pairwise_stats'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('ball_type') . ' = ' . $db->quote($ballType));
        $db->setQuery($query);
        $db->execute();
        
        // Insert new stats
        $now = new Date('now');
        $inserted = 0;
        
        foreach ($stats as $stat) {
            $query = $db->getQuery(true);
            
            $columns = [
                'game_id',
                'ball_type',
                'computed_at',
                'window_size',
                'num_i',
                'num_j',
                'p_i',
                'p_j',
                'p_ij',
                'lift',
                'created_at'
            ];
            
            $values = [
                $db->quote($gameId),
                $db->quote($ballType),
                $db->quote($now->toSql()),
                (int)$windowSize,
                (int)$stat['num_i'],
                (int)$stat['num_j'],
                (float)$stat['p_i'],
                (float)$stat['p_j'],
                (float)$stat['p_ij'],
                (float)$stat['lift'],
                $db->quote($now->toSql())
            ];
            
            $query->insert($db->quoteName('#__skai_pairwise_stats'))
                ->columns($db->quoteName($columns))
                ->values(implode(',', $values));
            
            $db->setQuery($query);
            $db->execute();
            $inserted++;
        }
        
        return $inserted;
        
    } catch (\Exception $e) {
        error_log('[SKAI] storePairwiseStats error: ' . $e->getMessage());
        return 0;
    }
}

/**
 * Get pairwise statistics from database
 * 
 * @param string $gameId    Game identifier
 * @param string $ballType  'main' or 'extra'
 * @return array            Pairwise stats lookup: [i_j => lift]
 */
function SKAI_getPairwiseStats($gameId, $ballType = 'main') {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('num_i, num_j, lift')
            ->from($db->quoteName('#__skai_pairwise_stats'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('ball_type') . ' = ' . $db->quote($ballType))
            ->order($db->quoteName('computed_at') . ' DESC');
        
        $db->setQuery($query);
        $results = $db->loadAssocList();
        
        // Build lookup map
        $liftMap = [];
        foreach ($results as $row) {
            $key = $row['num_i'] . '_' . $row['num_j'];
            $liftMap[$key] = (float)$row['lift'];
        }
        
        return $liftMap;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getPairwiseStats error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Calculate pairwise lift bonus for a candidate
 * 
 * @param int   $candidateNum  Candidate number
 * @param array $seedSet       High-ranked numbers (e.g., top 10)
 * @param array $liftMap       Lift lookup: [i_j => lift]
 * @param int   $topK          Use top K lifts (default 10)
 * @param float $cap           Max bonus cap (default 1.0)
 * @return float               Pairwise lift bonus
 */
function SKAI_calculatePairwiseBonus($candidateNum, $seedSet, $liftMap, $topK = 10, $cap = 1.0) {
    $lifts = [];
    
    foreach ($seedSet as $seedNum) {
        if ($seedNum == $candidateNum) {
            continue; // Skip self-pairs
        }
        
        $i = min($candidateNum, $seedNum);
        $j = max($candidateNum, $seedNum);
        $key = $i . '_' . $j;
        
        if (isset($liftMap[$key])) {
            $lifts[] = $liftMap[$key];
        }
    }
    
    if (empty($lifts)) {
        return 0.0;
    }
    
    // Sort descending and take top K
    rsort($lifts);
    $topLifts = array_slice($lifts, 0, $topK);
    
    // Average of top K lifts
    $bonus = array_sum($topLifts) / count($topLifts);
    
    // Apply cap
    return min($cap, max(-$cap, $bonus));
}

/**
 * Add pairwise bonuses to candidate list
 * 
 * @param array $candidates    Candidates: [{num, score_total, score_parts}]
 * @param array $liftMap       Lift lookup map
 * @param int   $seedSize      Size of seed set (default 10)
 * @param int   $topK          Top K lifts to average (default 10)
 * @param float $cap           Bonus cap (default 1.0)
 * @return array               Candidates with pairwise bonus added
 */
function SKAI_addPairwiseBonuses($candidates, $liftMap, $seedSize = 10, $topK = 10, $cap = 1.0) {
    // Sort by current score to identify seed set
    usort($candidates, function($a, $b) {
        return ($b['score_total'] ?? 0.0) <=> ($a['score_total'] ?? 0.0);
    });
    
    $seedSet = array_slice(array_column($candidates, 'num'), 0, $seedSize);
    
    // Calculate pairwise bonus for each candidate
    foreach ($candidates as &$candidate) {
        $bonus = SKAI_calculatePairwiseBonus(
            $candidate['num'],
            $seedSet,
            $liftMap,
            $topK,
            $cap
        );
        
        $candidate['score_parts']['pairwise'] = $bonus;
        $candidate['score_total'] += $bonus;
    }
    
    // Re-sort by updated score
    usort($candidates, function($a, $b) {
        return ($b['score_total'] ?? 0.0) <=> ($a['score_total'] ?? 0.0);
    });
    
    return $candidates;
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - GIBBS SAMPLER MODULE (Optional)
 * =====================================================================
 * Purpose: Set-aware inference using MCMC sampling with MaxEnt/Gibbs
 * Method: Sample sets using Metropolis-Hastings, estimate marginals
 * Flag: Enabled via [[SKAI_USE_GIBBS]] = 1
 * Dependencies: Joomla 5.1.2, pairwise stats
 * =====================================================================
 */



/**
 * Run Gibbs sampling to compute marginal probabilities
 * 
 * @param array $candidates      Initial ranked candidates
 * @param array $liftMap         Pairwise lift map
 * @param int   $setSize         Size of set to sample (e.g., 20)
 * @param int   $numIterations   Number of MCMC iterations (default 1000)
 * @param float $beta            Pairwise interaction strength (default 1.0)
 * @param array $constraints     Constraint weights: {sum_band, parity, gap}
 * @param int   $domain          Number domain max (e.g., 70)
 * @return array                 Marginal probabilities: {num => prob}
 */
function SKAI_gibbsSampling($candidates, $liftMap, $setSize, $numIterations = 1000, $beta = 1.0, $constraints = [], $domain = 70) {
    try {
        // Initialize with top K by calibrated score
        usort($candidates, function($a, $b) {
            $scoreA = $a['calibrated_score'] ?? $a['score_total'] ?? 0.0;
            $scoreB = $b['calibrated_score'] ?? $b['score_total'] ?? 0.0;
            return $scoreB <=> $scoreA;
        });
        
        $currentSet = array_slice(array_column($candidates, 'num'), 0, $setSize);
        $candidateNums = array_column($candidates, 'num');
        
        // Build quality map: q(i) = calibrated score or raw score
        $qualityMap = [];
        foreach ($candidates as $c) {
            $qualityMap[$c['num']] = $c['calibrated_score'] ?? $c['score_total'] ?? 0.0;
        }
        
        // Count inclusions for marginal estimation
        $inclusionCounts = array_fill(1, $domain, 0);
        $burnIn = (int)($numIterations * 0.2); // 20% burn-in
        
        // MCMC sampling
        for ($iter = 0; $iter < $numIterations; $iter++) {
            // Propose a swap: remove one, add another
            $removeIdx = array_rand($currentSet);
            $removeNum = $currentSet[$removeIdx];
            
            // Pick a candidate not in current set
            $available = array_diff($candidateNums, $currentSet);
            if (empty($available)) {
                break;
            }
            $addNum = $available[array_rand($available)];
            
            // Calculate energy change
            $deltaE = SKAI_calculateEnergyDelta(
                $currentSet,
                $removeNum,
                $addNum,
                $qualityMap,
                $liftMap,
                $beta,
                $constraints
            );
            
            // Metropolis acceptance
            $acceptProb = exp($deltaE); // Note: E(S) is defined such that higher is better
            if (mt_rand() / mt_getrandmax() < $acceptProb) {
                // Accept swap
                $currentSet[$removeIdx] = $addNum;
            }
            
            // After burn-in, count inclusions
            if ($iter >= $burnIn) {
                foreach ($currentSet as $num) {
                    if ($num >= 1 && $num <= $domain) {
                        $inclusionCounts[$num]++;
                    }
                }
            }
        }
        
        // Calculate marginal probabilities
        $totalSamples = $numIterations - $burnIn;
        $marginals = [];
        
        for ($num = 1; $num <= $domain; $num++) {
            if ($inclusionCounts[$num] > 0) {
                $marginals[$num] = $inclusionCounts[$num] / $totalSamples;
            }
        }
        
        // Log convergence diagnostics
        SKAI_logGibbsDiagnostics($marginals, $numIterations, $burnIn);
        
        return $marginals;
        
    } catch (\Exception $e) {
        error_log('[SKAI] gibbsSampling error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Calculate energy delta for a proposed swap
 * 
 * @param array $currentSet  Current set S
 * @param int   $removeNum   Number to remove
 * @param int   $addNum      Number to add
 * @param array $qualityMap  Quality scores q(i)
 * @param array $liftMap     Pairwise lift map
 * @param float $beta        Interaction strength
 * @param array $constraints Constraint weights
 * @return float             Delta E (positive favors acceptance)
 */
function SKAI_calculateEnergyDelta($currentSet, $removeNum, $addNum, $qualityMap, $liftMap, $beta, $constraints) {
    // Energy = sum_i q(i) + beta * sum_{i<j} lift(i,j) + constraint penalties
    
    // Quality delta
    $deltaQ = ($qualityMap[$addNum] ?? 0.0) - ($qualityMap[$removeNum] ?? 0.0);
    
    // Pairwise interaction delta
    $deltaPairwise = 0.0;
    foreach ($currentSet as $num) {
        if ($num == $removeNum) {
            continue;
        }
        
        // Remove old interactions with removeNum
        $i = min($removeNum, $num);
        $j = max($removeNum, $num);
        $key = $i . '_' . $j;
        $deltaPairwise -= ($liftMap[$key] ?? 0.0);
        
        // Add new interactions with addNum
        $i = min($addNum, $num);
        $j = max($addNum, $num);
        $key = $i . '_' . $j;
        $deltaPairwise += ($liftMap[$key] ?? 0.0);
    }
    
    // Constraint penalty delta (optional)
    $deltaConstraints = SKAI_calculateConstraintDelta($currentSet, $removeNum, $addNum, $constraints);
    
    return $deltaQ + $beta * $deltaPairwise + $deltaConstraints;
}

/**
 * Calculate constraint penalty delta
 * 
 * @param array $currentSet  Current set
 * @param int   $removeNum   Number to remove
 * @param int   $addNum      Number to add
 * @param array $constraints Constraint weights
 * @return float             Delta constraint penalty
 */
function SKAI_calculateConstraintDelta($currentSet, $removeNum, $addNum, $constraints) {
    $delta = 0.0;
    
    // Example: sum-band constraint (prefer set sum in target range)
    if (isset($constraints['sum_band'])) {
        $targetSum = $constraints['sum_band']['target'] ?? 0;
        $weight = $constraints['sum_band']['weight'] ?? 0.1;
        
        $currentSum = array_sum($currentSet);
        $newSum = $currentSum - $removeNum + $addNum;
        
        $currentPenalty = -abs($currentSum - $targetSum) * $weight;
        $newPenalty = -abs($newSum - $targetSum) * $weight;
        
        $delta += $newPenalty - $currentPenalty;
    }
    
    // Example: parity constraint (prefer balanced odd/even)
    if (isset($constraints['parity'])) {
        $weight = $constraints['parity']['weight'] ?? 0.05;
        
        $oddCount = 0;
        foreach ($currentSet as $num) {
            if ($num % 2 == 1) {
                $oddCount++;
            }
        }
        
        $removeIsOdd = ($removeNum % 2 == 1);
        $addIsOdd = ($addNum % 2 == 1);
        
        $newOddCount = $oddCount;
        if ($removeIsOdd) $newOddCount--;
        if ($addIsOdd) $newOddCount++;
        
        $setSize = count($currentSet);
        $ideal = $setSize / 2;
        
        $currentPenalty = -abs($oddCount - $ideal) * $weight;
        $newPenalty = -abs($newOddCount - $ideal) * $weight;
        
        $delta += $newPenalty - $currentPenalty;
    }
    
    // Add more constraints as needed (gap, consecutive, etc.)
    
    return $delta;
}

/**
 * Re-rank candidates by Gibbs marginal probabilities
 * 
 * @param array $candidates  Original candidates
 * @param array $marginals   Marginal probabilities: {num => prob}
 * @return array             Re-ranked candidates
 */
function SKAI_rerankByMarginals($candidates, $marginals) {
    foreach ($candidates as &$candidate) {
        $num = $candidate['num'];
        $candidate['gibbs_marginal'] = $marginals[$num] ?? 0.0;
        
        // Update score to use marginal as primary ranking
        $candidate['score_total'] = $candidate['gibbs_marginal'];
    }
    
    usort($candidates, function($a, $b) {
        return ($b['gibbs_marginal'] ?? 0.0) <=> ($a['gibbs_marginal'] ?? 0.0);
    });
    
    return $candidates;
}

/**
 * Log Gibbs sampling diagnostics
 */
function SKAI_logGibbsDiagnostics($marginals, $numIterations, $burnIn) {
    try {
        $numNonZero = count(array_filter($marginals, function($p) { return $p > 0; }));
        $maxMarginal = !empty($marginals) ? max($marginals) : 0.0;
        $minMarginal = !empty($marginals) ? min(array_filter($marginals, function($p) { return $p > 0; })) : 0.0;
        
        $diagnostics = [
            'num_iterations' => $numIterations,
            'burn_in' => $burnIn,
            'num_nonzero_marginals' => $numNonZero,
            'max_marginal' => $maxMarginal,
            'min_marginal' => $minMarginal
        ];
        
        error_log('[SKAI] Gibbs diagnostics: ' . json_encode($diagnostics));
        
    } catch (\Exception $e) {
        error_log('[SKAI] logGibbsDiagnostics error: ' . $e->getMessage());
    }
}

/**
 * Check if Gibbs sampling is enabled
 * 
 * @return bool  True if enabled
 */
function SKAI_isGibbsEnabled() {
    try {
        $config = Factory::getConfig();
        $flag = $config->get('SKAI_USE_GIBBS', 0);
        return (bool)$flag;
    } catch (\Exception $e) {
        return false;
    }
}

/**
 * Get Gibbs sampling parameters from config
 * 
 * @return array  {iterations, beta, constraints, set_size}
 */
function SKAI_getGibbsParams() {
    try {
        $config = Factory::getConfig();
        
        return [
            'iterations' => (int)$config->get('SKAI_GIBBS_ITERATIONS', 1000),
            'beta' => (float)$config->get('SKAI_GIBBS_BETA', 1.0),
            'set_size' => (int)$config->get('SKAI_GIBBS_SET_SIZE', 20),
            'constraints' => [
                'sum_band' => [
                    'target' => (int)$config->get('SKAI_GIBBS_SUM_TARGET', 350),
                    'weight' => (float)$config->get('SKAI_GIBBS_SUM_WEIGHT', 0.1)
                ],
                'parity' => [
                    'weight' => (float)$config->get('SKAI_GIBBS_PARITY_WEIGHT', 0.05)
                ]
            ]
        ];
    } catch (\Exception $e) {
        error_log('[SKAI] getGibbsParams error: ' . $e->getMessage());
        return [
            'iterations' => 1000,
            'beta' => 1.0,
            'set_size' => 20,
            'constraints' => []
        ];
    }
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - AUTO-TUNING MODULE
 * =====================================================================
 * Purpose: Optimize weights and parameters using walk-forward validation
 * Objective: Maximize Recall@20 + a*NDCG@20 - b*MeanWinnerRank
 * Method: Grid search or simple optimization
 * Dependencies: Joomla 5.1.2, backtest module
 * =====================================================================
 */



/**
 * Run auto-tuning on validation window
 * 
 * @param string   $gameId        Game identifier
 * @param array    $drawHistory   Historical draws
 * @param int      $valStart      Validation window start index
 * @param int      $valEnd        Validation window end index
 * @param callable $predictFn     Prediction function($trainWindow, $params) => $rankedList
 * @param array    $searchSpace   Parameter search space
 * @param array    $objective     Objective weights: {a, b}
 * @return array                  Best parameters and results
 */
function SKAI_autoTune($gameId, $drawHistory, $valStart, $valEnd, $predictFn, $searchSpace, $objective = ['a' => 1.0, 'b' => 0.1]) {
    try {
        $bestParams = null;
        $bestScore = -PHP_FLOAT_MAX;
        $allResults = [];
        
        // Generate parameter combinations
        $paramCombinations = SKAI_generateParamCombinations($searchSpace);
        
        error_log('[SKAI] Auto-tuning: testing ' . count($paramCombinations) . ' parameter combinations');
        
        foreach ($paramCombinations as $idx => $params) {
            // Run backtest on validation window with these params
            $backtestResult = SKAI_runWalkForwardBacktest(
                $gameId,
                $drawHistory,
                $params['window_size'] ?? 50,
                $valStart,
                $valEnd,
                $params,
                $predictFn
            );
            
            if (isset($backtestResult['error'])) {
                continue;
            }
            
            // Calculate objective
            $aggregate = $backtestResult['aggregate'];
            $recallAt20 = $aggregate['avg_recall_at_20'];
            $ndcgAt20 = $aggregate['avg_ndcg_at_20'];
            $meanWinnerRank = $aggregate['avg_mean_winner_rank'];
            
            $score = $recallAt20 
                + $objective['a'] * $ndcgAt20 
                - $objective['b'] * ($meanWinnerRank / 100.0); // Normalize MWR
            
            $allResults[] = [
                'params' => $params,
                'recall_at_20' => $recallAt20,
                'ndcg_at_20' => $ndcgAt20,
                'mean_winner_rank' => $meanWinnerRank,
                'objective_score' => $score
            ];
            
            if ($score > $bestScore) {
                $bestScore = $score;
                $bestParams = $params;
            }
            
            error_log('[SKAI] Tested params ' . ($idx + 1) . '/' . count($paramCombinations) . ': score=' . number_format($score, 4));
        }
        
        // Store best params in database
        if ($bestParams !== null) {
            $bestResult = null;
            foreach ($allResults as $r) {
                if ($r['objective_score'] == $bestScore) {
                    $bestResult = $r;
                    break;
                }
            }
            
            if ($bestResult) {
                SKAI_storeTunedParams(
                    $gameId,
                    $bestParams,
                    $bestResult,
                    $valStart,
                    $valEnd,
                    $drawHistory
                );
            }
        }
        
        return [
            'best_params' => $bestParams,
            'best_score' => $bestScore,
            'all_results' => $allResults
        ];
        
    } catch (\Exception $e) {
        error_log('[SKAI] autoTune error: ' . $e->getMessage());
        return ['error' => $e->getMessage()];
    }
}

/**
 * Generate parameter combinations from search space
 * 
 * @param array $searchSpace  Search space definition
 * @return array              Array of parameter combinations
 */
function SKAI_generateParamCombinations($searchSpace) {
    $combinations = [[]];
    
    foreach ($searchSpace as $param => $values) {
        $newCombinations = [];
        foreach ($combinations as $combination) {
            foreach ($values as $value) {
                $newCombination = $combination;
                $newCombination[$param] = $value;
                $newCombinations[] = $newCombination;
            }
        }
        $combinations = $newCombinations;
    }
    
    return $combinations;
}

/**
 * Store tuned parameters in database
 * 
 * @param string $gameId       Game identifier
 * @param array  $params       Tuned parameters
 * @param array  $results      Performance results
 * @param int    $valStart     Validation start index
 * @param int    $valEnd       Validation end index
 * @param array  $drawHistory  Historical draws
 * @return int|false           Inserted ID or false
 */
function SKAI_storeTunedParams($gameId, $params, $results, $valStart, $valEnd, $drawHistory) {
    try {
        $db = Factory::getDbo();
        
        // Deactivate previous tuned params
        $query = $db->getQuery(true);
        $query->update($db->quoteName('#__skai_tuned_params'))
            ->set($db->quoteName('is_active') . ' = 0')
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId));
        $db->setQuery($query);
        $db->execute();
        
        // Insert new tuned params
        $now = new Date('now');
        $numValDraws = $valEnd - $valStart;
        
        $valStartDraw = $drawHistory[$valStart] ?? null;
        $valEndDraw = $drawHistory[$valEnd - 1] ?? null;
        
        $columns = [
            'game_id',
            'tuned_at',
            'validation_window_start',
            'validation_window_end',
            'num_validation_draws',
            'objective_value',
            'recall_at_20',
            'ndcg_at_20',
            'mean_winner_rank',
            'params_json',
            'is_active',
            'created_at'
        ];
        
        $values = [
            $db->quote($gameId),
            $db->quote($now->toSql()),
            $valStartDraw ? $db->quote($valStartDraw['date']) : 'NULL',
            $valEndDraw ? $db->quote($valEndDraw['date']) : 'NULL',
            (int)$numValDraws,
            (float)$results['objective_score'],
            (float)$results['recall_at_20'],
            (float)$results['ndcg_at_20'],
            (float)$results['mean_winner_rank'],
            $db->quote(json_encode($params, JSON_UNESCAPED_UNICODE)),
            1, // is_active
            $db->quote($now->toSql())
        ];
        
        $query = $db->getQuery(true);
        $query->insert($db->quoteName('#__skai_tuned_params'))
            ->columns($db->quoteName($columns))
            ->values(implode(',', $values));
        
        $db->setQuery($query);
        $db->execute();
        
        return $db->insertid();
        
    } catch (\Exception $e) {
        error_log('[SKAI] storeTunedParams error: ' . $e->getMessage());
        return false;
    }
}

/**
 * Get active tuned parameters for a game
 * 
 * @param string $gameId  Game identifier
 * @return array|null     Tuned parameters or null
 */
function SKAI_getActiveTunedParams($gameId) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_tuned_params'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('is_active') . ' = 1')
            ->order($db->quoteName('tuned_at') . ' DESC')
            ->setLimit(1);
        
        $db->setQuery($query);
        $row = $db->loadAssoc();
        
        if ($row) {
            $row['params_json'] = json_decode($row['params_json'], true);
            return $row;
        }
        
        return null;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getActiveTunedParams error: ' . $e->getMessage());
        return null;
    }
}

/**
 * Get default search space for parameter tuning
 * 
 * @return array  Search space configuration
 */
function SKAI_getDefaultSearchSpace() {
    return [
        'w_freq' => [0.2, 0.4, 0.6, 0.8, 1.0],
        'w_recency' => [0.0, 0.2, 0.4, 0.6],
        'w_window' => [0.0, 0.2, 0.4],
        'w_ml' => [0.0, 0.5, 1.0, 1.5],
        'w_penalty' => [0.0, 0.1, 0.2],
        'w_pairwise' => [0.0, 0.5, 1.0],
        'window_size' => [30, 50, 100],
        'calibration_bins' => [5, 10, 20],
        'decay_tau' => [5, 10, 20]
    ];
}

/**
 * Quick tuning with fewer combinations (for faster iteration)
 * 
 * @return array  Reduced search space
 */
function SKAI_getQuickSearchSpace() {
    return [
        'w_freq' => [0.4, 0.8],
        'w_recency' => [0.2, 0.4],
        'w_window' => [0.0, 0.2],
        'w_ml' => [0.5, 1.0],
        'w_penalty' => [0.0, 0.1],
        'w_pairwise' => [0.0, 0.5],
        'window_size' => [50],
        'calibration_bins' => [10],
        'decay_tau' => [10]
    ];
}

/**
 * Run tuning with custom objective
 * 
 * @param string $gameId       Game identifier
 * @param array  $drawHistory  Historical draws
 * @param int    $valStart     Validation start
 * @param int    $valEnd       Validation end
 * @param callable $predictFn  Prediction function
 * @param string $mode         'full' or 'quick'
 * @return array               Tuning results
 */
function SKAI_quickTune($gameId, $drawHistory, $valStart, $valEnd, $predictFn, $mode = 'quick') {
    $searchSpace = ($mode === 'full') 
        ? SKAI_getDefaultSearchSpace() 
        : SKAI_getQuickSearchSpace();
    
    $objective = ['a' => 1.0, 'b' => 0.1]; // Favor recall and NDCG
    
    return SKAI_autoTune(
        $gameId,
        $drawHistory,
        $valStart,
        $valEnd,
        $predictFn,
        $searchSpace,
        $objective
    );
}

/**
 * =====================================================================
 * SKAI EVALUATION ENGINE - EVALUATION REPORTS MODULE
 * =====================================================================
 * Purpose: Generate aggregate evaluation reports per game
 * Features: Performance metrics, miss reasons, before/after comparison
 * Dependencies: Joomla 5.1.2, backtest and attribution modules
 * =====================================================================
 */



/**
 * Generate evaluation report for a game
 * 
 * @param string $gameId           Game identifier
 * @param string $periodStart      Evaluation period start date (YYYY-MM-DD)
 * @param string $periodEnd        Evaluation period end date (YYYY-MM-DD)
 * @param array  $beforeAfter      Optional: before/after comparison data
 * @return array                   Report data
 */
function SKAI_generateEvaluationReport($gameId, $periodStart, $periodEnd, $beforeAfter = null) {
    try {
        // Get backtest metrics for period
        $metrics = SKAI_getBacktestMetricsForPeriod($gameId, $periodStart, $periodEnd);
        
        if (empty($metrics)) {
            return [
                'error' => 'No backtest metrics found for this period',
                'game_id' => $gameId,
                'period_start' => $periodStart,
                'period_end' => $periodEnd
            ];
        }
        
        // Calculate aggregate metrics
        $numDraws = count($metrics);
        $totalRecall = 0.0;
        $totalNDCG = 0.0;
        $totalMWR = 0.0;
        
        foreach ($metrics as $m) {
            $totalRecall += $m['recall_at_20'];
            $totalNDCG += $m['ndcg_at_20'];
            $totalMWR += $m['mean_winner_rank'];
        }
        
        $avgRecall = $numDraws > 0 ? $totalRecall / $numDraws : 0.0;
        $avgNDCG = $numDraws > 0 ? $totalNDCG / $numDraws : 0.0;
        $avgMWR = $numDraws > 0 ? $totalMWR / $numDraws : 0.0;
        
        // Get top miss reasons
        $topMissReasons = SKAI_getTopMissReasons($gameId, 10);
        
        // Build summary text
        $summaryText = SKAI_buildReportSummary($gameId, $avgRecall, $avgNDCG, $avgMWR, $numDraws, $topMissReasons);
        
        // Store report in database
        $reportId = SKAI_storeEvaluationReport(
            $gameId,
            $periodStart,
            $periodEnd,
            $numDraws,
            $avgRecall,
            $avgNDCG,
            $avgMWR,
            $topMissReasons,
            $beforeAfter,
            $summaryText
        );
        
        return [
            'report_id' => $reportId,
            'game_id' => $gameId,
            'period_start' => $periodStart,
            'period_end' => $periodEnd,
            'num_draws_evaluated' => $numDraws,
            'avg_recall_at_20' => $avgRecall,
            'avg_ndcg_at_20' => $avgNDCG,
            'avg_mean_winner_rank' => $avgMWR,
            'top_miss_reasons' => $topMissReasons,
            'before_after' => $beforeAfter,
            'summary_text' => $summaryText
        ];
        
    } catch (\Exception $e) {
        error_log('[SKAI] generateEvaluationReport error: ' . $e->getMessage());
        return ['error' => $e->getMessage()];
    }
}

/**
 * Get backtest metrics for a date period
 */
function SKAI_getBacktestMetricsForPeriod($gameId, $periodStart, $periodEnd) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_backtest_metrics'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('test_draw_date') . ' >= ' . $db->quote($periodStart))
            ->where($db->quoteName('test_draw_date') . ' <= ' . $db->quote($periodEnd))
            ->order($db->quoteName('test_draw_date') . ' ASC');
        
        $db->setQuery($query);
        return $db->loadAssocList();
        
    } catch (\Exception $e) {
        error_log('[SKAI] getBacktestMetricsForPeriod error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Build human-readable report summary
 */
function SKAI_buildReportSummary($gameId, $avgRecall, $avgNDCG, $avgMWR, $numDraws, $topMissReasons) {
    $summary = "SKAI Evaluation Report - {$gameId}\n";
    $summary .= "=========================================\n\n";
    
    $summary .= "Performance Metrics (Last {$numDraws} draws):\n";
    $summary .= "  - Average Recall@20: " . number_format($avgRecall * 100, 2) . "%\n";
    $summary .= "  - Average NDCG@20: " . number_format($avgNDCG, 4) . "\n";
    $summary .= "  - Average Winner Rank: " . number_format($avgMWR, 2) . "\n\n";
    
    $summary .= "Top Miss Reasons:\n";
    foreach ($topMissReasons as $idx => $reason) {
        $summary .= "  " . ($idx + 1) . ". " . $reason['reason'] . ": " . $reason['count'] . " occurrences (" . number_format($reason['pct'], 1) . "%)\n";
    }
    
    $summary .= "\nBuilt on probabilities--not promises.\n";
    
    return $summary;
}

/**
 * Store evaluation report in database
 */
function SKAI_storeEvaluationReport($gameId, $periodStart, $periodEnd, $numDraws, $avgRecall, $avgNDCG, $avgMWR, $topMissReasons, $beforeAfter, $summaryText) {
    try {
        $db = Factory::getDbo();
        
        // Check if report for this game/date already exists
        $query = $db->getQuery(true);
        $reportDate = new Date('now');
        $reportDateStr = $reportDate->format('Y-m-d');
        
        $query->select('id')
            ->from($db->quoteName('#__skai_evaluation_reports'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('report_date') . ' = ' . $db->quote($reportDateStr));
        
        $db->setQuery($query);
        $existingId = $db->loadResult();
        
        if ($existingId) {
            // Update existing report
            $query = $db->getQuery(true);
            $query->update($db->quoteName('#__skai_evaluation_reports'))
                ->set($db->quoteName('evaluation_period_start') . ' = ' . $db->quote($periodStart))
                ->set($db->quoteName('evaluation_period_end') . ' = ' . $db->quote($periodEnd))
                ->set($db->quoteName('num_draws_evaluated') . ' = ' . (int)$numDraws)
                ->set($db->quoteName('avg_recall_at_20') . ' = ' . (float)$avgRecall)
                ->set($db->quoteName('avg_ndcg_at_20') . ' = ' . (float)$avgNDCG)
                ->set($db->quoteName('avg_mean_winner_rank') . ' = ' . (float)$avgMWR)
                ->set($db->quoteName('top_miss_reasons_json') . ' = ' . $db->quote(json_encode($topMissReasons)))
                ->set($db->quoteName('before_after_json') . ' = ' . ($beforeAfter ? $db->quote(json_encode($beforeAfter)) : 'NULL'))
                ->set($db->quoteName('summary_text') . ' = ' . $db->quote($summaryText))
                ->where($db->quoteName('id') . ' = ' . (int)$existingId);
            
            $db->setQuery($query);
            $db->execute();
            
            return $existingId;
        } else {
            // Insert new report
            $columns = [
                'game_id',
                'report_date',
                'evaluation_period_start',
                'evaluation_period_end',
                'num_draws_evaluated',
                'avg_recall_at_20',
                'avg_ndcg_at_20',
                'avg_mean_winner_rank',
                'top_miss_reasons_json',
                'before_after_json',
                'summary_text',
                'created_at'
            ];
            
            $now = new Date('now');
            $values = [
                $db->quote($gameId),
                $db->quote($reportDateStr),
                $db->quote($periodStart),
                $db->quote($periodEnd),
                (int)$numDraws,
                (float)$avgRecall,
                (float)$avgNDCG,
                (float)$avgMWR,
                $db->quote(json_encode($topMissReasons)),
                $beforeAfter ? $db->quote(json_encode($beforeAfter)) : 'NULL',
                $db->quote($summaryText),
                $db->quote($now->toSql())
            ];
            
            $query = $db->getQuery(true);
            $query->insert($db->quoteName('#__skai_evaluation_reports'))
                ->columns($db->quoteName($columns))
                ->values(implode(',', $values));
            
            $db->setQuery($query);
            $db->execute();
            
            return $db->insertid();
        }
        
    } catch (\Exception $e) {
        error_log('[SKAI] storeEvaluationReport error: ' . $e->getMessage());
        return false;
    }
}

/**
 * Get evaluation reports for a game
 * 
 * @param string $gameId  Game identifier
 * @param int    $limit   Number of reports to retrieve
 * @return array          Array of reports
 */
function SKAI_getEvaluationReports($gameId, $limit = 10) {
    try {
        $db = Factory::getDbo();
        $query = $db->getQuery(true);
        
        $query->select('*')
            ->from($db->quoteName('#__skai_evaluation_reports'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->order($db->quoteName('report_date') . ' DESC')
            ->setLimit($limit);
        
        $db->setQuery($query);
        $results = $db->loadAssocList();
        
        // Decode JSON fields
        foreach ($results as &$row) {
            $row['top_miss_reasons_json'] = json_decode($row['top_miss_reasons_json'], true);
            if ($row['before_after_json']) {
                $row['before_after_json'] = json_decode($row['before_after_json'], true);
            }
        }
        
        return $results;
        
    } catch (\Exception $e) {
        error_log('[SKAI] getEvaluationReports error: ' . $e->getMessage());
        return [];
    }
}

/**
 * Generate before/after comparison when tuning is applied
 * 
 * @param string $gameId       Game identifier
 * @param array  $drawHistory  Historical draws
 * @param int    $compareStart Start index for comparison
 * @param int    $compareEnd   End index for comparison
 * @param array  $oldParams    Old parameters
 * @param array  $newParams    New (tuned) parameters
 * @param callable $predictFn  Prediction function
 * @return array               Before/after comparison
 */
function SKAI_generateBeforeAfterComparison($gameId, $drawHistory, $compareStart, $compareEnd, $oldParams, $newParams, $predictFn) {
    try {
        // Run backtest with old params
        $beforeResult = SKAI_runWalkForwardBacktest(
            $gameId,
            $drawHistory,
            $oldParams['window_size'] ?? 50,
            $compareStart,
            $compareEnd,
            $oldParams,
            $predictFn
        );
        
        // Run backtest with new params
        $afterResult = SKAI_runWalkForwardBacktest(
            $gameId,
            $drawHistory,
            $newParams['window_size'] ?? 50,
            $compareStart,
            $compareEnd,
            $newParams,
            $predictFn
        );
        
        return [
            'before' => $beforeResult['aggregate'],
            'after' => $afterResult['aggregate'],
            'improvement' => [
                'recall_at_20' => $afterResult['aggregate']['avg_recall_at_20'] - $beforeResult['aggregate']['avg_recall_at_20'],
                'ndcg_at_20' => $afterResult['aggregate']['avg_ndcg_at_20'] - $beforeResult['aggregate']['avg_ndcg_at_20'],
                'mean_winner_rank' => $beforeResult['aggregate']['avg_mean_winner_rank'] - $afterResult['aggregate']['avg_mean_winner_rank'] // Lower is better
            ]
        ];
        
    } catch (\Exception $e) {
        error_log('[SKAI] generateBeforeAfterComparison error: ' . $e->getMessage());
        return [];
    }
}



// === END EVALUATION SYSTEM ===
// All evaluation functions are now available in this SKAI file

// ========================================================================
/**
 * SKAI: Resolve lottery_id robustly without schema changes.
 * Priority: POST(lottery_id) ? config.lottery_id ? URL game_id/gid ? JSON lookup by game_id/dbCol.
 */
if (!function_exists('skaiResolveLotteryId')) {
    function skaiResolveLotteryId(array $lotteryConfig, \Joomla\Input\Input $in, string $jsonPath): int
    {
        // 1) Explicit POST
        $postId = (int) $in->getInt('lottery_id', 0);
        if ($postId > 0) return $postId;

        // 2) From current page config
        $cfgId  = (int) ($lotteryConfig['lottery_id'] ?? 0);
        if ($cfgId > 0) return $cfgId;

        // 3) From URL (your routes commonly have game_id or gid)
        // NOTE: game_id/gid are logical identifiers (e.g. "801"), not the numeric
        // primary key lottery_id stored in #__lotteries. We do NOT return them
        // directly here; instead the JSON mapping below will translate them into
        // the correct lottery_id when available.

        // 4) Last resort: search the master JSON by game_id or dbCol
        try {
            $raw = @file_get_contents($jsonPath);
            if ($raw !== false) {
                $all = json_decode($raw, true);
                if (json_last_error() === JSON_ERROR_NONE && is_array($all)) {
                    // Accept either gid= or game_id= from the URL and normalize
                    $wantGid = (string) strtoupper(
                        trim((string) $in->getString('gid', $in->getString('game_id', '')))
                    );
                    $wantDb  = (string) ($lotteryConfig['dbCol'] ?? '');

                    foreach ($all as $row) {
                        // Normalize keys defensively
                        $rid    = (int)   ($row['lottery_id'] ?? $row['game_id'] ?? 0);
                        $rgid   = (string)strtoupper((string)($row['game_id'] ?? $row['gid'] ?? ''));
                        $rdbCol = (string)($row['dbCol'] ?? '');

                        // Prefer exact gid/game_id match if present
                        if ($wantGid !== '' && $rgid === $wantGid && $rid > 0) return $rid;

                        // Else, try matching by dbCol when we have it
                        if ($wantDb !== '' && $rdbCol !== '' && $rdbCol === $wantDb && $rid > 0) return $rid;
                    }
                }
            }
        } catch (\Throwable $e) { /* ignore; will fall through to 0 */ }

        return 0; // unresolved ? handled by required checks upstream
    }
}

/**
 * Retrieves the next non-blank next_draw_date, expanding #__ prefix.
 * Returns DATETIME (adds ' 00:00:00' if the source is DATE-only).
 *
 * [ADDED] Proven helper copied from your working file.
 */
if (!function_exists('getNextDrawDate')) {
    function getNextDrawDate(string $gameId, $db, string $tableName): ?string
    {
        $tbl = $db->quoteName($db->replacePrefix($tableName));

        $q = $db->getQuery(true)
            ->select($db->quoteName('next_draw_date'))
            ->from($tbl)
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->where($db->quoteName('next_draw_date') . ' IS NOT NULL')
            ->where($db->quoteName('next_draw_date') . " <> " . $db->quote('0000-00-00'))
            ->where($db->quoteName('next_draw_date') . " <> " . $db->quote('0000-00-00 00:00:00'))
            ->order($db->quoteName('draw_date') . ' DESC')
            ->setLimit(1);

        $db->setQuery($q);
        $val = $db->loadResult();

        // Normalize DATE -> DATETIME for downstream inserts (keeps your schema grouping stable)
        if (!empty($val) && preg_match('/^\d{4}-\d{2}-\d{2}$/', $val)) {
            $val .= ' 00:00:00';
        }

        return $val ?: null;
    }
}

/* ---------- SKAI: derive table meta from dbCol (rows_total, next_draw_*) ---------- */
try {
    if (!isset($db)) { $db = \Joomla\CMS\Factory::getContainer()->get('DatabaseDriver'); }
    $skaiDbMeta = ['rows_total'=>0,'next_draw_date'=>null,'next_draw_at'=>null,'draw_session'=>null];

    // New: resolve dbCol directly from lottery_skip_config.json and the current game id,
    // so we don't depend on $lotteryConfig being populated later in the file.
    $dbCol = '';
    try {
        // Rebuild the selected game key exactly like the later config section does.
        $rawId = (string) $in->getString('game_id', '');
        if ($rawId === '') {
            $rawId = (string) $in->getString('gameId', '');
        }
        if ($rawId === '') {
            $rawId = (string) $in->getString('gid', '');
        }
        if ($rawId === '') {
            $rawId = '101'; // same fallback you use later
        }
        $selectedGameId = strtoupper(trim($rawId));

        // Load the master config and pull dbCol for this lottery
        $cfgRaw = @file_get_contents($masterJsonPath);
        if ($cfgRaw !== false) {
            $cfg = json_decode($cfgRaw, true);
            if (
                json_last_error() === JSON_ERROR_NONE &&
                isset($cfg['lotteries'][$selectedGameId]) &&
                is_array($cfg['lotteries'][$selectedGameId])
            ) {
                $lotRow = $cfg['lotteries'][$selectedGameId];
                $dbCol  = (string) ($lotRow['dbCol'] ?? '');
            }
        }

        // Fallback: daily games use "tableName" in dailylotteries.json
        if ($dbCol === '' && !empty($dailyJsonPath) && function_exists('skaiDailyResolveDbCol')) {
            $dbCol = skaiDailyResolveDbCol($dailyJsonPath, $selectedGameId, (bool) $isDebug);
        }

    } catch (\Throwable $__) {
        // Keep $dbCol empty; meta stays default
        $dbCol = '';
    }

    if ($dbCol !== '') {
        // Use Joomla's prefix replacement so we hit the real draw table
        $tbl = $db->quoteName($db->replacePrefix($dbCol));

        // 1) Total rows = draws analyzed (best available proxy)
        $qCount = $db->getQuery(true)
            ->select('COUNT(*)')
            ->from($tbl);
        $db->setQuery($qCount);
        $skaiDbMeta['rows_total'] = (int) $db->loadResult();

        // 2) Read the latest row (by draw_date) and pull next_draw_* fields
        // [CHANGE] next_draw_date now uses proven getNextDrawDate() to skip blanks/0000-00-00.
        $qNext = $db->getQuery(true)
            ->select($db->quoteName(['next_draw_at','draw_session']))
            ->from($tbl)
            ->order($db->quoteName('draw_date') . ' DESC')
            ->setLimit(1);
        $db->setQuery($qNext);
        $latest = $db->loadAssoc() ?: [];

        // Best next_draw_date (non-blank, non-zero) by game_id + draw_date DESC
        try {
            $skaiDbMeta['next_draw_date'] = getNextDrawDate($selectedGameId, $db, $dbCol);
        } catch (\Throwable $__) {
            $skaiDbMeta['next_draw_date'] = null;
        }

        $skaiDbMeta['next_draw_at']   = $latest['next_draw_at']   ?? null;
        $skaiDbMeta['draw_session']   = $latest['draw_session']   ?? null;
    }
} catch (\Throwable $e) {
    // keep $skaiDbMeta defaults; avoid breaking page
    if (!empty($isDebug)) { $app->enqueueMessage('Meta resolve failed: '.$e->getMessage(), 'warning'); }
}

/* ============================================================
 * SKAI  Save Prediction (Skip & Hit) handler
 * Maps posted fields into #__user_saved_numbers without schema changes.
 * ============================================================ */

// [ADDED] Ensure $lotteryConfig exists as an array even if config loading happens later
// This prevents a TypeError in skaiResolveLotteryId(array $lotteryConfig, ...) on early POST saves.
if (!isset($lotteryConfig) || !is_array($lotteryConfig)) { $lotteryConfig = []; } // ? safety guard

try {
    // Guard: ensure this save handler executes only once per request (Sourcerer may render multiple times)
    if (defined('SKAI_SAVE_HANDLER_EXECUTED')) { goto SKAI_SAVE_DONE; }
    define('SKAI_SAVE_HANDLER_EXECUTED', true);

    $db   = Factory::getContainer()->get('DatabaseDriver');
    $user = Factory::getUser();

    // Membership gate: only group 14 (LottoExpert members) may save
    $allowedGroups = [14];
    $userGroups    = $user->groups ?? [];
    $isMember      = (bool) array_intersect($allowedGroups, $userGroups);
    if (!$isMember) {
        $app->enqueueMessage('Please sign in with a member account to save sets.', 'warning');
        goto SKAI_SAVE_DONE;
    }

    // Only proceed on POST save + valid token + logged-in member
    $doSave = ($in->getMethod() === 'POST')
        && ((int)$in->getInt('save_set', 0) === 1)
        && Session::checkToken();

    if ($doSave && !empty($saveable) && (int)$user->id > 0) {
        // Read posted payloads
        $numbersJson = (string) $in->getString('numbers_json', '');
        $evidenceJson= (string) $in->getString('top_combos_json', '');
        $labelInput  = trim((string) $in->getString('notes', ''));

        /*
         * NEXT DRAW RESOLUTION (canonical priority):
         * 1) Explicit POST override (if client sends next_draw_date/at)
         * 2) Latest draw-table meta already resolved above ($skaiDbMeta)
         * 3) Fallback null
         *
         * This fixes undefined $nextDrawDateSql usage and ensures dashboard grouping uses real next draw.
         */
        $nextDrawDateSql = trim((string) $in->getString('next_draw_date', ''));
        if ($nextDrawDateSql === '' && !empty($skaiDbMeta['next_draw_date'])) {
            $nextDrawDateSql = (string) $skaiDbMeta['next_draw_date'];
        }

        $nextDrawAtSql = trim((string) $in->getString('next_draw_at', ''));
        if ($nextDrawAtSql === '' && !empty($skaiDbMeta['next_draw_at'])) {
            $nextDrawAtSql = (string) $skaiDbMeta['next_draw_at'];
        }

        // Minify evidence JSON if possible (decode?encode) to keep storage lean
        if ($evidenceJson !== '') {
            $tmp = json_decode($evidenceJson, true);
            if (json_last_error() === JSON_ERROR_NONE) {
                $evidenceJson = json_encode($tmp, JSON_UNESCAPED_SLASHES);
            }
        }

        // --- Auto-label if empty: "Country ? State ? Lottery ? Mon D, YYYY"
        $labelInput = strip_tags($labelInput); // safety
        if ($labelInput === '') {
            $country = (string)($lotteryConfig['country'] ?? 'USA');
            $state   = (string)($lotteryConfig['state']   ?? '');
            // Prefer JSON "lotteryName", then legacy keys, then a generic fallback
            $lotName = (string)($lotteryConfig['lotteryName'] ?? $lotteryConfig['lottery_name'] ?? $lotteryConfig['game_name'] ?? 'Lottery');
            $dStr    = null;

            // Prefer next_draw_date; else today (site tz)
            try {
                $siteTz = isset($siteTz) ? $siteTz : 'America/New_York';
                if (!empty($nextDrawDateSql)) {
                    $dStr = (new Date($nextDrawDateSql, $siteTz))->format('M j, Y', true);
                } else {
                    $dStr = (new Date('now', $siteTz))->format('M j, Y', true);
                }
            } catch (\Throwable $e) {
                $dStr = date('M j, Y');
            }

$parts = array_filter([$country, $state, $lotName, $dStr], static function($v){ return $v !== ''; });
$labelInput = implode(' - ', $parts);
        }
        $label = $labelInput;

        // --- SCHEMA GUARD (prevents 1054: Unknown column 'game_id') ---
        // Map correct column names for #__user_saved_numbers.
        $columnsMap = $db->getTableColumns('#__user_saved_numbers'); // [col => type]
        $columnsMap = is_array($columnsMap) ? array_change_key_case($columnsMap, CASE_LOWER) : [];

        // NOTE: lottery_id resolution is handled centrally by skaiResolveLotteryId()
        // using $lotteryConfig (already populated with a numeric lottery_id) plus POST/URL.

        // Decode numbers_json ? arrays (legacy pre-normalization removed to avoid touching $data early)
        $nums = json_decode($numbersJson, true);
        $mainArr  = is_array($nums['main_numbers'] ?? null) ? $nums['main_numbers'] : [];
        $extraArr = is_array($nums['extra_numbers'] ?? null) ? $nums['extra_numbers'] : [];

        // Helper: detect daily (0?9) games so 0 is allowed there only
        $isDaily = (function(array $cfg): bool {
            // Try common keys in your JSON config (tolerant)
            $maxMain = null;
            if (isset($cfg['rangeMainMax']))        $maxMain = (int)$cfg['rangeMainMax'];
            elseif (isset($cfg['mainNumbersMax']))  $maxMain = (int)$cfg['mainNumbersMax'];
            elseif (isset($cfg['lotteryConfig']['mainNumbersMax'])) $maxMain = (int)$cfg['lotteryConfig']['mainNumbersMax'];
            // Heuristic: daily games typically have max = 9
            return ($maxMain !== null && $maxMain <= 9);
        })($lotteryConfig ?? []);

        // Normalize with project rule: exclude 0 unless it's a daily game
        // CHG: Preserve input order (probability order) while de-duping.
        // Sorting (numeric) will be applied later only for non-SKAI saves.
        $norm = static function(array $a, bool $allowZero): array {
            $out  = [];
            $seen = [];

            foreach ($a as $v) {
                $n = (int) $v;

                if ($n === 0 && !$allowZero) {
                    continue; // exclude 0 for non-daily
                }
                if ($n < 0) {
                    continue;
                }

                if (!isset($seen[$n])) {
                    $seen[$n] = true;
                    $out[]    = $n; // preserve original ordering
                }
            }

            return $out;
        };

        $mainArr  = $norm($mainArr,  $isDaily);
        $extraArr = $norm($extraArr, $isDaily);

        // --- Strict validation against config (size, range, uniqueness) ---
        $pickSize = (int) ($lotteryConfig['lotteryConfig']['pickSize'] ?? $lotteryConfig['pickSize'] ?? 0);
        $mainMax  = (int) ($lotteryConfig['lotteryConfig']['mainNumbersMax'] ?? $lotteryConfig['mainNumbersMax'] ?? 0);
        $mainMin  = (int) ($lotteryConfig['lotteryConfig']['mainNumbersMin'] ?? $lotteryConfig['mainNumbersMin'] ?? 1);
        $extraMax = (int) ($lotteryConfig['lotteryConfig']['extraNumbersMax'] ?? $lotteryConfig['extraNumbersMax'] ?? 0);
        $extraMin = (int) ($lotteryConfig['lotteryConfig']['extraNumbersMin'] ?? $lotteryConfig['extraNumbersMin'] ?? 1);
        $hasExtraCfg = !empty($lotteryConfig['hasExtraBall']) || !empty($lotteryConfig['lotteryConfig']['hasExtraBall']);

        // Determine if this save is a SKAI pool-style prediction (top 20/5),
        // which should not be forced to match pickSize or the 2-extra limit.
        $sourceRaw  = (string) $in->getString('analysis_type', 'skip_hit');
        $sourceNorm = preg_replace('/[^a-z0-9_\-]/i', '', $sourceRaw) ?: 'skip_hit';
        $isSkaiPool = in_array($sourceNorm, ['skai_prediction', 'skai_ai'], true);

        // Clamp mins
        if ($mainMin <= 0) $mainMin = $isDaily ? 0 : 1;
        if ($extraMin <= 0) $extraMin = $isDaily ? 0 : 1;

        // Range filter (drop anything out of range)
        $mainArr = array_values(array_filter($mainArr, function($n) use ($mainMin, $mainMax){
            if ($mainMax > 0) return ($n >= $mainMin && $n <= $mainMax);
            return ($n >= $mainMin);
        }));
        $extraArr = array_values(array_filter($extraArr, function($n) use ($extraMin, $extraMax){
            if ($extraMax > 0) return ($n >= $extraMin && $n <= $extraMax);
            return ($n >= $extraMin);
        }));

        // Size checks (best-effort: allow save when not provided in config)
        // For SKAI pool saves (skai_prediction), we allow > pickSize (e.g. top 20 mains).
        if (!$isSkaiPool && $pickSize > 0 && count($mainArr) !== $pickSize) {
            $app->enqueueMessage(
                'We couldn\'t save: expected ' . $pickSize . ' main numbers, got ' . count($mainArr) . '.',
                'error'
            );
            goto SKAI_SAVE_DONE;
        }
        if (!$isSkaiPool && $hasExtraCfg && $extraMax > 0) {
            // For non-SKAI saves with extras: allow 0, 1, or 2 depending on config; do not exceed 2 for now
            if (count($extraArr) > 2) {
                $app->enqueueMessage('We couldn\'t save: too many extra balls (max 2).', 'error');
                goto SKAI_SAVE_DONE;
            }
        } else {
            // No extra ball in config ? drop extras silently
            if (!$hasExtraCfg || $extraMax <= 0) {
                $extraArr = [];
            }
        }

        // --- Required checks (strict) ---
        if ((int)$user->id <= 0) {
            $app->enqueueMessage('You need to be signed in to save picks.', 'error');
            goto SKAI_SAVE_DONE;
        }

        // --- Canonicalize number arrays ---
        // CHG: For SKAI pool saves, preserve probability order.
        // For all other saves, keep numeric canonical order to avoid '01' vs '1' mismatches.
        $canon = static function(array $arr, bool $preserveOrder): array {
            $arr = array_map('intval', $arr); // force integers

            if ($preserveOrder) {
                // De-dupe while preserving original order (most probable -> least probable)
                $out  = [];
                $seen = [];
                foreach ($arr as $n) {
                    if (!isset($seen[$n])) {
                        $seen[$n] = true;
                        $out[]    = $n;
                    }
                }
                return $out;
            }

            // Legacy behavior: de-dupe + numeric sort
            $arr = array_values(array_unique($arr));
            sort($arr, SORT_NUMERIC);
            return $arr;
        };

        $preserveProbabilityOrder = !empty($isSkaiPool); // already derived from analysis_type earlier
        $mainArr  = $canon($mainArr,  $preserveProbabilityOrder);
        $extraArr = $canon($extraArr, $preserveProbabilityOrder);

        // Rebuild CSVs from canonical arrays
        $mainCsv  = implode(',', $mainArr);
        $extraCsv = implode(',', $extraArr);

        // Resolve lottery_id robustly (POST ? config ? URL ? JSON by game_id/dbCol) BEFORE validating
        $lotteryId = skaiResolveLotteryId($lotteryConfig, $in, $masterJsonPath);

        if ((int)$lotteryId <= 0) {
            $app->enqueueMessage('We couldn\'t resolve the lottery id for this page. Save aborted.', 'error');
            goto SKAI_SAVE_DONE;
        }
        if (empty($mainArr)) {
            $app->enqueueMessage('No main numbers to save. Please build your set first.', 'error');
            goto SKAI_SAVE_DONE;
        }

        // Back-compat: if JSON failed/empty, allow explicit CSVs from POST
        if ($mainCsv === '' && ($tmp = trim((string)$in->getString('main_numbers_csv',''))) !== '') {
            $mainCsv = preg_replace('/[^0-9,]/', '', $tmp);
        }
        if ($extraCsv === '' && ($tmp = trim((string)$in->getString('extra_ball_numbers_csv',''))) !== '') {
            $extraCsv = preg_replace('/[^0-9,]/', '', $tmp);
        }
        // Rehydrate arrays from CSV (so downstream star_ball1/2 mapping still works)
        if ($mainCsv !== '' && empty($mainArr))  { $mainArr  = array_values(array_filter(array_map('intval', explode(',', $mainCsv)), 'strlen')); }
        if ($extraCsv !== '' && empty($extraArr)) { $extraArr = array_values(array_filter(array_map('intval', explode(',', $extraCsv)), 'strlen')); }


        // Draws analyzed priority: 1) count($mainHistory) if available; 2) DB meta rows_total; 3) request fallback
        if (isset($mainHistory) && is_array($mainHistory) && count($mainHistory) > 0) {
            $drawsAnalyzed = (int) count($mainHistory);
        } elseif (isset($skaiDbMeta['rows_total']) && (int)$skaiDbMeta['rows_total'] > 0) {
            $drawsAnalyzed = (int) $skaiDbMeta['rows_total'];
        } else {
            // Accept client hint if provided
            $drawsAnalyzed = (int) $in->getInt('draws_analyzed', 0);
        }

        // Knobs: best-effort from POST/DOM; align with your defaults
        $laplaceK   = (int) $in->getInt('laplace_k', (int)($lotteryConfig['laplace_k'] ?? 1));
        $skipWindow = (int) $in->getInt('bt_windows', 0);
        $autoTune   = (int) $in->getInt('bt_autotune', 0);
        $bestWindow = (int) $in->getInt('best_window', 0);
        $tunedWin   = (int) $in->getInt('tuned_window', 0);

        // Source passthrough (analysis type) with sanitization; default skip_hit
        $source = (string) $in->getString('analysis_type', 'skip_hit');
        $source = preg_replace('/[^a-z0-9_\-]/i', '', $source) ?: 'skip_hit';


        // --- Optional weights (0?100), clamp safely; ignore if missing ---
        $clamp01   = static function($v){ $v=(int)$v; return max(0, min(100, $v)); };
        $freqW     = $in->getString('freq_weight', null);      $freqW     = ($freqW!==null)     ? $clamp01($freqW) : null;
        $skipW     = $in->getString('skip_weight', null);      $skipW     = ($skipW!==null)     ? $clamp01($skipW) : null;
        $histW     = $in->getString('hist_weight', null);      $histW     = ($histW!==null)     ? $clamp01($histW) : null;
        $pbFreqW   = $in->getString('pb_freq_weight', null);   $pbFreqW   = ($pbFreqW!==null)   ? $clamp01($pbFreqW) : null;
        $pbSkipW   = $in->getString('pb_skip_weight', null);   $pbSkipW   = ($pbSkipW!==null)   ? $clamp01($pbSkipW) : null;
        $pbHistW   = $in->getString('pb_hist_weight', null);   $pbHistW   = ($pbHistW!==null)   ? $clamp01($pbHistW) : null;

        // --- Optional NN / analysis params (pass-through if provided) ---
        $epochs    = $in->getInt('epochs', null);
        $batchSize = $in->getInt('batch_size', null);
        $dropout   = $in->getString('dropout_rate', null);
        $learnRate = $in->getString('learning_rate', null);
        $actFn     = $in->getString('activation_function', null);
        $hidden    = $in->getInt('hidden_layers', null);
        $recDecay  = $in->getString('recency_decay', null);

        // MCMC-ish knobs (present on other modules; harmless here if absent)
        $walks     = $in->getInt('walks', null);
        $burnIn    = $in->getInt('burn_in', null);
        $decay     = $in->getString('decay', null);
        $chainLen  = $in->getInt('chain_len', null);

        // Misc flags
        $pureMode  = $in->getInt('pure_mode', null);
        $tuneUsed  = $in->getInt('tune_used', null);

        // SKAI-specific parameters (blend, temperature, diversity, etc.)
        $skaiBlendSkipPct   = $in->getString('skai_blend_skip_pct', null);
        $skaiBlendAiPct     = $in->getString('skai_blend_ai_pct', null);
        $samplingTemp       = $in->getString('sampling_temperature', null);
        $diversityPenalty   = $in->getString('diversity_penalty', null);
        $gapScale           = $in->getString('gap_scale', null);
        $skaiWindowSize     = $in->getInt('skai_window_size', null);
        $skaiRunMode        = $in->getString('skai_run_mode', null);
        $skaiTopNNumbers    = $in->getInt('skai_top_n_numbers', null);
        $skaiTopNCombos     = $in->getInt('skai_top_n_combos', null);

        // User selection: risk profile + strategy (sanitize input)
        $riskProfile = $in->getString('risk_profile', null);
        if ($riskProfile !== null) {
            $riskProfile = trim(strtolower((string)$riskProfile));
            if (!in_array($riskProfile, ['balanced', 'explorative', 'conservative'], true)) {
                $riskProfile = 'balanced';
            }
        }
        $strategy = $in->getString('strategy', null);
        if ($strategy !== null) {
            $strategy = trim(strtolower((string)$strategy));
            if (!in_array($strategy, ['ai', 'hybrid', 'skip'], true)) {
                $strategy = 'hybrid';
            }
        }

        // Compose a user-friendly label ONLY if one hasn't already been built upstream.
        // Prefer JSON "lotteryName", then legacy keys.
        if (empty($label)) {
            $lotName = (string) ($lotteryConfig['lotteryName'] ?? $lotteryConfig['lottery_name'] ?? $lotteryConfig['game_name'] ?? 'Lottery');
            $dateNow = (new Date())->format('M j, Y');
            $label   = $labelInput !== '' ? $labelInput : ('SKAI - ' . $lotName . ' - ' . $dateNow);
        }

        // Compute timestamps with timezone awareness
        // Priority: Joomla user profile timezone -> site timezone -> fallback
        $userTz = null;
        try {
            $userParams = $user->getParameters();
            $userTz = $userParams->get('timezone', null);
        } catch (\Throwable $__) {}
        
        if (empty($userTz)) {
            try {
                $siteConfig = Factory::getConfig();
                $userTz = $siteConfig->get('offset', 'America/New_York');
            } catch (\Throwable $__) {
                $userTz = 'America/New_York';
            }
        }
        
        // Validate timezone identifier
        try {
            $testTz = new \DateTimeZone($userTz);
        } catch (\Throwable $__) {
            $userTz = 'America/New_York';
        }
        
        $siteTz = $userTz;
        $nowDate = new Date('now', $siteTz);
        $nowSql = $nowDate->toSql();
        
        // Store canonical UTC epoch (integer seconds)
        $utcEpoch = (int)$nowDate->toUnix();
        
        // Store user local datetime string (for dashboard display)
        $userLocalDatetime = $nowDate->format('Y-m-d H:i:s', true);
        
        // Store timezone identifier (IANA format)
        $timezoneId = $siteTz;

        // --- Sanitize lengths (defensive; no schema changes) ---
        // label VARCHAR-ish: keep to ~190 chars to be index-safe
        if ($label !== '') { $label = mb_substr($label, 0, 190, 'UTF-8'); }
        // top_combos_json TEXT-ish: keep reasonable (evidence is compact, but trim if huge)
        if (!empty($evidenceJson) && mb_strlen($evidenceJson, '8bit') > 64000) {
            $evidenceJson = mb_substr($evidenceJson, 0, 64000, '8bit');
        }

        // Optional next_draw_date/next_draw_at - prefer POST, then DB meta, then config; else NULL
        // CHG: DO NOT reset to NULL here. These may already be resolved above from POST/meta.
        $nextDrawDateSql = (isset($nextDrawDateSql) && trim((string)$nextDrawDateSql) !== '')
            ? substr(trim((string)$nextDrawDateSql), 0, 10)
            : null;

        $nextDrawAtSql = (isset($nextDrawAtSql) && trim((string)$nextDrawAtSql) !== '')
            ? (string)$nextDrawAtSql
            : null;


        // 1) Prefer an explicit posted next_draw_date if present (for parity with other modules)
        $postedNext = trim((string) $in->getString('next_draw_date', ''));
        if ($postedNext !== '') {
            // Store as simple YYYY-MM-DD (strip time if any)
            $nextDrawDateSql = substr($postedNext, 0, 10);
        }

        // 2) Fallbacks from DB meta and config (only if POST was empty)
        $ndd = $skaiDbMeta['next_draw_date'] ?? null;
        $nda = $skaiDbMeta['next_draw_at']   ?? null;

        // Parse next-draw timestamps using site TZ, fall back to config if meta missing
        try {
            if ($nextDrawDateSql === null && !empty($ndd)) {
                // Store as DATE in Y-m-d format for next_draw_date
                $nextDrawDateSql = (new Date($ndd, $siteTz))->format('Y-m-d', true);
            } elseif ($nextDrawDateSql === null && !empty($lotteryConfig['next_draw_date'])) {
                $nextDrawDateSql = (new Date($lotteryConfig['next_draw_date'], $siteTz))->format('Y-m-d', true);
            }
        } catch (\Throwable $e) { /* ignore; leave as NULL */ }

        // 3) Final fallback: proven backward scan in draw table
        if ($nextDrawDateSql === null && !empty($dbCol)) {
            try {
                $fallbackNdd = getNextDrawDate($selectedGameId, $db, $dbCol);
                if (!empty($fallbackNdd)) {
                    $nextDrawDateSql = (new Date($fallbackNdd, $siteTz))->format('Y-m-d', true);
                }
            } catch (\Throwable $__) { /* ignore */ }
        }

        if ($nextDrawDateSql !== null) {
            $nextDrawDateSql = substr(trim((string)$nextDrawDateSql), 0, 10);
        }

        try {
            if (!empty($nda)) {
                // Full timestamp for next_draw_at (DATETIME column)
                $nextDrawAtSql = (new Date($nda, $siteTz))->toSql();
            } elseif (!empty($lotteryConfig['next_draw_at'])) {
                $nextDrawAtSql = (new Date($lotteryConfig['next_draw_at'], $siteTz))->toSql();
            }
        } catch (\Throwable $e) { /* ignore; leave as NULL */ }

                // Resolve draw_session with the same priority style as next_draw_*:
        // 1) POST draw_session (if client sends)
        // 2) DB meta draw_session
        // 3) NULL
        $drawSessionSql = trim((string) $in->getString('draw_session', ''));
        if ($drawSessionSql === '' && !empty($skaiDbMeta['draw_session'])) {
            $drawSessionSql = (string) $skaiDbMeta['draw_session'];
        }
        if ($drawSessionSql === '') { $drawSessionSql = null; }

        // Build insert object (ONLY known columns) - deduped keys, sanitized values
 // CHG: Force canonical source for SKAI saves (prevents Heatmap branch on dashboard)
$source = 'skai_prediction';

// CHG: Build a SKAI settings blob so dashboard can render -Run parameters-
$skaiSettings = [
    'analysis'     => 'SKAI',
    'auto_tune'    => isset($autoTune) ? (int)$autoTune : null,
    'skip_window'  => ($skipWindow > 0) ? (int)$skipWindow : null,
    'best_window'  => !empty($bestWindow) ? (int)$bestWindow : null,
    'tuned_window' => !empty($tunedWin) ? (int)$tunedWin : null,
    'laplace_k'    => isset($laplaceK) ? (int)$laplaceK : null,

    // weights
    'weights' => [
        'freq'    => $freqW   ?? null,
        'skip'    => $skipW   ?? null,
        'hist'    => $histW   ?? null,
        'pb_freq' => $pbFreqW ?? null,
        'pb_skip' => $pbSkipW ?? null,
        'pb_hist' => $pbHistW ?? null,
    ],

    // NN params
    'nn' => [
        'epochs'       => $epochs    ?? null,
        'batch_size'   => $batchSize ?? null,
        'dropout_rate' => $dropout   ?? null,
        'learning_rate'=> $learnRate ?? null,
        'activation_function' => $actFn ?? null,
        'hidden_layers'=> $hidden    ?? null,
        'recency_decay'=> $recDecay  ?? null,
    ],
];

// Encode once here; DB insert step will keep it as string
$skaiSettingsJson = json_encode($skaiSettings, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);

$row = (object) [
    'user_id'             => (int) $user->id,
    'lottery_id'          => (int) $lotteryId,
    'main_numbers'        => (string) $mainCsv,
    'extra_ball_numbers'  => (string) $extraCsv,

    // If present, also map first two extras to star_ball1/2 (EuroMillions-style)
    'star_ball1'          => isset($extraArr[0]) ? (string)$extraArr[0] : null,
    'star_ball2'          => isset($extraArr[1]) ? (string)$extraArr[1] : null,

    'source'              => (string) $source,
    'label'               => (string) $label,

    // CHG: Persist SKAI settings for dashboard display
    'settings_json'       => $skaiSettingsJson,

    'top_combos_json'     => $evidenceJson, // may be NULL if malformed earlier
    'date_saved'          => $nowSql,
    'generated_at'        => $nowSql,
    'draws_analyzed'      => ($drawsAnalyzed > 0) ? (int)$drawsAnalyzed : null,
    // For compatibility with dashboard filters that expect both fields
    'draws_used'          => ($drawsAnalyzed > 0) ? (int)$drawsAnalyzed : null,
    'next_draw_date'      => $nextDrawDateSql,
    'next_draw_at'        => $nextDrawAtSql,

    // Session label if available
    'draw_session'        => $drawSessionSql,

    // Skip/Auto-Tune knobs (persist only when provided)
    // (kept ONCE here - duplicates removed)
    'laplace_k'           => isset($laplaceK)   ? (int)$laplaceK   : null,
    'skip_window'         => ($skipWindow > 0)  ? (int)$skipWindow : null,
    'auto_tune'           => isset($autoTune)   ? (int)$autoTune   : null,
    'best_window'         => !empty($bestWindow) ? (int)$bestWindow : null,
    'tuned_window'        => !empty($tunedWin)   ? (int)$tunedWin   : null,

    // MCMC / analysis knobs
    'walks'               => $walks     ?? null,
    'burn_in'             => $burnIn    ?? null,
    'decay'               => $decay     ?? null,
    'chain_len'           => $chainLen  ?? null,

    // Weights (0-100)
    'freq_weight'         => $freqW   ?? null,
    'skip_weight'         => $skipW   ?? null,
    'hist_weight'         => $histW   ?? null,
    'pb_freq_weight'      => $pbFreqW ?? null,
    'pb_skip_weight'      => $pbSkipW ?? null,
    'pb_hist_weight'      => $pbHistW ?? null,

    // NN params (if the page posts them; harmless for Skip/Hit)
    'epochs'              => $epochs    ?? null,
    'batch_size'          => $batchSize ?? null,
    'dropout_rate'        => $dropout   ?? null,
    'learning_rate'       => $learnRate ?? null,
    'activation_function' => $actFn     ?? null,
    'hidden_layers'       => $hidden    ?? null,
    'recency_decay'       => $recDecay  ?? null,

    // Flags
    'pure_mode'           => $pureMode ?? null,
    'tune_used'           => $tuneUsed ?? null,

    // SKAI-specific parameters (blend, temperature, diversity, etc.)
    'skai_blend_skip_pct'     => $skaiBlendSkipPct   ?? null,
    'skai_blend_ai_pct'       => $skaiBlendAiPct     ?? null,
    'sampling_temperature'    => $samplingTemp       ?? null,
    'diversity_penalty'       => $diversityPenalty   ?? null,
    'gap_scale'               => $gapScale           ?? null,
    'skai_window_size'        => $skaiWindowSize     ?? null,
    'skai_run_mode'           => $skaiRunMode        ?? null,
    'skai_top_n_numbers'      => $skaiTopNNumbers    ?? null,
    'skai_top_n_combos'       => $skaiTopNCombos     ?? null,

    // User selection: risk profile + strategy
    'risk_profile'            => $riskProfile        ?? null,
    'strategy'                => $strategy           ?? null,

    // Timezone-aware timestamps
    'utc_epoch'               => $utcEpoch           ?? null,
    'user_local_datetime'     => $userLocalDatetime  ?? null,
    'timezone_id'             => $timezoneId         ?? null,

    // Progress tracking (initialized to null, will be updated during computation)
    'progress_stage'          => 0,
    'progress_label'          => 'Saved',

    // Leave as-is (we do not fabricate)
    'digit_probabilities' => null,
];

        // Normalize: convert empty strings to NULL to avoid '' in nullable columns
        foreach ($row as $k => $v) {
            if ($v === '') { $row->$k = null; }
        }


        // --- Atomic insert (transaction) ---
        try {
            $db->transactionStart();

            // 1) Hard-map IDs: ensure lottery_id is set (schema uses lottery_id)
            if (!isset($row->lottery_id) || (int)$row->lottery_id === 0) {
                $lotteryIdFromCfg = (int)($lotteryConfig['lottery_id'] ?? 0);
                $row->lottery_id  = (int)($row->lottery_id ?? 0);
                if ($row->lottery_id === 0 && $lotteryIdFromCfg > 0) {
                    $row->lottery_id = $lotteryIdFromCfg;
                }
            }
            if (isset($row->game_id)) {
                unset($row->game_id); // prevent 1054 from unknown column in this table
            }

            // 2) Whitelist from live DB schema to avoid unknown columns (e.g., game_id)
            $schemaCols = (array) $db->getTableColumns('#__user_saved_numbers', false); // col => type
            $allowed    = array_keys($schemaCols);

            // 3) Build a clean data map from $row restricted to whitelist (drop anything else)
            $data = [];
            foreach ($allowed as $col) {
                if (isset($row->$col)) {
                    $data[$col] = $row->$col;
                }
            }
            // (Optional) Debug: show stripped keys if running in debug mode
            if (!empty($isDebug)) {
                $rowKeys  = array_keys(get_object_vars($row));
                $stripped = array_values(array_diff($rowKeys, $allowed));
                if (!empty($stripped)) {
                    error_log('[SKAI SAVE] stripped unknown cols: '.implode(',', $stripped));
                }
            }

            // 4) Defaults & final normalization
            // Ensure required basics exist
            if (!isset($data['user_id'])) {
                $data['user_id'] = (int)$user->id;
            }
            if (!isset($data['lottery_id'])) {
                $data['lottery_id'] = (int)($row->lottery_id ?? 0);
            }

            // Normalize JSON-capable fields (encode arrays/objects)
            // [CHANGE] JSON-encode complex fields; keeps strings as-is if already encoded.
            $jsonFields = [
                'main_numbers',
                'extra_ball_numbers',
                'top_combos_json',
                'matched_numbers',
                'digit_probabilities',
                'hidden_layers'
            ];
            foreach ($jsonFields as $jf) {
                if (array_key_exists($jf, $data)) {
                    $v = $data[$jf];
                    if (is_array($v) || is_object($v)) {
                        $data[$jf] = json_encode($v, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
                    }
                }
            }

            // Fill date defaults via Joomla time (portable/timezone-aware)
            $nowSql = \Joomla\CMS\Factory::getDate()->toSql();
            $useNowForDateSaved = false;
            if (!isset($data['date_saved']) || $data['date_saved'] === null || $data['date_saved'] === '') {
                $useNowForDateSaved = true;
            }
            $useNowForGenerated = false;
            if (!isset($data['generated_at']) || $data['generated_at'] === null || $data['generated_at'] === '') {
                $useNowForGenerated = true;
            }

            // 5) Type-aware rendering (numbers unquoted, strings quoted, NULL literal)
            // [CHANGE] Remove hidden_layers from intFields (it's JSON above).
            $intFields = [
                'id','user_id','lottery_id','draws_analyzed','main_matches','bonus_matches',
                'star_ball1','star_ball2','epochs','batch_size','walks','burn_in',
                'laplace_k','chain_len','skip_window','draws_used','best_window','tuned_window',
                'auto_tune','pure_mode','tune_used'
            ];
            $floatFields = [
                'dropout_rate','learning_rate','recency_decay','decay',
                'freq_weight','skip_weight','hist_weight','pb_freq_weight','pb_skip_weight','pb_hist_weight'
            ];

            $columns = [];
            $values  = [];

            foreach ($data as $k => $v) {
                // Only persist whitelisted cols
                if (!in_array($k, $allowed, true)) {
                    continue;
                }
                $columns[] = $db->quoteName($k);

                // Date defaults (Joomla date) ? use per-column flags
                if ($k === 'date_saved' && $useNowForDateSaved) {
                    $values[] = $db->quote($nowSql);
                    continue;
                }
                if ($k === 'generated_at' && $useNowForGenerated) {
                    $values[] = $db->quote($nowSql);
                    continue;
                }

                if ($v === null) {
                    $values[] = 'NULL';
                    continue;
                }

                if (in_array($k, $intFields, true)) {
                    $values[] = (string)((int)$v);
                    continue;
                }

                if (in_array($k, $floatFields, true)) {
                    $values[] = (string)((float)$v);
                    continue;
                }

                // strings/datetimes/json
                $values[] = $db->quote((string)$v);
            }

            // If date_saved was missing entirely and not present in $data, inject Joomla NOW
            if ($useNowForDateSaved && !in_array($db->quoteName('date_saved'), $columns, true)) {
                $columns[] = $db->quoteName('date_saved');
                $values[]  = $db->quote($nowSql);
            }
            // If generated_at was missing entirely, inject too
            if ($useNowForGenerated && !in_array($db->quoteName('generated_at'), $columns, true)) {
                $columns[] = $db->quoteName('generated_at');
                $values[]  = $db->quote($nowSql);
            }

            // Safety: ensure we have at least user_id, lottery_id
            if (!in_array($db->quoteName('user_id'), $columns, true)) {
                $columns[] = $db->quoteName('user_id');
                $values[]  = (string)((int)$user->id);
            }
            if (!in_array($db->quoteName('lottery_id'), $columns, true)) {
                $columns[] = $db->quoteName('lottery_id');
                $values[]  = (string)((int)($row->lottery_id ?? 0));
            }

            // 6) Build and execute INSERT
            $query = $db->getQuery(true)
                ->insert($db->quoteName('#__user_saved_numbers'))
                ->columns($columns)
                ->values(implode(',', $values));

            $db->setQuery($query)->execute();

            $db->transactionCommit();
        } catch (\Throwable $e) {
            // Rollback and notify
            try { $db->transactionRollback(); } catch (\Throwable $__) {}
            if (!empty($isDebug)) {
                // (intentionally blank)
            }

            // Enriched, privacy-safe context for logs (helps diagnose)
            $ctxUser   = isset($row->user_id) ? (int)$row->user_id : (int)$user->id;
            $ctxLotId  = isset($row->lottery_id) ? (int)$row->lottery_id : 0;
            $ctxSource = isset($row->source) ? (string)$row->source : 'skip_hit';
            error_log('[SKAI SAVE ROLLBACK] uid='.$ctxUser.' lotId='.$ctxLotId.' src='.$ctxSource.' err='.$e->getMessage());

            if (!empty($isDebug)) {
                $app->enqueueMessage('Save failed (rolled back): ' . $e->getMessage(), 'error');
            } else {
                $app->enqueueMessage('We couldn\'t save your set right now. Please try again.', 'error');
            }
            goto SKAI_SAVE_DONE;
        }

        // Success message and redirect to dashboard
        $newId = 0;
        try { $newId = (int) $db->insertid(); } catch (\Throwable $__) {}
        $app->enqueueMessage('Saved to your dashboard.', 'message');
        
        // Redirect to My LottoExpert dashboard
        try {
            $dashboardUrl = \Joomla\CMS\Uri\Uri::root() . 'membership/my-dashboard';
            $app->redirect($dashboardUrl);
            return; // stop further rendering in this execution path
        } catch (\Throwable $e) {
            // If redirect fails (rare), just continue; message is already queued
        }

        SKAI_SAVE_DONE:
    }
} catch (\Throwable $e) {
    if (!empty($isDebug)) {
        $app->enqueueMessage('Save failed: ' . $e->getMessage(), 'error');
    } else {
        $app->enqueueMessage('We couldn\'t save your set right now. Please try again.', 'error');
    }
}

$masterConfig = null;
try {
    $cfgMtime   = @filemtime($masterJsonPath) ?: 0;
    $apcuReady  = (\function_exists('apcu_enabled') ? \apcu_enabled() : (\function_exists('apcu_fetch') && (bool)\ini_get('apc.enabled')));
    $apcuKey    = 'skai.lottery_cfg.' . \md5($masterJsonPath . '|' . $cfgMtime);

    if ($apcuReady) {
        $cached = \apcu_fetch($apcuKey, $apcuHit);
        if ($apcuHit && \is_array($cached)) {
            $masterConfig = $cached; // cache hit
        }
    }

    if ($masterConfig === null) {
        // cache miss or APCu not available
        $masterRaw = \file_get_contents($masterJsonPath);
        if ($masterRaw === false) {
            throw new \RuntimeException('Unable to read configuration file.');
        }

        $decoded = \json_decode($masterRaw, true);
        if (!\is_array($decoded)) {
            // Provide informative JSON error message to logs; generic to users
            $jsonErr = \function_exists('json_last_error_msg') ? \json_last_error_msg() : 'unknown JSON error';
            if ($isDebug) {
                error_log('[SKAI] JSON decode error for lottery_skip_config.json: ' . $jsonErr);
            }
            throw new \RuntimeException('Invalid configuration JSON.');
        }

        $masterConfig = $decoded; 

        if ($apcuReady) {
            // Store to APCu (no TTL; invalidated by mtime change)
            \apcu_store($apcuKey, $masterConfig);
        }
    }
} catch (\Throwable $e) {
    // Keep user-facing message generic; log details if debug
    if ($isDebug) {
        error_log('[SKAI] Config load failure: ' . $e->getMessage());
    }
    $app->enqueueMessage('We\'re setting things up. Please refresh in a moment or try again shortly.', 'error');
    // Output content for Sourcerer before exiting
    echo "<!-- SKAI error -->";
    return;
}

// Read lottery ID from URL (fallback to 101 if missing) ? Joomla 4/5: use getInput()
$requestedId = (string) $in->getString('game_id', '');

// Some routes/tools use "gameId" (camelCase) just like the standalone AI page.
// Support that first before falling back to "gid".
if ($requestedId === '') {
    $requestedId = (string) $in->getString('gameId', '');
}

// Some of your legacy / alternate routes use "gid" instead of "game_id"
// (e.g., /euromillions-skai?gid=801). Support that here before falling back.
if ($requestedId === '') {
    $requestedId = (string) $in->getString('gid', '');
}

if ($requestedId === '') {
    $requestedId = '101'; // fallback (FL3)
}

$selectedGameId = strtoupper(trim($requestedId));

// Validate selected game (master spec first; fallback to daily catalog)
$dailyRow = null;

if (
    $selectedGameId === '' ||
    !isset($masterConfig['lotteries']) ||
    !is_array($masterConfig['lotteries'])
) {
    $app->enqueueMessage('This lottery link looks incomplete. Please choose a game from the menu and try again.', 'error');
    echo "<!-- SKAI error -->";
    return;
}

$hasMaster = (isset($masterConfig['lotteries'][$selectedGameId]) && is_array($masterConfig['lotteries'][$selectedGameId]));

if (!$hasMaster) {
    // Fallback: daily digit lotteries (Pick 2–Pick 5, Fireball/Wild, Midday/Evening variants)
    if (function_exists('skaiDailyLoadByGameId')) {
        $dailyRow = skaiDailyLoadByGameId($dailyJsonPath, $selectedGameId, (bool)$isDebug);
    }

    if (!is_array($dailyRow)) {
        $app->enqueueMessage('This lottery link looks incomplete. Please choose a game from the menu and try again.', 'error');
        echo "<!-- SKAI error -->";
        return;
    }
}

// Extract config for selected lottery:
// - master lottery_skip_config.json shape OR
// - normalized daily shape via skai_daily_bridge.php
$config = $hasMaster
    ? $masterConfig['lotteries'][$selectedGameId]
    : (function_exists('skaiNormalizeDailyToMasterLotteryShape') ? skaiNormalizeDailyToMasterLotteryShape($dailyRow) : []);

// Guard: config must be a usable array before we continue
if (!is_array($config) || empty($config)) {
    $app->enqueueMessage('We couldn\'t load this game configuration. Please try again.', 'error');
    echo "<!-- SKAI error -->";
    return;
}

// dbCol/table name (required downstream)
$dbCol = (string)($config['dbCol'] ?? '');

// Resolve canonical game_id from config (prefer snake_case), fallback to selected key
$gameId = (string)($config['game_id'] ?? $config['gameId'] ?? $selectedGameId);
if ($gameId === '') {
    $app->enqueueMessage('We couldn\'t identify this lottery. Please pick your game and try again.', 'error');
    echo "<!-- SKAI error -->";
    return;
}

// Resolve the real lottery_id (primary key) from #__lotteries using the game_id
if (!isset($db)) {
    $db = Factory::getContainer()->get('DatabaseDriver');
}
$queryLottery = $db->getQuery(true)
    ->select($db->quoteName('lottery_id'))
    ->from($db->quoteName('#__lotteries'))
    ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId));
$db->setQuery($queryLottery);
$lotteryId = (int) $db->loadResult();

if ($lotteryId <= 0) {
    // If we can-t resolve a valid lottery_id, abort to avoid saving bad references
    $app->enqueueMessage('We couldn\'t resolve the lottery id for this game.', 'error');
    echo "<!-- SKAI error: lottery_id lookup failed -->";
    return;
}

$lotteryName   = (string)($config['lotteryName'] ?? '');
$lotteryConfig = (array)($config['lotteryConfig'] ?? []);
$lotteryConfig['lottery_id'] = $lotteryId; // make sure config exposes the real lottery_id

// Auto-detect daily games: if loaded from dailylotteries.json (no master), mark as daily
// This avoids needing to modify the JSON files themselves
if (!$hasMaster && isset($dailyRow) && is_array($dailyRow)) {
    $lotteryConfig['is_daily'] = true;  // Loaded from dailylotteries.json
} elseif (!isset($lotteryConfig['is_daily'])) {
    $lotteryConfig['is_daily'] = false; // Loaded from lottery_skip_config.json or default
}

// Guard: require a valid data

// Guard: require a valid data table for this lottery
if ($dbCol === '') {
    $app->enqueueMessage('We couldn\'t find the data table for this lottery (missing dbCol in config). Please try again later.', 'error');
    if (!empty($isDebug)) {
        error_log('[SKAI] Missing dbCol for game_id=' . $gameId . ' in lottery_skip_config.json');
    }
    // Output content for Sourcerer before exiting
    echo "<!-- SKAI error -->";
    return;
}

    // Normalize key names so downstream code can rely on one shape
    // Snake_case ? canonical
    if (!isset($lotteryConfig['main_ball_max']) && isset($lotteryConfig['max_main_ball_number'])) {
        $lotteryConfig['main_ball_max'] = (int) $lotteryConfig['max_main_ball_number'];
    }
    if (!isset($lotteryConfig['extra_ball_max']) && isset($lotteryConfig['max_extra_ball_number'])) {
        $lotteryConfig['extra_ball_max'] = (int) $lotteryConfig['max_extra_ball_number'];
    }
    if (!isset($lotteryConfig['pick_size']) && isset($lotteryConfig['num_main_balls_drawn'])) {
        $lotteryConfig['pick_size'] = (int) $lotteryConfig['num_main_balls_drawn'];
    }
    if (!isset($lotteryConfig['extra_ball_count']) && isset($lotteryConfig['num_extra_balls_drawn'])) {
        $lotteryConfig['extra_ball_count'] = (int) $lotteryConfig['num_extra_balls_drawn'];
    }
    if (!isset($lotteryConfig['extra_ball_columns']) && !empty($lotteryConfig['extra_ball_column'])) {
        $lotteryConfig['extra_ball_columns'] = [ (string) $lotteryConfig['extra_ball_column'] ];
    }

    // CamelCase ? canonical
    if (!isset($lotteryConfig['main_ball_max']) && isset($lotteryConfig['mainNumbersMax'])) {
        $lotteryConfig['main_ball_max'] = (int) $lotteryConfig['mainNumbersMax'];
    }
    if (!isset($lotteryConfig['extra_ball_max']) && isset($lotteryConfig['extraBallMax'])) {
        $lotteryConfig['extra_ball_max'] = (int) $lotteryConfig['extraBallMax'];
    }
    if (!isset($lotteryConfig['pick_size']) && isset($lotteryConfig['pickSize'])) {
        $lotteryConfig['pick_size'] = (int) $lotteryConfig['pickSize'];
    }
    if (!isset($lotteryConfig['extra_ball_count']) && isset($lotteryConfig['numExtraBallsDrawn'])) {
        $lotteryConfig['extra_ball_count'] = (int) $lotteryConfig['numExtraBallsDrawn'];
    }
    if (!isset($lotteryConfig['has_extra_ball']) && array_key_exists('hasExtraBall', $lotteryConfig)) {
        $lotteryConfig['has_extra_ball'] = (bool) $lotteryConfig['hasExtraBall'];
    }
    if (!isset($lotteryConfig['extra_ball_columns']) && !empty($lotteryConfig['extraBallColumns']) && is_array($lotteryConfig['extraBallColumns'])) {
        $lotteryConfig['extra_ball_columns'] = array_map('strval', $lotteryConfig['extraBallColumns']);
    }
    if (!isset($lotteryConfig['extra_ball_columns']) && !empty($lotteryConfig['extraBallColumn'])) {
        $lotteryConfig['extra_ball_columns'] = [ (string) $lotteryConfig['extraBallColumn'] ];
    }

    // If still unset, infer has_extra_ball from extra_ball_max
    if (!isset($lotteryConfig['has_extra_ball']) && isset($lotteryConfig['extra_ball_max'])) {
        $lotteryConfig['has_extra_ball'] = ((int) $lotteryConfig['extra_ball_max']) > 0;
    }

    $config['lotteryConfig'] = $lotteryConfig;

    $defaultFreqWeight = (float)($config['defaultWeights']['frequency']  ?? 100.0);

$defaultSkipWeight = (float)($config['defaultWeights']['skip']       ?? 0.0);
$defaultHistWeight = (float)($config['defaultWeights']['historical'] ?? 0.0);

// Determine columns (robust, deduped, strings)
$mainBallCols = array_values(array_map('strval', (array)($lotteryConfig['main_ball_columns'] ?? [])));
$extraBallCols = [];
if (!empty($lotteryConfig['has_extra_ball'])) {
    if (!empty($lotteryConfig['extra_ball_columns']) && is_array($lotteryConfig['extra_ball_columns'])) {
        $extraBallCols = array_map('strval', $lotteryConfig['extra_ball_columns']);
    }
}
$extraBallCols = array_values(array_filter(array_unique($extraBallCols)));
$selectCols    = array_values(array_unique(array_merge($mainBallCols, $extraBallCols, ['draw_date'])));

// Guard: no main-ball columns ? nothing to analyze; tell the user clearly.
if (empty($mainBallCols)) {
    $app->enqueueMessage('We\'re missing the main-ball data fields for this lottery (game_id: ' . htmlspecialchars($gameId, ENT_QUOTES, 'UTF-8') . '), so analysis can\'t run yet.', 'error');
    if (!empty($isDebug)) {
        error_log('[SKAI] No main_ball_columns for game_id=' . $gameId . ' (dbCol=' . $dbCol . ')');
    }
    // Output content for Sourcerer before exiting
    echo "<!-- SKAI error -->";
    return;
}

// Fetch true lottery_id from DB (authoritative ID) with defensive try/catch ?
// but only if we do not already have a resolved numeric $lotteryId.
if (!isset($db)) {
    $db = Factory::getDbo();
}

/** Helper: quote table with Joomla prefix even if JSON gives plain name */
if (!function_exists('skai_quote_table')) {
    function skai_quote_table($db, string $name): string {
        $n = trim($name);
        if ($n === '') { return ''; }
        // If caller didn-t include "#__", add it so replacePrefix can work
        if (strpos($n, '#__') !== 0) { $n = '#__' . $n; }
        return $db->quoteName($db->replacePrefix($n));
    }
}


if ((int)($lotteryId ?? 0) === 0) {
    try {
        $q = $db->getQuery(true)
            ->select($db->quoteName('lottery_id'))
            ->from($db->quoteName('#__lotteries'))
            ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
            ->setLimit(1);

        $db->setQuery($q);
        $lotteryId = (int) $db->loadResult();
    } catch (\Throwable $dbEx) {
        if ($isDebug) {
            error_log('[SKAI] DB lookup error for game_id ' . $gameId . ': ' . $dbEx->getMessage());
        }
        $app->enqueueMessage('We couldn\'t reach our database to look up this lottery. Please refresh and try again.', 'error');
        // Output content for Sourcerer before exiting
    echo "<!-- SKAI error -->";
    return;
    }
}

// (unchanged) keep the guard and its closing braces
    if ($lotteryId === 0) {
        $app->enqueueMessage('We couldn\'t match this lottery in our records (game_id: ' . htmlspecialchars($gameId, ENT_QUOTES, 'UTF-8') . ').', 'error');
        // Output content for Sourcerer before exiting
    echo "<!-- SKAI error -->";
    return;
    }

/* ==========================================================================
   SKAI - Section 2: Data Fetching, Skip & Hit, Feature Extraction (PHP)
   ========================================================================== */
// [Unified] Legacy per-post save path fully retired. All saving is handled by the
// SKAI comprehensive handler above (CSRF, membership, canonicalization, evidence, PRG).
// Nothing to do here before analytics; proceed directly to data fetching.

if (!isset($config) || !is_array($config)) {
    throw new RuntimeException('SKAI: Missing $config from Section 1.');
}
if (!isset($lotteryConfig) || !is_array($lotteryConfig)) {
    $lotteryConfig = $config['lotteryConfig'];
}
// [CHANGED] Robust extra-ball detection: explicit has_extra_ball flag wins.
// If has_extra_ball is present (true/false), honor it. Only fall back to extra_ball_max
// when the flag is entirely absent to support older configs.
$__extraMaxCandidate = (int)($lotteryConfig['extra_ball_max'] ?? $lotteryConfig['max_extra_ball_number'] ?? 0);
$__extraCols         = (array)($lotteryConfig['extra_ball_columns'] ?? []);
$__hasExtraCols      = is_array($__extraCols) && count($__extraCols) > 0;

if (array_key_exists('has_extra_ball', $lotteryConfig)) {
    $__flagWantsExtra = !empty($lotteryConfig['has_extra_ball']);  // true only if flag is truthy
} else {
    $__flagWantsExtra = ($__extraMaxCandidate > 0);                // legacy heuristic
}

if ($__flagWantsExtra && !$__hasExtraCols) {
    // Fail-safe: configuration claims extra ball, but no columns configured.
    if (!empty($isDebug)) {
        error_log('[SKAI] Extra-ball requested but no columns configured for game_id=' . $gameId);
    }
$app->enqueueMessage('Bonus ball is enabled for this game, but its data isn\'t configured yet. We\'ll continue without it for now.', 'warning');
}

$hasExtra = ($__flagWantsExtra && $__hasExtraCols);

/* ---------- Fetch draws (ROW-LIMITED window; newest first, then reversed to ASC) ---------- */
// Pull up to the most recent rows to protect memory; then reverse to ASC for analytics.
$rowLimit = (int)($config['limits']['max_rows'] ?? 1500);

$query = $db->getQuery(true)
    ->select(array_map([$db, 'quoteName'], $selectCols))
    ->from(skai_quote_table($db, $dbCol)) // robust table prefixing
    ->where($db->quoteName('game_id') . ' = ' . $db->quote($gameId))
    ->order($db->quoteName('draw_date') . ' DESC');            // newest first

// Use Joomla DB pagination args for LIMIT/OFFSET: start=0, limit=$rowLimit
$db->setQuery($query, 0, $rowLimit);
$rowsDesc = (array) $db->loadObjectList();

// Reverse to ASC for temporal processing
$rowsAsc = $rowsDesc ? array_reverse($rowsDesc, false) : [];

// Derive a stable cutoff date (latest draw date) for downstream metadata
$cutoffDate = '';
if (!empty($rowsAsc)) {
    $lastIdx = count($rowsAsc) - 1;
    $lastRow = $rowsAsc[$lastIdx] ?? null;
    $rawCd   = ($lastRow && isset($lastRow->draw_date)) ? (string) $lastRow->draw_date : '';
    $cutoffDate = $rawCd !== '' ? substr($rawCd, 0, 10) : '';
}

/* ------------------------------------------------------------------------
 * Add: expose DB row count to JS and clamp the Window slider to DB length
 * Sorcerer rule: pure JS must use a normal
 * ------------------------------------------------------------------------ */
$rowsCount = (int) count($rowsAsc);

?>

<?php
/* ---------- Transform DB rows ? structured histories (ASC) ---------- */
$mainHistory  = [];   // [ {numbers:[...], date:'Y-m-d'} ... ]  (ASC)
$extraHistory = [];   // [ {number:int|null, date:'Y-m-d'} ... ] (ASC) // FIX: initialize to avoid undefined variable notices

// Early guard: nothing to transform
if (!$rowsAsc) {
    $fullMainHistory  = $mainHistory;
    $fullExtraHistory = $extraHistory; // now safely an empty array when there are no rows
} else {
    // Precompute first extra column if applicable
// Process rows: main numbers plus all configured extra balls (supports games with multiple extras)
foreach ($rowsAsc as $r) {
    // Fast date normalize: supports 'YYYY-mm-dd' and 'YYYY-mm-dd HH:MM:SS'
    $rawDate = isset($r->draw_date) ? (string) $r->draw_date : '';
    $date    = $rawDate !== '' ? substr($rawDate, 0, 10) : '';

    // MAIN numbers
    $nums = [];
    foreach ($mainBallCols as $col) {
        if (!isset($r->$col)) { continue; }
        $raw = trim((string) $r->$col);
        if ($raw === '') { continue; }

        // Fast integer extraction: prefer ctype_digit; fallback to regex if mixed text
        if (ctype_digit($raw)) {
            $nums[] = (int) $raw; // leading zeros collapse to int by design
        } elseif (preg_match('/\d+/', $raw, $m)) {
            $nums[] = (int) $m[0];
        }
    }
        $mainHistory[] = ['numbers' => $nums, 'date' => $date];

        // EXTRA numbers: support multiple extra_ball_columns (e.g., EuroMillions Lucky Stars)
        $extras = [];
        if (!empty($extraBallCols)) {
            foreach ($extraBallCols as $xCol) {
                if (!isset($r->$xCol)) {
                    continue;
                }
                $rawX = trim((string) $r->$xCol);
                if ($rawX === '') {
                    continue;
                }

                if (ctype_digit($rawX)) {
                    $extras[] = (int) $rawX;
                } elseif (preg_match('/\d+/', $rawX, $mx)) {
                    $extras[] = (int) $mx[0];
                }
            }
        }

        // Always append a row so histories stay aligned by date.
        $extraHistory[] = [
            // Backwards-compatible single extra: first Lucky Star (if present)
            'number'  => isset($extras[0]) ? $extras[0] : null,
            // NEW: all extras for this draw (0, 1 or 2 for EuroMillions)
            'numbers' => $extras,
            'date'    => $date,
        ];
    }

    // Expose full his
$fullMainHistory  = $mainHistory;
$fullExtraHistory = $extraHistory;

}

// ---------- Core analytics helpers (skip/hit histograms) ----------
// (Note) Using the newer implementation that appears below in this file.
// The earlier helper block has been removed to avoid duplicate definitions.

// Optional: alias for older call sites so the rest of the code keeps working unchanged.
if (!function_exists('calculateSkipsAndProbabilities')) {
  function calculateSkipsAndProbabilities(array $data, bool $single = false, int $laplaceK = 1): array {
    // Forward to the SKAI implementation with Laplace K (clamped in caller as needed)
    return skai_calculateSkipsAndProbabilities($data, $single, $laplaceK);
  }
}

/**
 * SKAI: Skip/Hit core math with canonicalization and Laplace smoothing.
 *
 * @param array $history   Array of draws (each draw is array of ints OR a string like "01, 12, 34")
 * @param bool  $single    True for extra-ball lanes (semantics don't change here; retained for compatibility)
 * @param int   $laplaceK  Laplace smoothing K in {0,1,2}, default 1
 *
 * @return array [$skips, $drawCounts, $lastDate, $prevIdx, $histProbs]
 *         - $skips:      [num => currentSkip]
 *         - $drawCounts: [num => total hit count]
 *         - $lastDate:   null (placeholder; retained for signature compatibility)
 *         - $prevIdx:    [num => lastHitIndexOrMinusOne]
 *         - $histProbs:  [num => ['p_hit_given_k', 'support_trials', 'support_hits']]
 */
if (!function_exists('skai_calculateSkipsAndProbabilities')) {
    function skai_calculateSkipsAndProbabilities(array $history, bool $single = false, int $laplaceK = 1): array
    {
        // --- Normalize draws to sets of integers, strip leading zeros -------------
        $draws = [];
        $maxBallObserved = 0;
        foreach ($history as $row) {
            if (is_array($row)) {
                $parts = $row;
            } else {
                $parts = preg_split('/[^\d]+/', (string) $row, -1, PREG_SPLIT_NO_EMPTY);
            }
            $set = [];
            foreach ($parts as $p) {
                $v = (int) $p;            // '01' -> 1
                if (!in_array($v, $set, true)) {
                    $set[] = $v;
                    if ($v > $maxBallObserved) {
                        $maxBallObserved = $v;
                    }
                }
            }
            $draws[] = $set;
        }
        $N = count($draws);
        if ($N === 0) {
            return [[], [], null, [], []];
        }

        // --- Zero-exclusion rule (#43): allow 0 only for daily games (range 0-9) ---
        // Heuristic: if the maximum observed ball = 9, treat as daily game - allow zero; else exclude zero.
        $allowZero = ($maxBallObserved <= 9);

        // Apply zero exclusion on the normalized stream
        for ($i = 0; $i < $N; $i++) {
            if (!$allowZero) {
                $draws[$i] = array_values(array_filter(
                    $draws[$i],
                    static function ($x) { return $x !== 0; }
                ));
            }
        }

        // --- Collect the domain of numbers observed (ensures parity with data) ----
        $domain = [];
        foreach ($draws as $set) {
            foreach ($set as $v) {
                $domain[$v] = true;
            }
        }
        ksort($domain);
        $numbers = array_keys($domain);
        if (empty($numbers)) {
            return [[], [], null, [], []];
        }

        // --- Build per-number hit indices -----------------------------------------
        $hitIdxs = [];
        foreach ($numbers as $n) {
            $hitIdxs[$n] = [];
        }
        for ($i = 0; $i < $N; $i++) {
            foreach ($draws[$i] as $h) {
                if (isset($hitIdxs[$h])) {
                    $hitIdxs[$h][] = $i;
                }
            }
        }

        // --- Compute prevIdx (last hit index), current skip, draw counts -----------
        $prevIdx    = [];
        $currSkips  = [];
        $drawCounts = [];
        foreach ($numbers as $n) {
            $idxs = $hitIdxs[$n];
            $drawCounts[$n] = count($idxs);
            if ($drawCounts[$n] > 0) {
                $prev = $idxs[$drawCounts[$n] - 1];
                $prevIdx[$n]   = $prev;
                $currSkips[$n] = ($N - $prev - 1);
            } else {
                $prevIdx[$n]   = -1;
                $currSkips[$n] = $N; // never seen: full history length as skip
            }
        }

        // --- Simple Laplace-smoothed hit probability summary ----------------------
        // Minimal semantics to avoid functional drift: overall hit-rate with Laplace K.
        $K = max(0, (int) $laplaceK);
        $histProbs = [];
        foreach ($numbers as $n) {
            $hits   = (int) ($drawCounts[$n] ?? 0);
            $trials = $N; // one "trial" per draw for overall rate summary
            $p      = ($hits + $K) / max(1, ($trials + 2 * $K)); // guard divide-by-zero

            // --- Calculate median_gap for Pattern Intelligence ---
            // Gap = number of draws between consecutive hits of this number
            $idxs = $hitIdxs[$n] ?? [];
            $gaps = [];
            $numHits = count($idxs);
            if ($numHits >= 2) {
                for ($g = 1; $g < $numHits; $g++) {
                    $gaps[] = $idxs[$g] - $idxs[$g - 1];
                }
            }
            $medianGap = null;
            if (!empty($gaps)) {
                sort($gaps, SORT_NUMERIC);
                $cnt = count($gaps);
                $mid = (int) floor($cnt / 2);
                if ($cnt % 2 === 0) {
                    $medianGap = (int) round(($gaps[$mid - 1] + $gaps[$mid]) / 2);
                } else {
                    $medianGap = (int) $gaps[$mid];
                }
            }

            $histProbs[$n] = [
                'p_hit_given_k'  => (float) $p,
                'support_trials' => (int) $trials,
                'support_hits'   => (int) $hits,
                'median_gap'     => $medianGap,
            ];
        }

        // lastDate placeholder kept as null for signature compatibility
        return [$currSkips, $drawCounts, null, $prevIdx, $histProbs];
    }
}


// Laplace K (server-side): clamp to {0,1,2}; default 1 (project rule)
$laplaceK = (int) max(0, min(2, (int) ($in->getInt('laplace_k', (int) ($lotteryConfig['laplace_k'] ?? 1)))));

/** SKAI helper: pad integer ball for UI only (internal math stays int). */
if (!function_exists('formatBallLabel')) {
    function formatBallLabel(int $n, int $padWidth = 2): string {
        return ($padWidth <= 1) ? (string) $n : str_pad((string) $n, $padWidth, '0', STR_PAD_LEFT);
    }
}
/** SKAI helper: format probability as WCAG-friendly percent text. */
if (!function_exists('skai_fmt_pct')) {
    function skai_fmt_pct(float $p, int $dec = 1): string {
        $p = max(0.0, min(1.0, $p));
        return number_format($p * 100.0, $dec) . '%';
    }
}
/** SKAI helper: accessible tooltip text for Pattern Intelligence labels. */
if (!function_exists('skai_pattern_hint')) {
    function skai_pattern_hint(
        string $pattern,
        ?int $skip,
        ?float $prob,
        $medianGap = null
    ): string {
        $parts = [];
        $parts[] = "Pattern type: {$pattern}";
        if ($skip !== null) {
            $parts[] = "Current gap (skips): {$skip} draws";
        }
        if ($medianGap !== null && is_numeric($medianGap)) {
            $parts[] = "Typical gap between hits: {$medianGap} draws";
        }
        if ($prob !== null) {
            $parts[] = "Estimated hit chance: " . skai_fmt_pct((float)$prob, 1);
        }
        // Keep it short, single line; screen readers will read the full string.
        return implode(' - ', $parts); // use a clean bullet separator
    }
}

// Flatten histories for analytics: pass only the numeric lanes, not date strings.
$mainDraws = array_map(static function ($row) {
    // each $row is ['numbers' => [...], 'date' => 'Y-m-d']
    if (is_array($row) && isset($row['numbers']) && is_array($row['numbers'])) {
        return $row['numbers'];
    }
    // Fallback: if older shape, treat row itself as the draw
    return is_array($row) ? $row : [$row];
}, $mainHistory);

// Main stats
list($mainSkips, $mainDrawCounts, $mainLastDate, $mainPrevIdx, $mainHistProbs)
    = skai_calculateSkipsAndProbabilities($mainDraws, false, $laplaceK);

// Extra stats
$extraSkips = $extraDrawCounts = $extraLastDate = $extraPrevIdx = $extraHistProbs = [];
$extraDraws = [];
if ($hasExtra) {
    $extraDraws = array_map(static function ($row) {
        // each $row is ['numbers' => [...], 'number' => int|null, 'date' => 'Y-m-d']
        if (!is_array($row)) {
            return [$row];
        }

        // NEW: prefer multi-extra shape when available (e.g., EuroMillions Lucky Stars)
        if (isset($row['numbers']) && is_array($row['numbers'])) {
            $out = [];
            foreach ($row['numbers'] as $n) {
                if ($n === null || $n === '') {
                    continue;
                }
                $out[] = (int) $n;
            }
            return $out;
        }

        // Backwards-compatible single-extra shape
        if (!isset($row['number']) || $row['number'] === null) {
            // draw exists but no extra ball hit
            return [];
        }
        return [(int) $row['number']];
    }, $extraHistory);

    list($extraSkips, $extraDrawCounts, $extraLastDate, $extraPrevIdx, $extraHistProbs)
        = skai_calculateSkipsAndProbabilities($extraDraws, true, $laplaceK);
}

// Current skips (relative to full history)
$currSkipMain = [];
$M = count($mainHistory);
foreach ($mainPrevIdx as $num => $idx) { $currSkipMain[(int)$num] = $M - $idx - 1; }
$currSkipExtra = [];
if ($hasExtra) {
    $E = count($extraHistory);
    foreach ($extraPrevIdx as $num => $idx) { $currSkipExtra[(int)$num] = $E - $idx - 1; }
}

// --- SKAI: build server-side Skip/Hit rows, sorted by P(hit|k) desc ----------
$mainSkipHitRows = [];
if (!empty($mainSkips)) {
    $padWidthMain = (max(array_keys($mainSkips)) >= 10) ? 2 : 1;
    foreach ($mainSkips as $n => $skip) {
        $n = (int)$n;
        $prob = (float)($mainHistProbs[$n]['p_hit_given_k'] ?? 0.0);
        $tr   = (int)  ($mainHistProbs[$n]['support_trials'] ?? 0);
        $hi   = (int)  ($mainHistProbs[$n]['support_hits'] ?? 0);
        $hits = (int)  ($mainDrawCounts[$n] ?? 0);
        // Lightweight Pattern Intelligence label
        // median_gap is now calculated by skai_calculateSkipsAndProbabilities() for proper pattern classification
        $medianGap = $mainHistProbs[$n]['median_gap'] ?? null;
        $pattern = 'Transition';
        if ((int)$skip === 0) {
            $pattern = 'Reset';
        } elseif ($medianGap !== null) {
            if ($skip >= (int)ceil(1.5 * (int)$medianGap)) {
                $pattern = 'Volatile';   // overdue relative to typical gap
            } elseif ($skip <= (int)floor(0.5 * (int)$medianGap) && $prob >= 0.10) {
                $pattern = 'Stable';     // recently hit-ish and hazard not tiny
            } else {
                $pattern = 'Transition';
            }
        }

        $mainSkipHitRows[] = [
            'n'       => $n,
            'label'   => formatBallLabel($n, $padWidthMain),
            'skip'    => (int)$skip,
            'hits'    => $hits,
            'prob'    => $prob,
            'prob_t'  => skai_fmt_pct($prob, 1),
            'sup'     => $tr,
            'hitk'    => $hi,
            'pattern' => $pattern, // new
            // NEW: accessibility/meta for direct use in template
            'title'       => skai_pattern_hint($pattern, (int)$skip, (float)$prob, $medianGap),
            'aria_label'  => skai_pattern_hint($pattern, (int)$skip, (float)$prob, $medianGap),
            'pattern_class'=> 'pi-' . strtolower($pattern), // e.g., pi-stable, pi-volatile
        ];
    }
    usort($mainSkipHitRows, static function($a,$b){
        if ($a['prob'] === $b['prob']) {
            if ($a['skip'] === $b['skip']) return $a['n'] <=> $b['n'];
            return $a['skip'] <=> $b['skip'];
        }
        return ($a['prob'] > $b['prob']) ? -1 : 1;
    });
}

$extraSkipHitRows = [];
if ($hasExtra && !empty($extraSkips)) {
    $padWidthExtra = (max(array_keys($extraSkips)) >= 10) ? 2 : 1;
    foreach ($extraSkips as $n => $skip) {
        $n = (int)$n;
        $prob = (float)($extraHistProbs[$n]['p_hit_given_k'] ?? 0.0);
        $tr   = (int)  ($extraHistProbs[$n]['support_trials'] ?? 0);
        $hi   = (int)  ($extraHistProbs[$n]['support_hits'] ?? 0);
        $hits = (int)  ($extraDrawCounts[$n] ?? 0);
        // Lightweight Pattern Intelligence label
        // median_gap is now calculated by skai_calculateSkipsAndProbabilities() for proper pattern classification
        $medianGap = $extraHistProbs[$n]['median_gap'] ?? null;
        $pattern = 'Transition';
        if ((int)$skip === 0) {
            $pattern = 'Reset';
        } elseif ($medianGap !== null) {
            if ($skip >= (int)ceil(1.5 * (int)$medianGap)) {
                $pattern = 'Volatile';
            } elseif ($skip <= (int)floor(0.5 * (int)$medianGap) && $prob >= 0.10) {
                $pattern = 'Stable';
            } else {
                $pattern = 'Transition';
            }
        }

        $extraSkipHitRows[] = [
            'n'       => $n,
            'label'   => formatBallLabel($n, $padWidthExtra),
            'skip'    => (int)$skip,
            'hits'    => $hits,
            'prob'    => $prob,
            'prob_t'  => skai_fmt_pct($prob, 1),
            'sup'     => $tr,
            'hitk'    => $hi,
            'pattern' => $pattern, // new
            // NEW: accessibility/meta for direct use in template
            'title'       => skai_pattern_hint($pattern, (int)$skip, (float)$prob, $medianGap),
            'aria_label'  => skai_pattern_hint($pattern, (int)$skip, (float)$prob, $medianGap),
            'pattern_class'=> 'pi-' . strtolower($pattern),
        ];
    }
    usort($extraSkipHitRows, static function($a,$b){
        if ($a['prob'] === $b['prob']) {
            if ($a['skip'] === $b['skip']) return $a['n'] <=> $b['n'];
            return $a['skip'] <=> $b['skip'];
        }
        return ($a['prob'] > $b['prob']) ? -1 : 1;
    });
}

// NOTE: $mainSkipHitRows and $extraSkipHitRows are ready for rendering.
// Columns available: label, skip, hits, prob (float), prob_t (e.g. "12.3%"), sup (trials), hitk (hits@k)

/* ---------- SKAI: Co-Occurrence window (last k draws) ---------- */
if (!function_exists('skai_cooccurrenceCounts')) {
    /**
     * Count how often each number appears over the last $k draws.
     * @param array $history  array of draws oldest?newest; each item array|csv
     * @param int   $k        window size (1..30)
     * @return array<int,int> number => count
     */
    function skai_cooccurrenceCounts(array $history, int $k): array
    {
        $N = count($history);
        if ($N <= 0) return [];
        $k = max(1, min(30, (int)$k));
        $tail = array_slice($history, -$k);
        $freq = [];

        // Zero-exclusion rule (#43): allow 0 only for daily games (range 0-9).
        // Heuristic matches core SKAI math: if max observed <= 9, treat as daily.
        $maxObserved = 0;
        foreach ($tail as $row) {
            $partsScan = is_array($row) ? $row : preg_split('/[^\d]+/', (string)$row, -1, PREG_SPLIT_NO_EMPTY);
            foreach ($partsScan as $pScan) {
                $vScan = (int)$pScan;
                if ($vScan > $maxObserved) { $maxObserved = $vScan; }
            }
        }
        $allowZero = ($maxObserved <= 9);

        foreach ($tail as $row) {
            $parts = is_array($row) ? $row : preg_split('/[^\d]+/', (string)$row, -1, PREG_SPLIT_NO_EMPTY);
            foreach ($parts as $p) {
                $n = (int)$p;
                if ($n === 0 && !$allowZero) { continue; } // exclude 0 for non-daily games
                $freq[$n] = ($freq[$n] ?? 0) + 1;
            }
        }
        return $freq;
    }
}
/* Attach co-occurrence to rows (safe even if n is missing; falls back to numeric label) */
$coK = (int)($lotteryConfig['cooccurrence_window'] ?? 5);
$coK = max(1, min(30, $coK));

$coMain = skai_cooccurrenceCounts($mainDraws ?? [], $coK);
if (!empty($mainSkipHitRows)) {
    foreach ($mainSkipHitRows as &$r) {
        $num = isset($r['n']) ? (int) $r['n'] : (int) preg_replace('/\D+/', '', (string) ($r['label'] ?? ''));
        $c   = $coMain[$num] ?? 0;
        $r['cooc']   = (int) $c;
        $r['cooc_t'] = (string) $c;
    }
    unset($r);
}

if (!empty($hasExtra) && !empty($extraDraws)) {
    $coExtra = skai_cooccurrenceCounts($extraDraws, $coK);
    if (!empty($extraSkipHitRows)) {
        foreach ($extraSkipHitRows as &$r) {
            $num = isset($r['n']) ? (int) $r['n'] : (int) preg_replace('/\D+/', '', (string) ($r['label'] ?? ''));
            $c   = $coExtra[$num] ?? 0;
            $r['cooc']   = (int) $c;
            $r['cooc_t'] = (string) $c;
        }
        unset($r);
    }
}
// End Co-Occurrence

/* ---------- SKAI Pattern Intelligence Summary (server-side) ---------- */
if (!function_exists('skai_buildPatternSummary')) {
    /**
     * Build pattern summary (counts + top examples per pattern).
     * @param array $rows Each row: ['n'=>int,'label'=>string,'skip'=>int,'hits'=>int,'prob'=>float,'pattern'=>string,...]
     * @return array ['counts'=>['stable'=>..,'volatile'=>..,'reset'=>..,'transition'=>..],
     *                'top'=>['stable'=>[row...],'volatile'=>[...],'reset'=>[...],'transition'=>[...]]]
     */
    function skai_buildPatternSummary(array $rows): array
    {
        $counts = ['stable' => 0, 'volatile' => 0, 'reset' => 0, 'transition' => 0];
        $groups = ['stable' => [], 'volatile' => [], 'reset' => [], 'transition' => []];

        foreach ($rows as $r) {
            $p = strtolower((string)($r['pattern'] ?? 'transition'));
            if (!isset($counts[$p])) { $p = 'transition'; }
            $counts[$p]++;

            // Normalize keys used downstream
            $n     = isset($r['n']) ? (int)$r['n'] : null;
            $label = (string)($r['label'] ?? ($n !== null ? (string)$n : ''));
            $skip  = (int)($r['skip'] ?? 0);
            $prob  = (float)($r['prob'] ?? 0.0);

            $groups[$p][] = [
                'n'    => $n,
                'label'=> $label,
                'skip' => $skip,
                'prob' => $prob,
            ];
        }

        // Sort each group: by prob desc, then skip asc, then number asc
        foreach ($groups as $k => &$g) {
            usort($g, static function ($a, $b) {
                if ($a['prob'] === $b['prob']) {
                    if ($a['skip'] === $b['skip']) {
                        return ($a['n'] ?? PHP_INT_MAX) <=> ($b['n'] ?? PHP_INT_MAX);
                    }
                    return $a['skip'] <=> $b['skip'];
                }
                return ($a['prob'] > $b['prob']) ? -1 : 1;
            });
            // keep top few examples for UI (safe: 5)
            $g = array_slice($g, 0, 5);
        }
        unset($g);

        return ['counts' => $counts, 'top' => $groups];
    }
}

/**
 * Simple rule-based recommendation from pattern counts.
 * Returns {headline, advice[], rationale[]}
 */
if (!function_exists('skai_patternRecommendation')) {
    /**
     * @param array $counts ['stable'=>int,'volatile'=>int,'reset'=>int,'transition'=>int]
     * @return array ['headline'=>string,'advice'=>string[],'rationale'=>string[]]
     */
function skai_patternRecommendation(array $counts): array
    {
        $c = array_merge(['stable'=>0,'volatile'=>0,'reset'=>0,'transition'=>0], $counts);
        $total = max(1, (int)$c['stable'] + (int)$c['volatile'] + (int)$c['reset'] + (int)$c['transition']);

        // Fractions
        $fs = $c['stable'] / $total;
        $fv = $c['volatile'] / $total;
        $fr = $c['reset'] / $total;

        $headline = 'What SKAI notices in your number behavior';
        $advice   = [];
        $why      = [];

        if ($fs >= 0.45) {
            $headline = 'Stable phase';
            $advice[] = 'Most of your key numbers are hitting at a steady rhythm.';
            $advice[] = 'Leaning a bit more on the highest-ranked numbers is reasonable.';
            $why[]    = 'Stable behavior is dominating recent draws.';
        } elseif ($fv >= 0.35) {
            $headline = 'Volatile phase';
            $advice[] = 'Hits are arriving in uneven bursts (hot and cold streaks).';
            $advice[] = 'Mix top-ranked numbers with a couple of mid-ranked contenders.';
            $why[]    = 'Volatile behavior is elevated compared to normal.';
        } elseif ($fr >= 0.20) {
            $headline = 'Fresh resets';
            $advice[] = 'Several numbers have just hit and reset their skip counts.';
            $advice[] = 'Include a few recently-hit numbers alongside your usual favorites.';
            $why[]    = 'Many numbers recently came off a longer gap.';
        } else {
            $headline = 'Transition phase';
            $advice[] = 'No single pattern stands out; staying near the top-ranked numbers is a safe choice.';
            $advice[] = 'Watch the next few draws for a clearer trend before making big changes.';
            $why[]    = 'Patterns are mixed, with no strong bias right now.';
        }

        return ['headline' => $headline, 'advice' => $advice, 'rationale' => $why];
    }
}

// Build summaries for Main/Extra
$piMain  = skai_buildPatternSummary($mainSkipHitRows ?? []);
$piExtra = !empty($hasExtra) ? skai_buildPatternSummary($extraSkipHitRows ?? []) : null;

// Compose overall counts (Main has priority in advice)
$adv = skai_patternRecommendation($piMain['counts'] ?? []);

if (!function_exists('skai_runRollingBacktest')) {
    /**
     * Rolling backtest using Skip/Hit P(hit|k) ranking.
     * Chooses top K main (pick size) and 1 extra (if present) at each step, scores next draw.
     *
     * @param array $mainHistory   Array of past main draws, oldest->newest. Each item: array|csv.
     * @param array $extraHistory  Array of past extra draws (optional), oldest->newest.
     * @param int   $pickSize      How many main numbers to pick (fallback 5).
     * @param int   $windows       Window size (history depth, <=100) for each backtest step.
     * @param array $weights       ['main_hit'=>5,'extra_hit'=>2] override via config.
     * @param int   $laplaceK      Smoothing K in {0,1,2}.
     * @return array Summary + per-window series.
     */
    function skai_runRollingBacktest(array $mainHistory, array $extraHistory, int $pickSize, int $windows, array $weights, int $laplaceK): array
    {
        $N        = count($mainHistory);
        $hasExtra = (count($extraHistory) === $N && $N > 0);

        // Treat $windows as the true history depth (W) in draws.
        $windowSize = max(5, min(100, (int) $windows));
        $pickSize   = max(1, (int) $pickSize);

        $wMain  = isset($weights['main_hit'])  ? (int) $weights['main_hit']  : 5;
        $wExtra = isset($weights['extra_hit']) ? (int) $weights['extra_hit'] : 2;

        // Not enough history to form at least one full window + next draw
        if ($N <= $windowSize) {
            return [
                'windows'              => $windowSize,
                'avg_score'            => 0.0,
                'mean_main_matches'    => 0.0,
                'mean_extra_matches'   => 0.0,
                'hit_rate_main_ge1'    => 0.0,
                'series'               => [],
                'weights'              => ['main_hit' => $wMain, 'extra_hit' => $wExtra],
                'pick_size'            => $pickSize,
                'has_extra'            => $hasExtra,
            ];
        }

        $series              = [];
        $totalScore          = 0;
        $totalMainMatches    = 0;
        $totalExtraMatches   = 0;
        $countAtLeastOneMain = 0;

        $canon = static function ($row): array {
            if (is_array($row)) {
                $parts = $row;
            } else {
                $parts = preg_split('/[^\d]+/', (string) $row, -1, PREG_SPLIT_NO_EMPTY);
            }
            $set = [];
            foreach ($parts as $p) {
                $v = (int) $p;
                if (!in_array($v, $set, true)) {
                    $set[] = $v;
                }
            }
            return $set;
        };

        // Accept BOTH shapes for extra history:
        //  A) rich associative rows: ['numbers'=>[...], 'number'=>..., 'date'=>...]
        //  B) already-flattened numeric draws: [7] or [3,11]
        $canonExtraRow = static function ($row): array {
            if (!is_array($row)) {
                return [(int) $row];
            }

            // Shape B: numeric list draw (sequential array)
            $isSequential = (array_values($row) === $row);
            if ($isSequential) {
                $out = [];
                foreach ($row as $n) {
                    if ($n === null || $n === '') {
                        continue;
                    }
                    $v = (int) $n;
                    if (!in_array($v, $out, true)) {
                        $out[] = $v;
                    }
                }
                return $out;
            }

            // Shape A: multi-extra associative row
            if (isset($row['numbers']) && is_array($row['numbers'])) {
                $out = [];
                foreach ($row['numbers'] as $n) {
                    if ($n === null || $n === '') {
                        continue;
                    }
                    $v = (int) $n;
                    if (!in_array($v, $out, true)) {
                        $out[] = $v;
                    }
                }
                return $out;
            }

            // Shape A: single-extra associative row
            if (isset($row['number']) && $row['number'] !== null && $row['number'] !== '') {
                return [(int) $row['number']];
            }

            return [];
        };

        // Rolling window:
        // For each evalIdx from W to N-1, use the previous W draws as history
        // and score the draw at evalIdx.
        for ($evalIdx = $windowSize; $evalIdx < $N; $evalIdx++) {
            // History window [evalIdx - W, ..., evalIdx - 1]
            $start        = $evalIdx - $windowSize;
            $prefixMain   = array_slice($mainHistory, $start, $windowSize);
            $prefixExtras = $hasExtra ? array_slice($extraHistory, $start, $windowSize) : [];

            $prefixExtraDraws = $hasExtra ? array_map($canonExtraRow, $prefixExtras) : [];

            // Skip & Hit probabilities for main balls
            list($preSkips, $preCounts, $preLast, $prePrev, $preProbs)
                = skai_calculateSkipsAndProbabilities($prefixMain, false, $laplaceK);

            $rankable = [];
            foreach ($preSkips as $n => $skip) {
                $rankable[] = [
                    'n'    => (int) $n,
                    'skip' => (int) $skip,
                    'prob' => (float) ($preProbs[$n]['p_hit_given_k'] ?? 0.0),
                ];
            }
            usort($rankable, static function ($a, $b) {
                if ($a['prob'] === $b['prob']) {
                    if ($a['skip'] === $b['skip']) {
                        return $a['n'] <=> $b['n'];
                    }
                    return $a['skip'] <=> $b['skip'];
                }
                return ($a['prob'] > $b['prob']) ? -1 : 1;
            });

            $picksMain = array_slice(array_column($rankable, 'n'), 0, $pickSize);

            // Extra ball Skip & Hit, if present
            $picksExtra = [];
            if ($hasExtra) {
                list($exSkips, $exCounts, $exLast, $exPrev, $exProbs)
                    = skai_calculateSkipsAndProbabilities($prefixExtraDraws, true, $laplaceK);

                $exRank = [];
                foreach ($exSkips as $n => $skip) {
                    $exRank[] = [
                        'n'    => (int) $n,
                        'skip' => (int) $skip,
                        'prob' => (float) ($exProbs[$n]['p_hit_given_k'] ?? 0.0),
                    ];
                }
                usort($exRank, static function ($a, $b) {
                    if ($a['prob'] === $b['prob']) {
                        if ($a['skip'] === $b['skip']) {
                            return $a['n'] <=> $b['n'];
                        }
                        return $a['skip'] <=> $b['skip'];
                    }
                    return ($a['prob'] > $b['prob']) ? -1 : 1;
                });

                if (!empty($exRank)) {
                    $picksExtra = [$exRank[0]['n']];
                }
            }

            // Evaluate against the actual draw at evalIdx
            $nextMain    = $canon($mainHistory[$evalIdx]);
            $mainMatches = count(array_intersect($picksMain, $nextMain));
            $score       = $mainMatches * $wMain;

            // Track actual extra draw for this step (if present)
            $nextExtra    = [];
            $extraMatches = 0;
            if ($hasExtra) {
                $nextExtra     = $canonExtraRow($extraHistory[$evalIdx]);
                $extraMatches  = count(array_intersect($picksExtra, $nextExtra));
                $score        += $extraMatches * $wExtra;
            }

            $totalScore        += $score;
            $totalMainMatches  += $mainMatches;
            $totalExtraMatches += $extraMatches;
            if ($mainMatches > 0) {
                $countAtLeastOneMain++;
            }

            $series[] = [
                'index'         => $evalIdx,
                'score'         => $score,
                'main_matches'  => $mainMatches,
                'extra_matches' => $extraMatches,
                'picked_main'   => $picksMain,
                'picked_extra'  => $picksExtra,
                // New: carry actual draws through so the table can display them
                'actual_main'   => $nextMain,
                'actual_extra'  => $nextExtra,
            ];
        }

        $den = max(1, count($series));

        return [
            'windows'              => $windowSize,
            'avg_score'            => $totalScore / $den,
            'mean_main_matches'    => $totalMainMatches / $den,
            'mean_extra_matches'   => $hasExtra ? ($totalExtraMatches / $den) : 0.0,
            'hit_rate_main_ge1'    => $countAtLeastOneMain / $den,
            'series'               => $series,
            'weights'              => ['main_hit' => $wMain, 'extra_hit' => $wExtra],
            'pick_size'            => $pickSize,
            'has_extra'            => $hasExtra,
        ];
    }
}

// Read WWW (windows) with hard cap 100; pick size from config or fallback 5
// (Guard) Ensure $in (Joomla input) is available
if (!isset($in) || !($in instanceof \Joomla\CMS\Input\Input)) {
    $app = \Joomla\CMS\Factory::getApplication();
    $in  = $app->getInput();
}

// Derive backtest window from the same knobs SKAI uses:
// Priority:
// 1) explicit bt_windows from the request (if > 0)
// 2) current Skip & Hit window ($skipWindow) if available
// 3) any tuned_window from Auto-Tune
// 4) any best_window from Auto-Tune
// 5) configured default.
$btWinInput = (int) $in->getInt('bt_windows', 0);

if ($btWinInput <= 0) {
    // If the main Skip & Hit / SKAI run already has a window selected,
    // prefer that so backtest matches the live configuration.
    if (isset($skipWindow) && (int) $skipWindow > 0) {
        $btWinInput = (int) $skipWindow;
    } elseif (!empty($tunedWin)) {
        $btWinInput = (int) $tunedWin;
    } elseif (!empty($bestWindow)) {
        $btWinInput = (int) $bestWindow;
    } else {
        $btWinInput = (int) ($lotteryConfig['bt_windows_default'] ?? 50);
    }
}

// Guard the final value into [5, 100]; skai_runRollingBacktest()
// will still clamp further based on available history length.
$btWindows = max(5, min(100, $btWinInput));

// Try to get pick size from the SKAI pool size config; safe fallback 20.
// We want backtest to reflect the size of the number pool SKAI actually
// recommends (e.g. 20 numbers for wheeling), not just the game's draw size.
$skaiPickSize = 20;

// Nested lottery config (common pattern: ['lotteryConfig' => ['poolSize' => 20]])
if (!empty($lotteryConfig['lotteryConfig']['poolSize'])) {
    $skaiPickSize = (int) $lotteryConfig['lotteryConfig']['poolSize'];
} elseif (!empty($lotteryConfig['lotteryConfig']['prediction_pool_size'])) {
    $skaiPickSize = (int) $lotteryConfig['lotteryConfig']['prediction_pool_size'];
// Flat config keys (e.g. top-level poolSize or prediction_pool_size)
} elseif (!empty($lotteryConfig['poolSize'])) {
    $skaiPickSize = (int) $lotteryConfig['poolSize'];
} elseif (!empty($lotteryConfig['prediction_pool_size'])) {
    $skaiPickSize = (int) $lotteryConfig['prediction_pool_size'];
}

// Hard guard: at least 1, cap at mainMax if we know it.
$skaiPickSize = max(1, (int) $skaiPickSize);
if (isset($mainMax) && (int) $mainMax > 0) {
    $skaiPickSize = min($skaiPickSize, (int) $mainMax);
}
if (isset($lotteryConfig['pickSize'])) {
    $skaiPickSize = (int) $lotteryConfig['pickSize'];
} elseif (
    isset($lotteryConfig['lotteryConfig']) &&
    is_array($lotteryConfig['lotteryConfig']) &&
    isset($lotteryConfig['lotteryConfig']['pickSize'])
) {
    $skaiPickSize = (int) $lotteryConfig['lotteryConfig']['pickSize'];
}
$scoreWeights = [
    'main_hit'  => (int) ($lotteryConfig['score_weights']['main_hit'] ?? 5),
    'extra_hit' => (int) ($lotteryConfig['score_weights']['extra_hit'] ?? 2),
];


// Run the single backtest with the current UI params
// IMPORTANT: use the flattened numeric histories ($mainDraws / $extraDraws),
// not the richer [$numbers,$date] structures, so we don't treat dates as numbers.
$skaiBacktest = skai_runRollingBacktest(
    $mainDraws  ?? [],     // flattened main draws (arrays of ints)
    $extraDraws ?? [],     // flattened extra draws (arrays of ints or []),
    $skaiPickSize,
    $btWindows,
    $scoreWeights,
    (int) $laplaceK
);
// Optionally run Auto-Tune when requested (DISABLED: client ML is the true AI tuner)
$doAuto = false; // force server-side Auto-Tune OFF

// Still read these for UI defaults / future use, but they won't trigger PHP Auto-Tune
$winMin = (int) ($in->getInt('bt_wmin', (int) ($lotteryConfig['bt_windows_min'] ?? 20)));
$winMax = (int) ($in->getInt('bt_wmax', (int) ($lotteryConfig['bt_windows_max'] ?? 100)));
$winStep = (int) ($in->getInt('bt_wstep', 10));

// Keep the safety cap logic so values stay sane if reused later
$winMin = max(1, min($winMin, 100));
$winMax = max($winMin, min($winMax, 100));
if ($winStep < 1) {
    $winStep = 1;
}

$KsList = $in->getString('bt_ks', '0,1,2');
$KsArr  = array_filter(array_map('trim', explode(',', $KsList)), static function ($v) {
    return $v !== '';
});
$KsArr  = array_map('intval', $KsArr);

// Server-side Auto-Tune is disabled; $skaiAutoTune stays null.
// The only Auto-Tune that actually runs is the client ML tuner in the AI Top Picks card.
$skaiAutoTune = null;

// --- SKAI Evidence payload (v1) for Why-this-pick & DB save ------------------
$skaiEvidenceTop = max(1, (int) ($lotteryConfig['evidence_top'] ?? 10));


$__skai_pickEvidence = static function(array $rows, int $top, array $hist): array {
    $out = [];
    $i = 0;
    foreach ($rows as $r) {
        $n = (int) ($r['n'] ?? 0);
        $h = $hist[$n] ?? [];
        $out[] = [
            'n'                 => $n,
            'label'             => (string) ($r['label'] ?? ''),
            'skip'              => (int) ($r['skip'] ?? 0),
            'p_hit_given_k'     => round((float) ($r['prob'] ?? 0.0), 6),
            'support_trials'    => (int) ($r['sup'] ?? 0),
            'support_hits_at_k' => (int) ($r['hitk'] ?? 0),
            'pattern'           => $r['pattern'] ?? null,
            'median_gap'        => isset($h['median_gap']) ? (int) $h['median_gap'] : null,
            'mean_gap'          => isset($h['mean_gap']) ? (float) $h['mean_gap'] : null,
        ];
        if (++$i >= $top) { break; }
    }
    return $out;
};

$skaiEvidence = [
    'version'      => 'skai_evidence_v1',
    // Use Joomla Date for ISO-8601 evidence timestamp (site-tz aware, normalized to UTC)
    'generated_at' => \Joomla\CMS\Factory::getDate()->toISO8601(true),
    'game_id'      => $gameId ?? ($lotteryConfig['game_id'] ?? null),
    'main'         => $__skai_pickEvidence($mainSkipHitRows ?? [], $skaiEvidenceTop, $mainHistProbs ?? []),
    'extra'        => !empty($hasExtra) ? $__skai_pickEvidence($extraSkipHitRows ?? [], $skaiEvidenceTop, $extraHistProbs ?? []) : [],
];

$skaiEvidencePayloadJson = json_encode($skaiEvidence, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);

// keep PHP open/close transitions as-is for the following HTML/JS blocks
?>

<?php

/* ---------- Feature extraction ---------- */
if (!function_exists('skai_norm_vec')) {
    function skai_norm_vec(array $arr, float $div): array { $d = max(1.0, $div); foreach ($arr as $i=>$v) { $arr[$i] = $v / $d; } return $arr; }
}
if (!function_exists('skai_features_from_history')) {
    function skai_features_from_history(array $drawsAsc, int $domainMax, int $pickSize, array $opts=[]): array {
        $N = count($drawsAsc); $domainMax=(int)$domainMax; $pickSize=(int)$pickSize;
        if ($N < 2 || $domainMax <= 0 || $pickSize <= 0) { return ['x' => [], 'inputDim' => 0]; }
        $allowZero = !empty($opts['allowZero']); $decay = isset($opts['decay']) ? max(0.0, min(1.0,(float)$opts['decay'])) : 0.9;
        $alpha = max(0.01, 1.0 - min(0.999, $decay));
        $b1=min(5,$N); $b2=min(15,$N); $b3=min(50,$N); $gapCap=$b3;
        $domain = $allowZero ? ($domainMax+1) : $domainMax;
        $ew=array_fill(0,$domain,0.0); $c1=$ew; $c2=$ew; $c3=$ew; $last=array_fill(0,$domain,-1);
        for ($j=0;$j<$N;$j++){
            for ($m=0;$m<$domain;$m++){ $ew[$m]*=$decay; }
            $nums = array_map('intval',(array)($drawsAsc[$j]['numbers']??[]));
            $limit = min($pickSize, count($nums));
            for ($k=0;$k<$limit;$k++){
                $v=$nums[$k];
                $valid = $allowZero ? ($v>=0 && $v<=$domainMax) : ($v>=1 && $v<=$domainMax);
                if(!$valid){continue;}
                $idx = $allowZero ? $v : ($v-1);
                if($idx<0||$idx>=$domain){continue;}
                $ew[$idx]+=$alpha;
                $age=($N-$j);
                if($age<=$b1){$c1[$idx]++;} if($age<=$b2){$c2[$idx]++;} if($age<=$b3){$c3[$idx]++;}
                $last[$idx]=$j;
            }
        }
        $gap=array_fill(0,$domain,$gapCap);
        for($i=0;$i<$domain;$i++){ $gap[$i]=($last[$i]===-1)?$gapCap:min($gapCap,$N-$last[$i]); }
        $x = array_merge(
            $ew,
            skai_norm_vec($c1, max(1,$b1)),
            skai_norm_vec($c2, max(1,$b2)),
            skai_norm_vec($c3, max(1,$b3)),
            skai_norm_vec($gap, max(1,$b3))
        );
        return ['x'=>$x,'inputDim'=>count($x)];
    }
}

$mainMax  = (int)(
    $lotteryConfig['max_main_ball_number']
    ?? $lotteryConfig['main_ball_max']
    ?? $lotteryConfig['mainNumbersMax']          // camelCase fallback
    ?? 0
);
$pickSize = (int)(
    $lotteryConfig['num_main_balls_drawn']
    ?? $lotteryConfig['pick_size']
    ?? $lotteryConfig['pickSize']               // camelCase fallback
    ?? count($mainBallCols)
);
$extraMax = (int)(
    $lotteryConfig['max_extra_ball_number']
    ?? $lotteryConfig['extra_ball_max']
    ?? $lotteryConfig['extraBallMax']           // camelCase fallback
    ?? 0
);
$extraCnt = (int)(
    $lotteryConfig['num_extra_balls_drawn']
    ?? $lotteryConfig['extra_ball_count']
    ?? $lotteryConfig['numExtraBallsDrawn']     // camelCase fallback
    ?? 1
); 

$mainMax  = max(0, $mainMax);
$pickSize = max(1, $pickSize);
$extraMax = max(0, $extraMax);
$extraCnt = max(0, $extraCnt);

// Laplace K (0/1/2) ? prefer posted value; fallback to config default or 1
$laplaceK = (int) max(0, min(2, (int) ($in->getInt(
    'laplace_k',
    (int) ($lotteryConfig['laplace_k_default'] ?? 1)
))));

// Build features
$skaiMain = skai_features_from_history(
    $fullMainHistory,            // ASC main history [{numbers:[], date}]
    $mainMax,                    // domain (max main ball)
    $pickSize,                   // pick size
    [
        'allowZero' => ($mainMax <= 9 && empty($hasExtra)),             // daily 0-9 games ONLY; never for bonus/extra games
        'decay'     => (float)($lotteryConfig['recency_decay'] ?? 0.9), // EWMA decay default
    ]
);

$skaiExtra = ['x'=>[], 'inputDim'=>0];
/* LEGACY DUPLICATE (commented out): was a no-op second assignment. Kept for audit history.
$skaiExtra = ['x'=>[], 'inputDim'=>0];
*/
if ($hasExtra && $extraMax > 0 && $extraCnt > 0) {
    // [CHANGE] Faster build without closures/array_map (lower allocs, same result)
    $extraAsMain = [];
    if (!empty($fullExtraHistory)) {
        foreach ($fullExtraHistory as $row) {
            $dt = (is_array($row) && array_key_exists('date', $row)) ? $row['date'] : null;

            // NEW: support multiple extra balls per draw (e.g., EuroMillions Lucky Stars)
            $nums = [];
            if (is_array($row) && array_key_exists('numbers', $row) && is_array($row['numbers'])) {
                foreach ($row['numbers'] as $n) {
                    if ($n === null || $n === '') {
                        continue;
                    }
                    $nums[] = (int) $n;
                }
            } elseif (is_array($row) && array_key_exists('number', $row)) {
                $n = $row['number'];
                if ($n !== null && $n !== '') {
                    $nums[] = (int) $n;
                }
            }

            $extraAsMain[] = [
                'numbers' => $nums,
                'date'    => $dt
            ];
        }
    }
    $skaiExtra = skai_features_from_history(
        $extraAsMain,
        $extraMax,
        max(1, $extraCnt),
        ['allowZero' => ($extraMax <= 9), 'decay' => 0.9]
    );
}

// Concatenate to build complete feature vector for current time
$skaiX = array_merge($skaiMain['x'], $skaiExtra['x']);
$skaiInputDim = count($skaiX);

// Derive cutoff date (first ASC row date if present)
$cutoffDate = '';
if (!empty($rowsAsc)) {
    $firstRaw = isset($rowsAsc[0]->draw_date) ? (string) $rowsAsc[0]->draw_date : '';
    $cutoffDate = $firstRaw !== '' ? substr($firstRaw, 0, 10) : '';
}

// Expose feature payload
$SKAI_FEATURES = [
    'x'         => $skaiX,
    'inputDim'  => $skaiInputDim,
    'main'      => [
        'inputDim' => $skaiMain['inputDim'],
        'domain'   => $mainMax,
        'pick'     => $pickSize,
        'currSkip' => $currSkipMain,
        'hist'     => $mainHistProbs,
        'drawCounts'=> $mainDrawCounts
    ],
    'extra'     => [
        'enabled'  => $hasExtra,
        'inputDim' => $skaiExtra['inputDim'],
        'domain'   => $extraMax,
        'count'    => $extraCnt,
        'currSkip' => $currSkipExtra,
        'hist'     => $extraHistProbs,
        'drawCounts'=> $extraDrawCounts
    ],
    'meta'      => [
        'lottery'  => $lotteryName,
        'gameId'   => $gameId,
        'cutoff'   => $cutoffDate,
        'rowsUsed' => count($mainHistory),
        'laplaceK' => $laplaceK
    ]
];

// [ADD] Global SKAI_ONCE guard (dedup helper) ? nowdoc to avoid quote parsing

?>

<?php
// SKAIJS;

// Gate flag for SKAI / Auto-Tune JS (members-only math)
echo '<script>window.SKAI_CAN_RUN=' . ($skaiUsable ? 'true' : 'false') . ';</script>';

// === Laplace-K smoothing for histograms ? window.SKAI_SERVER.FEATURES.main.hist_smoothed ===
// Non-blocking; re-evaluates when laplaceK_ui changes or ML/Auto-Tune completes.
echo '<script>
/* ==========================================================
   SKAI JS Block A: UI Helpers for Laplace K + Smoothing
   Purpose:
     - Reads current Laplace K from UI
     - Provides smoothing helpers used by later charts/optimizer
   Depends on:
     - DOM: #laplaceK_ui (if present)
   Exposes (globals):
     - None (IIFE only)
   Notes:
     - Must stay early; later blocks call these internals indirectly.
   ========================================================== */
(function(){
  "use strict";
  function currentK(){

    try{
      var el=document.getElementById("laplaceK_ui");
      if (el) {
        var v = parseInt(el.value, 10);
        if (isFinite(v)) return Math.max(0, v); // ES5-safe
      }
      var d = (window.SKAI_DEFAULTS || {});
      return Math.max(0, parseInt(d.laplaceK || 1, 10) || 1);
    }catch(_){ return 1; }
  }
  function smooth(){
    try{
      var S = window.SKAI_SERVER||{};
      var F = (S.FEATURES||{}), M = (F.main||{});
      var hist = M.hist||{}, draw = M.drawCounts||{};
      var K = currentK();
      var out = {};
      for(var n in hist){
        if(!Object.prototype.hasOwnProperty.call(hist,n)) continue;
        var bins = hist[n]||{};
        var W = Math.max(1, +draw[n]||1);
        var ob = {};
        for(var k in bins){
          if(!Object.prototype.hasOwnProperty.call(bins,k)) continue;
          var p = +bins[k]; if(!(p>=0 && p<=1)) continue;
          ob[k] = (p*W + K*0.5) / (W + K);
        }
        out[n]=ob;
      }
      if(!S.FEATURES) S.FEATURES={};
      if(!S.FEATURES.main) S.FEATURES.main={};
      S.FEATURES.main.hist_smoothed = out;
      window.SKAI_SERVER = S;
      try{ window.dispatchEvent(new CustomEvent("skai:laplace:update",{detail:{K:K}})); }catch(_){}
      try{ window.dispatchEvent(new CustomEvent("skai:hist:smoothed",{detail: out})); }catch(_){}
      try{ document.documentElement.setAttribute("data-skai-k", String(K)); }catch(_){}
    }catch(_){}
  }
  function wire(){
    try{
      var el=document.getElementById("laplaceK_ui");
      if(el) el.addEventListener("change", smooth, false);
    }catch(_){}
    window.addEventListener("skai:ml:done", smooth, false);
    window.addEventListener("skai:autotune:done", smooth, false);
    if(document.readyState!=="loading") smooth();
    else document.addEventListener("DOMContentLoaded", smooth, {once:true});
  }
  wire();
})();</script>';

// Quick sanity log (gated to avoid I/O spikes in production)

/* ------------------------------------------------------------------------
 * JS: ML defaults + Top-K sanitizer + daily zero rule (Sorcerer-safe)
 * ---------------------------------------------------------------------- */
$__allowZeroMain  = ($mainMax  <= 9 && empty($hasExtra)) ? 'true' : 'false';
// Align extra zero-rule with server-side spec: allow 0 only for 0–9 extra domains
// when NOT forced one-based (explicit config wins; else one-based if domain > 9).
$__forceOneBasedExtra = array_key_exists('extra_one_based', $lotteryConfig)
    ? (bool) $lotteryConfig['extra_one_based']
    : ($extraMax > 9);
$__allowZeroExtra = (!$__forceOneBasedExtra && $extraMax <= 9) ? 'true' : 'false';
echo <<<HTML
<script>
/* ==========================================================
   SKAI JS Block B: ES5 Polyfills / Safe Assign Utilities
   Purpose:
     - Provide ES5-safe Object.assign replacement
     - Used across SKAI UI + optimizer
   Depends on:
     - None
   Exposes (globals):
     - window.skaiAssign (or internal helper)
   Notes:
     - Keep near top; other blocks assume this exists.
   ========================================================== */
(function(){
  "use strict";

  // ES5-safe shallow assign (Object.assign replacement)

  function skaiAssign(target, src){
    target = target || {};
    src = src || {};
    for (var k in src){
      if (Object.prototype.hasOwnProperty.call(src, k)){
        target[k] = src[k];
      }
    }
    return target;
  }

  // === Defaults for ML stack (used by downstream JS if missing) ===
  window.SKAI_DEFAULTS = skaiAssign({
    ensembleN: 7,
    validationTailPct: 15,
    laplaceK: 1,
    coWindowK: 5,
    curriculum: [300, 900, "full"],
    balancedLoss: true,
    calibration: true
  }, window.SKAI_DEFAULTS || {});

  // === Domain rules (no 0 except daily games = 9) ===
  window.SKAI_RULES = skaiAssign({
    allowZeroMain: {$__allowZeroMain},
    allowZeroExtra: {$__allowZeroExtra},
    mainMax: {$mainMax},
    extraMax: {$extraMax}
  }, window.SKAI_RULES || {});

  // === Public sanitizer for picks (dedupe, clamp, strip 0 when disallowed) ===
  window.SKAI_sanitizePicks = function(payload){
    try{
      var R = window.SKAI_RULES || {};
      var maxM = +R.mainMax || 0, maxE = +R.extraMax || 0;
      function clampList(list, max, allowZero){
        var out=[], seen={};
        for (var i=0;i<(list||[]).length;i++){
          var v = parseInt(list[i], 10);
          if (!isFinite(v)) continue; // ES5-safe
          if (!allowZero && v === 0) continue;
          if (v < (allowZero ? 0 : 1)) continue;
          if (max > 0 && v > max) v = max;
          var key = String(v);
          if (seen[key]) continue;
          seen[key] = 1;
          out.push(v);
        }
        return out;
      }
      if (payload && typeof payload === "object"){
        if (Array.isArray(payload.main_numbers)){
          payload.main_numbers = clampList(payload.main_numbers, maxM, !!R.allowZeroMain);
        }
        if (Array.isArray(payload.extra_ball_numbers)){
          payload.extra_ball_numbers = clampList(payload.extra_ball_numbers, maxE, !!R.allowZeroExtra);
        }
      }
      return payload;
    }catch(_){ return payload; }
  };

  // === Hook save form submit to sanitize hidden fields before DB save ===
  function onSubmit(ev){
    var f = ev.target;
    if (!f || !f.querySelector("input[name='save_set']")) return;
    try{
      // NEW: inject tuned window & analysis_type (idempotent, optional)
      var tuned = (window.SKAI_TUNED_PARAMS && window.SKAI_TUNED_PARAMS.windowSize) ||
                  (window.SKAI_SERVER && window.SKAI_SERVER.usedWindow) || "";
      var uw   = f.querySelector("input[name='used_window']");
      if (!uw) { uw = document.createElement("input"); uw.type="hidden"; uw.name="used_window"; f.appendChild(uw); }
      if (String(tuned||"").length) { uw.value = String(tuned); }

      var at = f.querySelector("input[name='analysis_type']");
      if (!at) { at = document.createElement("input"); at.type="hidden"; at.name="analysis_type"; f.appendChild(at); }
      if (!at.value) { at.value = "SKAI"; }

      var m = f.querySelector("input[name='main_numbers']");
      var e = f.querySelector("input[name='extra_ball_numbers']");
      var obj = {};
      if (m){
        try { obj.main_numbers = JSON.parse(m.value); }
        catch(_){ obj.main_numbers = String(m.value||"").split(/[^\d]+/).map(function(x){ return parseInt(x,10); }); }
      }
      if (e){
        try { obj.extra_ball_numbers = JSON.parse(e.value); }
        catch(_){ obj.extra_ball_numbers = String(e.value||"").split(/[^\d]+/).map(function(x){ return parseInt(x,10); }); }
      }
      obj = window.SKAI_sanitizePicks(obj) || obj;
      if (m && Array.isArray(obj.main_numbers)) m.value = JSON.stringify(obj.main_numbers);
      if (e && Array.isArray(obj.extra_ball_numbers)) e.value = JSON.stringify(obj.extra_ball_numbers);
    }catch(_){}
  }
  document.addEventListener("submit", onSubmit, true);
})();
</script>
HTML;

/* =======================================================================
 * Section 2.9 - (consolidated) Save handler
 * Note: The canonical POST save logic lives in Section 3 below.
 * =====================================================================*/
 
/* --- SKAI bootstrap: expose limits + dataset to JS (Sorcerer-safe) --- */

$__rowsCount   = (int) count($rowsAsc);
$__firstDate   = $rowsAsc ? substr((string) ($rowsAsc[0]->draw_date ?? ''), 0, 10) : '';
$__lastIdx     = max(0, $__rowsCount - 1);
$__lastDate    = !empty($rowsAsc) ? substr((string) ($rowsAsc[$__lastIdx]->draw_date ?? ''), 0, 10) : '';
$__lotCfgJson  = json_encode($lotteryConfig, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
$__serverJson  = json_encode([
    'gameId'   => $gameId,
    'lotteryId'=> $lotteryId,
    'epochs'   => 0,
    'tunedWindow' => null,
    'usedWindow'  => null,
    'bestWindow'  => null,
    'CONFIG'   => ['lotteryConfig' => $lotteryConfig],
], JSON_UNESCAPED_SLASHES);

echo '<script>
/* ==========================================================
   SKAI JS Block C: Server ? Client Limits + Dataset Bridge
   Purpose:
     - Export SKAI_LIMITS (maxTuneWindows, caps)
     - Export SKAI_DATASET (rows + date bounds)
     - Set HTML data-* caps for sliders/optimizer
   Depends on:
     - PHP-injected values already printed in this block
   Exposes (globals):
     - window.SKAI_LIMITS
     - window.SKAI_DATASET
   Notes:
     - Must remain before any optimizer/grid search reads caps.
   ========================================================== */
(function(){try{'

 . 'window.SKAI_LIMITS=window.SKAI_LIMITS||{};if(!isFinite(+window.SKAI_LIMITS.maxTuneWindows))window.SKAI_LIMITS.maxTuneWindows=100;'
 . 'var N=' . (int)$__rowsCount . ';var NCap=Math.min(N,100);document.documentElement.setAttribute("data-skai-window-max",String(NCap));'
  . 'window.SKAI_DATASET={rows:N,first:"' . htmlspecialchars($__firstDate, ENT_QUOTES, 'UTF-8') . '",last:"' . htmlspecialchars($__lastDate, ENT_QUOTES, 'UTF-8') . '"};'
 . 'window.SKAI_SERVER=(function(a,b){a=a||{};b=b||{};var o={},k;for(k in a){if(Object.prototype.hasOwnProperty.call(a,k))o[k]=a[k];}for(k in b){if(Object.prototype.hasOwnProperty.call(b,k))o[k]=b[k];}return o;})(window.SKAI_SERVER||{},' . $__serverJson . ');' // SKAI: fix merge to use b[k] for new fields
 . 'try{var ws=document.getElementById("windowSize_ui")||document.getElementById("windowSize");if(ws){ws.max=String(NCap);if(+ws.value>NCap){ws.value=String(NCap);ws.dispatchEvent(new Event("input",{bubbles:true}));ws.dispatchEvent(new Event("change",{bubbles:true}));}}}catch(_){ }'

 . '}catch(_){}})();</script>';

// Quick sanity log (gated to avoid I/O spikes in production)

  // Clamp window slider to DB rows; set ML defaults; expose limits
  // [DUPLICATE BOOTSTRAP QUARANTINED]
  // Reason/benefit:
  // - This block is a duplicate of canonical SKAI_LIMITS / SKAI_DEFAULTS wiring earlier.
  // - It also defines a second SKAI_sanitizePicks with a different signature.
  // - We preserve it for audit history, but isolate it safely to avoid PHP nested-comment bugs.
  if (false) {
      echo '<script>
/* ==========================================================
   SKAI JS Block D: Safety Caps for Tune Window & Optimizer
   Purpose:
     - Enforce upper bounds for window sizes in UI/optimizer
     - Prevent runaway loops on small games (Pick-5)
   Depends on:
     - window.SKAI_LIMITS from Block C
   Exposes (globals):
     - Updates window.SKAI_LIMITS.maxWindow
   Notes:
     - Critical for Pick-5 stability; do not move.
   ========================================================== */
(function(){
      "use strict";
      window.SKAI_LIMITS = window.SKAI_LIMITS || {};

      window.SKAI_LIMITS.maxWindow = Math.min(' . (int)count($mainHistory) . ', 20);

      // Duplicate overrides (kept inert by quarantine)
      if (!Number.isFinite(+window.SKAI_LIMITS.maxTuneWindows) || window.SKAI_LIMITS.maxTuneWindows > 20) {
        window.SKAI_LIMITS.maxTuneWindows = 20;
      }
      window.SKAI_DEFAULTS = Object.assign({
        ensembleN: 7,
        valTail: 0.15,
        laplaceK: 1,
        coK: 5,
        curriculum: [300, 900, "full"],
        balancedLoss: true,
        calibration: true
      }, window.SKAI_DEFAULTS || {});

      if (typeof window.SKAI_sanitizePicks !== "function") {
        window.SKAI_sanitizePicks = function(picks, isDaily){
          var arr = Array.isArray(picks) ? picks.slice(0) : [];
          if (!isDaily) arr = arr.filter(function(n){ return (parseInt(n,10)||0) !== 0; });
          var seen = Object.create(null), out = [];
          for (var i=0;i<arr.length;i++){ var v = arr[i]|0; if (!seen[v]) { seen[v]=1; out.push(v); } }
          return out;
        };
      }
    })();</script>';
  }

// Quick sanity log (gated to avoid I/O spikes in production)
// [CHANGE] Only log when Joomla debug is enabled

// Publish SKAI server context to JS (Sorcerer-safe; used by sliders, Auto-Tune, and save wiring)
try {
$csrfName = \Joomla\CMS\Session\Session::getFormToken();
$__featMain  = $SKAI_FEATURES['main'];
$__featExtra = $SKAI_FEATURES['extra'];
$__featMeta  = $SKAI_FEATURES['meta'];
echo '<script id="skai-server-export">
/* ==========================================================
   SKAI JS Block E: SKAI_SERVER Export (Canonical Server State)
   Purpose:
     - Publish SKAI_SERVER payload (userId, gameId, settings, history)
     - Used by save wiring, UI defaults, and runners
   Depends on:
     - PHP config + draw history already computed
   Exposes (globals):
     - window.SKAI_SERVER
   Notes:
     - Keep exactly here; later blocks read SKAI_SERVER soon after.
   ========================================================== */
window.SKAI_SERVER='

        . json_encode([
            'userId'       => (int) ($currUser->id ?? 0),
            'gameId'       => (string) $gameId,
            'lotteryId'    => (int) $lotteryId,
            'laplaceK'     => (int) $laplaceK,
            'lotteryName'  => (string) $lotteryName,
            'rowsAvailable'=> count($fullMainHistory),
            'CONFIG'       => [
                'lotteryConfig' => $lotteryConfig,
                'weights' => [
                    'frequency'  => $defaultFreqWeight,
                    'skip'       => $defaultSkipWeight,
                    'historical' => $defaultHistWeight,
                ],
            ],
            'FEATURES'     => [
                'inputDim' => $skaiInputDim,
                'main'     => $__featMain,
                'extra'    => $__featExtra,
                'meta'     => $__featMeta,
            ],
            'LIMITS'       => [
                'maxTuneWindows' => min(100, max(1, (int)count($fullMainHistory))),
            ],
            'csrf'         => [
                'name'  => $csrfName,
                'value' => 1,
            ],
        ], JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE)
        . ';</script>';

// SKAI: bridge SKAI_SERVER.FEATURES into a JS-level SKAI_FEATURES alias for UI helpers (e.g., PI badge).
echo '<script>
/* ==========================================================
   SKAI JS Bridge: SKAI_FEATURES Alias
   Purpose:
     - Provide window.SKAI_FEATURES as a direct alias to
       window.SKAI_SERVER.FEATURES (if not already set).
   Depends on:
     - window.SKAI_SERVER from Block E
   ========================================================== */
(function(){
  "use strict";
  try{
    if (!window.SKAI_FEATURES && window.SKAI_SERVER && window.SKAI_SERVER.FEATURES){
      window.SKAI_FEATURES = window.SKAI_SERVER.FEATURES;
    }
  }catch(_){}
})();
</script>';

    /* ---------- Co-occurrence export (last k draws; default k=5, capped by available rows) ---------- */
    try {
        $coK = (int)($lotteryConfig['co_window_k'] ?? 5);
        $coK = max(1, min(50, $coK)); // safe cap
        $Nco = (int)count($fullMainHistory);
        $startIdx = max(0, $Nco - $coK);
        $pairs = [];
        $byNum = [];

        for ($i = $startIdx; $i < $Nco; $i++) {
            $nums = array_map('intval', (array)($fullMainHistory[$i]['numbers'] ?? []));
            $nums = array_values(array_unique($nums));
            sort($nums, SORT_NUMERIC);
            $cnt = count($nums);
            for ($a = 0; $a < $cnt; $a++) {
                $na = $nums[$a];
                for ($b = $a + 1; $b < $cnt; $b++) {
                    $nb = $nums[$b];
                    $key = $na . '-' . $nb;
                    $pairs[$key] = ($pairs[$key] ?? 0) + 1;
                    // symmetric neighbor counts
                    $byNum[$na][$nb] = ($byNum[$na][$nb] ?? 0) + 1;
                    $byNum[$nb][$na] = ($byNum[$nb][$na] ?? 0) + 1;
                }
            }
        }

        $coocPayload = [
            'k'      => $coK,
            'pairs'  => $pairs,     // flat "a-b" => count
            'byNum'  => $byNum,     // n => { m: count }
            'window' => [
                'rowsAvailable' => $Nco,
                'startIndex'    => $startIdx,
                'endIndex'      => max(0, $Nco - 1),
            ],
            'meta'   => [
                'gameId'  => $gameId,
                'lottery' => $lotteryName,
            ],
        ];

echo '<script id="skai-cooc-export">
/* ==========================================================
   SKAI JS Block F: Co-Occurrence Payload Export
   Purpose:
     - Publish SKAI_COOC for co-occurrence scoring/visuals
   Depends on:
     - PHP coocPayload output
   Exposes (globals):
     - window.SKAI_COOC
   Notes:
     - Read by scoring/heatmap blocks later.
   ========================================================== */
(function(){
  "use strict";
  if (window.SKAI_ONCE && !window.SKAI_ONCE("cooc-export")) return;
  try{
    window.SKAI_COOC=' . json_encode($coocPayload, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE) . ';
    document.documentElement.setAttribute("data-skai-coK","' . (int)$coK . '");
    window.dispatchEvent(new CustomEvent("skai:cooc:ready",{detail:{k:' . (int)$coK . '}}));
  }catch(_){}
})();</script>';
    } catch (\Throwable $__co) {
        if (!empty($isDebug)) { error_log('[SKAI] co-occ export error: ' . $__co->getMessage()); }
    }

    // Clamp the window slider max to DB rows; update labels; reflect LaplaceK into DOM (Sorcerer-safe)
echo '<script>
/* ==========================================================
   SKAI JS Block G: Apply Server Caps to UI Inputs
   Purpose:
     - Sets input max values (windows, burn-in, sims)
     - Prevents invalid ranges in optimizer runs
   Depends on:
     - window.SKAI_SERVER (Block E)
   Exposes (globals):
     - None
   Notes:
     - Safe to run early; no behavior change.
   ========================================================== */
(function(){function run(){try{var S=window.SKAI_SERVER||{};
var n=parseInt(S.rowsAvailable||0,10)||0;var ids=["windowSize","windowSize_ui"];for(var i=0;i<ids.length;i++){var el=document.getElementById(ids[i]);if(!el)continue;var cur=parseInt(el.value||"0",10)||0;el.max=String(n);if(cur>n){el.value=String(n);try{el.dispatchEvent(new Event("input",{bubbles:true}));el.dispatchEvent(new Event("change",{bubbles:true}));}catch(e){}}}var maxLbl=document.getElementById("windowSizeMax");if(maxLbl){maxLbl.textContent=String(n);}var valLbl=document.getElementById("windowSizeVal");if(valLbl){var vEl=document.getElementById("windowSize_ui")||document.getElementById("windowSize");var v=parseInt((vEl&&vEl.value)||"0",10)||0;if(v>n){v=n;}valLbl.textContent=String(v);}var k=(S.laplaceK==null?1:S.laplaceK|0);try{document.documentElement.setAttribute("data-skai-laplace",String(k));}catch(e){}var kUi=document.getElementById("laplaceK_ui");if(kUi&&kUi.value===""){kUi.value=String(k);} }catch(_){}}if(document.readyState==="loading"){document.addEventListener("DOMContentLoaded",run,{once:true});}else{run();}})();</script>';
} catch (\Throwable $__e) {
    if (!empty($isDebug)) { error_log('[SKAI] export error: ' . $__e->getMessage()); }
}

// Inject CSRF into Save Set forms (once; Sorcerer-safe)
$doc->addScriptDeclaration(<<<'SKAI_CSRF'
(function(){
  "use strict";
  try{
    var S = window.SKAI_SERVER || {}, C = (S.csrf || {});
    function inject(){
      try{
        var forms = document.querySelectorAll("form");
        for (var i=0;i<forms.length;i++){
          var f = forms[i];
          if (!f.querySelector('input[name="save_set"]')) continue;

          if (C && C.name && !f.querySelector('input[name="'+C.name+'"]')) {
            var t = document.createElement("input");
            t.type = "hidden"; t.name = String(C.name); t.value = String(C.value || 1);
            f.appendChild(t);
          }

          var req = ["main_numbers","extra_ball_numbers","top_combos_json","analysis_type"];
          for (var j=0;j<req.length;j++){
            var n = req[j];
            if (!f.querySelector('input[name="'+n+'"]')) {
              var h = document.createElement("input");
              h.type = "hidden";
              h.name = n;
              h.value = (n === "analysis_type") ? "SKAI" : (n === "top_combos_json" ? "" : "[]");
              f.appendChild(h);
            }
          }
        }
      }catch(_){}
    }
    if (document.readyState !== "loading") { inject(); }
    else { document.addEventListener("DOMContentLoaded", inject, { once:true }); }
  }catch(e){}
})();
SKAI_CSRF
);

/* consolidated: single client-side CSRF injector retained above */

// --- Save-form hardening: inject CSRF, prevent double submit, aria-live status (Sorcerer-safe) ---
echo '<script>
/* ==========================================================
   SKAI JS Block H: Save-to-Dashboard Form Wiring
   Purpose:
     - Auto-fills hidden fields for save_set / templates
     - Ensures consistent payload for MyLottoExpert
   Depends on:
     - DOM save form + hidden inputs
     - window.SKAI_SERVER (Block E)
   Exposes (globals):
     - window.skaiFillSaveForm()
   Notes:
     - Idempotent via __skaiSaveFormWired flag.
   ========================================================== */
(function(){
  "use strict";
  if (window.__skaiSaveFormWired) return; window.__skaiSaveFormWired = true;

  function ensureCsrfInput(form){
    try{
      var S = (window.SKAI_SERVER && window.SKAI_SERVER.csrf) || {};
      var name = S.name, val = S.value;
      if(!name){ return; }
      var sel = "input[name=\\"" + name.replace(/[\\\\"]/g,"\\\\$&") + "\\"]";
      var h = form.querySelector(sel);
      if(!h){
        h = document.createElement("input");
        h.type = "hidden";
        h.name = name;
        h.value = (val==null?1:val);
        form.appendChild(h);
      }
    }catch(_){}
  }
  function ensureLiveRegion(form){
    var reg = form.querySelector("[data-skai-save-status]");
    if(!reg){
      reg = document.createElement("div");
      reg.setAttribute("data-skai-save-status","");
      reg.setAttribute("role","status");
      reg.setAttribute("aria-live","polite");
      reg.style.position="absolute"; reg.style.width="1px"; reg.style.height="1px"; reg.style.overflow="hidden"; reg.style.clip="rect(1px,1px,1px,1px)";
      form.appendChild(reg);
    }
    return reg;
  }
  function disableButtons(form, on){
    var btns = form.querySelectorAll("button, input[type=submit]");
    for(var i=0;i<btns.length;i++){
      try{ btns[i].disabled = !!on; btns[i].setAttribute("aria-disabled", on?"true":"false"); }catch(_){}
    }
    try{ form.setAttribute("aria-busy", on?"true":"false"); }catch(_){}
  }
  function wireForm(form){
    if(form.__skaiSaveWired) return;
    form.__skaiSaveWired = true;
    ensureCsrfInput(form);
    form.addEventListener("submit", function(ev){
      if(form.__skaiSaving){ ev.preventDefault(); return false; }
      var hasMarker = !!form.querySelector("input[name=\\"save_set\\"]");
      if(!hasMarker){ return; }
      form.__skaiSaving = true;
      var live = ensureLiveRegion(form);
      // Plain ASCII status text to avoid encoding surprises
      try{ live.textContent = "Saving your prediction..."; }catch(_){}
      disableButtons(form, true);
      setTimeout(function(){
        if(!document.hidden){
          form.__skaiSaving = false;
          disableButtons(form, false);
          try{ live.textContent = "Save status unknown - please check your dashboard."; }catch(_){}
        }
      }, 3000);
    }, true);
  }
  function scan(){
    var forms = document.querySelectorAll("form");
    for(var i=0;i<forms.length;i++){
      if(forms[i] && forms[i].querySelector("input[name=\\"save_set\\"]")) wireForm(forms[i]);
    }
  }
  if(document.readyState !== "loading") scan();
  else document.addEventListener("DOMContentLoaded", scan, {once:true});
})();</script>';

// === Pattern Intelligence badge (Label + K + W) - Sorcerer-safe, a11y friendly ===
echo '<script>
/* ==========================================================
   SKAI JS Block I: Performance Index (PI) Badge Wiring
   Purpose:
     - Computes and renders PI badge from SKAI_FEATURES
   Depends on:
     - window.SKAI_FEATURES
     - Prediction outputs already present
   Exposes (globals):
     - None
   Notes:
     - UI-only. Safe to keep where it is.
   ========================================================== */
(function(){
  "use strict";
  if (window.__skaiPIBadgeWired) return; window.__skaiPIBadgeWired = true;
  function classify(){
    try{
      var curr = (window.SKAI_FEATURES && window.SKAI_FEATURES.main && window.SKAI_FEATURES.main.currSkip) || {};
      var ks = [];
      for (var key in curr){
        if (!Object.prototype.hasOwnProperty.call(curr, key)) continue;
        ks.push(+curr[key] || 0);
      }
      if (!ks.length) return "Unknown";

      var n = ks.length, sum = 0, i;
      for (i = 0; i < n; i++) sum += ks[i];

      var mean = sum / n, varsum = 0;
      for (i = 0; i < n; i++){
        var d = ks[i] - mean; varsum += d * d;
      }
      var sd = Math.sqrt(varsum / n);

      if (mean < 1 && sd < 1) return "Reset";
      if (sd < 2) return "Stable";
      if (sd > 5) return "Volatile";
      return "Transition";
    } catch(_){ return "Unknown"; }
  }

  function getWin(){
    try{
      var a=document.documentElement.getAttribute("data-skai-window");
      if (a) { 
        var v = parseInt(a, 10); 
        if (isFinite(v) && v > 0) return v; // ES5-safe
      }
      var S=window.SKAI_SERVER||{};
      return (S.usedWindow|0) || (S.bestWindow|0) || 0;
    }catch(_){ return 0; }
  }
  function getK(){
    try{
      var S=window.SKAI_SERVER||{};
      var F=(window.SKAI_FEATURES&&window.SKAI_FEATURES.meta)||{};
      var D=window.SKAI_DEFAULTS||{};
      var k=(+S.laplaceK)||(+F.laplaceK)||(+D.laplaceK)||1;
      k=parseInt(k,10);
      if(!isFinite(k)) k=1; // ES5-safe
      if(k<0) k=0; if(k>2) k=2;
      return k;
    }catch(_){ return 1; }
  }
  function ensureBadge(){
    var host=document.querySelector("[data-skai-pi-header]")||document.body;
    var el=document.getElementById("skaiPIBadge");
    if(!el){
      el=document.createElement("div");
      el.id="skaiPIBadge";
      el.setAttribute("role","status");
      el.setAttribute("aria-live","polite");
      el.setAttribute("data-skai-pi-badge","1");
      el.style.cssText="position:relative;display:inline-flex;gap:.5rem;align-items:center;font:600 12px/1.2 system-ui,Segoe UI,Roboto,Arial;border:1px solid #ddd;border-radius:999px;padding:.25rem .6rem;margin:.25rem 0;";
      if(host&&host.firstChild){ host.insertBefore(el, host.firstChild); } else { host.appendChild(el); }
    }
    return el;
  }
  function update(){
    try{
      var el=ensureBadge();
      var label=classify();
      window.SKAI_PI_LABEL = label;
      var k=getK();
      var w=getWin();
      var parts=["PI: "+label,"K="+k];
      if(w>0) parts.push("W="+w);
el.textContent = parts.join(" - ");
el.title = "Pattern Intelligence - " + label + " (Laplace K & active window)";

      try{ window.dispatchEvent(new CustomEvent("skai:pi:changed",{detail:{label:label,k:k,w:w}})); }catch(_){}
    }catch(_){}
  }
  // Keep PI badge in sync with Laplace K changes from the smoother.
  window.addEventListener("skai:laplace:update", function(e){
    try{
      var d = (e && e.detail) || {};
      // Accept both K (from smoother) and k (future callers)
      var k = (d.k != null) ? d.k : d.K;
      if (isFinite(+k)) {
        (window.SKAI_SERVER = window.SKAI_SERVER || {}).laplaceK = +k;
      }
    }catch(_){}
    update();
  }, false);
  window.addEventListener("skai:defaults:ready", update, false);
  window.addEventListener("skai:ml:done", update, false);

  // ES5-safe: MutationObserver may not exist in some clients
  if (typeof MutationObserver === "function") {
    var mo = new MutationObserver(function(muts){
      for (var i = 0; i < muts.length; i++){
        var m = muts[i];
        if (m.type === "attributes" && m.attributeName === "data-skai-window") {
          update();
          break;
        }
      }
    });
    try {
      mo.observe(document.documentElement, { attributes:true, attributeFilter:["data-skai-window"] });
    } catch(_){}
  }
  if(document.readyState!=="loading") update();
  else document.addEventListener("DOMContentLoaded", function(){ update(); }, {once:true});
})();</script>';

// If top_combos_json exists and has Unknown/missing label, inject current PI label before submit
echo '<script>
/* ==========================================================
   SKAI JS Block J: Save Submit Interceptor / Payload Normalizer
   Purpose:
     - Ensures save payload is valid JSON and normalized
     - Prevents empty/invalid saves from UI edge cases
   Depends on:
     - Save form exists
   Exposes (globals):
     - None
   Notes:
     - Runs on submit only; behavior-preserving.
   ========================================================== */
(function(){
  "use strict";
  function onSubmit(ev){
     var f=ev.target;
    if(!f || !f.querySelector(\'input[name="save_set"]\')) return;
    try{
      var h=f.querySelector(\'input[name="top_combos_json"]\');
      if(!h || !h.value) return;
      try{
        var obj=JSON.parse(h.value);
        if(obj && obj.pattern_intelligence){
          var cur=(obj.pattern_intelligence.label||"").trim();
          if(!cur || cur==="Unknown"){
            obj.pattern_intelligence.label = (window.SKAI_PI_LABEL||"Unknown");
            h.value = JSON.stringify(obj);
          }
        }
      }catch(_){}
    }catch(_){}
  }
  document.addEventListener("submit", onSubmit, true);
})();</script>';

// Top-K sanitizer & live DOM fixer (Sorcerer-safe; no external deps)
echo '<script>
/* ==========================================================
   SKAI JS Block K: Config Accessors (getSpec / getRules)
   Purpose:
     - Safe unified getters for current lottery spec/rules
     - Hides whether source is SKAI_SERVER or SKAI_CONFIG
   Depends on:
     - window.SKAI_SERVER (Block E) OR window.SKAI_CONFIG
   Exposes (globals):
     - window.SKAI_getSpec() (or internal)
   Notes:
     - Used by runners and UI; keep before those blocks.
   ========================================================== */
(function(){
  function getSpec(){
    var L=(window.SKAI_SERVER&&window.SKAI_SERVER.CONFIG&&window.SKAI_SERVER.CONFIG.lotteryConfig)

          ||(window.SKAI_CONFIG&&window.SKAI_CONFIG.lotteryConfig)
          ||window.SKAI_CONFIG||{};
    var mainMax=+((L.main_ball_max||L.max_main_ball_number||L.mainNumbersMax)||0);
    var extraMax=+((L.extra_ball_max||L.max_extra_ball_number||L.extraBallMax)||0);
    var pick   =+((L.pick_size||L.num_main_balls_drawn||L.pickSize)||0);
    var extraN =+((L.extra_ball_count||L.num_extra_balls_drawn||L.numExtraBallsDrawn)||0);
    var extraCntSafe = Math.max(0, extraN|0);
    return {
      pick: Math.max(1, pick|0),
      extraCnt: extraCntSafe,
      mainMax: Math.max(0, mainMax|0),
      extraMax: Math.max(0, extraMax|0),
      allowZeroMain: ((mainMax|0) <= 9) && (extraCntSafe === 0),
      allowZeroExtra:((extraMax|0) <= 9) && (extraCntSafe === 0)
    };
  }
  function sanitizeList(arr, isExtra){
    var s=getSpec(), max=isExtra?s.extraMax:s.mainMax, allow=isExtra?s.allowZeroExtra:s.allowZeroMain;
    var need=isExtra?Math.max(0,s.extraCnt):Math.max(1,s.pick);
    var out=[], seen=Object.create(null);
    for(var i=0;i<(arr||[]).length;i++){
      var v=parseInt(arr[i],10); if(!isFinite(v)) continue;
      if(!allow && v===0) continue;
      if(v<0 || v>max) continue;
      var k=String(v); if(seen[k]) continue; seen[k]=1;
      out.push(v); if(out.length>=need) break;
    }
    return out;
  }
if (typeof window.SKAI_sanitizePicks !== "function") {
  window.SKAI_sanitizePicks = function(picks, isExtra){
    return sanitizeList(picks, !!isExtra);
  };
}

// Read number text from DOM nodes into a simple array of strings
function readBalls(sel){
  var nodes = document.querySelectorAll(sel);
  var a = [];
  for (var i = 0; i < nodes.length; i++) {
    var n = nodes[i];
    var t = (n.textContent || "").trim();
    if (t) a.push(t);
  }
  return a;
}

  function writeBalls(sel,list){
    var nodes=document.querySelectorAll(sel);
    for(var i=0;i<nodes.length;i++){
      if(i<list.length){ nodes[i].textContent=String(list[i]); nodes[i].style.removeProperty("display"); }
      else { nodes[i].textContent=""; nodes[i].style.display="none"; }
    }
  }
  function runOnce(){
    try{
      // Only normalize SAVED-SET chips now; do NOT touch live SKAI Top Picks.
      // This preserves the true prediction output from SKAI_TOP_MAIN / SKAI_TOP_EXTRA.
      var m=sanitizeList(readBalls("[data-skai-set] .nball"),false);
      if(m.length) writeBalls("[data-skai-set] .nball",m);

      var x=sanitizeList(readBalls("[data-skai-set] .xball"),true);
      if(x.length) writeBalls("[data-skai-set] .xball",x);
    }catch(_){}
  }
  window.addEventListener("skai:ml:done",runOnce,false);
  window.addEventListener("skai:picks:ready",runOnce,false);
  if(document.readyState!=="loading"){ setTimeout(runOnce,0); }
  else { document.addEventListener("DOMContentLoaded",function(){ setTimeout(runOnce,0); },{once:true}); }
})();</script>';

// === Why-this-pick (tiny helper): attach 2-3 evidence bullets per number ===
echo '<script>
/* ==========================================================
   SKAI JS Block L: Smoothed Histogram Event Cache
   Purpose:
     - Buffers histogram/smoothing payloads between blocks
     - Avoids race conditions in chart updates
   Depends on:
     - Earlier smoothing helpers (Block A)
   Exposes (globals):
     - window.SKAI_lastSmooth (if assigned later)
   Notes:
     - Race-safety only; no user-visible behavior change.
   ========================================================== */
(function(){
  "use strict";
  // cache last smoothed histogram payload if events arrive earlier

  var SMOOTH = null;
  function onSmooth(e){ try{ SMOOTH = (e && e.detail) || null; }catch(_){} }
  window.addEventListener("skai:hist:smoothed", onSmooth, false);

  // Legacy helper (currently unused) - kept for reference but fully disabled.
  /*
  function getHistFor(n){
    try{
      var S    = window.SKAI_SERVER || {};
      var F    = S.FEATURES || {};
      var main = F.main || {};
      var extra = F.extra || {};

      var hMain  = (main.hist  || {})[n];
      var hExtra = (extra.hist || {})[n];

      // Prefer main-ball stats, but fall back to extra-ball stats
      return hMain || hExtra || null;
    }catch(_){
      return null;
    }
  }
  */
  function fmtPct(x){ var v = Math.max(0, Math.min(1, +x||0)); return (Math.round(v*1000)/10) + "%"; }

  function whyForNumber(n, currentSkip){
    var reasons = [];

    try{
      var S    = window.SKAI_SERVER || {};
      var F    = S.FEATURES || {};
      var meta = F.meta  || {};
      var main = F.main  || {};
      var extra = F.extra || {};
      var rowsUsed = +meta.rowsUsed || 0;

      // Decide whether this behaves more like a main ball or an extra ball,
      // based on where it has actually hit more often.
      var dcMain  = (main.drawCounts  || {})[n] || 0;
      var dcExtra = (extra.drawCounts || {})[n] || 0;
      var useExtra = (dcExtra > dcMain) && !!extra;

      var feat      = useExtra ? extra : main;
      var histMap   = feat.hist      || {};
      var currMap   = feat.currSkip  || {};
      var drawCounts = feat.drawCounts || {};

      // --- 1) Bounce-back behavior at the current skip --------------------
      var k = isFinite(+currentSkip) ? (+currentSkip | 0) : null; // ES5-safe
      if (k === null || !isFinite(k)) { // ES5-safe
        var rawK = currMap[n];
        if (isFinite(+rawK)) { // ES5-safe
          k = (+rawK | 0);
        }
      }

      var hN = histMap[n] || null;
      if (hN && typeof hN === "object") {
        // Probability at the CURRENT gap
        if (k !== null && Object.prototype.hasOwnProperty.call(hN, k)) {
          var pk = +hN[k];
          if (pk > 0) {
            reasons.push(
              "At its current gap (skip " + k + "), this number has bounced back about " +
              fmtPct(pk) + " of the time in similar situations."
            );
          }
        }

        // Best-performing skip range overall
        var bestK = null;
        var bestV = 0;
        for (var key in hN) {
          if (!Object.prototype.hasOwnProperty.call(hN, key)) continue;
          var vv = +hN[key];
          if (!isFinite(vv) || vv <= 0) continue; // ES5-safe
          if (vv > bestV) {
            bestV = vv;
            bestK = parseInt(key, 10);
          }
        }
        if (bestK !== null && bestV > 0) {
          reasons.push(
            "Historically it has performed best around skip " + bestK +
            ", with hit rates near " + fmtPct(bestV) + "."
          );
        }
      }

      // If we have a skip but no histogram at that exact bucket, give a light "overdue" hint.
      if (k !== null && (!hN || !Object.prototype.hasOwnProperty.call(hN, k))) {
        reasons.push(
          "Right now it is sitting at skip " + k +
          ", which puts it in an \"overdue\" zone compared to its usual rhythm."
        );
      }

      // --- 2) Long-run frequency profile ----------------------------------
      if (rowsUsed > 0 && drawCounts && drawCounts[n] != null) {
        var hits = +drawCounts[n] || 0;
        if (hits > 0) {
          var rate = hits / rowsUsed;
          if (rate > 0) {
            var pct = Math.max(0, Math.min(100, rate * 100));
            var band = "quieter than average";
            if (pct >= 60) {
              band = "high-activity hot number";
            } else if (pct >= 40) {
              band = "above-average performer";
            } else if (pct >= 20) {
              band = "typical activity level";
            }
            reasons.push(
              "Over the last " + rowsUsed + " draws it has hit about " +
              pct.toFixed(1).replace(/\\.0$/, "") + "% of the time - a " + band + "."
            );
          }
        }
      }

      // --- 3) Co-occurrence context (-travelling partners-) ---------------
      // Export format: SKAI_COOC.byNum[n] = { m: count, ... }
      var coocAll = (window.SKAI_COOC || {}).byNum || {};
      var coocMap = coocAll[n];

      if (coocMap && typeof coocMap === "object") {
        var pairs = [];
        for (var nb in coocMap) {
          if (!Object.prototype.hasOwnProperty.call(coocMap, nb)) continue;
          var cnt = +coocMap[nb] || 0;
          var mNum = parseInt(nb, 10);
          if (!isFinite(mNum) || cnt <= 0) continue; // ES5-safe
          pairs.push({ n: mNum, c: cnt });
        }

        pairs.sort(function(a,b){
          return (b.c - a.c) || (a.n - b.n);
        });

        var top = pairs.slice(0, 2).map(function(p){ return p.n; });

        if (top.length === 1) {
          reasons.push("It frequently appears together with " + top[0] + " in the same draw.");
        } else if (top.length === 2) {
          reasons.push("It often travels with " + top[0] + " and " + top[1] + " in the same draw.");
        }
      }

    } catch (_){}

    // Keep the micro-card tight: max 3 short bullet points.
    return reasons.slice(0,3);
  }

  function currentSkipOf(n){
    try{
      var S    = window.SKAI_SERVER || {};
      var F    = S.FEATURES || {};
      var main = F.main  || {};
      var extra = F.extra || {};

      var sMain  = (main.currSkip  || {})[n];
      var sExtra = (extra.currSkip || {})[n];

      var k = null;
      if (isFinite(+sMain)) { // ES5-safe
        k = +sMain;
      } else if (isFinite(+sExtra)) { // ES5-safe
        k = +sExtra;
      }

      return (isFinite(k) && k >= 0) ? k : null; // ES5-safe
    }catch(_){
      return null;
    }
  }

  function annotateAll(){
    try{
      var sel = ".skai-ai-main .nball, #prediction .nball, [data-skai-set] .nball";
      var nodes = document.querySelectorAll(sel);
      for (var i = 0; i < nodes.length; i++) { // ES5-safe NodeList loop
        var node = nodes[i];
        var t = (node.textContent || "").trim();
        if (!t) continue;
        var n = parseInt(t, 10); if (!isFinite(n)) continue; // ES5-safe
        var skip = currentSkipOf(n);
        var reasons = whyForNumber(n, skip);
        if (reasons.length) {
          var msg = reasons.join(" - ");

          try {
            node.setAttribute("title", msg);              // simple tooltip
            node.setAttribute("data-skai-why", msg);      // programmatic access
            node.setAttribute("aria-description", msg);   // a11y assist
          } catch(_) {}
        }
      }
      try{ window.dispatchEvent(new CustomEvent("skai:why:ready")); }catch(_){}
    }catch(_){}
  }

  // run when picks are shown or ML completes (and when cooc/hist becomes ready)
  window.addEventListener("skai:picks:ready", annotateAll, false);
  window.addEventListener("skai:ml:done", annotateAll, false);
  window.addEventListener("skai:cooc:ready", annotateAll, false);
  window.addEventListener("skai:hist:smoothed", function(){ setTimeout(annotateAll,0); }, false);

  if (document.readyState !== "loading") setTimeout(annotateAll,0);
  else { document.addEventListener("DOMContentLoaded",function(){ setTimeout(annotateAll,0); }, {once:true}); }
})();</script>';

echo '<script>(function(){
  "use strict";
  function targetContainer(){
    return document.querySelector("#prediction") ||
           document.querySelector(".skai-ai-main") ||
           document.body;
  }
  function ensureCard(){
    var host = targetContainer(); if(!host) return null;
    var card = document.getElementById("skai-why-card");
    if(!card){
      card = document.createElement("div");
      card.id = "skai-why-card";
      card.className = "skai-why-card";
      card.innerHTML = "<details><summary>Why these picks</summary><div class=\\"content\\" aria-live=\\"polite\\"></div></details>";
      host.appendChild(card);
    }
    return card;
  }
function readReasons(node){
  var msg = node.getAttribute("data-skai-why") || node.getAttribute("title") || "";
  return msg ? msg.split(/\s*-\s*/).filter(Boolean) : [];
}

  function buildRow(n, reasons){
    var wrap = document.createElement("div");
    wrap.className = "row";
    var chip = document.createElement("span"); chip.className = "chip"; chip.textContent = String(n);
    var ul = document.createElement("ul");
    for(var i=0;i<reasons.length;i++){ var li=document.createElement("li"); li.textContent=reasons[i]; ul.appendChild(li); }
    wrap.appendChild(chip); wrap.appendChild(ul);
    return wrap;
  }
  function collectPills(){
    var sel = ".skai-ai-main .nball, #prediction .nball, [data-skai-set] .nball";
    return Array.prototype.slice.call(document.querySelectorAll(sel));
  }
  function renderEvidence(){
    try{
      var pills = collectPills().filter(function(n){ return (n.textContent||"").trim(); });
      if(!pills.length) return;
      var card = ensureCard(); if(!card) return;
      var content = card.querySelector(".content"); if(!content) return;
      content.innerHTML = "";
      var total=0;
      pills.forEach(function(p){
        var n = parseInt((p.textContent||"").trim(), 10);
        if (!isFinite(n)) return; // ES5-safe
        var reasons = readReasons(p);
        if(!reasons.length) return;
        content.appendChild(buildRow(n, reasons.slice(0,3)));
        total++;
      });
      var sum = card.querySelector("summary");
      if(sum){ sum.textContent = total ? ("Why these picks ("+total+")") : "Why these picks"; }
      if(total){ try{ window.dispatchEvent(new CustomEvent("skai:evidence:ready",{detail:{count:total}})); }catch(_){}} 
    }catch(_){}
  }
  // Re-render ONLY when actual SKAI events fire
  window.addEventListener("skai:why:ready", renderEvidence, false);
  window.addEventListener("skai:picks:ready", renderEvidence, false);
  window.addEventListener("skai:ml:done", renderEvidence, false);
  window.addEventListener("skai:cooc:ready", renderEvidence, false);
  window.addEventListener("skai:hist:smoothed", function(){ setTimeout(renderEvidence,0); }, false);
  // Removed all DOM-ready auto-rendering
})();</script>';

// Quick sanity log (gated to avoid I/O spikes in production)

// Evidence Preview Card (Sorcerer-safe; a11y friendly)
echo '<script>(function(){
  "use strict";
  if (window.__skaiEvidenceCardWired) return; window.__skaiEvidenceCardWired = true;
  function classifyPattern(){
    try{
      var curr = (window.SKAI_FEATURES && window.SKAI_FEATURES.main && window.SKAI_FEATURES.main.currSkip) || {};
      var ks = [];
      for (var key in curr){
        if (!Object.prototype.hasOwnProperty.call(curr, key)) continue;
        ks.push(+curr[key] || 0);
      }
      if (!ks.length) return "Unknown";

      var sum = 0;
      for (var i = 0; i < ks.length; i++) sum += ks[i];
      var m = sum / ks.length;

      var varsum = 0;
      for (i = 0; i < ks.length; i++){
        var d = ks[i] - m; varsum += d * d;
      }
      var sd = Math.sqrt(varsum / ks.length);

      if (sd < 2) return "Stable";
      if (sd > 5) return "Volatile";
      return "Transition";
    }catch(_){ return "Unknown"; }
  }
  function topN(arr,n){
    var a=(arr||[]).slice(0);
    a.sort(function(x,y){ return (y.mean-x.mean)||((y.w|0)-(x.w|0)); });
    return a.slice(0, Math.max(0, n|0));
  }
  function ensureCard(){
    var host = document.getElementById("skai-header") || document.querySelector("[data-skai-root]") || document.body;
    var card = document.getElementById("skai-evidence-card");
    if (card) return card;
    card = document.createElement("div");
    card.id = "skai-evidence-card";
    card.setAttribute("role","region");
    card.setAttribute("aria-labelledby","skai-evidence-title");
    card.style.cssText = "margin:.25rem .5rem .5rem; border:1px solid #e5e7eb; border-radius:.5rem; padding:.5rem .75rem; background:#fff; max-width:720px;";
    var h = document.createElement("div");
    h.id = "skai-evidence-title";
    h.textContent = "Evidence Preview";
    h.style.cssText = "font:600 13px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial; margin-bottom:.25rem;";
    var sub = document.createElement("div");
    sub.id = "skai-evidence-sub";
    sub.style.cssText = "font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial; color:#4b5563; margin-bottom:.35rem;";
    var table = document.createElement("table");
    table.id = "skai-evidence-table";
    table.setAttribute("aria-describedby","skai-evidence-sub");
    table.style.cssText = "width:100%; border-collapse:collapse; font:12px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial;";
    var thead = document.createElement("thead");
    var trh = document.createElement("tr");
    ["Rank","# Window","Mean Score"].forEach(function(t,i){
      var th=document.createElement("th");
      th.textContent=t;
      th.style.cssText="text-align:"+ (i===2?"right":"left") +"; padding:.25rem .25rem; border-bottom:1px solid #e5e7eb; color:#374151; font-weight:600;";
      trh.appendChild(th);
    });
    thead.appendChild(trh);
    var tbody = document.createElement("tbody");
    tbody.id = "skai-evidence-body";
    table.appendChild(thead); table.appendChild(tbody);
    card.appendChild(h); card.appendChild(sub); card.appendChild(table);
    if (host && host.nextSibling) host.parentNode.insertBefore(card, host.nextSibling);
    else host.appendChild(card);
    return card;
  }
  function render(){
    try{
      // Only render when we actually have leaderboard rows
      var rows = topN(((window.SKAI_PI&&window.SKAI_PI.leaderboard)||[]), 5);
      if (!rows.length) return;

      var card = ensureCard();
      var sub  = document.getElementById("skai-evidence-sub");
      var body = document.getElementById("skai-evidence-body");
      if (!sub || !body) return;

      var label = classifyPattern();
sub.textContent = "Pattern: " + label + "  -  Source: Skip & Hit + ML";


      while(body.firstChild) body.removeChild(body.firstChild);
      for (var i=0;i<rows.length;i++){
        var r=rows[i], tr=document.createElement("tr");
        var rank=document.createElement("td");
        var ww=document.createElement("td");
        var mean=document.createElement("td");
        rank.textContent=String(i+1);
        ww.textContent  ="W"+String(r.w|0);
        mean.textContent=(+r.mean).toFixed(4);
        mean.style.textAlign="right";
        [rank,ww,mean].forEach(function(td){
          td.style.cssText = "padding:.25rem .5rem; border-bottom:1px solid #f3f4f6;"; // fix garbled CSS
          tr.appendChild(td);
        });
        body.appendChild(tr);
      }
    }catch(_){}
  }
  function safeRender(){
    // Evidence Preview card disabled by request - no auto-render anywhere.
    return;
  }
  // Evidence Preview listeners intentionally disabled (keep function as a no-op).
  // window.addEventListener("skai:autotune:done", safeRender, false);
  // window.addEventListener("skai:ml:done", safeRender, false);
})();</script>';

// Global once-guard (dedupe)
// [MERGE] Earlier code defines window.SKAI_ONCE(). Many later blocks call window.__skaiOnce().
// To avoid two competing dedupe systems, alias __skaiOnce to SKAI_ONCE when available.
// If SKAI_ONCE doesn't exist (edge case), fall back to a local __skaiOnce implementation.
echo '<script>(function(){ "use strict";
  if (window.SKAI_ONCE && !window.__skaiOnce) {
    window.__skaiOnce = window.SKAI_ONCE;
    return;
  }
  if (!window.__skaiOnce) {
    var __seen = Object.create(null);
    window.__skaiOnce = function(id){
      if (__seen[id]) {
        try { console.warn("[SKAI] DUPLICATE " + id + " - delete the SECOND copy"); } catch(_){}
        return false;
      }
      __seen[id] = 1;
      return true;
    };
  }
})();</script>';

// Pattern label stamp on <html> + aria-live announcement (Sorcerer-safe)
echo '<script>(function(){
  "use strict";
  if (!(window.__skaiOnce && window.__skaiOnce("pattern-stamp"))) return;
  function classifyPattern(){
    try{
      var curr = (window.SKAI_FEATURES && window.SKAI_FEATURES.main && window.SKAI_FEATURES.main.currSkip) || {};
      var ks = [];
      for (var key in curr){
        if (!Object.prototype.hasOwnProperty.call(curr, key)) continue;
        ks.push(+curr[key] || 0);
      }
      if (!ks.length) return "Unknown";

      var sum = 0, i;
      for (i = 0; i < ks.length; i++) sum += ks[i];
      var m = sum / ks.length;

      var varsum = 0;
      for (i = 0; i < ks.length; i++){
        var d = ks[i] - m; varsum += d * d;
      }
      var sd = Math.sqrt(varsum / ks.length);

      if (sd < 2) return "Stable";
      if (sd > 5) return "Volatile";
      return "Transition";
    }catch(_){ return "Unknown"; }
  }
  function ensureLive(){
    var el = document.getElementById("skai-pattern-live");
    if (el) return el;
    el = document.createElement("div");
    el.id = "skai-pattern-live";
    el.setAttribute("role","status");
    el.setAttribute("aria-live","polite");
    el.style.cssText = "position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden;";
    document.body.appendChild(el);
    return el;
  }
  function update(){
    try{
      var label = classifyPattern();
      document.documentElement.setAttribute("data-skai-pattern", label);
      ensureLive().textContent = "Pattern state: " + label + ".";
      try{ window.dispatchEvent(new CustomEvent("skai:pattern:update",{detail:{label:label}})); }catch(_){}
    }catch(_){}
  }
  function safeRender(){
    // Evidence Preview card disabled by request - no auto-render anywhere.
    return;
  }
  // Evidence Preview listeners intentionally disabled (keep function as a no-op).
  // window.addEventListener("skai:autotune:done", safeRender, false);
  // window.addEventListener("skai:ml:done", safeRender, false);
})();</script>';

// --- Auto-Tune WWW clamp (=100 and = DB rows) + live label sync (Sorcerer-safe) ---
echo '<script>(function(){
  "use strict";
  if (!(window.__skaiOnce && window.__skaiOnce("www-clamp"))) return;
  function int(v,d){
    v = parseInt(v, 10);
    return isFinite(v) ? v : (d|0); // ES5-safe
  }

  // Clamp #windowSize slider against DB rows and keep label in sync
  function syncWindow(){
    var S = window.SKAI_SERVER || {};
    var rows = int(S.rowsAvailable, 0);
    var ids = ["windowSize_ui","windowSize"];
    for (var i=0;i<ids.length;i++){
      var el = document.getElementById(ids[i]); if(!el) continue;
      var max = Math.max(1, rows || int(el.max, 1));
      try { el.max = String(max); } catch(_){}
      var v = int(el.value, max);
      if (v < 1) v = 1;
      if (v > max) { el.value = String(max); try{ el.dispatchEvent(new Event("input",{bubbles:true})); el.dispatchEvent(new Event("change",{bubbles:true})); }catch(_){} }
      var pill = document.getElementById("windowSizeVal"); if (pill) pill.textContent = String(int(el.value, max));
      var maxLbl = document.getElementById("windowSizeMax"); if (maxLbl) maxLbl.textContent = String(max);
      try { document.documentElement.setAttribute("data-skai-window-max", String(max)); } catch(_){}
    }
  }

  // Clamp Auto-Tune WWW slider = min(50, rowsAvailable); keep labels in sync
  function syncWWW(){
    var cap = 50;
    var rows = int((window.SKAI_SERVER && window.SKAI_SERVER.rowsAvailable), 0);
    var hardMax = Math.max(1, Math.min(cap, rows || cap));
    var ids = ["tuneWindows_ui","tuneWindows","WWW_ui","WWW"];
    for (var i=0;i<ids.length;i++){
      var el = document.getElementById(ids[i]); if(!el) continue;
      try { el.max = String(hardMax); } catch(_){}
      var v = int(el.value, hardMax);
      if (v < 1) v = 1;
      if (v > hardMax) {
        el.value = String(hardMax);
        try { el.dispatchEvent(new Event("input",{bubbles:true})); el.dispatchEvent(new Event("change",{bubbles:true})); } catch(_){}
      }
      var valLbl = document.getElementById("tuneWindowsVal") || document.getElementById("WWWVal");
      if (valLbl) valLbl.textContent = String(int(el.value, hardMax));
      var maxLbl = document.getElementById("tuneWindowsMax") || document.getElementById("WWWMax");
      if (maxLbl) maxLbl.textContent = String(hardMax);
    }

    // Also enforce global guard (ES5-safe check)
    window.SKAI_LIMITS = window.SKAI_LIMITS || {};
    var curMax = +window.SKAI_LIMITS.maxTuneWindows;
    if (!(curMax >= 0) || curMax > hardMax) {
      window.SKAI_LIMITS.maxTuneWindows = hardMax;
    }
  }

  function run(){ try{ syncWindow(); syncWWW(); }catch(_){} }
  if (document.readyState !== "loading") run();
  else document.addEventListener("DOMContentLoaded", run, {once:true});

  // Re-sync when server/data/defaults announce readiness
   window.addEventListener("skai:defaults:ready", run, false);
  window.addEventListener("skai:data:ready", run, false);
})();</script>';

echo '<script>(function(){
  "use strict";
  if (!(window.__skaiOnce && window.__skaiOnce("at-mode-toggle"))) return;

  function currentMode(){
    var n = document.querySelector("input[name=\'skai-at-mode\']:checked");
    var v = n && n.value || "quick";
    return (v === "full") ? "full" : "quick";
  }

  function applyMode(){
    try {
      var mode   = currentMode();
      var limits = window.SKAI_LIMITS || (window.SKAI_LIMITS = {});
      var rows   = +limits.rowsAvailable || +limits.effectiveMaxWindow || 0;

      // Hard cap: at most 100 candidate windows, and never more than rowsAvailable
      var hardMax = Math.max(10, Math.min(100, rows || 100));

      // QUICK: fewer candidate windows (faster), e.g. up to 30
      var quickMax = Math.max(10, Math.min(30, hardMax));

      limits.maxTuneWindows = (mode === "full") ? hardMax : quickMax;
      limits.mode = mode;

      try {
        window.dispatchEvent(new CustomEvent("skai:autotune:mode", {
          detail:{ mode:mode, maxWindows:limits.maxTuneWindows }
        }));
      } catch(_){}
    } catch(_){}
  }

  function wire(){
    applyMode();
    var nodes = document.querySelectorAll("input[name=\'skai-at-mode\']");
    for (var i = 0; i < nodes.length; i++){
      try { nodes[i].addEventListener("change", applyMode, false); } catch(_){}
    }
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", wire, { once:true });
  } else {
    wire();
  }

  window.addEventListener("skai:data:ready",     applyMode, false);
  window.addEventListener("skai:defaults:ready", applyMode, false);
})();</script>';


echo '<script>(function(){
  "use strict";
  if (!(window.__skaiOnce && window.__skaiOnce("live-region"))) return;
  var ID="skai-live";
  function ensureLive(){
    var n=document.getElementById(ID);
    if(!n){
      n=document.createElement("div");
      n.id=ID; 
      n.setAttribute("role","status"); 
      n.setAttribute("aria-live","polite"); 
      n.setAttribute("aria-atomic","true");
      // Visually hidden, SR-readable (prevents layout noise/CLS)
      n.style.position="absolute";
      n.style.left="-9999px";
      n.style.top="auto";
      n.style.width="1px";
      n.style.height="1px";
      n.style.overflow="hidden";
      document.body.appendChild(n);
    }
    return n;
  }
  function say(msg){
    try{ var n=ensureLive(); n.textContent=""; /* flush for screen readers */ setTimeout(function(){ n.textContent=String(msg||""); }, 10); }catch(_){}
  }
  function fmtWin(w){
    return isFinite(+w) && +w > 0 ? (" window " + (+w|0)) : ""; // ES5-safe
  }

  // Hooks
  window.addEventListener("skai:autotune:start", function(e){
    var w=(e&&e.detail&&e.detail.window)|0;
    say("Auto-Tune started"+fmtWin(w)+". Exploring up to one hundred windows.");
    try{
      if (window.skaiProgress && typeof window.skaiProgress.show === "function"){
        window.skaiProgress.show("SKAI is analyzing your draw history-");
      }
    }catch(_){}
  }, false);

  window.addEventListener("skai:autotune:candidate", function(e){
    var d=(e&&e.detail)||{}; var w=d.window|0; var s=+d.avgScore||+d.mean||0;
    // Keep it concise; announce occasionally (every ~10 windows)
    if (w % 10 === 0) {
      say("Auto-Tune progress"+fmtWin(w)+". Avg score "+(s.toFixed ? s.toFixed(3) : s));
      try{
        if (window.skaiProgress && typeof window.skaiProgress.setStatus === "function"){
          window.skaiProgress.setStatus("SKAI is testing different history windows (around " + w + " draws)-");
        }
      }catch(_){}
    }
  }, false);

  window.addEventListener("skai:autotune:done", function(e){
    var d=(e&&e.detail)||{}; var w=d.bestWindow||d.window;
    say("Auto-Tune complete. Best"+fmtWin(w)+".");
    try{
      if (window.skaiProgress && typeof window.skaiProgress.setStatus === "function"){
        window.skaiProgress.setStatus("SKAI is locking in the best-performing settings-");
      }
    }catch(_){}
  }, false);

  window.addEventListener("skai:ml:train:start", function(){
    say("Training models. Please hold.");
    try{
      if (window.skaiProgress && typeof window.skaiProgress.setStatus === "function"){
        window.skaiProgress.setStatus("SKAI is training its models on your tuned setup-");
      }
    }catch(_){}
  }, false);

  window.addEventListener("skai:ml:train:done",  function(){
    say("Models ready. Predictions updated.");
    try{
      if (window.skaiProgress && typeof window.skaiProgress.done === "function"){
        window.skaiProgress.done("Prediction ready - tuned to your game-s history.");
      }
    }catch(_){}
  }, false);

  if(document.readyState!=="loading") ensureLive();
  else document.addEventListener("DOMContentLoaded", ensureLive, {once:true});
})();</script>';

// --- Emit helpers for Auto-Tune & ML (single source of truth; Sorcerer-safe) ---
echo '<script id="skai-emit-helpers">(function(){
  "use strict";
  if (!(window.__skaiOnce && window.__skaiOnce("emit-helpers"))) return;
  if (window.SKAI_AUTOTUNE && window.SKAI_AUTOTUNE.__wired) return; // dedupe guard
  var E = (window.SKAI_AUTOTUNE = window.SKAI_AUTOTUNE || {});
  function emit(type, detail){ try{ window.dispatchEvent(new CustomEvent(type,{detail:detail||{}})); }catch(_){ } }
  E.emit = emit;
  E.emitStart = function(windowSize){ emit("skai:autotune:start", { window: (windowSize|0) }); };
  E.emitCandidate = function(d){
    // expected shape: {window, avgScore, mainAvg, bonusAvg, cases}
    d = d||{}; d.window = d.window|0; d.avgScore = +d.avgScore||+d.mean||0; d.mainAvg=+d.mainAvg||0; d.bonusAvg=+d.bonusAvg||0; d.cases=d.cases|0;
    emit("skai:autotune:candidate", d);
  };
  E.emitDone = function(d){
    // expected shape: {bestWindow, bestScore}
    d = d||{}; if (d.window && !d.bestWindow) d.bestWindow=d.window|0;
    emit("skai:autotune:done", d);
  };
  // ML training phase (optional use)
  E.ml = E.ml || {};
  E.ml.start = function(){ emit("skai:ml:train:start", {}); };
  E.ml.done  = function(){ emit("skai:ml:train:done",  {}); };
  E.__wired = true;
})();</script>';

// Quick sanity log (gated to avoid I/O spikes in production)
// [CHANGE] Only log when Joomla debug is enabled
if (!empty($isDebug)) {
    error_log('[SKAI] Section 2 ready - inputDim=' . $skaiInputDim
        . ', mainRows=' . count($fullMainHistory)
        . ', extraRows=' . count($fullExtraHistory));
}

// Quick sanity log (gated to avoid I/O spikes in production)

// Removed duplicate "Section 2 ready" log here (already logged above)
/* DUPLICATE EXPORT + CLAMP + DEFAULTS (commented out).
 * Reason/benefit:
 * - Canonical SKAI_SERVER export, SKAI_LIMITS, slider clamps, and live-region wiring
 *   already exist earlier in the file.
 * - Keeping this active re-overwrites SKAI_LIMITS.maxTuneWindows and rowsAvailable,
 *   risks conflicting aria-live regions, and can desync window clamps.
 * - Preserved for audit history only.
 *
 * echo '<script>(function(){try{'
 *    . 'window.SKAI_SERVER=window.SKAI_SERVER||{};'
 *    . 'window.SKAI_SERVER.CONFIG=Object.assign({},(window.SKAI_SERVER.CONFIG||{}),{lotteryConfig:' . json_encode($lotteryConfig ?? []) . '});'
 *    . 'window.SKAI_LIMITS=Object.assign({},(window.SKAI_LIMITS||{}),{maxTuneWindows:100});'
 *    . 'document.documentElement.setAttribute("data-skai-dbrows","' . (int)count($fullMainHistory) . '");'
 *    . 'document.documentElement.setAttribute("data-skai-window-max","' . (int)count($fullMainHistory) . '");'
 *    . 'window.SKAI_FEATURES_META=' . json_encode([...]) . ';'
 *    . '}catch(_){}})();</script>';
 *
 * echo '<script>(function(){...bindWindowMax...})();</script>';
 * echo '<script>(function(){...ensureLive / SKAI_DEFAULTS / clampWindowInput...})();</script>';
 */

/* DUPLICATE TOP-K SANITIZER / LIMITS MIRROR (commented out).
 * Reason/benefit:
 * - Canonical SKAI_LIMITS.maxTuneWindows and SKAI_sanitizePicks/TopK already set earlier.
 * - This block forces maxTuneWindows to 20, contradicting canonical 100-cap logic.
 * - Multiple sanitizers with different rules can corrupt save payloads.
 *
 * echo '<script>(function(){ ...duplicate sanitizer/limits... })();</script>';
 */

/* DUPLICATE UI WIRING (commented out).
 * Reason/benefit:
 * - Canonical bootstrap already sets SKAI_DB_ROWS, slider max, zero rule, and emits skai:data:ready.
 * - Double-emitting skai:data:ready can cause Auto-Tune / ML to re-initialize unexpectedly.
 *
 * $__skaiDbRows = (int) count($rowsAsc);
 * $__allowZeroDaily = ($mainMax <= 9) ? 'true' : 'false';
 * echo '<script>(function(){...duplicate data ready emit...})();</script>';
 */

/* DUPLICATE SAVE-TIME SANITIZER (commented out).
 * Reason/benefit:
 * - Canonical SKAI_sanitizePicks already runs on submit and preserves JSON array format.
 * - This block rewrites hidden fields to CSV ("1, 2, 3"), which can break POST schema
 *   and is a prime suspect for save failures (including next_draw_* not persisting).
 * - Preserved for audit history only.
 *
 * $__jsMainMax  = (int) $mainMax;
 * $__jsPickSize = (int) $pickSize;
 * $__jsExtraOn  = $hasExtra ? 'true' : 'false';
 * $__jsExtraMax = (int) $extraMax;
 * $__jsExtraCnt = (int) $extraCnt;
 * echo '<script>(function(){...duplicate CSV sanitizer...})();</script>';
 */

/* DUPLICATE ML DEFAULTS / SPLIT EMIT (commented out).
 * Reason/benefit:
 * - Canonical SKAI_DEFAULTS/SKAI_CFG and validation split emit already exist earlier.
 * - Double-emitting skai:validation:split can cause ML UI to re-initialize.
 *
 * $__skaiDbRows = (int) count($rowsAsc);
 * echo '<script>(function(){...duplicate ML defaults/split...})();</script>';
 */

/* ==========================================================================
   SKAI ? Section 3: Handle Save (POST)
   (consolidated: canonical save handler lives in the later {source} block)
   ========================================================================== */

/* ==========================================================================
   (consolidated) Section 3 save handler removed ? canonical `{source}` block below handles DB writes
   ========================================================================== */

// Stream lightweight PI leaderboard rows during Auto-Tune (no UI yet; used by Evidence/Why)

?>


<?php
// Quick sanity log (gated to avoid I/O spikes in production)


/* ---------------------------------------------------------------------------
 * SKAI - Server-side Save Handler
 * Joomla 5.1.2 - Sorcerer-safe - Inserts into #__user_saved_numbers
 * Triggers via: <form method="post"> - <input type="hidden" name="save_set" value="1">
 * Captures: main_numbers[], extra_ball_numbers[], top_combos_json, evidence_json, params[...]
 * ---------------------------------------------------------------------------*/
if ($_SERVER['REQUEST_METHOD'] === 'POST' && isset($_POST['save_set'])) {
    try {
        $app  = \Joomla\CMS\Factory::getApplication();
        $user = \Joomla\CMS\Factory::getUser();
        $uid  = (int) ($user->id ?? 0);

        // [SECURITY] Require login for saves (prevents anonymous spam + bad data)
        if ($uid <= 0) {
            $app->enqueueMessage('Please log in to save predictions to your dashboard.', 'warning');
            return; // Sorcerer-safe soft exit
        }

        // CSRF (Sorcerer-safe but ENFORCED)
        try {
            if (!\Joomla\CMS\Session\Session::checkToken('post')) {
                $app->enqueueMessage('Security token mismatch. Please refresh and try again.', 'error');
                return; // Sorcerer-safe soft exit
            }
        } catch (\Throwable $__t) {
            $app->enqueueMessage('Security token missing. Please refresh and try again.', 'error');
            return; // Sorcerer-safe soft exit
        }

        // JInput
        $in = $app->getInput();

        // Identity / context
        $postGameId    = (string) $in->getString('game_id', $gameId ?? '');
        $postLotteryId = (string) $in->getString('lottery_id', (string)($lotteryId ?? ''));
        $postDrawDate  = (string) $in->getString('draw_date', '');
        $analysisType  = (string) $in->getString('analysis_type', 'SKAI'); // NEW: honor posted analysis_type

        // Picks
        $main  = (array) $in->get('main_numbers', [], 'ARRAY');
        $extra = (array) $in->get('extra_ball_numbers', [], 'ARRAY');

        // JSON payloads (optional)
        $topCombStr = (string) $in->get('top_combos_json', '', 'RAW');
        $evStr      = (string) $in->get('evidence_json',  '', 'RAW');

        // Params (posted as params[...]) with project defaults
        $params = (array) $in->get('params', [], 'ARRAY');
        $params['windowSize']   = $params['windowSize']   ?? $in->getInt('windowSize',   0);
        $params['laplaceK']     = $params['laplaceK']     ?? $in->getInt('laplaceK',     1);
        $params['ensembleN']    = $params['ensembleN']    ?? 7;
        $params['validation']   = $params['validation']   ?? 'tail_15_percent';
        $params['coWindowK']    = $params['coWindowK']    ?? 5;
        // Plain ASCII curriculum label (avoid garbled punctuation)
        $params['curriculum']   = $params['curriculum']   ?? '300-900-full';
        $params['balancedLoss'] = array_key_exists('balancedLoss', $params) ? (bool)$params['balancedLoss'] : true;
        $params['calibration']  = array_key_exists('calibration',  $params) ? (bool)$params['calibration']  : true;

        // Best-effort next_draw_date (posted value > latest row's next_draw_date)
        $nextDrawDate = '';
        try {
            // 1) Prefer an explicit posted next_draw_date if present (for parity with other modules)
            $postedNext = trim((string) $in->getString('next_draw_date', ''));
            if ($postedNext !== '') {
                // store as simple YYYY-MM-DD (strip time if any)
                $nextDrawDate = substr($postedNext, 0, 10);
            } elseif (!empty($rowsAsc)) {
                // 2) Fallback: last known draw row's next_draw_date (ASC history)
                $lastIdx = count($rowsAsc) - 1;
                if ($lastIdx >= 0 && isset($rowsAsc[$lastIdx]->next_draw_date)) {
                    $rawNext = (string) $rowsAsc[$lastIdx]->next_draw_date;
                    if ($rawNext !== '') {
                        $nextDrawDate = substr($rawNext, 0, 10);
                    }
                }
            }
        } catch (\Throwable $__nd) {
            // Soft-fail: leave $nextDrawDate empty if anything goes wrong
            $nextDrawDate = '';
        }

        // Sanitize balls (numeric, dedup, keep order)
        $norm = static function(array $arr): array {
            $out=[]; $seen=[];
            foreach ($arr as $v) {
                $n = (int) filter_var((string)$v, FILTER_SANITIZE_NUMBER_INT);
                if ($n < 0) continue;
                if (!isset($seen[$n])) { $seen[$n]=1; $out[]=$n; }
            }
            return $out;
        };
        $main  = $norm($main);
        $extra = $norm($extra);

        // Evidence: compose if missing (skai_evidence_v1 shell; UI can enrich)
        if (trim($evStr) === '') {
            $evidence = [
                'type'   => 'skai_evidence_v1',
                'at'     => (new \Joomla\CMS\Date\Date())->toSql(), // FIX: use Joomla Date
                'source' => 'SKAI',
                'params' => [
                    'window'        => (int) ($params['windowSize'] ?? 0),
                    'laplaceK'      => (int) ($params['laplaceK']   ?? 1),
                    'ensembleN'     => (int) ($params['ensembleN']  ?? 7),
                    'validation'    => (string) ($params['validation'] ?? 'tail_15_percent'),
                    'coWindowK'     => (int) ($params['coWindowK'] ?? 5),
                    // [FIX] Plain ASCII curriculum label (prevents garbled punctuation in JSON)
                    'curriculum'    => (string) ($params['curriculum'] ?? '300-900-full'),
                    'balancedLoss'  => (bool)  ($params['balancedLoss'] ?? true),
                    'calibration'   => (bool)  ($params['calibration']  ?? true),
                ],
                'pattern_intel' => (string) $in->getString('pattern_intel', ''),
                'notes'         => 'Auto-generated evidence; UI augments with Pattern Intelligence & Why-this-pick.'
            ];
            $evStr = json_encode($evidence, JSON_UNESCAPED_SLASHES|JSON_UNESCAPED_UNICODE);
        }

        // Top combos: validate or synthesize from picks
        if (trim($topCombStr) === '') {
            $topComb = [
                'version' => 'skai_evidence_v1',
                'picks'   => [ 'main' => $main, 'extra' => $extra ],
                'ranked'  => []
            ];
            $topCombStr = json_encode($topComb, JSON_UNESCAPED_SLASHES|JSON_UNESCAPED_UNICODE);
        } else {
            json_decode($topCombStr, true);
            if (json_last_error() !== JSON_ERROR_NONE) {
                $topCombStr = json_encode(['invalid_payload' => 'top_combos_json'], JSON_UNESCAPED_SLASHES);
            }
        }

        // DB
        $db  = \Joomla\CMS\Factory::getDbo();
        $tbl = $db->replacePrefix('#__user_saved_numbers');
        $now = (new \Joomla\CMS\Date\Date())->toSql();

        // Resolve next_draw_date (upcoming draw) if we can infer a draw table.
        // IMPORTANT: do not reset $nextDrawDate here; preserve any earlier
        // best-effort value from POSTed next_draw_date or $rowsAsc.
        try {
            // Only attempt a lookup when we still have no value.
            if ($nextDrawDate === '') {
                // Prefer explicit draw_date when posted (e.g. backtesting / custom draw)
                if ($postDrawDate !== '') {
                    $nextDrawDate = $postDrawDate;
                } else {
                    // Derive draw table from config (dbCol is canonical in lottery_skip_config.json)
                    $cfg   = (isset($lotteryConfig) && is_array($lotteryConfig)) ? $lotteryConfig : [];
                    $dbCol = (string) (
                        $cfg['dbCol']
                        ?? ($cfg['lotteryConfig']['dbCol'] ?? '')
                        ?? ($cfg['db_col'] ?? '')
                    );

                    if ($dbCol !== '') {
                        // IMPORTANT: dbCol is "lotterydb_fl" etc. We must prepend "#__"
                        // so Joomla can expand it to "prefix_lotterydb_fl".
                        $drawTbl = $db->replacePrefix('#__' . $dbCol); // FIX: correct table name

                        // Reference = "now" in server time; find nearest upcoming next_draw_date
                        $refDate = new \Joomla\CMS\Date\Date();
                        $refSql  = $refDate->toSql();

                        $qNext = $db->getQuery(true)
                            ->select($db->quoteName(['next_draw_date', 'draw_date']))
                            ->from($db->quoteName($drawTbl))
                            ->where($db->quoteName('next_draw_date') . ' >= ' . $db->quote($refSql))
                            ->order($db->quoteName('next_draw_date') . ' ASC');

                        $db->setQuery($qNext, 0, 1);
                        $rowNext = $db->loadAssoc();

                        if (!empty($rowNext['next_draw_date'])) {
                            // Store full timestamp; UI can trim to date-only when rendering
                            $nextDrawDate = substr((string) $rowNext['next_draw_date'], 0, 19);
                        } elseif (!empty($rowNext['draw_date'])) {
                            $nextDrawDate = substr((string) $rowNext['draw_date'], 0, 19);
                        }
                    }
                }
            }
        } catch (\Throwable $__nd) {
            // Soft-fail: continue without next_draw_date; only log when debug is on
            if (!empty($isDebug)) {
                try {
                    error_log('[SKAI] next_draw_date lookup failed: ' . $__nd->getMessage());
                } catch (\Throwable $__e2) {}
            }
        }

        // Final fallback: if lookup failed or produced an empty value,
        // use the SKAI DB metadata we computed earlier in the request.
        if ($nextDrawDate === '' && !empty($skaiDbMeta) && is_array($skaiDbMeta)) {
            if (!empty($skaiDbMeta['next_draw_at'])) {
                // next_draw_at is already a normalized SQL datetime
                $nextDrawDate = substr((string) $skaiDbMeta['next_draw_at'], 0, 19);
            } elseif (!empty($skaiDbMeta['next_draw_date'])) {
                $nextDrawDate = substr((string) $skaiDbMeta['next_draw_date'], 0, 19);
            }
        }

        // --- Normalize next draw fields ---
        // Reason/benefit:
        // - Your schema has BOTH next_draw_date (DATE) and next_draw_at (DATETIME).
        // - We preserve your computed value, then split safely for each column.
        $nextDrawAt = '';
        if ($nextDrawDate !== '') {
            $trimmed = substr((string) $nextDrawDate, 0, 19);
            // If we have time, keep as next_draw_at
            if (strlen($trimmed) > 10) {
                $nextDrawAt = $trimmed;
                $nextDrawDate = substr($trimmed, 0, 10);
            } else {
                // Date-only posted/fallback: promote to midnight for next_draw_at
                $nextDrawDate = substr($trimmed, 0, 10);
                $nextDrawAt   = $nextDrawDate . ' 00:00:00';
            }
        }

        // Column existence helper
        $hasCol = static function($db, string $table, string $col): bool {
            try {
                $db->setQuery('SHOW COLUMNS FROM ' . $db->quoteName($table) . ' LIKE ' . $db->quote($col));
                return (bool) $db->loadResult();
            } catch (\Throwable $__) { return false; }
        };

        // Preferred columns (filter to what exists)
        $columns = [
            'user_id'           => $uid,
            'game_id'           => $postGameId,
            'lottery_id'        => $postLotteryId,
            'draw_date'         => $postDrawDate,

            // Next draw fields (schema-aligned)
            'next_draw_date'    => $nextDrawDate,
            'next_draw_at'      => $nextDrawAt,

            // Respect posted analysis_type; default stays SKAI
            'analysis_type'     => $analysisType,

            // Canonical schema fields (best-effort, filtered by hasCol)
            'source'            => $analysisType, // e.g., SKAI / AI / MCMC
            'label'             => (string) $in->getString('label', $analysisType),
            'date_saved'        => $now,
            'generated_at'      => $now,

            // Numbers
            'main_numbers'      => json_encode($main,  JSON_UNESCAPED_SLASHES),

            // Use canonical column name, but keep legacy key too
            'extra_ball_numbers'=> json_encode($extra, JSON_UNESCAPED_SLASHES),
            'extra_numbers'     => json_encode($extra, JSON_UNESCAPED_SLASHES),

            // Payloads
            'top_combos_json'   => $topCombStr,
            'evidence_json'     => $evStr,
            'params_json'       => json_encode($params, JSON_UNESCAPED_SLASHES|JSON_UNESCAPED_UNICODE),

            // Timestamps (legacy installs)
            'created_at'        => $now,
            'updated_at'        => $now,
        ];
        $insert = [];
        foreach ($columns as $c => $v) {
            if ($hasCol($db, $tbl, $c)) { $insert[$c] = $v; }
        }

        // Fallback: minimal schema collapses into data_json
        if (empty($insert)) {
            $payload = [
                'analysis_type'   => $analysisType, // NEW: respect posted analysis_type here as well
                'game_id'         => $postGameId,
                'lottery_id'      => $postLotteryId,
                'draw_date'       => $postDrawDate,
                'main_numbers'    => $main,
                'extra_numbers'   => $extra,
                'top_combos_json' => json_decode($topCombStr, true),
                'evidence_json'   => json_decode($evStr, true),
                'params'          => $params,
            ];
            $insert = [
                'user_id'    => $uid,
                'data_json'  => json_encode($payload, JSON_UNESCAPED_SLASHES|JSON_UNESCAPED_UNICODE),
                'created_at' => $now,
            ];
        }

        // Build & execute INSERT
        $q = $db->getQuery(true)
            ->insert($db->quoteName($tbl))
            ->columns(array_map([$db, 'quoteName'], array_keys($insert)))
            ->values(implode(',', array_map([$db, 'quote'], array_values($insert))));
        $db->setQuery($q)->execute();

        $app->enqueueMessage('Saved to My LottoExpert dashboard.', 'message');
    } catch (\Throwable $e) {
        try { \Joomla\CMS\Factory::getApplication()->enqueueMessage('Save failed: ' . $e->getMessage(), 'error'); } catch (\Throwable $__) {}
    }
}
?>



<?php

/**
 * SKAI - Section 5/9: Analytics Engine (Skip-Hit + Hybrid Scoring + Backtests + Tuning)
 *
 * EXPECTS (from Sections 1-3):
 *   - $lotteryName, $selectedGameId
 *   - $lotteryConfig (assoc):
 *       ['main_ball_columns' => [...],
 *        'has_extra_ball' => bool,
 *        'extra_ball_columns' or 'extra_ball_column',
 *        'pick_size' (optional)]
 *   - $dbCol, $gameId (used earlier to fetch $latestResult)
 *   - $latestResult : array of DB rows containing main/extra cols + draw_date (DESC)
 *   - UI inputs (sanitized earlier):
 *       $numDraws (int), $tune (0/1), $pureMode (0/1)
 *       $weights (['frequency'=>f, 'skip'=>s, 'historical'=>h])
 *       $pbWeights for extra ball (same shape), $enableExtra (0/1)
 *
 * DEFINES for later sections / UI:
 *   - $topMainNumbers                (array<int> length up to 20)
 *   - $topExtraNumbers               (array<int> length up to 5) when enabled
 *   - $backtestResults               (array rows)
 *   - $avgMainMatches                (float)
 *   - $avgExtraSuccessPercent        (float|null)
 *   - $drawsAnalyzed                 (int)
 *   - $labelText                     (string label in UTC, may include tuning/pure flags)
 *   - $useDraws                      (int window length used for final prediction)
 *   - $bestWindow, $cvResults        (when tuning enabled)
 *   - $nextDrawDate                  (from DB; if missing stays empty string)
 */


// ---------- Early outs / defaults ----------
$topMainNumbers         = [];
$topExtraNumbers        = [];
$backtestResults        = [];
$avgMainMatches         = 0.0;
$avgExtraSuccessPercent = null;
$cvResults              = [];
$bestWindow             = null;
$drawsAnalyzed          = 0;
$useDraws               = 0;
$labelText              = $lotteryName . ' - ' . gmdate('Y-m-d H:i') . ' UTC';
// Early outs / defaults
$nextDrawDate           = isset($nextDrawDate) ? $nextDrawDate : '';


// CHG: Ensure Joomla input exists (avoids undefined $in in certain compositions)
if (!isset($in) || !($in instanceof \Joomla\CMS\Input\Input)) {
$in = \Joomla\CMS\Factory::getApplication()->getInput();
}

// CHG: Define safe weights for main (prevents nulls)
// Sources: existing vars -> Joomla input -> Section-1 defaults -> hard fallback
$freqWeightInput = isset($freqWeightInput)
  ? (float) $freqWeightInput
  : (float) ($in->getString('freq_weight', (string) ($defaultFreqWeight ?? 100.0)));
$skipWeightInput = isset($skipWeightInput)
  ? (float) $skipWeightInput
  : (float) ($in->getString('skip_weight', (string) ($defaultSkipWeight ?? 0.0)));
$histWeightInput = isset($histWeightInput)
  ? (float) $histWeightInput
  : (float) ($in->getString('hist_weight', (string) ($defaultHistWeight ?? 0.0)));

// Clamp to [0, 100] then normalize (fall back to 40/30/30 when sum <= 0)
$freqWeightInput = max(0.0, min(100.0, $freqWeightInput));
$skipWeightInput = max(0.0, min(100.0, $skipWeightInput));
$histWeightInput = max(0.0, min(100.0, $histWeightInput));

$__sum = $freqWeightInput + $skipWeightInput + $histWeightInput;
if ($__sum <= 0) {
  $freqWeightInput = 100.0; $skipWeightInput = 0.0; $histWeightInput = 0.0; $__sum = 100.0;
}
$weights = [
  'frequency'  => $freqWeightInput / $__sum,
  'skip'       => $skipWeightInput / $__sum,
  'historical' => $histWeightInput / $__sum,
];

// Extra/PB weights (only used when extra ball present)
$pbFreqWeightInput = isset($pbFreqWeightInput)
  ? (float) $pbFreqWeightInput
  : (float) ($in->getString('pb_freq_weight', (string) ($defaultFreqWeight ?? 100.0)));
$pbSkipWeightInput = isset($pbSkipWeightInput)
  ? (float) $pbSkipWeightInput
  : (float) ($in->getString('pb_skip_weight', (string) ($defaultSkipWeight ?? 0.0)));
$pbHistWeightInput = isset($pbHistWeightInput)
  ? (float) $pbHistWeightInput
  : (float) ($in->getString('pb_hist_weight', (string) ($defaultHistWeight ?? 0.0)));

$pbFreqWeightInput = max(0.0, min(100.0, $pbFreqWeightInput));
$pbSkipWeightInput = max(0.0, min(100.0, $pbSkipWeightInput));
$pbHistWeightInput = max(0.0, min(100.0, $pbHistWeightInput));

$__pbsum = $pbFreqWeightInput + $pbSkipWeightInput + $pbHistWeightInput;
if ($__pbsum <= 0) {
  $pbFreqWeightInput = 100.0; $pbSkipWeightInput = 0.0; $pbHistWeightInput = 0.0; $__pbsum = 100.0;
}
$pbWeights = [
  'frequency'  => $pbFreqWeightInput / $__pbsum,
  'skip'       => $pbSkipWeightInput / $__pbsum,
  'historical' => $pbHistWeightInput / $__pbsum,
];

// ---------- Core analytics: use the canonical engine from Section 2 ----------
// (No re-definition here. This section relies on the Section-2 implementation.)

// ---------- Defer skip stats until histories are normalized (sorted ASC) ----------
$mainSkips = $mainDrawCounts = $mainHistProbs = [];
$mainLastDrawDate = '';
$mainPreviousIndex = [];
$powerballSkips = $powerballDrawCounts = $powerballHistProbs = [];
$powerballLastDrawDate = '';
$powerballPreviousIndex = [];
// NOTE: $hasExtra was already robustly set at line 1290, checking both the
// has_extra_ball flag AND that extra_ball_columns exist ($__flagWantsExtra && $__hasExtraCols).
// Do NOT overwrite it here. Fallback only if not yet set (should not happen in normal flow).
if (!isset($hasExtra)) {
    $hasExtra = !empty($lotteryConfig['has_extra_ball']);
}
try {
// ===== Domain + zero-handling flags (must exist before backtest uses them) =====
$mainMax  = (int)($lotteryConfig['max_main_ball_number']  ?? $lotteryConfig['main_ball_max']  ?? 0);
$extraMax = (int)($lotteryConfig['max_extra_ball_number'] ?? $lotteryConfig['extra_ball_max'] ?? 0);

// Extra ball one-based override: explicit config wins; else default to one-based if domain > 9
$forceOneBasedExtra = array_key_exists('extra_one_based', $lotteryConfig)
  ? (bool)$lotteryConfig['extra_one_based']
  : ($extraMax > 9);

// Main: allow zero only on tiny 0-9 games and only when there is no extra-ball stream
$allowZeroMain  = ($mainMax > 0 && $mainMax <= 9) && !$hasExtra;

// Extra: allow zero only if not forced one-based and the domain fits 0-9
$allowZeroExtra = !$forceOneBasedExtra && ($extraMax > 0 && $extraMax <= 9);

// Defensive: ensure main ball column list is an array
$mainBallColumns = (array)($lotteryConfig['main_ball_columns'] ?? []);

// CLOSE try{} started above
} catch (\Throwable $e) {
  if (!empty($isDebug)) {
    error_log('[SKAI] Section 5 prelude error: ' . $e->getMessage());
  }
}
?>


<!-- ======================= SKAI ? Server ? Client Hydration (safe) ======================= -->


<?php
// ---------- Normalize & sort histories (ASC by date) ----------
$fullMainHistory = array_values($fullMainHistory ?? []);
usort($fullMainHistory, function($a, $b){
  // Normalize any reasonable date string to a comparable integer timestamp
  $daRaw = is_array($a) ? ($a['date'] ?? '') : (isset($a->draw_date) ? (string)$a->draw_date : '');
  $dbRaw = is_array($b) ? ($b['date'] ?? '') : (isset($b->draw_date) ? (string)$b->draw_date : '');
  $ta = $daRaw !== '' ? strtotime($daRaw) : 0;
  $tb = $dbRaw !== '' ? strtotime($dbRaw) : 0;
  return $ta <=> $tb; // ASC
});

if (isset($fullExtraHistory) && is_array($fullExtraHistory)) {
  $fullExtraHistory = array_values($fullExtraHistory);
  usort($fullExtraHistory, function($a, $b){
    $daRaw = is_array($a) ? ($a['date'] ?? '') : (isset($a->draw_date) ? (string)$a->draw_date : '');
    $dbRaw = is_array($b) ? ($b['date'] ?? '') : (isset($b->draw_date) ? (string)$b->draw_date : '');
    $ta = $daRaw !== '' ? strtotime($daRaw) : 0;
    $tb = $dbRaw !== '' ? strtotime($dbRaw) : 0;
    return $ta <=> $tb; // ASC
  });
}

// ---------- Compute master skip stats on FULL history (now normalized) ----------
if (!empty($fullMainHistory)) {
  list($mainSkips, $mainDrawCounts, $mainLastDrawDate, $mainPreviousIndex, $mainHistProbs) =
    skai_calculateSkipsAndProbabilities($fullMainHistory, false);
}
if (!empty($lotteryConfig['has_extra_ball']) && !empty($fullExtraHistory)) {
  list($powerballSkips, $powerballDrawCounts, $powerballLastDrawDate, $powerballPreviousIndex, $powerballHistProbs) =
    skai_calculateSkipsAndProbabilities($fullExtraHistory, true);
}

// ---------- Read canonical inputs ----------
try {
  $drawMode = (string)($in->getString('draw_mode', '') ?? '');
  $tune     = (int)$in->getInt('tune', $tune ?? 0);
  $pureMode = (int)$in->getInt('pure_mode', $pureMode ?? 0);

  if ($drawMode === 'tune' && !$pureMode) {
    $tune = 1;
  } elseif ($drawMode === 'manual') {
    $tune = 0;
    $numDraws = (int)$in->getInt('num_draws', isset($numDraws) ? (int)$numDraws : 0);
  }
} catch (\Throwable $e) {
  /* keep defaults */
}

// ---------- Defensive fallbacks ----------
$lotteryName    = $lotteryName    ?? 'Unknown Lottery';
$selectedGameId = $selectedGameId ?? 'default';
$lotteryConfig  = $lotteryConfig  ?? ['has_extra_ball'=>0,'main_ball_columns'=>[]];

if (!isset($enableExtra)) { $enableExtra = !empty($lotteryConfig['has_extra_ball']) ? 1 : 0; }
else { $enableExtra = (int)$enableExtra; }

$tune                   = isset($tune) ? (int)$tune : 1;
$pureMode               = isset($pureMode) ? (int)$pureMode : 0;
$numDraws               = isset($numDraws) ? (int)$numDraws : 0;

$freqWeightInput        = isset($freqWeightInput) ? (float)$freqWeightInput : 100.0;
$skipWeightInput        = isset($skipWeightInput) ? (float)$skipWeightInput : 0.0;
$histWeightInput        = isset($histWeightInput) ? (float)$histWeightInput : 0.0;
$pbFreqWeightInput      = isset($pbFreqWeightInput) ? (float)$pbFreqWeightInput : 100.0;
$pbSkipWeightInput      = isset($pbSkipWeightInput) ? (float)$pbSkipWeightInput : 0.0;
$pbHistWeightInput      = isset($pbHistWeightInput) ? (float)$pbHistWeightInput : 0.0;

$topMainNumbers         = isset($topMainNumbers) ? (array)$topMainNumbers : [];
$topExtraNumbers        = isset($topExtraNumbers) ? (array)$topExtraNumbers : [];

$useDraws               = isset($useDraws) ? (int)$useDraws : 0;
$drawsAnalyzed          = (int)($useDraws ?? 0);

// CHG: enforce full-history default for analysis window (no hidden caps)
$historyCount = is_array($fullMainHistory ?? null) ? count($fullMainHistory) : 0;
if ($historyCount > 0) {
    // If client/server did not request a window, or requested an invalid one, use all draws
    if ($numDraws <= 0 || $numDraws > $historyCount) {
        $numDraws = $historyCount;
    }
    if ($useDraws <= 0 || $useDraws > $historyCount) {
        $useDraws = $historyCount;
        $drawsAnalyzed = $historyCount;
    }
}

$nextDrawDate           = $nextDrawDate ?? '';
$bestWindow             = isset($bestWindow) ? (int)$bestWindow : null;
$cvResults              = isset($cvResults) ? (array)$cvResults : [];
$avgMainMatches         = isset($avgMainMatches) ? (float)$avgMainMatches : 0.0;
$avgExtraSuccessPercent = array_key_exists('avgExtraSuccessPercent', get_defined_vars())
  ? (is_null($avgExtraSuccessPercent) ? null : (float)$avgExtraSuccessPercent)
  : null;
$avgExtraMatches        = $avgExtraMatches ?? ($avgExtraSuccessPercent ?? null);

$backtestResults        = isset($backtestResults) ? (array)$backtestResults : [];
$mainPreviousIndex      = isset($mainPreviousIndex) ? (array)$mainPreviousIndex : [];
$mainDrawCounts         = isset($mainDrawCounts) ? (array)$mainDrawCounts : [];
$mainLastDrawDate       = isset($mainLastDrawDate) ? (string)$mainLastDrawDate : '';
$mainSkips              = isset($mainSkips) ? (array)$mainSkips : [];

$powerballPreviousIndex = isset($powerballPreviousIndex) ? (array)$powerballPreviousIndex : [];
$powerballDrawCounts    = isset($powerballDrawCounts) ? (array)$powerballDrawCounts : [];
$powerballLastDrawDate  = isset($powerballLastDrawDate) ? (string)$powerballLastDrawDate : '';
$powerballSkips         = isset($powerballSkips) ? (array)$powerballSkips : [];


$userIsInAllowedGroup   = isset($userIsInAllowedGroup) ? (bool)$userIsInAllowedGroup : false;
$lotteryId              = isset($lotteryId) ? (int)$lotteryId : 0;
// If $saveable was explicitly set earlier, keep it; otherwise, mirror the access flag.
$saveable               = isset($saveable) ? (bool)$saveable : $userIsInAllowedGroup;

$bestWindowN            = $bestWindowN ?? null;
$focusBest              = $focusBest   ?? null;
$cvFocus                = $cvFocus     ?? [];

$weights                = $weights   ?? ['frequency'=>1.0,'skip'=>0.0,'historical'=>0.0];
$pbWeights              = $pbWeights ?? ['frequency'=>1.0,'skip'=>0.0,'historical'=>0.0];

// ---------- Build label (UTC) ----------
$timestampUTC  = gmdate('Y-m-d H:i');
// Normalize and guard bestWindow for comparisons (avoid null<int deprecations)
$bestWindowInt = is_numeric($bestWindow ?? null) ? (int)$bestWindow : 0;

if (!empty($tune) && $bestWindowInt >= 2 && isset($cvResults[$bestWindowInt])) {
  $avgMain = (float)$cvResults[$bestWindowInt];
  $avgExtra = (isset($avgExtraMatches) && is_numeric($avgExtraMatches)) ? (float)$avgExtraMatches : null;
  $gamma  = isset($cvFocus[$bestWindowInt]['gamma']) ? (float)$cvFocus[$bestWindowInt]['gamma'] : 0.97;
  $beta   = isset($cvFocus[$bestWindowInt]['beta'])  ? (float)$cvFocus[$bestWindowInt]['beta']  : 0.30;

  if ($avgExtra !== null) {
    $labelText = sprintf(
'%s - Auto-tuned (W=%d; EMD_main=%.3f; EMD_extra=%.3f; gamma=%.2f; beta=%.2f) - %s',
      $lotteryName, $bestWindowInt, $avgMain, $avgExtra, $gamma, $beta, $timestampUTC
    );
  } else {
    $labelText = sprintf(
'%s - Auto-tuned (W=%d; EMD_main=%.3f; gamma=%.2f) - %s',
      $lotteryName, $bestWindowInt, $avgMain, $gamma, $timestampUTC
    );
  }
} else {
  $labelText = "{$lotteryName} - {$timestampUTC}";
}
if (!empty($pureMode)) {
  $labelText .= ' [PURE-SKAI] (Pure Math)';
}
$labelAttr = htmlspecialchars($labelText, ENT_QUOTES, 'UTF-8');

// ---------- Build the JSON payload ----------
$didTune = (!empty($tune) && $bestWindowInt >= 2 && isset($cvResults[$bestWindowInt]));

$skaiServer = [
  'tuneRequested'   => (int)($tune ?? 0),
  'tuneRan'         => (int)$didTune,
  'tuneSucceeded'   => (int)$didTune,
  'usedWindow'      => (int)($useDraws ?? 0),
  'windowSize'      => (int)($useDraws ?? 0),
  'drawsAnalyzed'   => (int)($drawsAnalyzed ?? (int)($useDraws ?? 0)),
  'totalDraws'      => (int)(is_array($fullMainHistory ?? null) ? count($fullMainHistory) : 0), // ADDED: expose full DB size
  'bestWindow'      => (int)$bestWindowInt,
  'avgMainMatches'  => (float)($didTune ? $cvResults[$bestWindowInt] : ($avgMainMatches ?? 0)),
  'avgExtraSuccess' => !empty($lotteryConfig['has_extra_ball']) ? (float)($avgExtraSuccessPercent ?? 0) : null,

  // NEW: hydrate next draw date for client save payloads / UI (primary objective)
  'nextDrawDate'    => (string)($nextDrawDate ?? ''),

  'topMainNumbers'  => array_values(array_map('intval', $topMainNumbers ?? [])),
  'topExtraNumbers' => array_values(array_map('intval', $topExtraNumbers ?? [])),
  // lets client know we REALLY ran tuning
  'hasAutoTune'     => (bool)$didTune,
];

// --- NEW: enrich with full Auto-Tune details when available ---
try {
  if (!empty($cvResults) && is_array($cvResults)) {
    // list of W values evaluated
    $candidates = array_map('intval', array_keys($cvResults));

    // build scored rows + merge cvFocus metrics if present
    $scored = [];
foreach ($cvResults as $W => $score) {
  $Wint = (int)$W;
  // CHG: sanitize negatives/NaN to stabilize UI charts
  $sval = (float)$score;
  if (!is_finite($sval) || $sval < 0) { $sval = 0.0; }
  $row  = ['W' => $Wint, 'score' => $sval];

  if (!empty($cvFocus[$Wint]) && is_array($cvFocus[$Wint])) {
    $f = $cvFocus[$Wint];
    if (isset($f['gamma']))    { $row['gamma']    = (float)$f['gamma']; }
    if (isset($f['beta']))     { $row['beta']     = (float)$f['beta']; }
    if (isset($f['emdMain']))  {
      $em = (float)$f['emdMain'];  $row['emdMain']  = (is_finite($em)  && $em  >= 0) ? $em  : null;
    }
    if (isset($f['emdExtra'])) {
      $ex = (float)$f['emdExtra']; $row['emdExtra'] = (is_finite($ex) && $ex >= 0) ? $ex : null;
    }
  }

  $scored[] = $row;
}

    // sort high score first; tie-break to smaller W
    usort($scored, function($a,$b){
      $cmp = ($b['score'] <=> $a['score']);
      return $cmp !== 0 ? $cmp : ($a['W'] <=> $b['W']);
    });

    // attach raw + diagnostics
    $skaiServer['cvResults'] = $cvResults;
    if (!empty($cvFocus) && is_array($cvFocus)) {
      $skaiServer['cvFocus'] = $cvFocus;
      $gammaBest = $cvFocus[$bestWindowInt]['gamma'] ?? null;
      $betaBest  = $cvFocus[$bestWindowInt]['beta']  ?? null;
    } else {
      $gammaBest = null; $betaBest = null;
    }

    // rich tuneDetails for your ?Auto-Tune Math? panel
    $skaiServer['tuneDetails'] = [
      'didTune'     => (bool)$didTune,
      'bestWindow'  => (int)$bestWindowInt,
      'gamma'       => is_null($gammaBest) ? null : (float)$gammaBest,
      'beta'        => is_null($betaBest)  ? null : (float)$betaBest,
      // CHG: copy polish - remove encoding artifact and keep meaning precise.
      'objective'   => 'maximize cross-validated score; prefer lower EMD; ties favor smaller W',
      'candidates'  => $candidates,
      'scored'      => $scored,
    ];
  }
} catch (\Throwable $e) {
  // keep minimal export if anything goes wrong
}

$skaiServerJson = json_encode(
  $skaiServer,
  JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES |
  JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT
);

// ---------- Emit DOM nodes entirely from PHP (no PHP inside HTML that follows) ----------
echo '<div id="skai-anchor" data-skai-label="', $labelAttr, '" style="display:none"></div>';
// Use <template> so content is never rendered, even if a filter strips the <script> tag.
echo '<template id="skai-server-json" data-type="application/json" style="display:none">', $skaiServerJson, '</template>';

?>
<!-- SKAI - Consolidated, de-duplicated, organized CSS (single file)
     Sorcerer-safe: emits one <style id="skai-consolidated"> block you can paste once. -->
<style id="skai-consolidated">
/* ======================================================================
   [CSS] CONSOLIDATED STYLES (SAFE SINGLE BLOCK)
   ====================================================================== */

/* ===========================================================
   SKAI CONSOLIDATED CSS
   - Palette, spacing, type, motion tokens
   - Base + layout wrappers & grid
   - Panels, hero, stacks, media
   - Controls (buttons/chips), forms, ranges
   - Tables, balls
   - Popovers, collapsibles, modal, busy state
   - AI Central, Run banner, Progress host
   - Evidence/Why card, Insights widget, Progress badge
   - Confidence gauge, micro-interactions
   - Accessibility: focus, reduced-motion, high-contrast
   =========================================================== */

/* =========================
   1) TOKENS & GLOBAL BASE
   ========================= */
:root{
  /* Palette */
  --page-bg:#f7f9fc; --panel-bg:#ffffff; --panel-border:#E5E7EB;
  --panel-shadow:0 6px 22px rgba(17,24,39,.06);
  --ink:#0B0C10; --muted:#4B5563;

  /* Brand */
  --accent:#1E40AF; --accent-weak:#EEF2FF; --accent-ring:#93C5FD;

  /* States */
  --good:#16a34a; --warn:#F59E0B; --error:#EF4444;

  /* Shape & rhythm */
  --radius:12px; --gap:16px;

  /* Type scale */
  --t-1:clamp(1.15rem,2.2vw,1.45rem); /* hero h1 */
  --t-2:1.05rem;                      /* panel headers */
  --t-3:.95rem;                       /* body */
  --t-4:.78rem;                       /* badges */

  /* Motion & elevation */
  --motion-fast:.15s ease; --motion-medium:.25s ease;
  --elev-raise:0 8px 24px rgba(17,24,39,.08);
}
@media (prefers-color-scheme:dark){
  /* Keep panels light for readability per SKAI spec */
  :root{ --page-bg:#f7f9fc; --panel-bg:#ffffff; --panel-border:#E5E7EB; }
}

html,body{margin:0;padding:0}
body{
  background:var(--page-bg); color:var(--ink);
  font:500 var(--t-3)/1.5 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
  -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
}

/* ==============================
   2) WRAPPERS, CONTAINERS & GRID
   ============================== */
#skai{width:100%;max-width:1200px;margin:24px auto 40px;padding:0 16px}
.skai-wrap{max-width:1200px;margin:24px auto 32px;padding-inline:clamp(16px,2.5vw,24px)}
@media (min-width:992px){ #skai{padding:0 24px} }

.skai-container{max-width:1200px;margin-inline:auto;padding-inline:16px}
@media (min-width:992px){ .skai-container{padding-inline:24px} }

.row{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center}
.col{flex:1 1 320px;min-width:280px}
@media (max-width:1024px){ .col{flex:1 1 360px} }
@media (max-width:680px){ .row{gap:12px}.col{flex:1 1 100%} }

/* Responsive grid utility (12/8/4) */
.grid{display:grid;gap:12px 16px}
@media (min-width:1200px){
  .grid{grid-template-columns:repeat(12,1fr)}
  .col-4{grid-column:span 4}
  .col-6{grid-column:span 6}
  .col-8{grid-column:span 6} /* balanced to avoid holes */
  .col-12{grid-column:span 12}
}
@media (min-width:768px) and (max-width:1199px){
  .grid{grid-template-columns:repeat(8,1fr)}
  .col-4{grid-column:span 4}
  .col-6{grid-column:span 4}
  .col-8{grid-column:span 8}
  .col-12{grid-column:span 8}
}
@media (max-width:767px){
  .grid{grid-template-columns:repeat(4,1fr)}
  .col-4,.col-6,.col-8,.col-12{grid-column:span 4}
}

/* =================
   3) PANELS & HERO
   ================= */
.skai-panel,.panel,.tile{
  background:var(--panel-bg); border:1px solid var(--panel-border);
  border-radius:var(--radius); box-shadow:var(--panel-shadow);
}

/* -------------------------------------------------
   SKAI Results Header - premium hierarchy + rhythm
   ------------------------------------------------- */
.skai-results-header{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:14px;
  margin:2px 0 10px;
  flex-wrap:wrap;
}

.skai-results-title{
  min-width:220px;
}

.skai-results-h3{
  margin:0;
  font-weight:700;
  font-size:1.05rem;
  letter-spacing:0.01em;
  color:var(--ink);
}

.skai-results-sub{
  margin:6px 0 0;
  font-size:0.92rem;
  line-height:1.45;
  color:var(--muted);
}

.skai-results-actions{
  display:flex;
  flex-direction:column;
  align-items:flex-end;
  gap:6px;
  min-width:240px;
}

.skai-results-actions-label{
  font-size:0.88rem;
  text-align:right;
  color:var(--muted);
}

.skai-results-chips{
  display:flex;
  gap:6px;
  flex-wrap:wrap;
  justify-content:flex-end;
}

.skai-results-copy{
  margin-left:4px;
}

/* Evidence note - calmer, clearer */
.skai-why-note{
  margin-top:8px;
  font-size:0.86rem;
  line-height:1.45;
  color:var(--muted);
}

.skai-panel{margin:18px 0;overflow:hidden}
.tile{padding:12px}

.panel-header{
  padding:12px 16px; border-bottom:1px solid #F3F4F6;
  font:800 var(--t-2)/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  color:var(--ink); background:#F9FAFB; border-radius:var(--radius) var(--radius) 0 0;
}
.panel .content{padding:16px 12px 12px}

.skai-hero-panel{padding:20px 20px 12px}
.skai-hero{padding:8px 0 6px;margin-bottom:0}
#skai-hero h1{margin:0 0 6px;font:700 var(--t-1)/1.22 system-ui;letter-spacing:.1px;color:var(--ink)}
.skai-tagline{margin:2px 0 10px;color:#374151;font:500 .95rem/1.45 system-ui}
.hero-meta{margin-top:6px}
.hero-meta .trust-badge,.trust-badge{
  display:inline-block;padding:.18rem .5rem;border-radius:999px;background:#F3F4F6;color:#111827;
  font:600 var(--t-4)/1.2 system-ui;border:1px solid #e5e7eb;
}
.skai-head{margin:8px 0 6px}
.hero-cta-wrap{display:flex;gap:10px;flex-wrap:wrap;padding:6px 0 4px}
#startPrediction{position:sticky;top:12px;z-index:10}
.skai-autotune-status{
  font:400 var(--t-3)/1.4 system-ui;
  color:#4b5563; /* gray-600 */
  margin:4px 0 0 0;
  min-height:1.4em; /* reserve space to avoid layout shift */
}

/* ====================
   4) STACKS & MEDIA
   ==================== */
.skai-stack{display:grid;gap:16px}
.skai-stack--tight{gap:12px}
.skai-stack--loose{gap:24px}

.skai-media{position:relative;overflow:hidden;background:#f6f7f9;border:1px solid var(--panel-border);border-radius:10px}
.skai-media--16x9{aspect-ratio:16/9}
.skai-media--4x3{aspect-ratio:4/3}
.skai-media>img{width:100%;height:100%;object-fit:cover}

/* =========================
   5) CONTROLS (Buttons/Chips)
   ========================= */
.btn{
  display:inline-flex;align-items:center;justify-content:center;gap:.45rem;
  min-height:40px;padding:.55rem .9rem;border-radius:8px;cursor:pointer;
  border:1px solid var(--accent);background:var(--accent);color:#fff;
  font:700 .95rem/1 system-ui;box-shadow:0 2px 8px rgba(30,64,175,.22);
  transition:transform var(--motion-fast),box-shadow var(--motion-medium),filter var(--motion-fast),
             background-color var(--motion-fast),border-color var(--motion-fast),color var(--motion-fast);
  will-change:transform,box-shadow;
}
.btn:hover{filter:brightness(1.02);transform:translateY(-1px)}
.btn:active{transform:translateY(0);filter:brightness(.98)}
.btn:disabled{opacity:.55;cursor:not-allowed}

.btn-outline{
  background:#fff;color:var(--accent);border:1px solid var(--accent);
  display:inline-flex;align-items:center;justify-content:center;gap:.5rem;
  min-height:40px;padding:.55rem .9rem;border-radius:8px;font:700 .95rem/1 system-ui;box-shadow:none;cursor:pointer;
}
.btn-outline:focus-visible{outline:2px solid var(--accent-ring)}

.btn-chip{
  display:inline-flex;align-items:center;justify-content:center;
  padding:.38rem .7rem;min-height:32px;border-radius:999px;cursor:pointer;
  border:1px solid #CBD5E1;background:#F8FAFC;color:var(--ink);font:700 .86rem/1.1 system-ui;
  transition:transform var(--motion-fast),box-shadow var(--motion-medium),filter var(--motion-fast),
             background-color var(--motion-fast),border-color var(--motion-fast),color var(--motion-fast);
  will-change:transform,box-shadow;
}
.btn-chip:hover{background:var(--accent-weak);border-color:var(--accent);color:#1E3A8A}
.btn-chip:active{transform:translateY(0)}
.btn-chip.is-active,
.btn-chip--active,
.btn-chip[aria-pressed="true"]{
  border-color:var(--accent);
  background:var(--accent-weak);
  color:#1E3A8A;
}

.btn-chip:focus-visible{
  outline:2px solid var(--accent);
  outline-offset:2px;
  box-shadow:0 0 0 4px rgba(37,99,235,0.18);
}

#startPrediction.skai-btn--ready,
#btnRunAI.skai-btn--ready,
[data-skai-run].skai-btn--ready{background:var(--good);border-color:var(--good);color:#fff;cursor:pointer}
#startPrediction.skai-btn--ready:hover,
#btnRunAI.skai-btn--ready:hover,
[data-skai-run].skai-btn--ready:hover{transform:translateY(-1px)}

.btn-wrap{display:flex;gap:8px;flex-wrap:wrap}

/* ================
   6) FORMS & RANGE
   ================ */
label{display:block;font-size:12px;color:#374151;margin-bottom:6px;font-weight:600}
input[type=number],input[type=text],select{
  width:100%;box-sizing:border-box;border:1px solid #CBD5E1;border-radius:8px;padding:10px 12px;
  font-size:14px;color:#111;background:#fff;transition:border .15s,box-shadow .15s;font-weight:600;
}
input[type=number]:focus,input[type=text]:focus,select:focus{
  outline:none;border-color:#2563eb;box-shadow:0 0 0 4px rgba(37,99,235,.12);
}
input[readonly]{background:#f9fafb;color:#374151}

.range-row{display:flex;align-items:center;gap:10px}
.range-row input[type=range]{flex:1 1 auto}
.range-row input[type=number]{width:96px;max-width:96px}
.pill{min-width:42px;text-align:center}

.slider-row{display:grid;grid-template-columns:1fr;gap:6px}
#skai-blend-range{width:100%;accent-color:var(--accent)}

.help{font-size:12px;color:#6B7280;margin:4px 0 10px}

/* Hide legacy elements if present */
#presets,#blendMode,.skai-btnbar{display:none!important}
#startPrediction[disabled]{cursor:not-allowed;filter:grayscale(10%)}

/* =======================
   7) TABLES & NUMBER BALLS
   ======================= */
table{width:100%;border-collapse:collapse;font-size:12px}
th,td{border:1px solid var(--panel-border);padding:6px;text-align:center}
th{background:#f9fafb}

.nball,.xball{
  display:inline-flex;align-items:center;justify-content:center;
  width:40px;height:40px;margin:4px;border-radius:50%;line-height:40px;
  font-weight:700;box-sizing:border-box;text-align:center;
}
.nball{background:radial-gradient(circle at 50% 20%,#eee,#bbb 75%,#999 100%);color:#222}
.xball{background:radial-gradient(circle at 50% 20%,#f97f92,#a3071e 75%,#333 100%);color:#fff}
@media (max-width:680px){.nball,.xball{width:32px;height:32px;line-height:32px}}

/* ======================
   8) POPOVERS & TOOLTIPS
   ====================== */
.opt-card{padding:12px}
.opt-title{display:flex;align-items:center;gap:8px;margin:0 0 8px 0;font:700 .96rem/1.2 system-ui;color:var(--ink)}
.opt-hint{font-weight:600;color:#6B7280;margin-left:4px}

.opt-pop .pop[data-open="1"]{display:block}
.opt-pop .pop::before{
  content:"";position:absolute;top:-6px;left:16px;width:10px;height:10px;transform:rotate(45deg);
  background:#fff;border-left:1px solid #e5e7eb;border-top:1px solid #e5e7eb;
}
.pop h5{margin:0 0 6px 0;font-size:13px;font-weight:800;color:#0f172a}
.pop p{margin:0 0 6px 0;color:#374151}
.pop ul{margin:6px 0 0 18px;padding:0}
.pop li{margin:3px 0;color:#374151}

/* ==========================
   9) COLLAPSIBLES & MODAL ETC
   ========================== */
.skai-collapsible{padding:12px}
.carat{color:var(--accent)}
.skai-collapsible-head{display:flex;justify-content:space-between;align-items:center}
#skai-adv-toggle{font-weight:700}
#skai-adv-toggle[aria-expanded="true"] .carat{transform:rotate(0deg)!important}
.skai-collapsible-body .help{margin-top:6px;margin-bottom:12px}

/* === SKAI Details Collapsible (Skip & Hit tables, etc.) === */
.skai-details-collapsible{
  border:1px solid var(--gray-200,#e5e7eb);
  border-radius:8px;
  margin:12px 0;
  background:var(--white,#fff);
}
.skai-details-summary{
  display:flex;
  align-items:center;
  justify-content:space-between;
  cursor:pointer;
  padding:12px 16px;
  background:var(--gray-50,#f9fafb);
  border-radius:8px;
  user-select:none;
  list-style:none;
}
.skai-details-summary::-webkit-details-marker{display:none}
.skai-details-summary::marker{display:none}
.skai-details-summary .skai-h3{margin:0;font-size:1rem;font-weight:600}
.skai-details-caret{
  display:inline-block;
  width:0;height:0;
  border-left:6px solid transparent;
  border-right:6px solid transparent;
  border-top:8px solid var(--accent,#6366f1);
  transition:transform .2s ease;
}
.skai-details-collapsible[open] .skai-details-caret{transform:rotate(180deg)}
.skai-details-content{
  padding:16px;
  border-top:1px solid var(--gray-200,#e5e7eb);
}

/* NOTE:
   Let JS control open/closed state via .skai-collapsed and inline styles.
   We do NOT force all collapsibles open here, and we keep the toggle clickable.
*/

.skai-adv-actions .btn-outline{
  padding:10px 14px;font-weight:700;border:1px solid #cbd5e1;background:#fff;color:#111;border-radius:8px;
}

/* [GRAY-OUT FIX] Remove full-screen dark backdrop; keep modal positioning for content */
.modal{position:fixed;left:0;top:0;width:100%;height:100%;background:transparent;z-index:9999}

/* [GRAY-OUT FIX] Hard-disable any legacy blocking overlays that gray-out the whole UI */
#skaiOverlay,
.skai-overlay,
[data-skai-overlay],
[data-overlay="true"]{
  display:none !important;
  background:transparent !important;
  pointer-events:none !important;
}

.btn[data-busy="true"]{pointer-events:none;position:relative}
.btn[data-busy="true"]::after{
  content:"";display:inline-block;width:1em;height:1em;margin-left:.5em;vertical-align:-0.125em;
  border:.18em solid currentColor;border-top-color:transparent;border-radius:50%;animation:skaiSpin .8s linear infinite;
}

/* ARIA live region */
#skai-live{position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden}

/* =========================
   10) AI CENTRAL & RUN BANNER
   ========================= */
.skai-ai-panel .panel{padding:14px}

.ai-central{
  border:1px solid #e5e7eb;border-radius:12px;background:#fff;
  box-shadow:0 6px 18px rgba(0,0,0,.06);padding:10px 12px;margin:10px 0;
}
.ai-central .aic-head{display:flex;align-items:center;gap:8px;font:700 13px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#0f172a;margin-bottom:6px}
.ai-central .aic-head .dot{width:10px;height:10px;border-radius:50%;background:#94a3b8;box-shadow:0 0 0 2px rgba(148,163,171,.2)}
.ai-central .aic-head .t{font-weight:800}
.ai-central .aic-head .sub{margin-left:auto;opacity:.85;font-weight:600}
.ai-central .aic-stages{list-style:none;padding:0;margin:0;display:flex;flex-direction:column;gap:6px}
.ai-central .ai-stage{
  display:grid;grid-template-columns:18px 1fr auto;gap:8px;align-items:center;
  border:1px solid #e5e7eb;border-radius:8px;padding:6px 8px;background:#fff;
}
.ai-central .ai-stage .b{width:12px;height:12px;border-radius:50%;background:#d1d5db;justify-self:center}
.ai-central .ai-stage .label{font-weight:700;color:#0f172a}
.ai-central .ai-stage .msg{font-weight:600;color:#475569}
/* Active / done states */
.ai-central .ai-stage.is-active{border-color:#93c5fd;box-shadow:0 0 0 3px rgba(147,197,253,.25)}
.ai-central .ai-stage.is-active .b{background:#3b82f6}
.ai-central .ai-stage.is-active .msg{color:#1d4ed8}
.ai-central .ai-stage.is-done{border-color:#86efac;background:#f0fdf4}
.ai-central .ai-stage.is-done .b{background:#22c55e}
.ai-central .ai-stage.is-done .msg{color:#16a34a}


/* Run banner (ID and class support) */
#skai-run-banner{opacity:0;transform:translateY(-4px);transition:opacity .18s ease,transform .18s ease;will-change:opacity,transform}
#skai-run-banner.show{opacity:1;transform:translateY(0)}

.skai-run-banner{
  position:sticky;top:0;z-index:5;margin:6px 0;padding:8px 10px;
  border:1px solid #cfe8ff;border-radius:10px;background:#f1f8ff;
  font:700 12px/1.25 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:#0f172a;
  transform:translateY(-4px);transition:transform .18s ease;
}
.skai-run-banner.show{transform:translateY(0)}
.skai-run-banner[hidden]{display:none}
.skai-run-banner .dot{width:10px;height:10px;border-radius:50%;background:#06b6d4;display:inline-block;margin-right:6px;box-shadow:0 0 0 2px rgba(6,182,212,.15)}
.skai-run-banner .txt{vertical-align:middle;white-space:normal}

/* Progress host */
#skaiProgressHost{
  position:relative;width:100%;min-height:22px;margin:0 0 8px;display:block;
  background:#eef2f7;border:1px solid #dbe4f0;border-radius:8px;padding:6px 8px;
}

/* ==========================
   11) SKIP/HIT TABLE HELPERS
   ========================== */
.skai-skiphit{margin:1rem 0}
.skai-h3{margin:0 0 .5rem;font-size:1.1rem;line-height:1.3}
.skai-table{width:100%;border-collapse:collapse}
.skai-table th,.skai-table td{padding:.5rem .6rem;border-bottom:1px solid #e6e6e6;text-align:left}
.skai-table thead th{font-weight:600;border-bottom:2px solid #ddd}
.skai-empty{margin:.5rem 0;color:#666}

/* Pattern labels (single source of truth) */
.pi-reset{
  font-weight:600;
  border-left:4px solid currentColor;
  padding-left:.4rem;
  background:#FFF9C4; /* highlight Reset rows in a soft yellow */
  color:#111;
  border-radius:2px;
}
.pi-stable{color:#0a7}
.pi-transition{color:#555}
.pi-volatile{color:#c52}

/* Sortable headers (A11Y-friendly suffix) */
.skai-table thead th[data-key]{cursor:pointer;user-select:none}
/* [FIX] Premium, readable sort arrows (no placeholder glyphs). */
.skai-table thead th[aria-sort="ascending"]::after{content:" ↑";font-weight:400}
.skai-table thead th[aria-sort="descending"]::after{content:" ↓";font-weight:400}
/* Visually highlight whichever column the table is currently sorted by */
.skai-table thead th[aria-sort="ascending"],
.skai-table thead th[aria-sort="descending"]{
  background:#FFF9C4; /* soft yellow highlight */
  color:#111;
}

/* =========================
   11.5) SKAI RESULTS PANEL - STABILITY + POLISH
   Fixes:
   - Hyperparameters -jumping- (pins alignment + reserves space)
   - Button consistency (chips + copy button match)
   - Ball pills regain premium weight
   - Save AI block separated as its own calm sub-card
   ========================= */

#skai-ai-results .btn-group,
#skai-ai-panel .btn-group,
#skai-ai-results .results-toolbar,
#skai-ai-panel .results-toolbar{
  display:flex !important;
  flex-wrap:wrap !important;
  justify-content:flex-start !important; /* stop right/center jitter */
  align-items:center !important;
  gap:8px !important;
  margin:6px 0 10px 0 !important;
}

/* Unified button system for Top 10/15/20 + Copy SKAI picks */
#skai-ai-results .btn-group .btn-chip,
#skai-ai-panel .btn-group .btn-chip,
#skai-ai-results .btn-group .btn-outline.btn,
#skai-ai-panel .btn-group .btn-outline.btn{
  appearance:none;
  border:1.5px solid rgba(0,0,0,0.18);
  background:#fff;
  color:var(--ink);
  height:36px;
  padding:0 12px;
  border-radius:999px;
  font-weight:700;
  font-size:0.9rem;
  line-height:1;
  letter-spacing:0.01em;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  box-shadow:0 1px 0 rgba(0,0,0,0.03);
  transition:background .15s ease,border-color .15s ease,transform .05s ease;
}

#skai-ai-results .btn-group .btn-chip[aria-pressed="true"],
#skai-ai-panel .btn-group .btn-chip[aria-pressed="true"]{
  background:rgba(17,24,39,0.06);
  border-color:rgba(17,24,39,0.35);
}

#skai-ai-results .btn-group .btn-chip:hover,
#skai-ai-panel .btn-group .btn-chip:hover,
#skai-ai-results .btn-group .btn-outline.btn:hover,
#skai-ai-panel .btn-group .btn-outline.btn:hover{
  background:rgba(0,0,0,0.03);
}

#skai-ai-results .btn-group .btn-chip:active,
#skai-ai-panel .btn-group .btn-chip:active,
#skai-ai-results .btn-group .btn-outline.btn:active,
#skai-ai-panel .btn-group .btn-outline.btn:active{
  transform:translateY(1px);
}

/* Hyperparameters block: lock to left, full width, calm rhythm */
#skai-param-status{
  display:block !important;
  width:100% !important;
  text-align:left !important;
  margin-top:12px !important;
  padding-top:10px !important;
  border-top:1px solid rgba(0,0,0,0.08) !important;
}

#skai-param-status .results-section-head{
  font-weight:800 !important;
  font-size:0.95rem !important;
  letter-spacing:0.01em !important;
  margin:0 0 6px 0 !important;
  color:var(--ink) !important;
  text-align:left !important;
}

/* Reserve a little space so it doesn-t -snap- during render */
#skai-param-status-body{
  min-height:22px;              /* prevents vertical twitch */
  display:block;
  font-size:0.9rem;
  line-height:1.45;
  color:var(--muted);
  text-align:left !important;
  white-space:normal !important;
  word-break:break-word !important;
}


/* =========================================================
   11.9) RESULTS PANEL POLISH - buttons, balls, save-card
   (Non-breaking overrides; safe to remove later)
   ========================================================= */

/* Toolbar buttons - single source of truth
   ---------------------------------------------
   We already style Top 10/15/20 + Copy picks
   inside the scoped toolbar at Section 11.5:

   #skai-ai-results .btn-group .btn-chip
   #skai-ai-results .btn-group .btn-outline.btn

   Removing global duplicates prevents:
   - cross-panel mismatches
   - flicker between two style systems
   - unintended theme bleed elsewhere
   --------------------------------------------- */

/* (intentionally left blank - scoped toolbar styles apply) */


/* --- 3) Restore main / extra ball look (no thin ring) --- */

.xball{
  /* keep your red or gradient if defined earlier; just ensure no ring */
  border:none !important;
}

/* --- 4) Save AI prediction = distinct calm sub-card (single source of truth) --- */
.skai-save-card,
.skai-save.skai-save--ai,
.skai-save--ai,
#aiSaveCard{
  margin-top:14px;
  padding:14px 14px 12px;
  max-width:520px; /* reads as a secondary action panel */
  background:rgba(248,250,252,0.9);
  border:1px solid rgba(0,0,0,0.08);
  border-radius:12px;
  box-shadow:0 1px 0 rgba(0,0,0,.03);
}

.skai-save-card h4,
.skai-save--ai h4,
#aiSaveCard h4,
.skai-save.skai-save--ai .skai-h3{
  margin:0 0 6px 0;
  font-size:1.02rem;
  font-weight:800;
  letter-spacing:0.01em;
}

.skai-save-card .muted,
.skai-save--ai .muted,
#aiSaveCard .muted,
.skai-save.skai-save--ai .help{
  margin:0 0 10px 0;
  color:var(--muted);
  font-size:0.9rem;
}

/* Optional: make the save button feel like a real CTA */
.skai-save-card button,
.skai-save--ai button,
#aiSaveCard button,
.skai-save-card input[type="submit"],
.skai-save--ai input[type="submit"],
#aiSaveCard input[type="submit"]{
  border-radius:10px;
  padding:.55rem .9rem;
  font-weight:700;
}

/* =========================
   12) EVIDENCE / WHY CARD UI
   ========================= */

/* Evidence / Why panel - visible, premium, WCAG-friendly */
.skai-why-card{
  display:none; /* Temporarily hidden per product decision */
  margin-top:14px;
  border:1px solid rgba(0,0,0,0.10);
  border-radius:12px;
  background:#fff;
  box-shadow:0 2px 10px rgba(0,0,0,0.05);
}
.skai-why-card details{padding:10px 12px}
.skai-why-card summary{
  cursor:pointer;
  font-weight:650;
  list-style:none;
  letter-spacing:0.01em;
  line-height:1.25;
}
.skai-why-card summary::-webkit-details-marker{display:none}

/* rows */
.skai-why-card .row{
  display:flex;
  align-items:flex-start;
  gap:12px;
  padding:8px 0;
  border-top:1px solid rgba(0,0,0,0.06);
}
.skai-why-card .row:first-of-type{border-top:none}

/* number chip */
.skai-why-card .chip{
  min-width:30px;
  height:30px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border-radius:999px;
  border:1px solid rgba(0,0,0,0.14);
  font-weight:700;
  font-size:0.95rem;
  background:#f7f8fa;
  color:#111;
}

/* bullets */
.skai-why-card ul{
  margin:0;
  padding-left:18px;
}
.skai-why-card li{
  margin:0.15rem 0;
  font-size:0.95rem;
  line-height:1.45;
  color:#1a1a1a;
}

/* -------------------------------------------------
   SKAI -Why This Pick?- - premium evidence layout
   (Used inside tooltips / evidence card)
   ------------------------------------------------- */
.skai-why-head{
  display:flex;
  align-items:baseline;
  justify-content:space-between;
  gap:8px;
  padding:2px 0 8px;
  border-bottom:1px solid rgba(0,0,0,.06);
  margin-bottom:8px;
}

.skai-why-title{
  font-weight:700;
  font-size:0.95rem;
  color:var(--ink);
  letter-spacing:0.01em;
}

.skai-why-ball{
  font-weight:700;
  font-size:1.02rem;
  color:var(--ink);
  background:rgba(0,0,0,.04);
  border:1px solid rgba(0,0,0,.06);
  border-radius:999px;
  padding:2px 8px;
  line-height:1.2;
}

.skai-why-dl{
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:8px 12px;
  margin:0 0 8px;
  font-size:0.9rem;
}

.skai-why-dl dt{
  font-weight:600;
  color:var(--muted);
  margin:0;
  line-height:1.35;
}

.skai-why-dl dd{
  margin:2px 0 0;
  font-weight:700;
  color:var(--ink);
}

.skai-why-block{
  padding:8px 10px;
  border:1px solid rgba(0,0,0,.06);
  border-radius:10px;
  background:rgba(255,255,255,0.9);
  margin-top:8px;
}

.skai-why-kicker{
  font-size:0.78rem;
  font-weight:700;
  letter-spacing:0.04em;
  text-transform:uppercase;
  color:var(--muted);
  margin-bottom:4px;
}

.skai-why-body{
  font-size:0.92rem;
  line-height:1.45;
  color:var(--ink);
}

.skai-why-list{
  margin:0;
  padding-left:16px;
  font-size:0.92rem;
  line-height:1.45;
  color:var(--ink);
}

.skai-why-list li{
  margin:2px 0;
}

/* Keep the note calm and low-contrast but readable */
.skai-why-note{
  margin:10px 0 0;
  font-size:0.86rem;
  line-height:1.45;
  color:var(--muted);
}

/* Why column helpers */
.skai-col-why{width:1%;white-space:nowrap}
.skai-why-btn{padding:.3rem .55rem;border:1px solid #ccc;border-radius:6px;background:#fff;cursor:pointer}
.skai-why-btn:focus{outline:2px solid #000;outline-offset:2px}
.skai-why-pop{
  position:absolute;z-index:9999;min-width:220px;max-width:320px;background:#fff;
  border:1px solid #ddd;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.12);padding:.6rem .7rem;
}
.skai-why-pop h4{margin:.1rem 0 .35rem;font-size:.95rem}
.skai-why-pop p{margin:.15rem 0;font-size:.9rem;line-height:1.35}
.skai-why-pop .skai-x{float:right;border:0;background:transparent;font-size:1rem;cursor:pointer}

/* =========================
   13) RESULTS - LOADING + READY STATES
   Premium CLS-safe handoff
   ========================= */

/* Reserve space and keep alignment stable in all phases */
.skai-results--loading{
  min-height:96px;            /* slightly taller to match real content height */
  display:flex;
  align-items:center;
  justify-content:center;
  padding:10px 0;
}

/* Loading shell reads like a calm -system card- */
.skai-loading-shell{
  width:100%;
  max-width:520px;
  border:1px solid rgba(0,0,0,.08);
  border-radius:12px;
  padding:12px 14px;
  background:rgba(248,250,252,0.9);
  text-align:left;
  box-shadow:0 1px 0 rgba(0,0,0,.02);
}

/* Title/sub copy with Apple-clean rhythm */
.skai-loading-title{
  font-weight:800;
  font-size:1rem;
  color:var(--ink);
  margin:0 0 4px 0;
  letter-spacing:0.01em;
}

.skai-loading-sub{
  font-size:0.92rem;
  color:var(--muted);
  margin:0;
  line-height:1.45;
}

/* Subtle shimmer bar (optional, no motion jank) */
.skai-loading-bar{
  margin-top:8px;
  height:6px;
  border-radius:999px;
  background:rgba(0,0,0,.06);
  overflow:hidden;
  position:relative;
}
.skai-loading-bar::after{
  content:"";
  position:absolute;
  inset:0;
  transform:translateX(-65%);
  background:linear-gradient(90deg,
    rgba(255,255,255,0) 0%,
    rgba(255,255,255,0.7) 50%,
    rgba(255,255,255,0) 100%);
  animation:skaiShimmer 1.6s ease-in-out infinite;
}
@keyframes skaiShimmer{
  0%{ transform:translateX(-65%); }
  100%{ transform:translateX(65%); }
}

/* Ready state class: keeps panel height steady and fades in */
.skai-results--ready{
  animation:skaiReadyFade .18s ease-out;
}
@keyframes skaiReadyFade{
  from{ opacity:0.6; transform:translateY(1px); }
  to{ opacity:1; transform:none; }
}

/* Guarded: keep class but REMOVE any dimming / blocking
   Reason: this class was lowering opacity & saturation and could dim whole UI if
   applied to a parent. We preserve the state hook without visual gray-out. */
.skai-save--inactive{
  opacity:1 !important;
  filter:none !important;
  pointer-events:auto !important;
}

.skai-save--inactive .skai-save-card,
.skai-save--inactive .save-card,
.skai-save--inactive [data-skai-save-card]{
  background:rgba(248,250,252,0.9) !important;
  border-color:rgba(0,0,0,.08) !important;
}

/* When ready, restore full presence */
.skai-save--active{
  opacity:1;
  filter:none;
  pointer-events:auto;
}

/* =========================
   13) SKAI RESULTS PANEL - PREMIUM UI POLISH
   Apple/Stripe-level hierarchy, rhythm, contrast
   ========================= */

#skai-ai-results,
.skai-ai-results{
  margin-top:16px;
}

/* Panel / card container */
.skai-results-panel{
  background:#fff;
  border:1px solid rgba(0,0,0,.08);
  border-radius:16px; /* softer, more premium */
  box-shadow:
    0 1px 2px rgba(0,0,0,.035),
    0 10px 28px rgba(0,0,0,.055);
  padding:16px 16px 14px; /* calmer breathing room */
  overflow:hidden;
}

/* Header rhythm */
.skai-results-header{
  display:flex;
  align-items:flex-start;
  justify-content:space-between;
  gap:10px;
  padding:2px 2px 8px;               /* slightly tighter */
  border-bottom:1px solid rgba(0,0,0,.05);
  margin-bottom:12px;                /* more separation from body */
}

.skai-results-title{
  font-size:1.08rem;
  font-weight:800;
  letter-spacing:0.01em;
  color:var(--ink);
  line-height:1.25;
  margin:0;
}

.skai-results-sub{
  font-size:0.92rem;
  color:var(--muted);
  margin:4px 0 0 0;                  /* cleaner optical spacing */
  line-height:1.45;
}

/* Main + Extra layout - calmer rhythm, premium spacing */
.skai-results-body{
  display:grid;
  grid-template-columns:1fr;
  gap:14px;                 /* slightly more air between sections */
  margin-top:6px;
}

/* Sub-panels for main/extra - clearer hierarchy */
.skai-results-section{
  border:1px solid rgba(0,0,0,.07);
  border-radius:12px;
  padding:12px 12px 10px;   /* more comfortable internal rhythm */
  background:rgba(255,255,255,0.98);
  box-shadow:0 1px 0 rgba(0,0,0,.02);
}

/* Section header row */
.skai-results-section-head{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:10px;
  padding-bottom:6px;
  border-bottom:1px solid rgba(0,0,0,.05);
}

.skai-results-section-title{
  font-weight:800;
  font-size:0.96rem;
  color:var(--ink);
  letter-spacing:0.01em;
}

/* Optional subtext (if present) */
.skai-results-section-sub{
  font-size:0.88rem;
  color:var(--muted);
  line-height:1.4;
}

/* Ball row layout - consistent wrapping + spacing */
.skai-results-balls,
.skai-ai-main,
#aiPredictedNumbers{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
  align-items:center;
  padding:4px 0 2px;
}

/* Extra balls row should read as a sibling, not a continuation */
.skai-results-section--extra{
  background:rgba(248,250,252,0.85);
  border-color:rgba(0,0,0,.06);
}

/* Give extra row a subtle -label rhythm- if it uses a heading */
.skai-results-section--extra .skai-results-section-title{
  font-weight:800;
}

/* Summary line inside sections (if used) */
.skai-results-summary{
  margin-top:8px;
  font-size:0.9rem;
  line-height:1.45;
  color:var(--muted);
}

/* Chips row */
.skai-results-chips{
  display:flex;
  flex-wrap:wrap;
  gap:8px;
}

/* Main balls */
.skai-results-chips .nball,
.skai-ai-main .nball{
  min-width:36px;
  height:36px;
  padding:0 10px;
  border-radius:999px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:800;
  font-size:1rem;
  letter-spacing:0.01em;
  color:#0b0b0c;
  background: linear-gradient(180deg, #ffffff 0%, #f6f7f9 100%);
  border:1px solid rgba(0,0,0,.12);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.7),
    0 1px 2px rgba(0,0,0,.06);
}

/* Extra balls */
.skai-results-chips .xball,
.skai-ai-extra .xball{
  min-width:36px;
  height:36px;
  padding:0 10px;
  border-radius:999px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  font-weight:800;
  font-size:1rem;
  letter-spacing:0.01em;
  color:#111;
  background: linear-gradient(180deg, #fff7e8 0%, #ffe6b8 100%);
  border:1px solid rgba(160,110,0,.35);
  box-shadow:
    inset 0 0 0 1px rgba(255,255,255,.7),
    0 1px 2px rgba(0,0,0,.06);
}

/* Divider within results */
.skai-results-divider{
  height:1px;
  background:rgba(0,0,0,.06);
  margin:8px 0;
}

/* Confidence / hyperparameter meta row - layout-stable, no jitter */
.skai-results-meta{
  display:flex;
  flex-wrap:wrap;
  gap:10px 14px;
  margin-top:6px;
  font-size:0.9rem;
  color:var(--muted);

  /* Stability: keep all items anchored left */
  justify-content:flex-start;
  align-items:flex-start;
  text-align:left;

  /* Reserve space so live updates don-t shift alignment */
  min-height:1.4em;
}

.skai-results-meta > *{
  /* Prevent flex auto-stretching that causes center/right hops */
  flex:0 0 auto;
  max-width:100%;
}

.skai-results-meta strong{
  color:var(--ink);
  font-weight:700;
}

/* CTA row below results */
.skai-results-cta{
  display:flex;
  align-items:center;
  justify-content:flex-end;
  gap:8px;
  padding-top:10px;
  margin-top:10px;
  border-top:1px solid rgba(0,0,0,.06);
}

.skai-results-cta .skai-btn{
  appearance:none;
  border:1px solid rgba(0,0,0,.12);
  background:#fff;
  border-radius:10px;
  padding:8px 12px;
  font-weight:700;
  font-size:0.95rem;
  color:var(--ink);
  cursor:pointer;
  transition:transform .08s ease, box-shadow .12s ease, border-color .12s ease;
  box-shadow:0 1px 2px rgba(0,0,0,.06);
}

.skai-results-cta .skai-btn:hover{
  transform:translateY(-1px);
  box-shadow:0 4px 12px rgba(0,0,0,.10);
  border-color:rgba(0,0,0,.18);
}

.skai-results-cta .skai-btn:focus{
  outline:2px solid #000;
  outline-offset:2px;
}

/* Empty / waiting state */
.skai-results-empty{
  padding:12px;
  font-size:0.95rem;
  color:var(--muted);
  background:rgba(0,0,0,.02);
  border:1px dashed rgba(0,0,0,.12);
  border-radius:10px;
}

/* Responsive refinement */
@media (min-width: 768px){
  .skai-results-body{
    grid-template-columns: 1.2fr .8fr;
    gap:12px;
  }
}

@media (max-width: 420px){
  .skai-results-panel{
    padding:12px 10px 10px;
    border-radius:12px;
  }
  .skai-results-chips .nball,
  .skai-results-chips .xball{
    min-width:32px;
    height:32px;
    font-size:0.95rem;
  }
}

/* ==========================
   13.5) INSIGHTS & PROGRESS BADGE
   ========================== */

#skai-insights{
  border:1px solid var(--skai-brd,#e3e7ef);background:var(--skai-bg,#ffffff);border-radius:8px;
  padding:12px;margin-top:12px;box-shadow:0 1px 2px rgba(0,0,0,0.04);
}
#skai-insights .skai-insights__hdr{font-weight:600;font-size:14px;line-height:1.2;margin:0 0 8px 0;color:var(--skai-hdr,#0b1736)}
#skai-insights .skai-insights__bar{position:relative;height:6px;border-radius:999px;background:var(--skai-bar-bg,#e8edf6);overflow:hidden;margin:6px 0 10px 0}
#skai-insights .skai-insights__bar>i{display:block;height:100%;width:var(--w,0%);background:var(--skai-bar-fill,#3b82f6);border-radius:inherit}
#skai-insights .skai-insights__body{font-size:13px;line-height:1.45;color:var(--skai-txt,#1d2330)}
#skai-insights .skai-insights__why,
#skai-insights .skai-insights__conf,
#skai-insights .skai-insights__picks{margin:4px 0}
#skai-insights .skai-insights__chips{margin-top:6px;display:flex;flex-wrap:wrap;gap:6px}
#skai-insights .skai-chip{
  font-size:12px;line-height:1;padding:5px 8px;border-radius:999px;
  background:var(--skai-chip-bg,#eef2fb);color:var(--skai-chip-txt,#0b1736);border:1px solid var(--skai-chip-brd,#dde3f3);
}
#skai-insights .skai-unc{opacity:.75}

/* High-contrast & dark mode for insights */
@media (prefers-color-scheme:dark){
  #skai-insights{
    --skai-bg:#111418; --skai-brd:#222833; --skai-hdr:#dbe6ff; --skai-txt:#cfd7e6;
    --skai-chip-bg:#1a2130; --skai-chip-txt:#dbe6ff; --skai-chip-brd:#2a3346;
    box-shadow:none;
  }
}
@media (prefers-contrast:more){
  .skai-panel,.panel,.tile{box-shadow:none;border-color:#B8BCC2}
  .btn{box-shadow:none}
}

/* Progress badge (generic) */
.skai-progress-badge{
  display:inline-block;padding:.2rem .55rem;border-radius:999px;
  font:600 12px/1.2 system-ui,-apple-system,"Segoe UI",Roboto,Arial,"Noto Sans","Helvetica Neue",sans-serif;
  background:#eef2ff;border:1px solid rgba(0,0,0,.08);color:#1f2937;position:relative;
}
.skai-progress-badge .skai-progress-track{
  display:block;width:100%;height:4px;border-radius:999px;margin-top:2px;background:rgba(31,41,55,.12);
}
.skai-progress-badge .skai-progress-fill{
  display:block;height:100%;width:0%;border-radius:999px;background:#4f46e5;
}

/* =======================
   14) CONFIDENCE GAUGE FIX
   ======================= */
.skai-conf-wrap{min-height:140px;height:140px}
#skaiConfGauge,#skai-confidence-gauge{width:100%;height:100%;display:block}

/* ===========================
   15) MICRO-INTERACTIONS & FX
   =========================== */
.tile{transition:transform var(--motion-fast),box-shadow var(--motion-medium)}
.tile:hover{transform:translateY(-2px);box-shadow:var(--elev-raise)}
#skaiProgress{will-change:width}
@keyframes skaiSpin{to{transform:rotate(360deg)}}

/* ==========================
   16) ACCESSIBILITY & MOTION
   ========================== */
:focus-visible{outline:2px solid var(--accent-ring);outline-offset:2px}
.visually-hidden,.skai-visually-hidden{
  position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0;
}
@media (prefers-reduced-motion:reduce){
  *,#skai-insights,#skai-insights *{transition:none!important;animation:none!important}
  .tile,.btn,.btn-chip{transition:none!important;transform:none!important}
}

/* --- Minimal, accessible chips styling (Sorcerer-safe) --- */
.skai-combo-why{margin-top:.25rem;display:flex;flex-wrap:wrap;gap:.25rem}
.skai-chip{padding:0 .5rem;border:1px solid #d0d7de;border-radius:999px;font:600 12px/1.8 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:rgba(0,0,0,.04)}
@media (prefers-contrast: more){.skai-chip{background:#fff;border-color:#000}}

/* SKAI Pulse Orb */
.skai-progress-orb{
  display:flex;
  align-items:center;
  gap:10px;

  /* NEW: soft glow-green background behind the orb + text */
  padding:10px 14px;
  border-radius:999px; /* pill-shaped bar */
  background:rgba(5,150,105,0.08); /* very soft emerald tint */
  border:1px solid rgba(5,150,105,0.28); /* subtle outline for contrast */
}

.skai-progress-orb__circle{
  width:26px;
  height:26px;
  border-radius:50%;

  /* UPDATED: make the orb circle bolder and glowing */
  border:3px solid rgba(5,150,105,0.98); /* thicker emerald ring */
  background:radial-gradient(circle at 30% 30%, #ecfdf5 0%, #ffffff 40%, #d1fae5 100%);
  box-shadow:
    0 0 0 2px rgba(5,150,105,0.25),      /* subtle outer halo */
    0 0 10px rgba(5,150,105,0.45);       /* soft glow to make it pop */

  position:relative;
  overflow:hidden;
}

.skai-progress-orb__circle::before{
  content:"";
  position:absolute;
  inset:3px;
  border-radius:50%;

  /* UPDATED: stronger, clearer pulse ring */
  border:3px solid rgba(5,150,105,0.85);
  background:radial-gradient(circle, rgba(16,185,129,0.25) 0%, transparent 60%);
  opacity:1;

  animation:skai-pulse 1.2s ease-in-out infinite;
}

@keyframes skai-pulse{
  0%   { transform:scale(0.9); opacity:0.4; }
  50%  { transform:scale(1);   opacity:1;   }
  100% { transform:scale(0.9); opacity:0.4; }
}

  .skai-progress-orb__status{
   margin:0;              /* align nicely inside the pill */
   font-size:0.95rem;

   /* NEW: deep green text for WCAG-friendly contrast */
   color:#064e3b; /* dark emerald */
 }

 /* Global floating SKAI status banner (site-wide, just under the main header) */
 #skai-global-status-wrapper{
   position:fixed;
   left:50%;
   /* Uses CSS variable so you can tune it without editing this file.
      Example override (in template or custom.css):
        :root{ --skai-header-offset: 104px; } */
   top:calc(env(safe-area-inset-top, 0px) + var(--skai-header-offset, 96px));
   transform:translateX(-50%);
   z-index:9999;
   pointer-events:none; /* clicks pass through unless on the pill itself */
 }

 #skai-global-status{
   /* display:none;  - QUARANTINED (redundant; overridden by display:flex below)
      Evidence: this block also sets display:flex later, so none never applies.
      Keeping commented for audit trail; JS visibility control should be handled elsewhere. */
   pointer-events:auto;
   min-width:260px;
   max-width:640px;
   padding:8px 16px;
   border-radius:999px;
   background:rgba(15,23,42,0.96); /* deep slate, Apple/Stripe style */
   color:#e5e7eb;
   font:500 13px/1.4 system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif;
   box-shadow:0 16px 40px rgba(15,23,42,0.45);
   display:flex;
   align-items:center;
   gap:8px;
 }

 #skai-global-status .skai-global-status-dot{
   width:8px;
   height:8px;
   border-radius:50%;
   background:#22c55e; /* emerald */
   box-shadow:0 0 0 2px rgba(34,197,94,0.50);
 }

 /* Two-line layout: main line + smaller detail line */
 #skai-global-status-text{
   display:flex;
   flex-direction:column;
   line-height:1.3;
   white-space:nowrap;
   overflow:hidden;
   text-overflow:ellipsis;
 }

 #skai-global-status-text .skai-global-status-main{
   font-weight:600;
   white-space:nowrap;
   overflow:hidden;
   text-overflow:ellipsis;
 }

 #skai-global-status-text .skai-global-status-sub{
   font-size:12px;
   opacity:0.85;
   white-space:nowrap;
   overflow:hidden;
   text-overflow:ellipsis;
 }

 @media (max-width:768px){
   #skai-global-status{
     max-width:92vw;
     font-size:12px;
     padding:8px 12px;
   }
 }

 .skai-tech-details{
   margin-top:12px;
 }

.skai-tech-summary{
  cursor:pointer;
  font-size:0.85rem;
  color:#555;
  padding:4px 0;
}

.skai-tech-summary:hover{
  text-decoration:underline;
}

.skai-backtest-subline{
  margin:4px 0 8px 0;
  font-size:0.9rem;
  color:#555;
}

.skai-backtest-label{
  font-size:0.78rem;
  color:#4b5563;
  text-transform:uppercase;
  letter-spacing:0.08em;
  margin:0 0 2px 0;
}

.skai-bt-summary-comparison{
  margin-top:10px;
  padding-top:6px;
  border-top:1px solid #e5e7eb;
}

.skai-bt-subheading{
  margin:0 0 4px 0;
  font-size:0.8rem;
  text-transform:uppercase;
  letter-spacing:0.08em;
  color:#4b5563;
}

.skai-bt-mini th,
.skai-bt-mini td{
  font-size:0.78rem;
  padding:4px 6px;
}


/* Hide the floating Pattern Intelligence badge that was appearing above the site header */
#skaiPIBadge{
  display:none !important;
}

.skai-bt table thead th{
  background:#f1f1f1;
  color:#222;
}

.skai-divider{
  margin:8px 0;
  border-bottom:none; /* remove faint rule line above SKAI sections */
}

.skai-section{
  margin:24px 0;
}

.skai-card{
  background:#ffffff;
  border-radius:8px;
  box-shadow:0 1px 3px rgba(0,0,0,0.06);
  padding:16px 20px;
}

.skai-card--hero{
  margin-bottom:16px;
}

.skai-hero-subline{
  margin:4px 0 12px 0;
  font-size:0.95rem;
  color:#555;
}

/* .skai-hero-lottery - QUARANTINED duplicate.
   Evidence: same selector redefined later in this chunk with margin:4px 0 0.
   Keeping later definition as source of truth. */
/*
.skai-hero-lottery{
  font:500 14px/1.5 system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color:#111827;
  margin:2px 0 0;
}
*/

.skai-hero-chips{
  display:flex;
  flex-wrap:wrap;
  gap:6px;
  margin:0;
  padding:0;
  list-style:none;
}

.skai-hero-chip{
  font-size:0.85rem;
  padding:4px 8px;
  border-radius:999px;
  border:1px solid #e0e0e0;
  background:#fafafa;
}

.skai-advanced{
  margin:24px 0 16px 0;
}

.skai-advanced .skai-h2{
  margin:0 0 4px 0;
  font-size:1.2rem;
  font-weight:600;
}

.skai-advanced-subline{
  margin:0 0 12px 0;
  font-size:0.95rem;
  color:#555;
}

.skai-hero-lottery{
  font:500 14px/1.5 system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color:#111827;
  margin:4px 0 0;
}

#skai-confidence-explainer {
  display: none !important;
  visibility: hidden !important;
}
 
/* Running mode collapse ENABLED (per SKAI request).
   When .skai-is-running is active, hide everything except #skai-engine-shell
   so the SKAI Cockpit (single progress bar + run log) is the primary focus. */
#skai-ui-root.skai-is-running > *:not(#skai-engine-shell){
  display: none !important; /* FIX: valid value + !important */
}

    #skai-engine-shell{
      position: relative;
      margin-bottom: 16px;
    }

    /* Sticky header with 0-100 bar + status line */
    #skai-run-header{
      display: none; /* shown only while a run is active */
      position: sticky;
      top: 0;
      z-index: 998;
      padding: 10px 16px;
      background: #020617;
      color: #f9fafb;
      border-radius: 10px;
      box-shadow: 0 10px 30px rgba(15,23,42,0.45);
      border: 1px solid rgba(148,163,184,0.5);
    }
    #skai-run-header-main{max-width: 1080px;margin: 0 auto;}
    #skai-run-title{
      font-size: 12px;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.85);
      margin-bottom: 4px;
    }
    #skai-run-status{
      font-size: 14px;
      line-height: 1.4;
    }
    .skai-run-progress-outer{
      margin-top: 8px;
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(148,163,184,0.35);
      overflow: hidden;
    }
    #skai-run-progress-inner{
      width: 0;
      height: 100%;
      border-radius: 999px;
      background: linear-gradient(90deg,#0ea5e9,#facc15);
      transition: width .25s ease;
    }

    /* Console-style log area */
    #skai-run-console{
      max-width: 1080px;
      margin: 10px auto 0 auto;
      border-radius: 10px;
      border: 1px solid rgba(148,163,184,0.35);
      background: #020617;
      padding: 8px 10px 10px;
    }
    #skai-run-console-header{
      font-size: 12px;
      font-weight: 600;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: rgba(226,232,240,0.9);
      margin-bottom: 4px;
    }
    #skai-run-console-body{
      margin: 0;
      padding: 8px 10px;
      font-family: Menlo,Consolas,"SF Mono",monospace;
      font-size: 11px;
      line-height: 1.5;
      color: #e5e7eb;
      background: rgba(15,23,42,0.96);
      border-radius: 8px;
      max-height: 220px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

/* Force SKAI Advanced panel to start collapsed by default */
#skai-advanced.skai-collapsed .skai-collapsible-body,
#skai-advanced.skai-collapsed [data-skai-body]{
  display:none !important;
}

/* Arrow state when collapsed */
#skai-advanced.skai-collapsed #skai-adv-toggle .carat{
  transform:rotate(-90deg) !important;
}

.skai-button-disabled {
  opacity: 0.55;
  cursor: not-allowed;
}
  /* Hide SKAI debug/status UI globally (top bar + telemetry details) */
  #skai-global-status,
  #skai-tech-details,
  #skai-state-chip {
    display: none !important;
  }

/* ========================================================
   Progress Indicator: Lightweight traffic light milestones
   ======================================================== */
.skai-progress-indicator {
  margin: 16px 0;
  padding: 16px;
  background: #f8f9fa;
  border: 1px solid rgba(0,0,0,0.08);
  border-radius: 8px;
}

.skai-progress-title {
  font-size: 0.9rem;
  font-weight: 600;
  color: #334155;
  margin-bottom: 12px;
  text-align: center;
}

.skai-progress-steps {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 8px;
  max-width: 600px;
  margin: 0 auto;
}

.skai-progress-step {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
}

.skai-progress-light {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 2px solid transparent;
  transition: all 0.3s ease;
}

.skai-progress-light--pending {
  background: #cbd5e1;
  border-color: #94a3b8;
}

.skai-progress-light--active {
  background: #fbbf24;
  border-color: #f59e0b;
  box-shadow: 0 0 8px rgba(251,191,36,0.5);
  animation: pulse-light 1.5s ease-in-out infinite;
}

.skai-progress-light--completed {
  background: #22c55e;
  border-color: #16a34a;
}

@keyframes pulse-light {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.skai-progress-label {
  font-size: 0.75rem;
  color: #64748b;
  text-align: center;
  line-height: 1.2;
  font-weight: 500;
}

.skai-progress-step[data-active="true"] .skai-progress-label {
  color: #1e293b;
  font-weight: 600;
}

#skai-progress-details {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid rgba(0,0,0,0.06);
}

#skai-progress-computation {
  font-size: 0.95rem;
  font-weight: 600;
  color: #1e293b;
  margin-bottom: 6px;
  min-height: 22px;
}

#skai-progress-eta {
  font-size: 0.85rem;
  font-weight: 500;
  color: #64748b;
  min-height: 20px;
}

/* Consolidated progress card header */
.skai-progress-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
}

.skai-progress-header .skai-progress-title {
  margin-bottom: 0;
  text-align: left;
}

#skai-autotune-badge-consolidated {
  font-size: 0.75rem;
  padding: 4px 10px;
  border-radius: 12px;
  background: #e0f2fe;
  color: #0369a1;
  border: 1px solid #7dd3fc;
}

#skai-autotune-badge-consolidated[data-state="running"] {
  background: #fef3c7;
  color: #92400e;
  border-color: #fbbf24;
}

#skai-autotune-badge-consolidated[data-state="complete"] {
  background: #dcfce7;
  color: #166534;
  border-color: #86efac;
}

/* Status messages in consolidated card */
.skai-progress-status {
  margin-bottom: 16px;
  padding: 12px;
  background: #ffffff;
  border-radius: 6px;
  border: 1px solid rgba(0,0,0,0.05);
}

.skai-progress-stage-msg {
  font-size: 0.95rem;
  font-weight: 600;
  color: #1e293b;
  margin-bottom: 4px;
}

.skai-progress-sub-msg {
  font-size: 0.85rem;
  color: #64748b;
}

/* Auto-tune results section */
.skai-progress-autotune-results {
  margin-top: 16px;
  padding-top: 12px;
  border-top: 1px solid rgba(0,0,0,0.06);
}

.skai-progress-autotune-title {
  font-size: 0.85rem;
  font-weight: 600;
  color: #334155;
  margin-bottom: 8px;
}

#skai-progress-autotune-content {
  font-size: 0.8rem;
  color: #475569;
  line-height: 1.6;
}

#skai-progress-autotune-content strong {
  color: #1e293b;
  font-weight: 600;
}

/* Hide duplicate Main Numbers AI Run progress bar (info shown in unified progress card) */
#skaiProgressMain {
  display: none !important;
}

/* Math Console Styles */
.skai-math-console {
  margin-top: 16px;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  background: #f9fafb;
  overflow: hidden;
}

.skai-math-console-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  background: #1e293b;
  color: #fff;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  user-select: none;
}

.skai-math-console-title {
  display: flex;
  align-items: center;
  gap: 8px;
}

.skai-math-console-title::before {
  content: "⚡";
  font-size: 1rem;
}

.skai-math-console-toggle {
  background: transparent;
  border: none;
  color: #fff;
  font-size: 0.9rem;
  cursor: pointer;
  padding: 4px;
  line-height: 1;
  transition: transform 0.2s;
}

.skai-math-console-toggle.collapsed {
  transform: rotate(-90deg);
}

.skai-math-console-body {
  max-height: 300px;
  overflow-y: auto;
  transition: max-height 0.3s ease;
}

.skai-math-console-body.collapsed {
  max-height: 0;
  overflow: hidden;
}

.skai-math-console-content {
  padding: 12px 14px;
  font-family: 'Courier New', Consolas, Monaco, monospace;
  font-size: 0.75rem;
  line-height: 1.5;
  color: #1e293b;
  background: #fff;
  border-top: 1px solid #e5e7eb;
}

.skai-math-line {
  padding: 2px 0;
  white-space: pre-wrap;
  word-break: break-word;
}

.skai-math-line.autotune {
  color: #0891b2;
}

.skai-math-line.training {
  color: #7c3aed;
}

.skai-math-line.prediction {
  color: #059669;
}

.skai-math-line.complete {
  color: #dc2626;
  font-weight: 600;
}

.skai-math-line strong {
  font-weight: 700;
}


.skai-freshness{
  margin-top: 10px;
  display: inline-block;
  font-size: 0.95rem;
  font-weight: 650;
  padding: 8px 12px;
  border-radius: 12px;
  background: rgba(20, 80, 255, 0.08);
  border: 1px solid rgba(20, 80, 255, 0.18);
}

.skai-micro-explainer{
  margin-top: 10px;
  max-width: 74ch;
  font-size: 1.0rem;
  line-height: 1.45;
  opacity: 0.92;
}

/* =========================================================
   SKAI Daily Decision Panel (Pick 3 / Pick 4)
   ========================================================= */
.skai-daily-panel{
  background: linear-gradient(180deg, #EFEFF5 0%, #FFFFFF 100%);
  border: 1px solid rgba(10,26,51,0.08);
  border-radius: 14px;
  margin-top: 12px;
  overflow: hidden;
  box-shadow: 0 10px 26px rgba(10,26,51,0.10);
}

.skai-daily-panel-head{
  background: linear-gradient(135deg, #0A1A33 0%, #1C66FF 100%);
  padding: 14px 16px;
  color: #FFFFFF;
}

.skai-daily-title{
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 0.2px;
}

.skai-daily-sub{
  margin-top: 2px;
  font-size: 12px;
  opacity: 0.92;
}

.skai-daily-grid{
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  padding: 12px;
}

.skai-daily-card{
  flex: 1 1 280px;
  background: #FFFFFF;
  border: 1px solid rgba(10,26,51,0.08);
  border-radius: 12px;
  padding: 12px;
}

.skai-daily-card-h{
  font-size: 13px;
  font-weight: 700;
  color: #0A1A33;
  margin-bottom: 10px;
}

.skai-daily-foot{
  margin-top: 10px;
  font-size: 12px;
  color: #7F8DAA;
  line-height: 1.45;
}

.skai-daily-ladder-row{
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 6px 0;
}

.skai-daily-digit{
  width: 34px;
  height: 34px;
  border-radius: 999px;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  background: #0A1A33;
  color: #FFFFFF;
  font-weight: 800;
  font-size: 13px;
}

.skai-daily-bar{
  flex: 1;
  height: 10px;
  border-radius: 999px;
  background: rgba(10,26,51,0.10);
  overflow: hidden;
}

.skai-daily-bar > span{
  display: block;
  height: 100%;
  width: 0%;
  background: #1C66FF;
}

.skai-daily-pct{
  width: 52px;
  text-align: right;
  font-size: 12px;
  color: #0A1A33;
  font-weight: 700;
}

.skai-daily-combos{
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.skai-daily-combo{
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  padding: 10px 10px;
  border-radius: 10px;
  border: 1px solid rgba(10,26,51,0.08);
  background: #FFFFFF;
}

.skai-daily-combo-left{
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
}

.skai-daily-tag{
  font-size: 11px;
  font-weight: 700;
  color: #0A1A33;
  background: rgba(32,201,151,0.14);
  border: 1px solid rgba(32,201,151,0.25);
  padding: 4px 8px;
  border-radius: 999px;
}

.skai-daily-combo-digits{
  font-size: 14px;
  font-weight: 800;
  letter-spacing: 1px;
  color: #0A1A33;
}

.skai-daily-combo-score{
  font-size: 12px;
  color: #7F8DAA;
  font-weight: 700;
}

.skai-daily-rationale{
  border-top: 1px solid rgba(10,26,51,0.08);
  padding: 12px 16px 14px 16px;
  background: #FFFFFF;
}

.skai-daily-why{
  margin: 8px 0 0 18px;
  color: #0A1A33;
  font-size: 12.5px;
  line-height: 1.5;
}

</style>



<!-- SKAI: Act 1 - Tuned SKAI story (status + proof + patterns) -->
<!-- Removed redundant "Today's SKAI analysis for" header section -->

<div class="skai-divider"></div>

<section class="skai-section skai-section--insights" id="skai-insights-section" aria-label="Today&rsquo;s SKAI insights" style="display:none">
  <!-- Hidden by default; revealed after SKAI Auto-Tune + ML prediction complete -->
  <div class="skai-card skai-card--hero">
    <h2 class="skai-h2">What SKAI found today</h2>
    <p class="skai-hero-subline">
      SKAI analyzed your recent draw history, auto-tuned its settings, and ranked numbers by how often they hit, how much pressure is building, and how their behavior is shifting.
    </p>
    <ul class="skai-hero-chips">
      <li class="skai-hero-chip">Reads number behavior: stable vs. volatile</li>
      <li class="skai-hero-chip">Highlights numbers with strong recent signals</li>
      <li class="skai-hero-chip">Shows why certain picks move to the top</li>
    </ul>
  </div>

  <!-- SKAI: Pattern Intelligence Summary (Act 1 bridge) -->
  <div class="skai-card skai-pi" role="region" aria-label="Pattern Intelligence">
    <h3 class="skai-h3">Pattern Intelligence</h3>

    <!-- Plain-language legend so users know what these words mean -->
    <p class="skai-pi-legend">
      <strong>How SKAI reads the board:</strong>
      <strong>Stable</strong> numbers show up at a steady rhythm and act like anchors.
      <strong>Volatile</strong> numbers move in bursts — they can heat up quickly, then cool off.
      <strong>Reset</strong> numbers just hit after a long quiet stretch and often pause.
      <strong>Transition</strong> numbers are changing behavior; SKAI watches these for the next move.
    </p>

    <div class="skai-pi-grid">
      <!-- MAIN BALLS -->
      <div class="skai-pi-card">
        <h4 class="skai-pi-title">Main numbers</h4>

        <?php
          $mCounts     = $piMain['counts'] ?? ['stable'=>0,'volatile'=>0,'reset'=>0,'transition'=>0];
          $mStable     = (int)($mCounts['stable'] ?? 0);
          $mVolatile   = (int)($mCounts['volatile'] ?? 0);
          $mReset      = (int)($mCounts['reset'] ?? 0);
          $mTransition = (int)($mCounts['transition'] ?? 0);
          $mTotal      = max(1, $mStable + $mVolatile + $mReset + $mTransition);

          // Simple “mood” line for the main field
          $mainMood = 'Patterns are fairly balanced across the main board.';
          if ($mVolatile > $mTransition && $mVolatile >= $mStable) {
            $mainMood = 'The main board is running hot and streaky — volatile numbers are doing most of the talking.';
          } elseif ($mTransition >= $mVolatile && $mTransition >= $mStable) {
            $mainMood = 'Many main numbers are in a transition phase — behavior is shifting and SKAI expects changes.';
          } elseif ($mStable >= $mVolatile && $mStable >= $mTransition) {
            $mainMood = 'The main board is relatively steady — more numbers are behaving like reliable anchors.';
          }

          // “How to use this board” guidance for main numbers
          $mainTip = 'A common approach is to start with 1–2 stable anchor numbers and then layer in a few hot or transitioning picks.';
          if ($mStable && !$mVolatile && !$mTransition) {
            $mainTip = 'Tonight looks calm on the main board. Many players would lean more on stable anchors and use your wheeling system to spread around them.';
          } elseif ($mVolatile > $mStable && $mVolatile >= $mTransition) {
            $mainTip = 'Because volatility is high, some players like to keep 1–2 stable anchors and give extra room in their wheels to a small set of hot, volatile numbers.';
          } elseif ($mTransition > $mStable && $mTransition > $mVolatile) {
            $mainTip = 'With many numbers in transition, it can help to mix anchors with a handful of numbers in motion that SKAI flags as shifting.';
          }
        ?>

        <p class="skai-pi-counts">
          Stable: <strong><?php echo $mStable; ?></strong> ·
          Volatile: <strong><?php echo $mVolatile; ?></strong> ·
          Reset: <strong><?php echo $mReset; ?></strong> ·
          Transition: <strong><?php echo $mTransition; ?></strong>
        </p>
        <p class="skai-pi-mood"><?php echo htmlspecialchars($mainMood, ENT_QUOTES, 'UTF-8'); ?></p>
        <p class="skai-pi-tip"><?php echo htmlspecialchars($mainTip, ENT_QUOTES, 'UTF-8'); ?></p>

        <?php if (!empty($piMain['top'])): ?>
          <p class="skai-pi-ex">Main numbers SKAI is watching most closely:</p>
          <ul class="skai-pi-list">
            <?php foreach (['stable','volatile','reset','transition'] as $k):
              $arr = $piMain['top'][$k] ?? [];
              if (!$arr) continue;

              // Only show a few per line so it’s readable
              $arr = array_slice($arr, 0, 4);

              $labelNice = ucfirst($k);
              $prefix = '';
              if ($k === 'stable') {
                $prefix = 'Steady anchors that keep showing up: ';
              } elseif ($k === 'volatile') {
                $prefix = 'Numbers that tend to hit in bursts when they wake up: ';
              } elseif ($k === 'reset') {
                $prefix = 'Recently hit after a long wait — they may cool for a bit: ';
              } elseif ($k === 'transition') {
                $prefix = 'Numbers whose behavior is shifting — SKAI is watching these: ';
              }

              // Turn each entry into “61 (around 9.2% of recent draws)”
              $parts = array_map(function($x){
                $lab = $x['label'] ?? (string)($x['n'] ?? '');
                if ($lab === '') return '';
                if (isset($x['prob'])) {
                  $pt  = round(100 * (float)$x['prob'], 1);
                  return $lab . ' (around ' . $pt . '% of recent draws)';
                }
                return $lab;
              }, $arr);
              $parts = array_filter($parts);
              if (!$parts) continue;
            ?>
              <li>
                <em><?php echo htmlspecialchars($labelNice, ENT_QUOTES, 'UTF-8'); ?>.</em>
                <?php echo htmlspecialchars($prefix, ENT_QUOTES, 'UTF-8'); ?>
                <?php echo htmlspecialchars(implode('; ', $parts), ENT_QUOTES, 'UTF-8'); ?>.
              </li>
            <?php endforeach; ?>
          </ul>
        <?php endif; ?>
      </div>

      <!-- EXTRA BALLS (if present) -->
      <?php if (!empty($piExtra)): ?>
      <div class="skai-pi-card">
        <h4 class="skai-pi-title">Extra / bonus</h4>

        <?php
          $eCounts     = $piExtra['counts'] ?? ['stable'=>0,'volatile'=>0,'reset'=>0,'transition'=>0];
          $eStable     = (int)($eCounts['stable'] ?? 0);
          $eVolatile   = (int)($eCounts['volatile'] ?? 0);
          $eReset      = (int)($eCounts['reset'] ?? 0);
          $eTransition = (int)($eCounts['transition'] ?? 0);
          $eTotal      = max(1, $eStable + $eVolatile + $eReset + $eTransition);

          $extraMood = 'Bonus numbers are fairly balanced today.';
          if ($eVolatile > $eTransition && $eVolatile >= $eStable) {
            $extraMood = 'Bonus numbers are behaving aggressively — more of them are in a hot, volatile phase.';
          } elseif ($eTransition >= $eVolatile && $eTransition >= $eStable) {
            $extraMood = 'Bonus numbers are in a transition phase — SKAI expects shifts in which ones are active.';
          } elseif ($eStable >= $eVolatile && $eStable >= $eTransition) {
            $extraMood = 'Bonus numbers are relatively steady; there are clear anchor candidates here too.';
          }

          $extraTip = 'Many players like to pick one strong bonus anchor and then rotate around a small set of hot or transitioning bonus numbers.';
          if ($eStable && !$eVolatile && !$eTransition) {
            $extraTip = 'With mostly stable bonus numbers, you can confidently choose an anchor and let your wheeling system do the spreading.';
          } elseif ($eVolatile > $eStable && $eVolatile >= $eTransition) {
            $extraTip = 'Because volatility is high in the bonus field, consider giving a bit more space to the hot bonus picks SKAI is flagging.';
          } elseif ($eTransition > $eStable && $eTransition > $eVolatile) {
            $extraTip = 'With many bonus numbers in transition, it can help to mix one anchor with a rotating cast of numbers in motion.';
          }
        ?>

        <p class="skai-pi-counts">
          Stable: <strong><?php echo $eStable; ?></strong> ·
          Volatile: <strong><?php echo $eVolatile; ?></strong> ·
          Reset: <strong><?php echo $eReset; ?></strong> ·
          Transition: <strong><?php echo $eTransition; ?></strong>
        </p>
        <p class="skai-pi-mood"><?php echo htmlspecialchars($extraMood, ENT_QUOTES, 'UTF-8'); ?></p>
        <p class="skai-pi-tip"><?php echo htmlspecialchars($extraTip, ENT_QUOTES, 'UTF-8'); ?></p>

        <?php if (!empty($piExtra['top'])): ?>
          <p class="skai-pi-ex">Bonus numbers SKAI is watching:</p>
          <ul class="skai-pi-list">
            <?php foreach (['stable','volatile','reset','transition'] as $k):
              $arr = $piExtra['top'][$k] ?? [];
              if (!$arr) continue;

              $arr = array_slice($arr, 0, 4);

              $labelNice = ucfirst($k);
              $prefix = '';
              if ($k === 'stable') {
                $prefix = 'Steady bonus anchors: ';
              } elseif ($k === 'volatile') {
                $prefix = 'Hot / streaky bonus picks: ';
              } elseif ($k === 'reset') {
                $prefix = 'Recently hit after a quiet stretch: ';
              } elseif ($k === 'transition') {
                $prefix = 'Bonus numbers in motion (watch for moves): ';
              }

              $parts = array_map(function($x){
                $lab = $x['label'] ?? (string)($x['n'] ?? '');
                if ($lab === '') return '';
                if (isset($x['prob'])) {
                  $pt  = round(100 * (float)$x['prob'], 1);
                  return $lab . ' (around ' . $pt . '% of recent draws)';
                }
                return $lab;
              }, $arr);
              $parts = array_filter($parts);
              if (!$parts) continue;
            ?>
              <li>
                <em><?php echo htmlspecialchars($labelNice, ENT_QUOTES, 'UTF-8'); ?>.</em>
                <?php echo htmlspecialchars($prefix, ENT_QUOTES, 'UTF-8'); ?>
                <?php echo htmlspecialchars(implode('; ', $parts), ENT_QUOTES, 'UTF-8'); ?>.
              </li>
            <?php endforeach; ?>
          </ul>
        <?php endif; ?>
      </div>
      <?php endif; ?>
    </div>

    <!-- Advice / narrative from SKAI -->
    <div class="skai-pi-adv" role="note" aria-live="polite">
      <p class="skai-pi-head">
        <strong><?php echo htmlspecialchars($adv['headline'] ?? 'Tonight\'s pattern at a glance', ENT_QUOTES, 'UTF-8'); ?></strong>
      </p>
      <?php if (!empty($adv['advice'])): ?>
        <ul class="skai-pi-list">
          <?php foreach (($adv['advice'] ?? []) as $tip): ?>
            <li><?php echo htmlspecialchars($tip, ENT_QUOTES, 'UTF-8'); ?></li>
          <?php endforeach; ?>
        </ul>
      <?php endif; ?>
      <?php if (!empty($adv['rationale'])): ?>
        <p class="skai-pi-r">
          <?php echo htmlspecialchars(implode(' ', $adv['rationale']), ENT_QUOTES, 'UTF-8'); ?>
        </p>
      <?php endif; ?>
    </div>
  </div>
</section>

<div class="skai-divider"></div>

<?php if ($skaiUsable): ?>
<section class="skai-advanced" role="region" aria-label="Advanced Analysis - Skip &amp; Hit">
  <h2 class="skai-h2">Advanced Analysis – Skip &amp; Hit</h2>
  <p class="skai-advanced-subline">
    These tables help you understand <strong>number behavior</strong> in a simple, consistent way:
    how often a number has hit, how long it has been skipping, what phase it appears to be in,
    and SKAI&rsquo;s estimated chance it will hit on the next draw.
  </p>

  <p class="skai-advanced-subline skai-advanced-subline--note">
    <strong>Chance to hit next</strong> is the plain-English name for <strong>P(hit|k)</strong> — an estimate based on what happened historically when a number reached the same skip value.
    The <strong>Pattern</strong> label (Reset / Transition / Volatile) is a behavioral summary, not a promise.
  </p>

  <!-- Education: Pattern labels explained (this renders inside the Advanced Analysis section) -->
  <details class="skai-help" aria-labelledby="help-patterns-title">
    <summary id="help-patterns-title" class="skai-help-summary">
      What do the Pattern labels mean (Reset, Transition, Volatile)?
    </summary>

    <div class="skai-help-body">
      <p>
        SKAI assigns each number a <strong>pattern label</strong> by comparing its <em>current skip</em>
        (how many draws it has missed since it last appeared) to its own historical rhythm.
        These labels do <strong>not</strong> predict outcomes — they describe what the number is doing <em>right now</em>.
      </p>

      <h4>Reset</h4>
      <p>
        <strong>Reset</strong> means the number appeared in the most recent draw, so its skip is now <strong>0</strong>.
      </p>
      <p>
        <em>How to interpret it:</em> This simply identifies numbers coming off a hit.
        Some numbers cluster, others pause — the label is descriptive, not a signal to chase.
      </p>

      <h4>Transition</h4>
      <p>
        <strong>Transition</strong> is the middle zone: the number is neither freshly hit nor unusually overdue.
        It is behaving within a typical range, but could move toward either Reset (hits) or Volatile (longer skip).
      </p>
      <p>
        <em>How to interpret it:</em> Use this as a “watch” label — rely more on the probability column and your preferences.
      </p>

      <h4>Volatile</h4>
      <p>
        <strong>Volatile</strong> means the number is skipping <em>longer than usual</em> compared to its own historical gap between hits.
        It is in a more uneven phase (streaky behavior).
      </p>
      <p>
        <em>How SKAI detects this:</em> the current skip is meaningfully above the number&rsquo;s typical (median) gap.
      </p>
      <p>
        <em>How to interpret it:</em> Volatile does <strong>not</strong> mean “due.”
        It means the number is outside its normal rhythm — sometimes it resolves soon, sometimes it extends.
      </p>

      <p>
        <strong>Best practice:</strong> Read <strong>Pattern</strong> together with <strong>Chance to hit next (P(hit|k))</strong>.
        Pattern describes behavior; probability estimates likelihood.
      </p>
    </div>
  </details>


  <!-- CANONICAL Main Skip & Hit block (collapsible, collapsed by default) -->
  <details class="skai-skiphit skai-skiphit--main skai-details-collapsible" aria-label="Skip &amp; Hit - Main Balls">
    <summary class="skai-details-summary">
      <h3 class="skai-h3">Skip &amp; Hit - Main Balls</h3>
      <span class="skai-details-caret" aria-hidden="true"></span>
    </summary>
    <div class="skai-details-content">
      <p class="skai-reset-note">
        <strong>-Reset- (yellow)</strong> means that number just hit in the latest draw, so its skip counter has gone back to 0.
      </p>

      <?php if (!empty($mainSkipHitRows)): ?>
      <table class="skai-table skai-sortable" role="table" aria-live="polite">
        <caption class="skai-visually-hidden">Skip and Hit metrics for main balls</caption>
        <thead>
          <tr>
            <th scope="col" data-key="label"   aria-sort="none">Ball</th>
            <th scope="col" data-key="skip"    aria-sort="none">Skip</th>
            <th scope="col" data-key="hits"    aria-sort="none">Hits</th>
            <th scope="col" data-key="pattern" aria-sort="none">Pattern</th>
            <th scope="col" data-key="prob" aria-sort="descending"
                title="Chance this number will hit in the next draw, based on how long it has been skipping.">
              Chance to hit next (P(hit|k))
            </th>
            <th scope="col" data-key="support" aria-sort="none">Support</th>
            <th scope="col"
                data-key="cooc"
                aria-sort="none"
                title="How often this ball has appeared in the same draw as SKAI&rsquo;s stronger numbers over the last <?php echo (int)$coK; ?> draws.">
              Partner hits (<?php echo (int)$coK; ?>)
            </th>
          </tr>
        </thead>
        <tbody>
          <?php foreach ($mainSkipHitRows as $row): ?>
            <tr>
              <td><?php echo htmlspecialchars($row['label'], ENT_QUOTES, 'UTF-8'); ?></td>
              <td><?php echo (int)$row['skip']; ?></td>
              <td><?php echo (int)$row['hits']; ?></td>

              <td
                class="<?php echo htmlspecialchars($row['pattern_class'] ?? ('pi-' . strtolower((string)($row['pattern'] ?? 'transition'))), ENT_QUOTES, 'UTF-8'); ?>"
                title="<?php echo htmlspecialchars($row['title'] ?? '', ENT_QUOTES, 'UTF-8'); ?>"
                aria-label="<?php echo htmlspecialchars($row['aria_label'] ?? ($row['title'] ?? ''), ENT_QUOTES, 'UTF-8'); ?>">
                <?php echo htmlspecialchars($row['pattern'] ?? 'Transition', ENT_QUOTES, 'UTF-8'); ?>
              </td>

              <td><?php echo htmlspecialchars($row['prob_t'], ENT_QUOTES, 'UTF-8'); ?></td>
              <td><?php echo (int)$row['hitk']; ?>/<?php echo (int)$row['sup']; ?></td>
              <td><?php echo isset($row['cooc']) ? (int)$row['cooc'] : 0; ?></td>
            </tr>
          <?php endforeach; ?>
        </tbody>
      </table>
      <?php else: ?>
        <p class="skai-empty" role="note">No main-ball data available.</p>
      <?php endif; ?>
    </div>
  </details>

<?php if (!empty($hasExtra)): ?>
  <div class="skai-skiphit skai-skiphit--extra" role="region" aria-label="Skip &amp; Hit - Extra Balls">
  <?php /* keep this block OPEN; the closing </div> and corresponding endif; appear after the Extra table below */ ?>

    <!-- SKAI: Auto-Tune Results consolidated into SKAI Analysis Progress card -->

    <!-- SKAI Pulse Orb moved to SKAI Hybrid Intelligence panel -->

    <?php if (!empty($skaiAutoTune) && !empty($skaiAutoTune['best'])): ?>
      <?php
        $autoBest    = $skaiAutoTune['best'];
        $autoCands   = $skaiAutoTune['candidates'] ?? [];
        $autoW       = isset($autoBest['windows'])   ? (int) $autoBest['windows']   : 0;
        $autoK       = isset($autoBest['laplace_k']) ? (int) $autoBest['laplace_k'] : 0;
        $autoAvg     = isset($autoBest['avg_score']) ? (float) $autoBest['avg_score'] : 0.0;
        $autoHitRate = isset($autoBest['hit_rate'])  ? (float) $autoBest['hit_rate']  : 0.0;

        // Estimate how many configurations were evaluated.
        // This mirrors the ranges already used by skai_autotuneRollingBacktest.
        $autoConfigsTested = 0;
        if (!empty($KsArr)) {
          $autoSpan = max(0, (int) floor(($winMax - $winMin) / max(1, $winStep)) + 1);
          $autoConfigsTested = $autoSpan * count($KsArr);
        } else {
          // Fallback: use visible candidates count if KsArr is not available.
          $autoConfigsTested = count($autoCands);
        }
      ?> 
      <div class="skai-bt skai-bt--autotune-summary" role="note" aria-label="SKAI Auto-Tune Results" style="display:none;margin-bottom:12px">
        <div class="skai-bt-summary skai-bt-summary--hero">
          <div class="skai-bt-summary-main">
		  <p class="skai-bt-kv">
        <strong>SKAI Optimization Complete</strong><br>
        <?php if ($autoConfigsTested > 0): ?>
          SKAI quietly tested <?php echo (int) $autoConfigsTested; ?> different history + smoothing setups to find the most reliable pattern for today.
        <?php else: ?>
          SKAI quietly tested multiple history + smoothing setups to find the most reliable pattern for today.
        <?php endif; ?>
           </p>
<p class="skai-bt-kv">
  <strong>What SKAI chose:</strong><br>
  - History window: <?php echo $autoW; ?> draws<br>
  - Smoothing level (K value): <?php echo $autoK; ?>
</p>
<p class="skai-bt-kv">
  <strong>How this setting performed:</strong><br>
  - Average backtest score: <?php echo number_format($autoAvg, 2); ?><br>
  - Hit at least one main ball: <?php echo number_format($autoHitRate * 100.0, 1); ?>%
</p>
          </div>
        </div>
      </div>
      <!-- Store auto-tune data for JS to display in consolidated progress card -->
      <script>
      window.__SKAI_AUTOTUNE_DATA__ = {
        configsTested: <?php echo (int) $autoConfigsTested; ?>,
        window: <?php echo $autoW; ?>,
        kValue: <?php echo $autoK; ?>,
        avgScore: <?php echo number_format($autoAvg, 2); ?>,
        hitRate: <?php echo number_format($autoHitRate * 100.0, 1); ?>
      };
      </script>
    <?php endif; ?>

    <div class="skai-divider"></div>

<?php /*
<!-- SKAI: Rolling Backtest (SKAI Performance) - hidden here; canonical backtest lives in Act 1 -->
<div class="skai-bt" role="region" aria-label="SKAI Backtest Performance">
	  <p class="skai-backtest-label">How SKAI Skip &amp; Hit compares to random 20-number wheels (historical)</p>
	  <h3 class="skai-h3">SKAI Skip &amp; Hit Backtest - Proof of Performance</h3>
	  <p class="skai-backtest-subline">
	    These results reflect how the Skip &amp; Hit core of SKAI performed on past draws using the same Skip &amp; Hit settings you used for your prediction today. The window W shown below is the auto-tuned history depth selected for this lottery, and it can be different for each game.
	  </p>

	  <?php if (!empty($skaiBacktest)): ?>
		<?php
      $btWindows = (int)($skaiBacktest['windows'] ?? 0);
      $btK       = isset($skaiBacktest['laplace_k']) ? (int)$skaiBacktest['laplace_k'] : null;
      $btAvg     = (float)($skaiBacktest['avg_score'] ?? 0.0);
      $btHit1    = (float)($skaiBacktest['hit_rate_main_ge1'] ?? 0.0);
      $btMeanM   = (float)($skaiBacktest['mean_main_matches'] ?? 0.0);
      $btMeanX   = (float)($skaiBacktest['mean_extra_matches'] ?? 0.0);
      $btPick    = (int)($skaiBacktest['pick_size'] ?? 0);
      $btHasExtra= !empty($skaiBacktest['has_extra']);

      $wMain = isset($skaiBacktest['weights']['main_hit']) ? (int)$skaiBacktest['weights']['main_hit'] : 0;
      $wExtra= isset($skaiBacktest['weights']['extra_hit']) ? (int)$skaiBacktest['weights']['extra_hit'] : 0;

      // Baseline: how a simple random wheel (same pick size) would behave on this game (theoretical).
      $randMeanMain    = null;
      $randHit1        = null;
      $randLiftHit1    = null;

      // Monte Carlo baseline: simulate random wheels on the same backtest draws.
      $mcRandMeanMain  = null;
      $mcRandHit1      = null;
      $mcRandLiftHit1  = null;
      $mcTrials        = 256; // number of random wheels per draw for simulation

      if (isset($mainMax) && $mainMax > 0 && $btPick > 0) {
          // Estimate how many main balls are drawn in this lottery (e.g. 5 for Powerball).
          $drawMainCount = 0;
          if (!empty($mainDraws)) {
              $sample = reset($mainDraws);
              if (is_array($sample)) {
                  $drawMainCount = count($sample);
              } else {
                  $parts = preg_split('/[^\d]+/', (string) $sample, -1, PREG_SPLIT_NO_EMPTY);
                  $drawMainCount = count($parts);
              }
          }

          if ($drawMainCount > 0) {
              // Expected main matches for random picks:
              //   E[intersection size] = P * D / N
              //   P = pick size (your SKAI wheel size)
              //   D = main balls drawn in the game
              //   N = main domain (e.g. 69 for Powerball)
              $randMeanMain = ($btPick * $drawMainCount) / $mainMax;

              // Probability of hitting at least 1 main ball with random picks.
              // Exact without-replacement model:
              //   P(no hit) = ∏_{j=0}^{D-1} (N - P - j) / (N - j)
              //   P(hit >= 1) = 1 - P(no hit)
              $N = $mainMax;
              $P = min($btPick, $N);
              $D = min($drawMainCount, $N);

              $noHit = 1.0;
              for ($j = 0; $j < $D; $j++) {
                  $num = max(0.0, $N - $P - $j);
                  $den = max(1.0, $N - $j);
                  $noHit *= ($den > 0.0) ? ($num / $den) : 1.0;
              }

              $randHit1 = 1.0 - $noHit;

              // Lift against random (theoretical baseline).
              if ($randHit1 > 0.0) {
                  $randLiftHit1 = $btHit1 / $randHit1;
              }

              // Monte Carlo simulation over the same backtest draws.
              if (!empty($skaiBacktest['series'])) {
                  $series        = $skaiBacktest['series'];
                  $domain        = range(1, $mainMax);
                  $sumMatches    = 0;
                  $sumHit1       = 0;
                  $validDraws    = 0;

                  foreach ($series as $row) {
                      if (empty($row['actual_main']) || !is_array($row['actual_main'])) {
                          continue;
                      }
                      $validDraws++;
                  }

                  if ($validDraws > 0) {
                      for ($t = 0; $t < $mcTrials; $t++) {
                          foreach ($series as $row) {
                              if (empty($row['actual_main']) || !is_array($row['actual_main'])) {
                                  continue;
                              }
                              $actual = array_map('intval', $row['actual_main']);
                              if (!$actual) {
                                  continue;
                              }

                              // Draw P distinct random numbers from the domain for this trial/draw.
                              $pickKeys = (array) array_rand($domain, min($btPick, count($domain)));
                              $randPick = [];
                              foreach ($pickKeys as $k) {
                                  $randPick[] = $domain[$k];
                              }

                              $matches = count(array_intersect($randPick, $actual));
                              $sumMatches += $matches;
                              if ($matches > 0) {
                                  $sumHit1++;
                              }
                          }
                      }

                      $totalSim       = max(1, $validDraws * $mcTrials);
                      $mcRandMeanMain = $sumMatches / $totalSim;
                      $mcRandHit1     = $sumHit1 / $totalSim;

                      if ($mcRandHit1 > 0.0) {
                          $mcRandLiftHit1 = $btHit1 / $mcRandHit1;
                      }
                  }
              }
          }
      }

      // Compact random baseline values for UI tiles (prefer Monte Carlo when available).
      $randMeanForUi = ($mcRandMeanMain !== null) ? $mcRandMeanMain : $randMeanMain;
      $randHitForUi  = ($mcRandHit1   !== null) ? $mcRandHit1   : $randHit1;
      $haveRandomUi  = ($randMeanForUi !== null && $randHitForUi !== null);

    ?>

    <!-- Premium summary panel -->
    <div class="skai-bt-summary skai-bt-summary--hero" role="note" aria-live="polite">
      <div class="skai-bt-summary-main">
        <p class="skai-bt-kv">
          <strong>Window (history depth):</strong>
          W=<?php echo $btWindows; ?>
          <?php if ($btK !== null): ?>
            &nbsp;&middot;&nbsp;<strong>Laplace K:</strong> <?php echo $btK; ?>
          <?php endif; ?>
        </p>
        <p class="skai-bt-kv">
          <strong>Historical performance score:</strong>
          <?php echo number_format($btAvg, 2); ?>
          (main - <?php echo $wMain; ?><?php if ($btHasExtra): ?>, extra - <?php echo $wExtra; ?><?php endif; ?>)
        </p>
        <p class="skai-bt-kv">
          <strong>At least 1 main hit:</strong>
          <?php echo number_format($btHit1 * 100.0, 1); ?>%
        </p>
      </div>

       <div class="skai-bt-summary-metrics">
         <div class="skai-bt-metric">
           <span class="skai-bt-label">Mean main matches</span>
           <span class="skai-bt-value"><?php echo number_format($btMeanM, 2); ?></span>
         </div>
         <?php if ($btHasExtra): ?>
           <div class="skai-bt-metric">
             <span class="skai-bt-label">Mean extra matches</span>
             <span class="skai-bt-value"><?php echo number_format($btMeanX, 2); ?></span>
           </div>
         <?php endif; ?>
         <div class="skai-bt-metric">
           <span class="skai-bt-label">Pick size</span>
           <span class="skai-bt-value"><?php echo $btPick; ?></span>
         </div>
       </div>

       <?php if ($haveRandomUi): ?>
         <div class="skai-bt-summary-comparison" role="group" aria-label="Random versus Skip &amp; Hit averages">
           <h4 class="skai-bt-subheading">Random vs Skip &amp; Hit (per draw)</h4>
           <table class="skai-table skai-bt-mini">
             <thead>
               <tr>
                 <th scope="col">Metric</th>
                 <th scope="col">Random</th>
                 <th scope="col">Skip &amp; Hit</th>
               </tr>
             </thead>
             <tbody>
               <tr>
                 <td>Mean main matches</td>
                 <td><?php echo number_format($randMeanForUi, 2); ?></td>
                 <td><?php echo number_format($btMeanM, 2); ?></td>
               </tr>
               <tr>
                 <td>At least 1 main hit</td>
                 <td><?php echo number_format($randHitForUi * 100.0, 1); ?>%</td>
                 <td><?php echo number_format($btHit1 * 100.0, 1); ?>%</td>
               </tr>
             </tbody>
           </table>
         </div>
       <?php endif; ?>

       <p class="skai-bt-note">
         These stats show how the Skip &amp; Hit core of SKAI performed when it replayed your history on past draws using the current Skip &amp; Hit settings.
         <?php if ($randMeanMain !== null && $randHit1 !== null): ?>
           By calculation, picking <?php echo (int) $btPick; ?> numbers completely at random for each draw
           would typically average about <?php echo number_format($randMeanMain, 2); ?> main hits and
           hit at least one main ball about <?php echo number_format($randHit1 * 100.0, 1); ?>% of the time.
         <?php endif; ?>
         <?php if ($mcRandMeanMain !== null && $mcRandHit1 !== null): ?>
           In a Monte Carlo simulation with <?php echo (int) $mcTrials; ?> random wheels per draw over the same history,
           pure random picks actually averaged about <?php echo number_format($mcRandMeanMain, 2); ?> main hits and
           hit at least one main ball about <?php echo number_format($mcRandHit1 * 100.0, 1); ?>% of the time.
         <?php endif; ?>
         On that same history, this Skip &amp; Hit setup averaged <?php echo number_format($btMeanM, 2); ?> main hits and
         hit at least one main ball <?php echo number_format($btHit1 * 100.0, 1); ?>% of the time
         across the same draws<?php
           $liftToUse = $mcRandLiftHit1 !== null ? $mcRandLiftHit1 : $randLiftHit1;
           if ($liftToUse !== null): ?>, roughly
           <?php echo number_format($liftToUse, 1); ?>x the hit at least 1 main rate of pure random picks<?php endif; ?>.
         This backtest currently evaluates the Skip &amp; Hit core only; it does not yet include the additional machine learning layer SKAI uses for live predictions. Backtest results are not a guarantee for future draws; they are a statistical comparison that shows how much better this tuned Skip &amp; Hit configuration has performed than simple random wheels on your past data. Random baselines are computed from standard lottery probability formulas plus Monte Carlo simulations that anyone can reproduce.
       </p>
    </div>

    <?php
      // Last 10 draws: SKAI pick vs actual results (proof of performance)
      $btSeries = $skaiBacktest['series'] ?? [];
      $btTail   = array_slice($btSeries, -10);
    ?>
    <?php if (!empty($btTail)): ?>
      <table class="skai-table skai-bt-table" role="table" aria-describedby="bt-caption">
        <caption id="bt-caption" class="skai-visually-hidden">
          Last 10 draws: SKAI picks versus actual results
        </caption>
        <thead>
          <tr>
            <th scope="col">Draw #</th>
            <th scope="col">SKAI picked (main)</th>
            <?php if ($btHasExtra): ?>
              <th scope="col">SKAI picked (extra)</th>
            <?php endif; ?>
            <th scope="col">Actual draw (main)</th>
            <?php if ($btHasExtra): ?>
              <th scope="col">Actual draw (extra)</th>
            <?php endif; ?>
            <th scope="col">Main matches</th>
            <?php if ($btHasExtra): ?>
              <th scope="col">Extra matches</th>
            <?php endif; ?>
            <th scope="col">Score</th>
          </tr>
        </thead>
        <tbody>
          <?php foreach ($btTail as $row): ?>
            <?php
              $pickedMain  = implode(', ', array_map('strval', $row['picked_main']  ?? []));
              $pickedExtra = implode(', ', array_map('strval', $row['picked_extra'] ?? []));
              $actualMain  = implode(', ', array_map('strval', $row['actual_main']  ?? []));
              $actualExtra = implode(', ', array_map('strval', $row['actual_extra'] ?? []));
            ?>
            <tr>
              <td><?php echo (int)($row['index'] ?? 0); ?></td>
              <td><?php echo htmlspecialchars($pickedMain, ENT_QUOTES, 'UTF-8'); ?></td>
              <?php if ($btHasExtra): ?>
                <td><?php echo htmlspecialchars($pickedExtra, ENT_QUOTES, 'UTF-8'); ?></td>
              <?php endif; ?>
              <td><?php echo htmlspecialchars($actualMain, ENT_QUOTES, 'UTF-8'); ?></td>
              <?php if ($btHasExtra): ?>
                <td><?php echo htmlspecialchars($actualExtra, ENT_QUOTES, 'UTF-8'); ?></td>
              <?php endif; ?>
              <td><?php echo (int)($row['main_matches']  ?? 0); ?></td>
              <?php if ($btHasExtra): ?>
                <td><?php echo (int)($row['extra_matches'] ?? 0); ?></td>
              <?php endif; ?>
              <td><?php echo (int)($row['score'] ?? 0); ?></td>
            </tr>
          <?php endforeach; ?>
        </tbody>
      </table>
    <?php endif; ?>

  <?php else: ?>
    <p class="skai-empty" role="note">
      Backtest is not available yet for this dataset. Run SKAI with Auto-Tune first to see historical performance.
    </p>
  <?php endif; ?>
</div>

<!-- SKAI: Backtest Auto-Tune (UI hidden; Auto-Tune now runs automatically and is summarized above backtest) -->
<div class="skai-bt skai-bt--auto" role="region" aria-label="Backtest Auto-Tune" style="display:none">
  <h3 class="skai-h3">Auto-Tune (Windows &amp; Laplace K)</h3>
  <form method="get" class="skai-bt-form" aria-label="Auto-Tune Controls">
    <input type="hidden" name="bt_autotune" value="1" />
    <label for="bt_wmin" class="skai-label">W min</label>
    <input id="bt_wmin" name="bt_wmin" type="number" min="5" max="100" value="<?php echo (int)$winMin; ?>" class="skai-input" />
    <label for="bt_wmax" class="skai-label">W max</label>
    <input id="bt_wmax" name="bt_wmax" type="number" min="5" max="100" value="<?php echo (int)$winMax; ?>" class="skai-input" />
    <label for="bt_wstep" class="skai-label">Step</label>
    <input id="bt_wstep" name="bt_wstep" type="number" min="1" max="25" value="<?php echo (int)$winStep; ?>" class="skai-input" />
    <label for="bt_ks" class="skai-label">K set</label>
    <input id="bt_ks" name="bt_ks" type="text" value="<?php echo htmlspecialchars($KsList, ENT_QUOTES, 'UTF-8'); ?>" class="skai-input" aria-describedby="bt-ks-help" />
    <span id="bt-ks-help" class="skai-visually-hidden">Comma-separated Laplace K values (each 0, 1, or 2)</span>
    <button type="submit" class="skai-btn">Run Auto-Tune</button>
  </form>
*/ ?>


  <?php if (!empty($skaiAutoTune['candidates'])): ?>
    <?php $best = $skaiAutoTune['best']; $cands = $skaiAutoTune['candidates']; ?>
    <div class="skai-bt-summary" role="note">
      <p class="skai-bt-kv"><strong>Best:</strong>
        WWW=<?php echo (int)$best['windows']; ?>,
        K=<?php echo (int)$best['laplace_k']; ?>,
        Avg=<?php echo number_format((float)$best['avg_score'], 2); ?>,
        Hit=1=<?php echo number_format((float)$best['hit_rate']*100, 1); ?>%
        <a class="skai-apply" href="?bt_windows=<?php echo (int)$best['windows']; ?>&amp;laplace_k=<?php echo (int)$best['laplace_k']; ?>">Apply</a>
      </p>
    </div>

    <table class="skai-table skai-bt-table" role="table" aria-describedby="autotune-caption">
      <caption id="autotune-caption" class="skai-visually-hidden">Auto-Tune candidates</caption>
      <thead>
        <tr>
          <th scope="col">WWW</th>
          <th scope="col">K</th>
          <th scope="col">Avg Score</th>
          <th scope="col">Hit=1 Main</th>
          <th scope="col">Apply</th>
        </tr>
      </thead>
      <tbody>
        <?php foreach ($cands as $c): ?>
        <tr>
          <td><?php echo (int)$c['windows']; ?></td>
          <td><?php echo (int)$c['laplace_k']; ?></td>
          <td><?php echo number_format((float)$c['avg_score'], 2); ?></td>
          <td><?php echo number_format((float)$c['hit_rate']*100, 1); ?>%</td>
          <td><a class="skai-apply" href="?bt_windows=<?php echo (int)$c['windows']; ?>&amp;laplace_k=<?php echo (int)$c['laplace_k']; ?>">Apply</a></td>
        </tr>
        <?php endforeach; ?>
      </tbody>
    </table>
  <?php elseif ((int)$in->getInt('bt_autotune', 0) === 1): ?>
    <p class="skai-empty" role="note">No candidates could be evaluated for Auto-Tune.</p>
  <?php endif; ?>
</div>

  <!-- CANONICAL Extra Skip & Hit block (collapsible, collapsed by default) -->
  <details class="skai-skiphit skai-skiphit--extra skai-details-collapsible" aria-label="Skip &amp; Hit - Extra Balls">
    <summary class="skai-details-summary">
      <h3 class="skai-h3">Skip &amp; Hit - Extra Balls</h3>
      <span class="skai-details-caret" aria-hidden="true"></span>
    </summary>
    <div class="skai-details-content">
      <?php if (!empty($extraSkipHitRows)): ?>
      <table class="skai-table skai-sortable" role="table" aria-live="polite">
        <caption class="skai-visually-hidden">Skip and Hit metrics for extra balls</caption>
        <thead>
          <tr>
            <th scope="col" data-key="label"   aria-sort="none">Ball</th>
            <th scope="col" data-key="skip"    aria-sort="none">Skip</th>
            <th scope="col" data-key="hits"    aria-sort="none">Hits</th>
            <th scope="col" data-key="pattern" aria-sort="none">Pattern</th>
            <th scope="col" data-key="prob"    aria-sort="none">P(hit|k)</th>
            <th scope="col" data-key="support" aria-sort="none">Support</th>
            <th scope="col"
                data-key="cooc"
                aria-sort="none"
                title="How often this extra ball has appeared in the same draw as SKAI&rsquo;s stronger numbers over the last <?php echo (int)$coK; ?> draws.">
              Partner hits (<?php echo (int)$coK; ?>)
            </th>
          </tr>
        </thead>
        <tbody>
          <?php foreach ($extraSkipHitRows as $row): ?>
            <tr>
              <td><?php echo htmlspecialchars($row['label'], ENT_QUOTES, 'UTF-8'); ?></td>
              <td><?php echo (int)$row['skip']; ?></td>
              <td><?php echo (int)$row['hits']; ?></td>

              <td
                class="<?php echo htmlspecialchars($row['pattern_class'] ?? ('pi-' . strtolower((string)($row['pattern'] ?? 'transition'))), ENT_QUOTES, 'UTF-8'); ?>"
                title="<?php echo htmlspecialchars($row['title'] ?? '', ENT_QUOTES, 'UTF-8'); ?>"
                aria-label="<?php echo htmlspecialchars($row['aria_label'] ?? ($row['title'] ?? ''), ENT_QUOTES, 'UTF-8'); ?>">
                <?php echo htmlspecialchars($row['pattern'] ?? 'Transition', ENT_QUOTES, 'UTF-8'); ?>
              </td>

              <td><?php echo htmlspecialchars($row['prob_t'], ENT_QUOTES, 'UTF-8'); ?></td>
              <td><?php echo (int)$row['hitk']; ?>/<?php echo (int)$row['sup']; ?></td>
              <td><?php echo isset($row['cooc']) ? (int)$row['cooc'] : 0; ?></td>
            </tr>
          <?php endforeach; ?>
        </tbody>
      </table>
      <?php else: ?>
        <p class="skai-empty" role="note">No extra-ball data available.</p>
      <?php endif; ?>
    </div>
      </details>
<?php endif; ?>

<?php endif; ?>  <!-- end $skaiUsable gate for Skip &amp; Hit advanced tables -->

<div class="skai-divider"></div>

<?php if (false): ?>  <!-- SKAI: Skip & Hit save section disabled -->

<!-- SKAI: Save Prediction (Skip & Hit) -->
<?php if (!empty($saveable)): ?>
  <div class="skai-save" role="region" aria-label="Save Prediction">
    <h3 class="skai-h3">Save this Skip &amp; Hit set</h3>
    <p class="skai-small">We'll save your picked numbers with today's settings so they appear on your dashboard.</p>

    <form id="skai-save-form"
          method="post"
          action="<?php echo htmlspecialchars(\Joomla\CMS\Uri\Uri::getInstance()->toString(), ENT_QUOTES, 'UTF-8'); ?>"
          novalidate>
      <input type="hidden" name="save_set" value="1" />
      <input type="hidden" name="lottery_id" value="<?php echo (int) $lotteryId; ?>" />
      <input type="hidden" name="numbers_json" id="skai-numbers-json" value="" />
      <input type="hidden" name="top_combos_json" id="skai-top-combos-json" value="" />
      <input type="hidden" name="main_numbers" id="skai-main-json" value="" />
      <input type="hidden" name="extra_ball_numbers" id="skai-extra-json" value="" />
      <input type="hidden" name="analysis_type" value="skip_hit" />
      <input type="hidden" name="module_tag" value="SKAI SkipHit v1" />
      <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>

      <!-- Back-compat fields for legacy handlers (optional but harmless) -->
      <input type="hidden" name="main_numbers_csv" id="skai-main-csv" value="" />
      <input type="hidden" name="extra_ball_numbers_csv" id="skai-extra-csv" value="" />

      <!-- Keep legacy value under a non-colliding name for any old handlers/tools -->
      <input type="hidden" name="lottery_id_legacy" id="skai-lottery-id"
             value="<?php echo (int)($lotteryConfig['lottery_id'] ?? $lotteryConfig['game_id'] ?? 0); ?>" />

      <input type="hidden" name="draws_analyzed" id="skai-draws-analyzed"
             value="<?php echo isset($skaiDbMeta['rows_total']) ? (int)$skaiDbMeta['rows_total'] : 0; ?>" />

      <!-- User selection: risk profile + strategy -->
      <input type="hidden" name="risk_profile" id="skai-risk-profile" value="" />
      <input type="hidden" name="strategy" id="skai-strategy" value="" />

      <?php
        $defaultPickSize = (int) ($lotteryConfig['lotteryConfig']['pickSize'] ?? $lotteryConfig['pickSize'] ?? 5);
        $hasExtraLocal   = !empty($hasExtra);
      ?>
      <div class="skai-save-controls">
        <label class="skai-label" for="skai-pick-main">How many main numbers?</label>
        <input id="skai-pick-main" class="skai-input" type="number" min="1" max="20" value="<?php echo (int)$defaultPickSize; ?>" />
        <?php if ($hasExtraLocal): ?>
          <label class="skai-label" for="skai-pick-extra">How many extra balls?</label>
          <input id="skai-pick-extra" class="skai-input" type="number" min="0" max="2" value="1" />
        <?php endif; ?>
      </div>

      <label class="skai-label" for="skai-notes">Notes (optional)</label>
      <textarea id="skai-notes" name="notes" rows="2" class="skai-textarea" placeholder="Add a short note-"></textarea>

      <div class="skai-save-actions">
        <button type="button" id="skai-build-payload" class="skai-btn">Build from table</button>
        <button type="submit" id="skai-submit-save" class="skai-btn skai-btn--primary" disabled>Save to My Dashboard</button>
      </div>
    </form>

    <p id="skai-save-hint" class="skai-small" aria-live="polite"></p>
  </div>
<?php else: ?>
  <div class="skai-save skai-save--locked" role="region" aria-label="Save Prediction (Sign in)">
    <h3 class="skai-h3">Save this Skip &amp; Hit set</h3>
    <p class="skai-empty">Please sign in as a LottoExpert member to save your picks.</p>
  </div>
<?php endif; ?>


  <!-- Education: What is Laplace K? -->
  <details class="skai-help" aria-labelledby="help-k-title">
    <summary id="help-k-title" class="skai-help-summary">What is Laplace K?</summary>
    <div class="skai-help-body">
      <p><strong>Laplace K</strong> is a tiny 'guard rail' that prevents zero or tiny sample sizes from making our probability estimates (<code>P(hit|k)</code>) too extreme.</p>
      <ul>
        <li><strong>K = 0</strong> (no smoothing): uses raw counts only. Best when you have lots of data and want maximum sensitivity - but it can overreact to noise.</li>
        <li><strong>K = 1</strong> (default): gentle smoothing. Safer for typical lottery histories; reduces overfitting without hiding real signals.</li>
        <li><strong>K = 2</strong> (extra smoothing): more conservative. Helpful when data is sparse or very volatile, but it may mute short-term spikes.</li>
      </ul>
      <p><em>Rule of thumb:</em> Try K = 1 first. If results swing too much between windows, test K = 2. If your history is long and stable, test K = 0.</p>
    </div>
  </details>

<!-- Education: What is P(hit|k)? -->
<details class="skai-help" aria-labelledby="help-phitk-title">
  <summary id="help-phitk-title" class="skai-help-summary">What is P(hit|k)?</summary>
  <div class="skai-help-body">
    <p><strong>P(hit|k)</strong> means the chance this number hits on the next draw, given its current <em>skip</em> is <code>k</code>. A number&rsquo;s <em>skip</em> is how many draws it has missed since it last appeared.</p>
    <p>We estimate it from past draws at the same skip value using Laplace smoothing:</p>
    <pre><code>P(hit|k) = (hits_at_skip_k + K) / (trials_at_skip_k + 2K)</code></pre>
    <ul>
      <li><code>hits_at_skip_k</code>: how many times a number did hit when its skip was exactly <code>k</code></li>
      <li><code>trials_at_skip_k</code>: how many times we observed numbers with skip <code>k</code></li>
      <li><code>K</code>: Laplace K (0/1/2). K = 1 (default) gently avoids over/under-confidence with small samples.</li>
     </ul>
    <p><em>How to read it:</em> higher P(hit|k) means more likely to hit next, all else equal. We still consider <strong>skip</strong> and <strong>pattern</strong> to avoid chasing noise.</p>
  </div>
</details>

<!-- Education: What do the Skip & Hit patterns mean? -->
<details class="skai-help" aria-labelledby="help-patterns-title">
  <summary id="help-patterns-title" class="skai-help-summary">
    What do the Skip &amp; Hit patterns mean?
  </summary>

  <div class="skai-help-body">
    <p>
      SKAI groups numbers into simple <strong>behavior patterns</strong> based on how their current
      <em>skip</em> compares to their own historical rhythm. These labels do <strong>not</strong>
      predict outcomes — they describe how a number is behaving <em>right now</em> relative to its past.
    </p>

    <h4>Reset</h4>
    <p>
      A number labeled <strong>Reset</strong> has just appeared in the most recent draw.
      Its skip count is now <strong>0</strong>.
    </p>
    <p>
      <em>How to read it:</em> Resets often pause briefly after hitting, but some numbers do cluster.
      SKAI flags these so you can see which numbers are coming off a hit — not to chase them blindly.
    </p>

    <h4>Volatile</h4>
    <p>
      <strong>Volatile</strong> numbers are skipping <em>longer than usual</em> compared to their
      typical gap between hits. In other words, they are running late relative to their own history.
    </p>
    <p>
      <em>How SKAI detects this:</em> The current skip is significantly larger than the number&rsquo;s
      historical median gap.
    </p>
    <p>
      <em>How to read it:</em> Volatile does <strong>not</strong> mean &ldquo;due.&rdquo;
      It means the number is in an uneven phase — sometimes these resolve quickly, sometimes they stretch further.
    </p>

    <h4>Transition</h4>
    <p>
      <strong>Transition</strong> numbers sit between stable and volatile behavior.
      They are neither freshly hit nor unusually overdue.
    </p>
    <p>
      <em>How to read it:</em> Transition is a watch zone.
      These numbers are changing state, and SKAI monitors them closely for movement in either direction.
    </p>

    <p>
      <strong>Important:</strong> Pattern labels are meant to be read <em>alongside</em>
      <strong>Chance to hit next (P(hit|k))</strong>, not instead of it.
      Patterns describe behavior; probabilities estimate likelihood.
    </p>
  </div>
</details>

<?php endif; ?>  <!-- end disabled Skip & Hit save section -->
<?php if (!empty($skaiEvidencePayloadJson)): ?>
  <script type="application/json" id="skai_evidence_v1"><?php
    // ENT_NOQUOTES preserves JSON quotes; content is non-executable in this MIME type.
    echo htmlspecialchars($skaiEvidencePayloadJson, ENT_NOQUOTES, 'UTF-8');
  ?></script>
 
<?php endif; ?>

<div class="skai-skiphit skai-skiphit--main-legacy" role="region" aria-label="Skip &amp; Hit - Main Balls (Legacy Copy)" aria-hidden="true" style="display:none">
  <h3 class="skai-h3">Skip &amp; Hit - Main Balls</h3>

  <?php if (!empty($mainSkipHitRows)): ?>
<table class="skai-table skai-sortable" role="table" aria-live="polite">
  <caption class="skai-visually-hidden">Skip and Hit metrics for main balls</caption>
  <thead>
    <tr>
      <th scope="col" data-key="label"   aria-sort="none">Ball</th>
      <th scope="col" data-key="skip"    aria-sort="none">Skip</th>
      <th scope="col" data-key="hits"    aria-sort="none">Hits</th>
      <th scope="col" data-key="pattern" aria-sort="none">Pattern</th>
      <th scope="col" data-key="prob"    aria-sort="none">P(hit|k)</th>
      <th scope="col" data-key="support" aria-sort="none">Support</th>
      <th scope="col" data-key="cooc"    aria-sort="none">Co-Occur (<?php echo (int)$coK; ?>)</th>
    </tr>
  </thead>
      <tbody>
        <?php foreach ($mainSkipHitRows as $row): ?>
          <tr>
<td><?php echo htmlspecialchars($row['label'], ENT_QUOTES, 'UTF-8'); ?></td>
            <td><?php echo (int)$row['skip']; ?></td>
            <td><?php echo (int)$row['hits']; ?></td>

             <td
              class="<?php echo htmlspecialchars($row['pattern_class'] ?? ('pi-' . strtolower((string)($row['pattern'] ?? 'transition'))), ENT_QUOTES, 'UTF-8'); ?>"
              title="<?php echo htmlspecialchars($row['title'] ?? '', ENT_QUOTES, 'UTF-8'); ?>"
              aria-label="<?php echo htmlspecialchars($row['aria_label'] ?? ($row['title'] ?? ''), ENT_QUOTES, 'UTF-8'); ?>">
              <?php echo htmlspecialchars($row['pattern'] ?? 'Transition', ENT_QUOTES, 'UTF-8'); ?>
            </td>

            <td><?php echo htmlspecialchars($row['prob_t'], ENT_QUOTES, 'UTF-8'); ?></td>

            <td><?php echo (int)$row['hitk']; ?>/<?php echo (int)$row['sup']; ?></td>
            <td><?php echo isset($row['cooc']) ? (int)$row['cooc'] : 0; ?></td>
          </tr>
        <?php endforeach; ?>
      </tbody>
    </table>
    <?php else: ?>
      <p class="skai-empty" role="note">No main-ball data available.</p>
    <?php endif; ?>
</div>
</section>

<!-- === SKAI: AI Central (mounted under #skai-run-options when present) === -->
<!-- SKAI AI Central consolidated into SKAI Analysis Progress card below -->
<div id="skai-ai-central" class="tile ai-central" style="display:none;">
<div class="head">
    <h4>SKAI AI Central</h4>
    <span id="skai-autotune-badge" class="skai-badge" data-state="idle">
      <span class="msg">Auto-Tune: ON</span> <span class="sub">(ready)</span>
    </span>
  </div>
  <div class="body">
<div id="ai-central-stage" class="stage">SKAI is standing by.</div>
<div id="ai-central-sub"   class="sub">Adjust your settings, then press "Run Prediction" to start this run.</div>
  </div>
</div>


<div class="skai-wrap" id="skai-ui-root">

  <!-- Removed redundant skai-run-header progress section -->



<div class="skai-panel skai-hero-panel" id="skai-hero-panel">
  <div class="skai-hero" id="skai-hero">

    <?php
      // -----------------------------
      // HERO: State + Lottery + Freshness + Draw-agnostic explainer
      // Expects (as you already have):
      //   $lotteryName (string) e.g., "Mega Millions"
      //   $gameId (string) fallback
      // Uses URL param:
      //   stn=Wyoming (preferred)
      //   st=wy (fallback)
      // -----------------------------

      // Resolve Lottery Name
      $heroLotteryName = 'this lottery';
      if (isset($lotteryName) && trim((string)$lotteryName) !== '') {
        $heroLotteryName = (string) $lotteryName;
      } elseif (isset($gameId) && trim((string)$gameId) !== '') {
        $heroLotteryName = (string) $gameId;
      }

      // Resolve State Name (prefer stn)
// Resolve State Name — NEVER show placeholder text
$stateName = '';

// Priority order:
// 1. Explicit state name variable (if your controller already sets one)
// 2. URL param stn (full name, e.g. Wyoming)
// 3. URL param state (some pages)
// 4. URL param st (2-letter code, uppercase)
// 5. Final fallback: omit state entirely

if (isset($stateNameFull) && trim((string)$stateNameFull) !== '') {
  $stateName = (string) $stateNameFull;
} elseif (isset($_GET['stn']) && trim((string)$_GET['stn']) !== '') {
  $stateName = (string) $_GET['stn'];
} elseif (isset($_GET['state']) && trim((string)$_GET['state']) !== '') {
  $stateName = (string) $_GET['state'];
} elseif (isset($_GET['st']) && trim((string)$_GET['st']) !== '') {
  $stateName = strtoupper((string) $_GET['st']);
} elseif (isset($dbCol) && trim((string)$dbCol) !== '') {
  // Fallback: derive state from draw table name suffix (last 2 letters)
  // Example: "#__skai_draws_wy" -> "WY"
  $dbColStr = strtoupper((string) $dbCol);

  $abbr = '';
  // Prefer underscore/hyphen suffix like _WY or -WY
  if (preg_match('/[_-]([A-Z]{2})\s*$/', $dbColStr, $m)) {
    $abbr = $m[1];
  } else {
    // Last resort: last 2 alpha chars at end
    if (preg_match('/([A-Z]{2})\s*$/', $dbColStr, $m2)) {
      $abbr = $m2[1];
    }
  }

  if ($abbr !== '') {
    // Map 2-letter abbreviation to full state name (for H1 exact-match quality)
// Map 2-letter suffix to a human-friendly region label.
// US states + key country codes you need.
$regionMap = [
  // US
  'AL'=>'Alabama','AK'=>'Alaska','AZ'=>'Arizona','AR'=>'Arkansas','CA'=>'California','CO'=>'Colorado','CT'=>'Connecticut',
  'DE'=>'Delaware','FL'=>'Florida','GA'=>'Georgia','HI'=>'Hawaii','ID'=>'Idaho','IL'=>'Illinois','IN'=>'Indiana','IA'=>'Iowa',
  'KS'=>'Kansas','KY'=>'Kentucky','LA'=>'Louisiana','ME'=>'Maine','MD'=>'Maryland','MA'=>'Massachusetts','MI'=>'Michigan',
  'MN'=>'Minnesota','MS'=>'Mississippi','MO'=>'Missouri','MT'=>'Montana','NE'=>'Nebraska','NV'=>'Nevada','NH'=>'New Hampshire',
  'NJ'=>'New Jersey','NM'=>'New Mexico','NY'=>'New York','NC'=>'North Carolina','ND'=>'North Dakota','OH'=>'Ohio','OK'=>'Oklahoma',
  'OR'=>'Oregon','PA'=>'Pennsylvania','RI'=>'Rhode Island','SC'=>'South Carolina','SD'=>'South Dakota','TN'=>'Tennessee','TX'=>'Texas',
  'UT'=>'Utah','VT'=>'Vermont','VA'=>'Virginia','WA'=>'Washington','WV'=>'West Virginia','WI'=>'Wisconsin','WY'=>'Wyoming',
  'DC'=>'District of Columbia',

  // UK / Ireland
  'UK'=>'United Kingdom',    // common internal suffix
  'GB'=>'United Kingdom',    // ISO-ish
  'IE'=>'Ireland'            // Ireland
];

// If it’s in the map, use the friendly name.
// Otherwise, keep the 2-letter code rather than leaving it blank.
$stateName = $regionMap[$abbr] ?? $abbr;

  }
}

// Build exact-match H1 pattern (single assignment; do not overwrite)
// Appends "SKAI Analysis" at the end as requested.
$h1 = ($stateName !== '')
  ? ($stateName . ' ' . $heroLotteryName . ' Analysis & AI Predictions — SKAI Analysis')
  : ($heroLotteryName . ' Analysis & AI Predictions — SKAI Analysis');

// -------------------------------------------------
// Freshness: use LAST OFFICIAL DRAW DATE (date only)
// -------------------------------------------------
$rawLastDrawDate = '';
// Best source (if present): use the last element of a draw history array
// Common names: $mainHistory, $fullMainHistory
if ($rawLastDrawDate === '' && isset($fullMainHistory) && is_array($fullMainHistory) && !empty($fullMainHistory)) {
  $last = end($fullMainHistory);
  if (is_array($last) && !empty($last['date'])) {
    $rawLastDrawDate = (string) $last['date']; // typically YYYY-MM-DD from DB
  }
  reset($fullMainHistory);
}
if ($rawLastDrawDate === '' && isset($mainHistory) && is_array($mainHistory) && !empty($mainHistory)) {
  $last = end($mainHistory);
  if (is_array($last) && !empty($last['date'])) {
    $rawLastDrawDate = (string) $last['date'];
  }
  reset($mainHistory);
}

// Prefer existing draw-date variables if present
if (isset($lastDrawDate) && trim((string)$lastDrawDate) !== '') {
  $rawLastDrawDate = (string) $lastDrawDate;
} elseif (isset($latestDrawDate) && trim((string)$latestDrawDate) !== '') {
  $rawLastDrawDate = (string) $latestDrawDate;
} elseif (isset($drawDate) && trim((string)$drawDate) !== '') {
  $rawLastDrawDate = (string) $drawDate;
} elseif (isset($lastDrawingDate) && trim((string)$lastDrawingDate) !== '') {
  $rawLastDrawDate = (string) $lastDrawingDate;
}

// Fallback: latest result array (common pattern)
if ($rawLastDrawDate === '' && isset($latestResult) && is_array($latestResult)) {
  if (!empty($latestResult['draw_date'])) {
    $rawLastDrawDate = (string) $latestResult['draw_date'];
  } elseif (!empty($latestResult['drawDate'])) {
    $rawLastDrawDate = (string) $latestResult['drawDate'];
  }
}

$formattedDrawDate = '';
if ($rawLastDrawDate !== '') {
  $tz = new DateTimeZone('America/New_York');
  try {
    $dt = new DateTime($rawLastDrawDate, $tz);
    $formattedDrawDate = $dt->format('F j, Y');
  } catch (Exception $e) {
    $formattedDrawDate = '';
  }
}

$escDrawDate = htmlspecialchars($formattedDrawDate, ENT_QUOTES, 'UTF-8');

      // Escape outputs
      $escState   = htmlspecialchars($stateName, ENT_QUOTES, 'UTF-8');
      $escLottery = htmlspecialchars($heroLotteryName, ENT_QUOTES, 'UTF-8');
      $escH1      = htmlspecialchars($h1, ENT_QUOTES, 'UTF-8');
// (Removed) $freshDate / $freshTime are not used anymore.
// Freshness is based on last official draw date only.
    ?>

    <!-- H1: State + Lottery (exact-match pattern) -->
    <h1><?php echo $escH1; ?></h1>

    <p class="skai-tagline">
      SKAI learns from thousands of past draws to surface statistically optimized number sets - fast, transparent, and responsible.
    </p>

<p class="skai-hero-lottery">
  You&rsquo;re analyzing:
  <?php echo ($escState !== '' ? ($escState . ' ') : ''); ?><?php echo $escLottery; ?>
</p>

    <!-- Freshness signal -->
<?php if ($formattedDrawDate !== '') : ?>
  <div class="skai-freshness" role="status" aria-live="polite">
    Updated as of the most recent official <?php echo $escLottery; ?> draw (<?php echo $escDrawDate; ?>).
  </div>
<?php else : ?>
  <div class="skai-freshness" role="status" aria-live="polite">
    Updated as of the most recent official <?php echo $escLottery; ?> draw.
  </div>
<?php endif; ?>

    <!-- Draw-agnostic SKAI explainer -->
    <p class="skai-micro-explainer">
      SKAI recalibrates its statistical models after each official draw by incorporating newly released results,
      adjusting frequency weights, skip behavior, and pattern momentum specific to this lottery.
      This helps ensure every prediction set reflects the most current draw cycle rather than static or outdated data.
    </p>

    <div class="hero-meta">
      <!-- keep your existing hero meta content here -->

  <span class="trust-badge" aria-label="Explainable AI methodology">Explainable AI</span>
  <span class="trust-badge" aria-label="Probability-based, no promises">Probability-based • No promises</span>
</div>
</div>

<!-- Value-first block (conversion) -->
<div class="tile" style="margin:12px 0 12px 0;">
  <h3 class="skai-h3" style="margin:0 0 6px 0;">What SKAI gives you</h3>
  <ul style="margin:0;padding-left:18px;color:#374151;line-height:1.55;">
    <li>AI-ranked number sets for this lottery</li>
    <li>Probability-based scoring using historical draw behavior</li>
    <li>Skip &amp; Hit pattern intelligence with clear explanations</li>
    <li>Backtests and transparency into why picks are ranked</li>
    <li>Save and compare runs in My LottoExpert</li>
  </ul>
  <div style="margin-top:8px;font-size:0.85rem;line-height:1.45;color:#6b7280;">
    SKAI does not guarantee outcomes. It provides explainable, probability-based ranking to support disciplined play.
  </div>
</div>

<div class="hero-cta-wrap">

  <button
    type="button"
    class="btn"
    id="startPrediction"
    <?php echo (!$skaiUsable ? 'disabled aria-disabled="true" style="opacity:.55;cursor:not-allowed;"' : ''); ?>
  >
    Run SKAI Prediction
  </button>

  <a href="/picking-winning-numbers/artificial-intelligence/how-skai-tm-works"
     class="btn-outline"
     id="skai-learn-how"
     style="display:inline-block; text-decoration:none;">
    Learn How It Works
  </a>

</div>

<?php if (!$skaiUsable): ?>
  <div class="skai-locked-note" style="margin-top:10px;padding:12px 14px;border:1px solid #e5e7eb;border-radius:12px;background:#f9fafb;">
    <div style="font-weight:900;margin:0 0 6px 0;color:#111827;">
      SKAI AI-ranked picks are members-only
    </div>

    <div style="margin:0 0 10px 0;font-size:0.92rem;line-height:1.45;color:#374151;">
      SKAI is an AI-driven, probability-based system that analyzes historical draw behavior, applies simulation and pattern learning,
      and ranks number sets with clear, explainable reasoning. To run SKAI live for this lottery, log in or become a member.
    </div>

    <div style="display:flex;flex-wrap:wrap;gap:10px;">
      <a class="btn" href="/membership" style="text-decoration:none;">
        Become a Member (Unlock SKAI)
      </a>
      <a class="btn-outline" href="/membership/members-login" style="text-decoration:none;">
        Log In
      </a>
      <a class="btn-outline" href="/picking-winning-numbers/artificial-intelligence/ai-powered-predictions?game_id=101" style="text-decoration:none;">
        Try Free AI Analysis
      </a>
    </div>

    <div style="margin-top:8px;font-size:0.85rem;line-height:1.4;color:#6b7280;">
      Free AI Analysis is available to registered users and can be saved to My LottoExpert. SKAI is the premium engine for members.
    </div>
  </div>
<?php endif; ?>



<a
  href="/picking-winning-numbers/artificial-intelligence/how-skai-tm-works"
  class="btn-outline"
  id="skai-learn-how"
  style="display:inline-block; text-decoration:none;"
>
  Learn How It Works
</a>


<?php if ($skaiUsable): ?>
<!-- Ensure the options container is not inside a form; if it is, explicit button types prevent accidental submits -->
<div id="skai-run-options" class="tile" aria-labelledby="skai-run-options-title" style="margin:10px 0 14px 0; display:none;">
<h4 id="skai-run-options-title" style="margin:0 0 8px 0">
  How do you want SKAI to think today?
</h4>
<!--
  <div class="help" id="skai-at-mode-choices" style="margin:4px 0 10px 0;">
    <label style="margin-right:16px; white-space:nowrap;">
      <input type="radio"
             name="skai-at-mode"
             id="skai-at-mode-quick"
             value="quick"
             checked>
      Quick Auto-Tune
      <span class="help-inline" style="font-weight:500;">(tests a compact set of windows; fastest)</span>
    </label>

    <label style="white-space:nowrap;">
      <input type="radio"
             name="skai-at-mode"
             id="skai-at-mode-full"
             value="full">
      Full Auto-Tune
      <span class="help-inline" style="font-weight:500;">(tests a wider range of windows; slower)</span>
    </label>

    <span class="opt-pop"
          style="margin-left:8px;"
          data-pop="Quick Auto-Tune checks a smaller family of window sizes so you get a fast answer. Full Auto-Tune scans a wider range of windows for a more exhaustive search, which can take longer on games with a lot of history. Both modes use the real Skip &amp; Hit history and return a genuine best-performing window.">
      
    </span>
  </div>
-->


<div id="skaiProgressHost">
  <div id="skaiProgress" style="height:8px; width:0%; background:#2563eb; border-radius:6px; transition:width .3s ease"></div>
</div>


<div id="skai-run-banner" class="skai-run-banner" hidden>
<span class="txt">All set. SKAI is tuned and ready.</span>
</div>


  <!-- Profile (training recipe) -->
<div class="opt-card" role="group" aria-labelledby="skai-profile-title" style="margin-bottom:8px">
<div id="skai-profile-title" class="opt-title">
      Training style
      <span class="opt-hint">How bold SKAI should behave</span>
  </div>
  <p class="opt-help-line">
    Choose how SKAI trains for this run: <strong>Balanced</strong> for everyday play, <strong>Explorative</strong> to chase patterns more aggressively, or <strong>Conservative</strong> to stay closer to long-term behavior.
  </p>
<div id="skai-profile-buttons" class="btn-row" data-role="profile">
  <button type="button" class="btn-chip is-active" data-profile="balanced" aria-pressed="true">
    Balanced
  </button>
  <button type="button" class="btn-chip" data-profile="explorative" aria-pressed="false">
    Explorative
      </button>
<button type="button" class="btn-chip" data-profile="conservative" aria-pressed="false">
  Conservative
</button>
</div>
</div>

  <!-- Strategy (how to combine ML with skip-prior) -->
<div class="opt-card" role="group" aria-labelledby="skai-strategy-title" style="margin-bottom:8px">
<div id="skai-strategy-title" class="opt-title">
      Skip vs AI strategy
      <span class="opt-hint">How SKAI mixes patterns with AI</span>
  </div>
  <p class="opt-help-line">
    Pick how SKAI combines <strong>Skip &amp; Hit patterns</strong> with <strong>AI predictions</strong>. Hybrid keeps you balanced, AI-forward leans into the model, and Skip boost leans into overdue patterns.
  </p>
  <div id="skai-strategy-buttons" class="btn-row" data-role="strategy">
      <button type="button" class="btn-chip" data-strategy="ai" aria-pressed="false">AI-Forward</button>
      <button type="button" class="btn-chip is-active" data-strategy="hybrid" aria-pressed="true">
        Balanced mix (recommended)
      </button>
      <button type="button" class="btn-chip" data-strategy="skip" aria-pressed="false">Skip Pattern Boost</button>
    </div>
  </div>

  <!-- Blend (single slider controlling Skip vs AI mix) -->
  <div class="opt-card" role="group" aria-labelledby="skai-blend-title">
  <div id="skai-blend-title" class="opt-title">Blend (Skip / AI)</div>
  <div class="slider-row" style="position:relative;">
  <input type="range" id="skai-blend-range" min="0" max="100" value="55" step="1" aria-describedby="skai-blend-help">
  <output id="skai-blend-range-out" for="skai-blend-range" class="skai-range-out" style="display:none">55</output> <!-- hidden legacy readout -->
  <div id="skai-blend-center"
        style="position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
               pointer-events:none; padding:4px 10px; border-radius:999px;
               font-weight:600; font-variant-numeric:tabular-nums;
               box-shadow:0 1px 3px rgba(0,0,0,15); background:#fff; border:1px solid rgba(0,0,0,08);">
    55%
  </div>
</div>
<div id="skai-blend-help" class="opt-help">
  <p class="opt-help-line">
    This slider controls how SKAI blends <strong>Skip &amp; Hit patterns</strong> with <strong>AI (ML)</strong> for your picks.
  </p>

  <ul class="opt-help-list">
    <li><strong>0-30%</strong> &mdash; <strong>Skip-leaning:</strong> favors long-term patterns and overdue numbers.</li>
    <li><strong>40-60%</strong> &mdash; <strong>Hybrid (recommended):</strong> balanced mix of SKAI&rsquo;s AI and Skip &amp; Hit behavior.</li>
    <li><strong>70-100%</strong> &mdash; <strong>AI-leaning:</strong> lets the neural model explore more creative combinations.</li>
  </ul>

  <p class="opt-help-note">
    Adjust the slider and re-run SKAI anytime. The pill in the center shows the current <strong>AI share</strong> as a percentage.
  </p>


<!-- Selected summary (no confirmation checkbox) -->
<div id="skai-selection-summary" class="opt-summary" style="margin-top:8px" aria-live="polite">
Selected: Profile = Balanced - Strategy = Hybrid - Blend = Skip 45% / AI 55% (Hybrid)
</div>
<div id="skai-reset-wrap" style="margin-top:6px">
<button type="button" id="skai-reset-selections" class="link-reset"
  aria-label="Reset selections to defaults (Balanced - Hybrid - Blend 55%)">
    Reset selections to defaults
</button>
</div>


<!-- ===== Confidence - Recommendation (World-class UX micro-explainer) ===== -->
<div id="skai-confidence-explainer" class="tile" style="margin:10px 0 14px 0;display:none">
  <div class="panel-header">What SKAI sees right now</div>

  <!-- Compact gauge (no external libs; pure CSS) -->
  <div style="display:grid;gap:6px">
    <div style="display:flex;align-items:center;gap:10px">
      <div aria-hidden="true" style="flex:1;height:10px;border-radius:999px;background:#eef2f7;border:1px solid #dbe4f0;overflow:hidden">
        <div id="skai-confidence-bar" style="height:100%;width:0%;background:linear-gradient(90deg,#f59e0b,#16a34a);transition:width .25s ease"></div>
      </div>
      <div id="skai-confidence-score" style="min-width:48px;text-align:right;font-weight:800;color:#0f172a">-%</div>
    </div>

<div id="skai-confidence-label" class="opt-summary" aria-live="polite" style="margin:0">
  Confidence: - - Recommendation: -
</div>

<!-- Legend for transparency -->
<div style="font-size:.8rem;color:#6b7280">
  <strong>Guidance:</strong>
  <em>0-39%</em> Cautious -
  <em>40-69%</em> Balanced -
  <em>70-100%</em> Strong
</div>
</div>
</div>
</div>

<div id="skai-advanced" class="tile skai-collapsible skai-collapsed" data-skai-collapsible style="margin:10px 0 16px 0">
<div class="skai-collapsible-head" data-skai-head data-text-show="Show Custom Settings (Advanced)" data-text-hide="Hide Custom Settings (Advanced)">
  <button id="skai-adv-toggle" class="btn-outline" type="button" style="display:flex;align-items:center;gap:8px" aria-expanded="false">
    <span class="carat" style="display:inline-block;transform:rotate(-90deg);transition:transform .18s ease;"></span>
    <span data-skai-label-text>Show Custom Settings (Advanced)</span>
  </button>
</div>


<div id="skai-adv-body" class="skai-collapsible-body" data-skai-body style="margin-top:10px;display:none">

  <!-- Epochs -->
  <label for="skaiadv_epochs">Epochs</label>
  <div class="range-row">
    <input type="range" id="skaiadv_epochs" min="1" max="500" value="120" step="1">
    <input type="number" id="skaiadv_epochs_num" min="1" max="500" value="120">
  </div>
  <div class="help">How many full training passes SKAI makes over your draw history. Higher values can capture more patterns but take longer and may overfit (too focused on past noise).</div>

  <!-- Batch Size -->
  <label for="skaiadv_batch">Batch Size</label>
  <div class="range-row">
    <input type="range" id="skaiadv_batch" min="1" max="512" value="32" step="1">
    <input type="number" id="skaiadv_batch_num" min="1" max="512" value="32">
  </div>
  <div class="help">How many examples SKAI learns from at once. Larger batches can run faster but may smooth away very fine details; smaller batches react more to each draw.</div>

  <!-- Dropout -->
  <label for="skaiadv_dropout">Dropout Rate</label>
  <div class="range-row">
    <input type="range" id="skaiadv_dropout" min="0" max="0.6" value="0.2" step="0.01">
    <input type="number" id="skaiadv_dropout_num" min="0" max="0.6" value="0.2" step="0.01">
  </div>
  <div class="help">Protection against overfitting. Higher dropout makes SKAI more cautious and robust, but if set too high it can weaken the learning signal.</div>

  <!-- Learning Rate -->
  <label for="skaiadv_lr">Learning Rate</label>
  <div class="range-row">
    <input type="range" id="skaiadv_lr" min="0.000001" max="0.1" value="0.001" step="0.000001">
    <input type="number" id="skaiadv_lr_num" min="0.000001" max="0.1" value="0.001" step="0.000001">
  </div>
  <div class="help">How boldly SKAI updates its understanding each step. Very high values can bounce around and miss patterns; very low values can feel slow or stuck.</div>

  <!-- Recency Decay -->
  <label for="skaiadv_decay">Recency Decay</label>
  <div class="range-row">
    <input type="range" id="skaiadv_decay" min="0" max="0.999" value="0.9" step="0.001">
    <input type="number" id="skaiadv_decay_num" min="0" max="0.999" value="0.9" step="0.001">
  </div>
  <div class="help">How much extra weight SKAI gives to recent draws compared to older ones. Values closer to 1.0 lean strongly on recent history; lower values treat all draws more evenly.</div>

  <!-- Window Size (Auto-Tune still enforces final W at run-time) -->
  <label for="skaiadv_window">Window Size</label>
  <div class="range-row">
    <input type="range" id="skaiadv_window" min="5" max="500" value="50" step="1">
    <input type="number" id="skaiadv_window_num" min="5" max="500" value="50">
  </div>
  <div class="help">
    How many past draws SKAI studies together when it looks for patterns. Larger windows capture long term behavior; smaller windows react faster to recent changes. Auto-Tune still chooses the final window automatically at run time.
  </div>


  <!-- Hidden Layers -->
  <label for="skaiadv_layers">Hidden Layers</label>
  <div class="range-row">
    <input type="range" id="skaiadv_layers" min="1" max="12" value="6" step="1">
    <input type="number" id="skaiadv_layers_num" min="1" max="12" value="6">
  </div>
  <div class="help">How deep SKAI&rsquo;s neural network is. More layers allow SKAI to capture more complex relationships between numbers, but too many can latch onto noise.</div>


  <!-- Activation -->
  <label for="skaiadv_activation">Activation</label>
  <select id="skaiadv_activation" aria-describedby="skaiadv_activation_help">
    <option value="tanh" selected>tanh</option>
    <option value="relu">relu</option>
    <option value="elu">elu</option>
    <option value="sigmoid">sigmoid</option>
  </select>
  <div class="help" id="skaiadv_activation_help">
    relu = fast & stable; tanh = subtle; elu = robust on noise; sigmoid = compact but limited.
  </div>

<!-- Sampling Temperature -->
<label for="skaiadv_temp">Sampling Temperature</label>
<div class="range-row">
  <input type="range" id="skaiadv_temp" min="0.5" max="1.5" value="0.85" step="0.01">
  <input type="number" id="skaiadv_temp_num" min="0.5" max="1.5" value="0.85" step="0.01">
</div>

<!-- Diversity Penalty -->
<div class="help">
  Controls randomness. Lower (0.6-0.9) = safer; higher (1.0-1.3) = more diverse and riskier.
</div>

<!-- Diversity Penalty -->
<label for="skaiadv_diversity">Diversity Penalty</label>
<div class="range-row">
  <input type="range" id="skaiadv_diversity" min="0" max="0.1" value="0.02" step="0.001">
  <input type="number" id="skaiadv_diversity_num" min="0" max="0.1" value="0.02" step="0.001">
</div>
<div class="help">
  Reduces repeat numbers. 0.01-0.03 = subtle; higher spreads picks wider but may skip strong ones.
</div>

<!-- Gap Scale -->
<label for="skaiadv_gap">Gap Scale</label>
<div class="range-row">
  <input type="range" id="skaiadv_gap" min="0" max="1" value="0.20" step="0.01">
  <input type="number" id="skaiadv_gap_num" min="0" max="1" value="0.20" step="0.01">
</div>
<div class="help">
  Weight of "gap" (skip distance) in scoring. 0.1-0.3 is typical; higher = stronger skip consideration.
</div>

<!-- Skip Gamma -->
<label for="skaiadv_skipgamma">Skip Gamma</label>
<div class="range-row">
  <input type="range" id="skaiadv_skipgamma" min="0" max="1" value="0.20" step="0.01">
  <input type="number" id="skaiadv_skipgamma_num" min="0" max="1" value="0.20" step="0.01">
</div>
<div class="help">
  Controls how strongly "overdue-ness" becomes a prior boost. 0.0 = no overdue boost; 0.15-0.30 typical; higher can overfit to long-skips.
</div>

  <!-- Reset to defaults -->
  <div style="display:flex;justify-content:flex-end;margin-top:10px">
    <button type="button" id="skai-adv-reset" class="btn-outline" title="Reset Advanced settings to defaults">
      Reset to defaults
    </button>
  </div>
</div>
</div>  <!-- closes the outer #skai-advanced container -->
<?php endif; ?>

<!-- === Quick Overview (summary + confidence gauge) === -->
<?php if ($skaiUsable): ?>
<div id="skai-summary-card" class="skai-panel skai-summary-card" style="margin:14px 0 10px;display:none">
  <div class="panel-header">Quick Overview</div>
  <div class="content">
    <div class="skai-summary-row">
<div>
  <div class="skai-summary-kv">
    <div class="kv"><span>Profile</span> <b id="skai-summary-profile">Balanced</b></div>
    <div class="kv"><span>Strategy</span> <b id="skai-summary-strategy">Hybrid (Default)</b></div>
<div class="kv"><span>Blend</span> <b id="skai-summary-blend">Skip 60% / AI 40%</b></div>
  </div>
</div>
<div>
  <div class="skai-gauge">
    <svg viewBox="0 0 120 120" id="skai-gauge">
      <title id="gtitle">Model confidence</title>
      <desc id="gdesc">Radial gauge from 0 to 100 percent confidence</desc>
      <path class="gauge-track" d="M12,60 A48,48 0 0 1 108,60"></path>
      <path class="gauge-value" id="skai-gauge-arc" d="M12,60 A48,48 0 0 1 108,60" stroke-dasharray="151" stroke-dashoffset="69.46"></path>
    </svg>
    <div class="gauge-label" id="skai-gauge-label">54%</div>
    <div class="gauge-sub">Confidence (post-run)</div>
  </div>
</div>

</div>
</div>
</div>

<?php endif; ?>


<div class="hero-cta-wrap">


<!-- Modal trigger button (no ARIA - reduced code per requirement) -->
<button
  type="button"
  id="openSignup"
  class="btn-outline btn"
  <?php echo !empty($saveable) ? 'style="display:none"' : ''; ?>>
  Unlock All Features
</button>


</div>
</div> <!-- /skai-wrap -->

<!-- Minimal modal for gating (optional) -->
<div class="modal" id="signupModal" style="display:none;align-items:center;justify-content:center"><div class="modal-content" style="background:#fff;border-radius:10px;max-width:520px;width:92vw;padding:18px;box-shadow:0 18px 60px rgba(0,0,0,.35)">
<button id="closeSignup" class="close"
        style="float:right;border:0;background:transparent;font-size:22px;cursor:pointer">
  &times;
</button>
<h3 id="signupTitle" style="margin:6px 0 8px 0">
  Unlock SKAI AI-Driven Ranked Picks
</h3>
    <p class="help" style="margin-top:0">
      Log in or subscribe to save picks, view full breakdowns, and enable pro features.
    </p>
  </div>
</div>


<?php if (!$skaiUsable): ?>
<div class="skai-locked-panel" role="region" aria-label="SKAI analysis locked for guests or non-members" style="margin:16px 0;padding:14px 16px;border-radius:10px;border:1px solid #e5e7eb;background:#f9fafb;">
  <h3 class="skai-h3" style="margin-top:0;margin-bottom:6px;">Live SKAI math is members-only</h3>
<p class="skai-empty" style="margin:0 0 10px 0;font-size:0.92rem;line-height:1.5;color:#374151;">
  SKAI is an AI-driven, probability-based system that analyzes historical draw behavior,
  applies simulation and pattern learning, and ranks number sets with transparent explanations.
  To run it live for this lottery, log in or become a LottoExpert member.
</p>
</div>
<?php endif; ?>


  <!-- Analysis Settings -->

<?php if ($skaiUsable): ?>
<div id="skai-ai-panel" class="skai-ai-panel">
<div class="panel">

  <!-- SKAI Pulse Orb: long-running progress indicator (moved above Hybrid heading) -->
  <div id="skai-progress-orb" class="skai-progress-orb" aria-live="polite" aria-atomic="true" style="display:none;margin:10px 0;">
    <div class="skai-progress-orb__circle"></div>
    <p class="skai-progress-orb__status" id="skai-progress-orb-status">
      SKAI is analyzing your draw history
    </p>
  </div>

  <div class="panel-header">
    SKAI Hybrid Intelligence - Prediction Center for
    <?php
      // Reuse the same resolved name if available; else recompute from $lotteryName / $gameId
      if (!isset($skaiLotteryName)) {
          $skaiLotteryName = 'this lottery';
          if (isset($lotteryName) && $lotteryName !== '') {
              $skaiLotteryName = $lotteryName;
          } elseif (isset($gameId) && $gameId !== '') {
              $skaiLotteryName = $gameId;
          }
      }
      echo ' ' . htmlspecialchars($skaiLotteryName, ENT_QUOTES, 'UTF-8');
    ?>
  </div>

  <div class="content">
<p class="help">
  This runs a lightweight neural model entirely in your browser. It learns from the same Skip-Hit history used by the server. Click <strong>Run Prediction</strong> to compute fresh picks. Nothing is sent off-site.
</p>

    <p class="help" id="ai-skiphit-explain">
<strong>How Skip-Hit is used</strong> - The model derives features automatically (recent frequency, current skip, short/medium/long recency counts, time-since-seen). You don&rsquo;t have to run Skip-Hit first. Choose a window if you like, then start <em>AI (ML)</em>.
    </p>


<!-- Progress Indicator: Lightweight traffic light milestones -->
<div id="skai-progress-indicator" class="skai-progress-indicator" role="status" aria-live="polite">
  <div class="skai-progress-header">
    <div class="skai-progress-title">SKAI Analysis Progress</div>
    <span id="skai-autotune-badge-consolidated" class="skai-badge" data-state="idle">
      <span class="msg">Auto-Tune: ON</span> <span class="sub">(ready)</span>
    </span>
  </div>
  <div id="skai-progress-status" class="skai-progress-status">
    <div id="skai-progress-stage-msg" class="skai-progress-stage-msg">SKAI is standing by.</div>
    <div id="skai-progress-sub-msg" class="skai-progress-sub-msg">Adjust your settings, then press "Run Prediction" to start this run.</div>
  </div>
  <div class="skai-progress-steps">
    <div class="skai-progress-step" data-step="0">
      <div class="skai-progress-light skai-progress-light--pending"></div>
      <div class="skai-progress-label">Auto Tune</div>
    </div>
    <div class="skai-progress-step" data-step="1">
      <div class="skai-progress-light skai-progress-light--pending"></div>
      <div class="skai-progress-label">Loading Data</div>
    </div>
    <div class="skai-progress-step" data-step="2">
      <div class="skai-progress-light skai-progress-light--pending"></div>
      <div class="skai-progress-label">Training Main AI</div>
    </div>
    <div class="skai-progress-step" data-step="3">
      <div class="skai-progress-light skai-progress-light--pending"></div>
      <div class="skai-progress-label">Training Extra AI</div>
    </div>
    <div class="skai-progress-step" data-step="4">
      <div class="skai-progress-light skai-progress-light--pending"></div>
      <div class="skai-progress-label">Generating Picks</div>
    </div>
    <div class="skai-progress-step" data-step="5">
      <div class="skai-progress-light skai-progress-light--pending"></div>
      <div class="skai-progress-label">Complete</div>
    </div>
  </div>
  <div id="skai-progress-details">
    <div id="skai-progress-computation"></div>
    <div id="skai-progress-eta"></div>
  </div>
  <div id="skai-progress-autotune-results" class="skai-progress-autotune-results" style="display:none;">
    <div class="skai-progress-autotune-title">Optimization Results</div>
    <div id="skai-progress-autotune-content"></div>
  </div>
  <div id="skai-math-console" class="skai-math-console" style="display:none;">
    <div class="skai-math-console-header">
      <span class="skai-math-console-title">Live Mathematical Computations</span>
      <button id="skai-math-console-toggle" class="skai-math-console-toggle" type="button" aria-label="Toggle math console">▼</button>
    </div>
    <div id="skai-math-console-body" class="skai-math-console-body">
      <div id="skai-math-console-content" class="skai-math-console-content"></div>
    </div>
  </div>
</div>

<div id="skai-ai-results" class="tile" style="margin-bottom:16px;" tabindex="-1">

      <!-- Header + action -->
      <div class="skai-results-header">
        <div class="skai-results-title">
          <h3 class="skai-results-h3">SKAI picks</h3>
          <p class="skai-results-sub">
            Ordered from <strong>highest likelihood</strong> to lower likelihood, based on SKAI&rsquo;s confidence.
          </p>
        </div>

        <div class="skai-results-actions" role="group" aria-label="Top picks display controls">
          <div class="skai-results-actions-label help">
            How many numbers would you like to see?
          </div>

          <div class="btn-group skai-results-chips">
            <button type="button" class="btn-chip" data-skai-top-limit="10" aria-pressed="false">
              Top 10
            </button>
            <button type="button" class="btn-chip" data-skai-top-limit="15" aria-pressed="false">
              Top 15
            </button>
            <button type="button" class="btn-chip" data-skai-top-limit="20" aria-pressed="true">
              Top 20
            </button>

            <button id="btnCopyAiBoth" class="btn-chip skai-results-copy" type="button">
              Copy picks
            </button>
          </div>
        </div>
      </div><!-- /skai-results-header -->


<!-- Main numbers -->
<div id="aiPredictedNumbers" class="row skai-ai-main">
  <span class="help">
    When you run SKAI, your AI-picked numbers will appear here.
  </span>
</div>

<!-- Daily Decision Panel (Pick 3 / Pick 4 only; JS auto-hides otherwise) -->
<div id="skai-daily-panel" class="skai-daily-panel" style="display:none;" aria-live="polite">
  <div class="skai-daily-panel-head">
    <div class="skai-daily-title">Daily Decision Panel</div>
    <div class="skai-daily-sub">Ranked digits and top combinations, derived from SKAI scoring.</div>
  </div>

  <div class="skai-daily-grid">
    <div class="skai-daily-card">
      <div class="skai-daily-card-h">Top digits (ranked)</div>
      <div id="skai-daily-digit-ladder" class="skai-daily-ladder"></div>
      <div class="skai-daily-foot">Digits are ordered by SKAI score (relative ranking, not guarantees).</div>
    </div>

    <div class="skai-daily-card">
      <div class="skai-daily-card-h">Top straight combinations</div>
      <div id="skai-daily-combos" class="skai-daily-combos"></div>
      <div class="skai-daily-foot">“Straight” means exact order. “Box” groups the same digits regardless of order.</div>
    </div>
  </div>

  <div class="skai-daily-rationale">
    <div class="skai-daily-card-h">Why these rose to the top</div>
    <ul id="skai-daily-why" class="skai-daily-why"></ul>
  </div>
</div>

<div id="ai-param-readout" class="help" style="margin-top:6px;">
  Run parameters will appear here after SKAI finishes a prediction.
</div>

      <div id="aiExtraPredictionContainer" class="row" style="display:flex; flex-wrap:wrap; gap:8px; margin-top:6px;"></div>

      <!-- Hyperparameters (this run) - lives inside the Analysis card, below results -->
      <div id="skai-param-status">
        <div class="results-section-head">
          Hyperparameters (this run)
        </div>
        <div id="skai-param-status-body" class="help">
          Loading&hellip;
        </div>
      </div>

      <?php
        // Default label for AI saves - prefer resolved lottery name
        // Use $lotteryName when set; otherwise fall back to JSON lotteryName / legacy keys
        $skaiAiLotName = (string)(
            ($lotteryName ?? '') !== ''
                ? $lotteryName
                : ($lotteryConfig['lotteryName'] ?? $lotteryConfig['lottery_name'] ?? $lotteryConfig['game_name'] ?? 'Lottery')
        );
        $skaiAiLabelDefault = $skaiAiLotName . ' - AI Prediction - ' . date('M j, Y');

      // CHG: numeric-safe lottery_id fallback - avoid (int)"ID4" => 0.
      $rawAiLotteryId = $lotteryConfig['lottery_id'] ?? $lotteryId ?? 0;
      if (!is_numeric($rawAiLotteryId) && isset($lotteryConfig['game_id']) && is_numeric($lotteryConfig['game_id'])) {
          $rawAiLotteryId = $lotteryConfig['game_id'];
      }
      $skaiAiLotteryId = (int) $rawAiLotteryId;
      ?>
 
      <?php if (!empty($saveable)): ?>
      <div class="skai-save skai-save--ai" role="region" aria-label="Save AI prediction">
        <h3 class="skai-h3">Save this AI prediction</h3>
        <p class="help">After you run SKAI, you can save these AI-picked numbers to your LottoExpert dashboard.</p>

        <form id="skai-ai-save-form"
              method="post"
              action="<?php echo htmlspecialchars(\Joomla\CMS\Uri\Uri::getInstance()->toString(), ENT_QUOTES, 'UTF-8'); ?>"
              novalidate>
          <input type="hidden" name="save_set" value="1" />
          <input type="hidden" name="analysis_type" value="skai_prediction" />
          <input type="hidden" name="module_tag" value="SKAI AI v1" />
          <?php echo \Joomla\CMS\HTML\HTMLHelper::_('form.token'); ?>

          <!-- Core SKAI payloads (AI flavor) -->
          <input type="hidden" name="numbers_json" id="skai-ai-numbers-json" value="" />
          <input type="hidden" name="top_combos_json" id="skai-ai-top-combos-json" value="" />
          <input type="hidden" name="main_numbers" id="skai-ai-main-json" value="" />
          <input type="hidden" name="extra_ball_numbers" id="skai-ai-extra-json" value="" />

          <!-- Back-compat CSV mirrors for unified save handler -->
          <input type="hidden" name="main_numbers_csv" id="skai-ai-main-csv" value="" />
          <input type="hidden" name="extra_ball_numbers_csv" id="skai-ai-extra-csv" value="" />

          <!-- Identity / context -->
          <input type="hidden" name="lottery_id" id="skai-ai-lottery-id" value="<?php echo $skaiAiLotteryId; ?>" />
          <input type="hidden" name="game_id" value="<?php echo htmlspecialchars((string) $gameId, ENT_QUOTES, 'UTF-8'); ?>" />

          <?php
          // Ensure we pass the upcoming draw date through to the unified save handler.
          // This aligns with the server logic that prefers a posted `next_draw_date`
          // over the fallback from $rowsAsc.
          $nextDrawDateSafe = '';
          if (!empty($nextDrawDate)) {
              // Store as simple YYYY-MM-DD (strip any time component, mirroring handler logic)
              $nextDrawDateSafe = substr((string) $nextDrawDate, 0, 10);
          }
          ?>
          <input type="hidden"
                 name="next_draw_date"
                 id="skai-ai-next-draw-date"
                 value="<?php echo htmlspecialchars($nextDrawDateSafe, ENT_QUOTES, 'UTF-8'); ?>" />

          <?php
          // NEW: Provide next_draw_at when we have a time component.
          // If $nextDrawDate is date-only, handler will fall back safely.
          $nextDrawAtSafe = '';
          if (!empty($nextDrawDate)) {
              $ts = strtotime((string) $nextDrawDate);
              if ($ts) {
                  // ISO-like local timestamp string; matches handler expectations
                  $nextDrawAtSafe = date('Y-m-d H:i:s', $ts);
              }
          }
          ?>
          <input type="hidden"
                 name="next_draw_at"
                 id="skai-ai-next-draw-at"
                 value="<?php echo htmlspecialchars($nextDrawAtSafe, ENT_QUOTES, 'UTF-8'); ?>" />

          <input type="hidden" name="draws_analyzed" id="skai-ai-draws-analyzed" value="" />
          <input type="hidden" name="generated_at" id="skai-ai-generated-at" value="" />

          <!-- User selection: risk profile + strategy -->
          <input type="hidden" name="risk_profile" id="skai-ai-risk-profile" value="" />
          <input type="hidden" name="strategy" id="skai-ai-strategy" value="" />

          <!-- NN / AI hyperparameters (mirrors working AI page columns) -->
          <input type="hidden" name="epochs" id="skai-ai-epochs" value="" />
          <input type="hidden" name="batch_size" id="skai-ai-batch-size" value="" />
          <input type="hidden" name="dropout_rate" id="skai-ai-dropout" value="" />
          <input type="hidden" name="learning_rate" id="skai-ai-lr" value="" />
          <input type="hidden" name="activation_function" id="skai-ai-activation" value="" />
          <input type="hidden" name="hidden_layers" id="skai-ai-layers" value="" />
          <input type="hidden" name="recency_decay" id="skai-ai-recency-decay" value="" />

          <!-- SKAI blend and advanced parameters -->
          <input type="hidden" name="skai_blend_skip_pct" id="skai-ai-blend-skip-pct" value="" />
          <input type="hidden" name="skai_blend_ai_pct" id="skai-ai-blend-ai-pct" value="" />
          <input type="hidden" name="sampling_temperature" id="skai-ai-sampling-temp" value="" />
          <input type="hidden" name="diversity_penalty" id="skai-ai-diversity-penalty" value="" />
          <input type="hidden" name="gap_scale" id="skai-ai-gap-scale" value="" />
          <input type="hidden" name="laplace_k" id="skai-ai-laplace-k" value="" />
          <input type="hidden" name="skip_gamma" id="skai-ai-skip-gamma" value="" />
          <input type="hidden" name="skai_window_size" id="skai-ai-window-size" value="" />
          <input type="hidden" name="skai_run_mode" id="skai-ai-run-mode" value="" />
          <input type="hidden" name="skai_top_n_numbers" id="skai-ai-top-n-numbers" value="" />
          <input type="hidden" name="skai_top_n_combos" id="skai-ai-top-n-combos" value="" />

          <!-- Auto-tune and skip window parameters -->
          <input type="hidden" name="bt_autotune" id="skai-ai-autotune" value="" />
          <input type="hidden" name="bt_windows" id="skai-ai-skip-window" value="" />
          <input type="hidden" name="best_window" id="skai-ai-best-window" value="" />
          <input type="hidden" name="tuned_window" id="skai-ai-tuned-window" value="" />
          <input type="hidden" name="tune_used" id="skai-ai-tune-used" value="" />

          <label class="skai-label" for="skai-ai-label">Label</label>
          <input id="skai-ai-label"
                 class="skai-input"
                 type="text"
                 name="label"
                 value="<?php echo htmlspecialchars($skaiAiLabelDefault, ENT_QUOTES, 'UTF-8'); ?>" />

          <label class="skai-label" for="skai-ai-notes">Notes (optional)</label>
          <textarea id="skai-ai-notes"
                    name="notes"
                    rows="2"
                    class="skai-textarea"
                    placeholder="Add a short note."></textarea>

          <div class="skai-save-actions">
            <button type="submit"
                    id="skai-ai-submit-save"
                    class="skai-btn skai-btn--primary">
              Save AI prediction to My Dashboard
            </button>
          </div>


          <p id="skai-ai-save-hint" class="skai-small" aria-live="polite"></p>
        </form>
      </div>
      <?php else: ?>
      <div class="skai-save skai-save--locked" role="region" aria-label="Save AI prediction (Sign in)">
        <h3 class="skai-h3">Save this AI prediction</h3>
        <p class="skai-empty">Please sign in as a LottoExpert member to save AI picks for this game.</p>
      </div>
      <?php endif; ?>

    </div>
  </div>
</div>
</div> <!-- /.content -->
</div>   <!-- /.panel -->

<?php endif; ?>  <!-- end $skaiUsable gate for SKAI prediction panel -->


</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div><!-- /#skai -->

<script>
// Hard-kill SKAI global status bar ("Idle  Ready") without affecting the rest of the page.
document.addEventListener('DOMContentLoaded', function () {
  try {
    function removeGlobalBar(node) {
      if (node && node.id === 'skai-global-status' && node.parentNode) {
        node.parentNode.removeChild(node);
      }
    }

    // Remove if it already exists on load
    removeGlobalBar(document.getElementById('skai-global-status'));

    // Watch for any future creations and remove them
    if (window.MutationObserver) {
      var obs = new MutationObserver(function (mutations) {
        for (var i = 0; i < mutations.length; i++) {
          var added = mutations[i].addedNodes || [];
          for (var j = 0; j < added.length; j++) {
            removeGlobalBar(added[j]);
          }
        }
      });
      obs.observe(document.body, { childList: true });
    }
  } catch (e) {
    // Fail silently; page still loads normally
  }
});
</script>



<?php
// ========================================================================
// [JS INDEX] RUNTIME BLOCKS (Ctrl+F by -SKAI Runner/Optimizer Block #-)
// ------------------------------------------------------------------------
//  A) Core Shims, Debug, Event Bridge
//  B) Copy / Export Utilities + Save Wiring
//  C) TFJS Loader (ensureTF)
//  D) Runtime Flag Reset / Cleanup
//  E) Canonical Config Publish (SKAI_CONFIG / SKAI_SERVER.CONFIG)
//  F) Co-Occurrence Export (SKAI_COOC)
//  G) Apply Server Caps to UI Inputs
//  H) Save-to-Dashboard Form Wiring
//  I) Performance Index (PI) Badge Wiring
//  J) Save Submit Interceptor / Payload Normalizer
//  K) Config Accessors (getSpec / getRules)
//  L) Smoothed Histogram Event Cache
//  1) Optimizer Selection + Input Sync
//  2) Start Button Lifecycle / aria-busy
//  3) Auto-Tune Gatekeeper
//  4) SKAI_SERVER Hydrator
//  5) Root/Panel Bootstrap
//  6) Parameter Echo + Runner Event Shim
//  7) Auto-Tune / Grid Optimizer Engine
// ========================================================================
?>

<?php echo '<script>'; ?>

// (removed duplicate SKAI_SERVER export; earlier Sec-4 export remains canonical)
// Export raw draws (ASC) from server (Section 4/5 build) for client ML
// Shape: [ { numbers:[...], date:'YYYY-MM-DD' }, ... ]
window.draws = <?php echo json_encode(
  $fullMainHistory ?? [],
  JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT
); ?>;

// Export extra-draws stream for client ML (ASC)
// Shape: [ { number:int, date:'YYYY-MM-DD' }, ... ]
window.extraDraws = <?php echo json_encode(
  $fullExtraHistory ?? [],
  JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT
); ?>;

// Normalize extraDraws in case numbers are stringy like "07"
;(function(){
  var arr = Array.isArray(window.extraDraws) ? window.extraDraws : [];
window.extraDraws = arr.map(function(r){
    var n = Number(r && r.number);

    // CHG: ES5-safe finite check.
    return { number: (isFinite(n) ? n : null), date: (r && r.date) || '' };
  });
})();

// Robust meta export ? do not rely on $SKAI_FEATURES
<?php
$__domain      = (int)($lotteryConfig['max_main_ball_number']  ?? $lotteryConfig['main_ball_max']  ?? 0);
$__pick        = (int)($lotteryConfig['pick_size']             ?? count($lotteryConfig['main_ball_columns'] ?? []));
$__extraDomain = (int)($lotteryConfig['max_extra_ball_number'] ?? $lotteryConfig['extra_ball_max'] ?? 0);
// FIX: Use the already-computed $hasExtra (set at line 1290: $__flagWantsExtra && $__hasExtraCols)
// which checks both has_extra_ball flag AND that columns exist. Fall back to config check if not yet set.
$__hasExtra    = isset($hasExtra) ? (bool)$hasExtra : !empty($lotteryConfig['has_extra_ball']);
$__allowZero   = ($__domain > 0 && $__domain <= 9) && !$__hasExtra;

/**
 * Whether the extra ball should be treated as strictly 1-based on the client.
 * Priority: explicit config override -> default heuristic (domain > 9 => 1-based).
 */
$__forceOneBasedExtra = array_key_exists('extra_one_based', $lotteryConfig)
  ? (bool)$lotteryConfig['extra_one_based']
  : ($__extraDomain > 9);
?>
window.SKAI_META = <?php
echo json_encode([
  'domain'              => $__domain,
  'pick'                => $__pick,
  'extraDomain'         => $__extraDomain,
  'hasExtraBall'        => (bool)$__hasExtra,
  'allowZero'           => (bool)$__allowZero,
  'forceOneBasedExtra'  => (bool)$__forceOneBasedExtra,
  'isDaily'             => !empty($lotteryConfig['is_daily']) || !empty($lotteryConfig['isDaily'])
], JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_AMP | JSON_HEX_APOS | JSON_HEX_QUOT);
?>;
<?php echo '</script>'; ?>



 <script>
/* ==========================================================
   SKAI Runner/Optimizer Block R2: Evidence ? Save Form Bridge
   Purpose:
     - Copies evidence JSON (#skai_evidence_v1) into hidden
       input[name="top_combos_json"] for saving
   Depends on:
     - <script type="application/json" id="skai_evidence_v1">
     - Save form hidden input present
   Exposes (globals):
     - None
   Notes:
     - Safe, runs once per load; doesn-t alter prediction logic.
   ========================================================== */
  ;(function(){
    'use strict';
    // Progressive enhancement: if a save form has top_combos_json, populate it.
    var el = document.getElementById('skai_evidence_v1');

    if (!el) return;
    var json = el.textContent || '';
    if (!json) return;
    var input = document.querySelector('input[name="top_combos_json"]');
    if (input && !input.value) {
      try { input.value = json; } catch(e){}
    }
  })();
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block R1: Global Deduper (SKAI_ONCE)
   Purpose:
     - Prevents duplicate wiring when Sorcerer/Helix re-inject blocks
     - Lets other blocks safely -run once- by key
   Depends on:
     - None (should be early)
   Exposes (globals):
     - window.SKAI_ONCE(key)  -> boolean
     - window.__SKAI_ONCE__   (internal map)
   Notes:
     - Used across UI, runner, optimizer, and bridges.
   ========================================================== */
(function(){
  'use strict';
  if (!window.__SKAI_ONCE__) window.__SKAI_ONCE__ = Object.create(null);
  window.SKAI_ONCE = function(key){

    if (!key) return true;
    if (window.__SKAI_ONCE__[key]) {
      try { console.warn('[SKAI] Duplicate wiring detected for key: ' + key + '. Remove the second copy.'); } catch (_){}
      return false;
    }
    window.__SKAI_ONCE__[key] = 1;
    return true;
  };
})();
</script>

<script>
(function(){
  'use strict';

  function setIf(el, val){
    if (!el) return;
    try { el.value = String(val); el.setAttribute('aria-valuenow', String(val)); el.dispatchEvent(new Event('change')); } catch(_){}
  }
  function label(el, txt){ if (!el) return; try { el.setAttribute('aria-label', txt); } catch(_){} }

  function ensureStatus(){
    var s = document.getElementById('skaiAriaStatus');
    if (!s) {
      s = document.createElement('div');
      s.id = 'skaiAriaStatus';
      s.setAttribute('role','status');
      s.setAttribute('aria-live','polite');
      s.style.position='absolute'; s.style.width='1px'; s.style.height='1px';
      s.style.overflow='hidden'; s.style.clip='rect(1px,1px,1px,1px)';
      document.body.appendChild(s);
    }
    return s;
  }
  function announce(msg){ try { ensureStatus().textContent = String(msg||''); } catch(_){ } }

  function go(){
    try{
      var d = (window.SKAI_DEFAULTS || {});
      setIf(document.getElementById('ensembleN_ui'), d.ensembleN || 7);
      setIf(document.getElementById('validationTail_ui'), (d.validationTail || 0.15));
      setIf(document.getElementById('laplaceK_ui'), d.laplaceK || 1);

      label(document.getElementById('ensembleN_ui'), 'Ensemble size (default 7)');
      label(document.getElementById('validationTail_ui'), 'Validation tail fraction (default 0.15)');
      label(document.getElementById('laplaceK_ui'), 'Laplace smoothing K (default 1)');

      // Laplace K change wiring
      (function(){
        var k = document.getElementById('laplaceK_ui'); if (!k) return;
        k.addEventListener('change', function(){
          var v = parseInt(k.value, 10);
          if (!isFinite(v)) return; // ES5-safe
          (window.SKAI_SERVER = window.SKAI_SERVER || {}).laplaceK = v;
          try { window.dispatchEvent(new CustomEvent('skai:laplace:changed', { detail:{ k:v } })); } catch(_){}
          announce('Laplace K set to ' + v);
        });
      })();

      // Window control wiring
      (function(){
        var w = document.getElementById('windowSize_ui') || document.getElementById('windowSize'); if (!w) return;
        function pushWin(){
          var v = parseInt(w.value || '0', 10);
          if (!isFinite(v) || v <= 0) return; // ES5-safe
          try { document.documentElement.setAttribute('data-skai-window', String(v)); } catch(_){}
          try { window.dispatchEvent(new CustomEvent('skai:window:changed', { detail:{ w:v } })); } catch(_){}
          announce('Window set to ' + v);
        }
        w.addEventListener('input',  pushWin);
        w.addEventListener('change', pushWin);
        pushWin();
      })();

    } catch(_){}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', go, { once:true });
  } else {
    go();
  }
})();
</script>

<script>

;(function(){
  'use strict';

  // Safety: ensure global "detail" identifier exists so any legacy listeners or shims
  // that accidentally reference `detail` cannot throw errors.
  // We make it a plain object so calls like `detail.W` are safe (they just read `undefined`).
  if (typeof window.detail === 'undefined' || window.detail === null) {
    // Define as a harmless global; real code should use e.detail or payload.detail.
    window.detail = {};
  }

  function getWindowStatusEl(){
    return document.getElementById('skai-window-status');
  }

  function setWindowStatus(msg){
    var el = getWindowStatusEl();
    if (!el) return;
    el.textContent = msg || '';
  }

  // Start of Auto-Tune window search
  window.addEventListener('skai:autotune:begin', function(e){
    setWindowStatus('Auto-Tune window search: preparing candidates…');

    // Auto-scroll disabled here; we keep this listener only to update status.
  });

  // Live progress: which window and which step
  window.addEventListener('skai:autotune:progress', function(e){
    var d = (e && e.detail) || {};
    var W     = (d.W != null) ? d.W : d.window;
    var idx   = (typeof d.index === 'number') ? d.index : null;
    var total = (typeof d.total === 'number') ? d.total : null;
    var pct   = (typeof d.percent === 'number' && isFinite(d.percent)) ? d.percent : null;

    var parts = [];
    if (W != null) parts.push('testing window W=' + W);
    if (idx != null && total != null && total > 0) {
      parts.push('step ' + idx + ' of ' + total);
    }
    if (pct != null) {
      parts.push(pct.toFixed(0) + '% complete');
    }

    if (parts.length) {
      var label = 'Auto-Tune window search: ' + parts.join(' - ');
      setWindowStatus(label);

      // NEW: mirror the same rich message into the SKAI orb / bubble
      try {
        if (window.skaiProgress && typeof window.skaiProgress.setStatus === 'function') {
          window.skaiProgress.setStatus(label);
        }
      } catch(_){}
    }
  });

  // Auto-Tune finished
  window.addEventListener('skai:autotune:done', function(e){
    var d = (e && e.detail) || {};
    var best = d.best || d.result || {};
    var W = best.W || best.window || d.bestWindow || d.window || d.W || 'n/a'; // clearer fallback
    setWindowStatus('Auto-Tune complete. Best window W=' + W + '. Training and backtesting are now running.');
  });

  // If something stops or fails
  window.addEventListener('skai:analysis-stop', function(){
    setWindowStatus('Auto-Tune stopped or failed. You can adjust settings and run again.');
  });
})();
</script>

<script>
/* SKAI: Re-flow SKAI sections + gate insights below prediction block (Sorcerer-safe) */
(function () {
  function getAnchor() {
    // Preferred anchor: Prediction Center, then hero, then UI root
    return (
      document.getElementById('skai-ai-panel') ||
      document.getElementById('skai-hero-panel') ||
      document.getElementById('skai-ui-root')
    );
  }

  function insertAfter(anchor, node) {
    if (!anchor || !node || !anchor.parentNode) return;
    if (node === anchor) return;

    var parent = anchor.parentNode;

    // If it's already immediately after, nothing to do
    if (anchor.nextSibling === node) return;

    // Move node into the right parent in the right position
    if (anchor.nextSibling) {
      parent.insertBefore(node, anchor.nextSibling);
    } else {
      parent.appendChild(node);
    }
  }

  // Re-flow layout so story, insights, and advanced Skip & Hit
  // live directly under the prediction area in this order:
  //   1) .skai-story
  //   2) #skai-insights-section
  //   3) .skai-advanced (Skip & Hit)
  function reflowSections() {
    try {
      var anchor   = getAnchor();
      if (!anchor) return;

      var story    = document.querySelector('section.skai-story');
      var insights = document.getElementById('skai-insights-section');
      var advanced = document.querySelector('section.skai-advanced');

      // Ensure order: story -> insights -> advanced
      if (story) {
        insertAfter(anchor, story);
        anchor = story;
      }

      if (insights) {
        insertAfter(anchor, insights);
        anchor = insights;
      }

      if (advanced) {
        insertAfter(anchor, advanced);
      }
    } catch (_) {}
  }

  // Track when Auto-Tune and ML have both completed so we can reveal insights.
  var autoDone = false;
  var mlDone   = false;

  function maybeShowInsights() {
    try {
      // Only show insights once both phases are done
      if (!autoDone || !mlDone) return;

      var sec = document.getElementById('skai-insights-section');
      if (sec) {
        sec.style.display = ''; // remove inline "display:none"
      }
    } catch (_) {}
  }

  // Also expose this helper on window so any other SKAI code can call it safely.
  if (typeof window !== 'undefined') {
    window.maybeShowInsights = window.maybeShowInsights || maybeShowInsights;
  }

  function onAutoDone() {
    autoDone = true;
    maybeShowInsights();
  }

  function onMlDone() {
    mlDone = true;
    maybeShowInsights();
  }

  // Listen for SKAI lifecycle events
  try {
    window.addEventListener('skai:autotune:done', onAutoDone, false);
    window.addEventListener('skai:ml:done',       onMlDone,   false);
  } catch (_) {}

  // Keep Skip & Hit directly AFTER insights (or story if insights hidden),
  // inside the SAME parent as the prediction anchor. This prevents the
  // advanced section from being pulled into a different container.
  function forceAdvancedBottom() {
    try {
      var adv = document.querySelector('section.skai-advanced');
      if (!adv) return;

      // Prefer to anchor under insights if present; else under story; else under main anchor.
      var insights = document.getElementById('skai-insights-section');
      var story    = document.querySelector('section.skai-story');
      var anchor   = insights || story || getAnchor();
      if (!anchor) return;

      // Reuse insertAfter so advanced stays in the same DOM stream.
      insertAfter(anchor, adv);
    } catch (_) {}
  }

  // Re-flow sections as soon as the DOM is ready so the story and
  // insights live under the prediction area, then pin Skip & Hit
  // to the bottom of the SKAI container.
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    reflowSections();
    forceAdvancedBottom();
  } else {
    try {
      document.addEventListener('DOMContentLoaded', function () {
        reflowSections();
        forceAdvancedBottom();
      }, { once: true });
    } catch (_) {
      // Fallback in very old browsers
      reflowSections();
      forceAdvancedBottom();
    }
  }
})();

</script>


<script>
;(function(){
  'use strict';
  if (window.__skaiBtSync) return; window.__skaiBtSync = true;

  function clamp(v,min,max){ v = parseInt(v||0,10); if (isNaN(v)) v=min; return Math.max(min, Math.min(max, v)); }

  function init(){
    var r = document.getElementById('bt_windows_range');
    var n = document.getElementById('bt_windows');
    if (!r || !n) return;

    var min = parseInt(r.min||'5',10), max = parseInt(r.max||'100',10);

    // keep initial alignment in bounds
    n.value = clamp(n.value, min, max);
    r.value = n.value;

    r.addEventListener('input', function(){ n.value = this.value; });
    n.addEventListener('input', function(){ this.value = clamp(this.value, min, max); r.value = this.value; });
    n.addEventListener('change', function(){ this.value = clamp(this.value, min, max); r.value = this.value; });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>

<script>
;(function(){
  'use strict';
  if (window.__skaiSaveInit) return; window.__skaiSaveInit = true;

  function qs(id){ return document.getElementById(id); }
  function text(el){ return (el && el.textContent || '').trim(); }

  function getRankedRows(tableSel){
    var t = document.querySelector(tableSel);
    if (!t || !t.tBodies || !t.tBodies[0]) return [];
    var rows = Array.prototype.slice.call(t.tBodies[0].rows);
    var thead = t.tHead && t.tHead.rows[0], pIdx = -1, lIdx = -1;
    if (thead){
      for (var i=0;i<thead.cells.length;i++){
        var key = thead.cells[i].getAttribute('data-key');
        if (key === 'prob') pIdx = i;
        if (key === 'label' && lIdx < 0) lIdx = i;
      }
    }
    function parseProbToNum(s){
      s = String(s||'').trim(); if (!s) return 0;
      // CHG: ES5-safe percent suffix check (avoids String.prototype.endsWith).
      if (s.charAt(s.length - 1) === '%') return parseFloat(s) || 0;
      var v = parseFloat(s); if (!isNaN(v) && v<=1) return v*100;
      return isNaN(v) ? 0 : v;
    }
    return rows.sort(function(a,b){
      var ap = parseProbToNum(text(a.cells[pIdx]||{}));
      var bp = parseProbToNum(text(b.cells[pIdx]||{}));
      if (ap !== bp) return (bp - ap);
      var al = parseInt(text(a.cells[lIdx]||{}).replace(/\D+/g,''), 10) || 0;
      var bl = parseInt(text(b.cells[lIdx]||{}).replace(/\D+/g,''), 10) || 0;
      return al - bl;
    });
  }

  function topLabels(rows, n){
    var out=[]; n = Math.max(0, Math.min(rows.length, n));
    for (var i=0;i<n;i++){
      var lab = text(rows[i].cells[0]); // first col = Ball
      var num = parseInt(lab.replace(/\D+/g,''), 10);
      if (!isNaN(num)) out.push(num);
    }
    return out;
  }

function buildPayload(){
    var pmEl = qs('skai-pick-main');
    var pickMain = parseInt((pmEl && pmEl.value) || '0', 10);
    if (isNaN(pickMain) || pickMain <= 0) pickMain = 5;

    var peEl = qs('skai-pick-extra');
    var pickExtra = peEl ? parseInt(peEl.value || '0', 10) : 0;

    // Always prefer the MAIN table explicitly; fallback to the last .skai-skiphit table if not found
    var mainTable = document.querySelector('.skai-skiphit--main .skai-table');
    if (!mainTable) {
      var allSkai = document.querySelectorAll('.skai-skiphit .skai-table');
      if (allSkai && allSkai.length) mainTable = allSkai[allSkai.length - 1];
    }
    var mainRows = mainTable ? getRankedRows('.skai-skiphit--main .skai-table') : [];
    if (!mainRows.length && mainTable) {
      // fallback: compute rows from the chosen fallback table selector
      mainRows = getRankedRows('.skai-skiphit .skai-table');
    }
    var mainTop  = topLabels(mainRows, pickMain);

    var extraTop = [];
    var ex = document.querySelector('.skai-skiphit--extra .skai-table');
    if (ex && pickExtra > 0){
      extraTop = topLabels(getRankedRows('.skai-skiphit--extra .skai-table'), pickExtra);
    }

    function readNum(id, d){ var el=document.getElementById(id); var v=el && el.value; v=parseInt(v||d,10); return isNaN(v)?d:v; }
    var btWindows = readNum('bt_windows', 50);
    var laplaceK  = readNum('laplace_k', 1);
    var coK       = (function(){ var el=document.querySelector('[name="cooccurrence_window"]'); var v=el && el.value; v=parseInt(v||5,10); return isNaN(v)?5:v; })();

    var numbersPayload = {
      main_numbers:  mainTop,
      extra_numbers: extraTop,
      meta: { analysis: 'skip_hit', pick_main: pickMain, pick_extra: pickExtra }
    };
    var evidence = {
      version: 'skai_evidence_v1',
      analysis: 'skip_hit',
      knobs: { bt_windows: btWindows, laplace_k: laplaceK, cooc_k: coK },
      picks: { main: mainTop, extra: extraTop }
    };

    var nj = qs('skai-numbers-json'), tj = qs('skai-top-combos-json');
    if (!nj || !tj) return {ok:false, msg:'Form inputs missing.'};
    nj.value = JSON.stringify(numbersPayload);
    tj.value = JSON.stringify(evidence);

    // NEW: Fill first-class fields the server expects
    var mJson = qs('skai-main-json');
    var eJson = qs('skai-extra-json');
    if (mJson) mJson.value = JSON.stringify(mainTop);
    if (eJson) eJson.value = JSON.stringify(extraTop);

    // Back-compat CSV mirrors
    var mainCsv  = (mainTop||[]).join(',');
    var extraCsv = (extraTop||[]).join(',');
    var mEl = document.getElementById('skai-main-csv');
    var eEl = document.getElementById('skai-extra-csv');
    if (mEl) mEl.value = mainCsv;
    if (eEl) eEl.value = extraCsv;

    // Best-effort draws_analyzed (in case server can't resolve)
    var dEl = document.getElementById('skai-draws-analyzed');
    if (dEl) {
      var guess = Array.isArray(mainRows) ? mainRows.length : (parseInt(dEl.value||'0',10)||0);
      // don't overwrite if server already filled a larger/real value
      if (guess > parseInt(dEl.value||'0',10)) dEl.value = guess;
    }

    // Populate risk_profile and strategy from current UI selection
    try {
      var profileBtn = document.querySelector('#skai-profile-buttons .btn-chip[aria-pressed="true"]');
      var profileVal = profileBtn ? (profileBtn.getAttribute('data-profile') || 'balanced') : 'balanced';
      var profileEl = document.getElementById('skai-risk-profile');
      if (profileEl) profileEl.value = profileVal;

      var strategyBtn = document.querySelector('#skai-strategy-buttons .btn-chip[aria-pressed="true"]');
      var strategyVal = strategyBtn ? (strategyBtn.getAttribute('data-strategy') || 'hybrid') : 'hybrid';
      var strategyEl = document.getElementById('skai-strategy');
      if (strategyEl) strategyEl.value = strategyVal;
    } catch(_) {}

    var submitBtn = qs('skai-submit-save'), hint = qs('skai-save-hint');
    if (submitBtn) submitBtn.disabled = false;
    if (hint) hint.textContent = 'Ready to save: ' + mainTop.length + ' main' + (extraTop.length? (' + ' + extraTop.length + ' extra') : '');
    return {ok:true};
  }

  function init(){
    var build = qs('skai-build-payload'), form  = qs('skai-save-form');
    if (!form || !build) return;

    build.addEventListener('click', function(){
      var res = buildPayload();
      if (!res.ok){ var hint = qs('skai-save-hint'); if (hint) hint.textContent = res.msg; }
    });

    form.addEventListener('submit', function(e){
      var nj = qs('skai-numbers-json'), tj = qs('skai-top-combos-json');
      if (!nj || !tj || !nj.value || !tj.value){
        e.preventDefault();
        var res = buildPayload();
        if (!res.ok){ var hint = qs('skai-save-hint'); if (hint) hint.textContent = 'Please click “Build from table” first.'; }
      }
    });
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
<!-- Open script with data attribute to avoid PHP interpolation inside JS -->
<script data-skai-rows="<?php echo (int) $rowsCount; ?>">
(function(){
  'use strict';

  // rows available for tuning/backtest (read from data attribute)
  var rowsRaw = parseInt(
    (document.currentScript && document.currentScript.getAttribute('data-skai-rows')) || '0',
    10
  ) || 0;

  // Hard cap: Auto-Tune and sliders MUST NOT test windows above this value.
  var hardCap = 2000;

  // Ensure global SKAI_LIMITS exists and enforce the hard cap.
  window.SKAI_LIMITS = window.SKAI_LIMITS || {};
  window.SKAI_LIMITS.maxTuneWindows = hardCap;

  // rowsCapped is what every other module sees as "rowsAvailable" for tuning.
  var rowsCapped = Math.max(0, Math.min(rowsRaw, hardCap));
  window.SKAI_LIMITS.rowsAvailable       = rowsCapped;
  window.SKAI_LIMITS.effectiveMaxWindow  = rowsCapped; // alias for optimizers

  // Clamp the Window (WWW) control(s) to DB rows (capped), min = 5
  function clampWindow(){
    try {
      var ids = ['windowSize_ui','windowSize','skai-window','window'];
      for (var i = 0; i < ids.length; i++){
        var el = document.getElementById(ids[i]);
        if (!el) continue;
        var min = 5;
        var max = Math.max(min, rowsCapped);
        el.setAttribute('min', String(min));
        el.setAttribute('max', String(max));
        // fix current value if out of bounds
        var v = parseInt(String(el.value || '0'), 10);
        if (!isFinite(v) || v < min) v = min; // ES5-safe finite check
        if (v > max) v = max;
        el.value = String(v);
        // a11y hint
        if (!el.getAttribute('aria-label')){
          el.setAttribute('aria-label', 'Window of past draws used for analysis');
        }
      }
    } catch (e) { /* swallow to avoid UI breakage */ }
  }

  if (document.readyState !== 'loading') {
    clampWindow();
  } else {
    document.addEventListener('DOMContentLoaded', clampWindow, { once: true });
  }
})();
</script>


<script>
(function(){
  window.SKAI_PI = window.SKAI_PI || { leaderboard:[] };

  // De-dupe by window "w": replace existing row if new mean is higher; keep list = 200
  function onCand(e){
    try{
      var d=(e&&e.detail)||{};
      var w=(d.window|0);
      var row={
        w:w,
        mean:+(d.avgScore||0),
        mainAvg:+(d.mainAvg||0),
        bonusAvg:+(d.bonusAvg||0),
        cases:+(d.cases||0)
      };
      var L=window.SKAI_PI.leaderboard;
      var idx=-1; 
      for(var i=0;i<L.length;i++){ 
        if(((L[i]&&L[i].w)|0)===w){ idx=i; break; } 
      }
      if(idx>=0){
        // keep the higher-scoring version for this window
        if(+row.mean > +(L[idx].mean||0)) L[idx]=row;
      }else{
        L.push(row);
        if(L.length>200){ L.shift(); }
      }
    }catch(_){}
  }

  // Bind once
  window.addEventListener("skai:autotune:candidate", onCand, false);
})();
</script>

<script>
// Evidence-on-submit helper: populate hidden "top_combos_json" with skai_evidence_v1
(function () {
  "use strict";
  // [DEDUPLICATION GUARD]
  // Reason/benefit: if this script is printed twice, we must not attach two submit listeners.
  if (window.__skaiEvidenceOnSubmitWired) { return; }
  window.__skaiEvidenceOnSubmitWired = true;

  function ensureHiddenInput(f) {
    // Use simple, unescaped querySelector to keep PHP designers happy
    var h = f.querySelector("input[name='top_combos_json']");
    if (!h) {
      h = document.createElement("input");
      h.type = "hidden";
      h.name = "top_combos_json";
      f.appendChild(h);
    }
    return h;
  }

  function topN(arr, n) {
    var a = (arr || []).slice(0);
    a.sort(function (x, y) {
      return (y.mean - x.mean) || ((y.w | 0) - (x.w | 0));
    });
    return a.slice(0, Math.max(0, n | 0));
  }

  // Mini "why" chips renderer (no-op if container missing)
  function renderChips(evd) {
    try {
      var host = document.getElementById("skaiEvidenceChips")
        || document.querySelector(".skai-evidence-chips")
        || document.querySelector("#prediction")
        || document.querySelector(".skai-ai-main");

      if (!host) return;

      var box = document.createElement("div");
      box.className = "skai-why-chips";
      box.setAttribute("role", "list");

      var details = [];
      if (evd && evd.sources && evd.sources.skip_hit && Array.isArray(evd.sources.skip_hit.details)) {
        details = evd.sources.skip_hit.details;
      }

      for (var i = 0; i < details.length; i++) {
        var d = details[i] || {};
        var label = d.label != null ? String(d.label) : "";
        var value = d.value != null ? String(d.value) : "";

        var chip = document.createElement("span");
        chip.className = "skai-chip";
        chip.setAttribute("role", "listitem");

        var text = label;
        if (value !== "") {
          text = label ? (label + ": " + value) : value;
        }
        chip.appendChild(document.createTextNode(text));
        box.appendChild(chip);
      }

      var old = host.querySelector(".skai-why-chips");
      if (old && old.parentNode) old.parentNode.removeChild(old);
      host.appendChild(box);
    } catch (e) {
      // swallow to avoid UI breakage
    }
  }

  function buildEvidence() {
    var tunedW = (function () {
      var a = document.documentElement.getAttribute("data-skai-window");
      var v = a ? parseInt(a, 10) : NaN;
      if (isFinite(v) && v > 0) return v; // ES5-safe
      var S = (window.SKAI_SERVER || {});
      return (+S.tunedWindow) || (+S.usedWindow) || (+S.bestWindow) || null;
    })();

    var board = topN((window.SKAI_PI && window.SKAI_PI.leaderboard) || [], 10);

    var pattern = (function () {
      try {
        var curr = (window.SKAI_FEATURES && window.SKAI_FEATURES.main && window.SKAI_FEATURES.main.currSkip) || {};
        var ks = [];
        for (var key in curr){
          if (!Object.prototype.hasOwnProperty.call(curr, key)) continue;
          ks.push(+curr[key] || 0);
        }
        if (!ks.length) {
          return "Pattern is unclear right now; results are mixed.";
        }

        var sum = 0, i;
        for (i = 0; i < ks.length; i++) sum += ks[i];
        var m = sum / ks.length;

        var varsum = 0;
        for (i = 0; i < ks.length; i++){
          var d = ks[i] - m; varsum += d * d;
        }
        var sd = Math.sqrt(varsum / ks.length);

        // Friendlier, plain-English pattern descriptions for end users
        if (sd < 2) {
          return "These numbers have been very stable lately (small swings between hits).";
        }
        if (sd > 5) {
          return "These numbers are spiking and swinging a lot right now (high volatility).";
        }
        return "These numbers are in a transition phase, moving between quiet and active periods.";
      } catch (e) {
        return "Pattern is unclear right now; results are mixed.";
      }
    })();

    var F = (window.SKAI_FEATURES || {});
    var M = (F.main || {});
    var H = (M.hist || {});
    var C = (M.currSkip || {});
    var DC = (M.drawCounts || {});
    var numbers = Object.keys(DC).map(function (k) { return parseInt(k, 10); })
      .filter(function (x) { return isFinite(x); }); // ES5-safe

    var detailList = [];

    // Frequency tilt
    try {
      var freqs = numbers.map(function (n) { return +DC[n] || 0; })
        .sort(function (a, b) { return a - b; });
      var meanF = freqs.length ? (freqs.reduce(function (a, b) { return a + b; }, 0) / freqs.length) : 0;
      var medF = freqs.length ? freqs[Math.floor(freqs.length / 2)] : 0;
      var tilt = medF > 0 ? ((meanF / medF) - 1) : 0;
      detailList.push({
        key: "freq_tilt",
        label: "Frequency tilt",
        value: (tilt > 0 ? "+" : "") + (tilt * 100).toFixed(1) + "%"
      });
    } catch (e) { }

    // Recent hits (% skip <= 2)
    try {
      var recent = numbers.filter(function (n) { return (+C[n] || 0) <= 2; }).length;
      var pct = numbers.length ? (recent * 100 / numbers.length) : 0;
      detailList.push({
        key: "recent_hits",
        label: "Recent hits",
        value: pct.toFixed(1) + "%"
      });
    } catch (e) { }

    // Favorable skips
    try {
      var good = 0;
      var tot = 0;
      numbers.forEach(function (n) {
        var k = +C[n];
        if (!isFinite(k)) return; // ES5-safe
        var bins = H[n] || {};
        var keys = Object.keys(bins);
        if (!keys.length) return;
        tot++;
        var avg = keys.reduce(function (a, b) { return a + (+bins[b] || 0); }, 0) / keys.length;
        var pk = +bins[k];
        if (isFinite(pk) && pk > avg) good++; // ES5-safe
      });
      var gPct = tot ? (good * 100 / tot) : 0;
      detailList.push({
        key: "favorable_skips",
        label: "Favorable skips",
        value: gPct.toFixed(1) + "%"
      });
    } catch (e) { }

    var S = (window.SKAI_SERVER || {});
    var W = ((S.CONFIG || {}).weights || {});
    var lapK = +S.laplaceK;
    if (!isFinite(lapK)) lapK = 1; // ES5-safe

    return {
      version: "skai_evidence_v1",
      tuned_window: tunedW,
      // Keep friendly explanation in `label`, but also store short canonical PI state.
      // Reason/benefit: helps server-side save handler map to DB `label` reliably.
      pattern_intelligence: {
        label: pattern,
        short_label: (window.SKAI_PI_LABEL || "Unknown"),
        leaderboard: board
      },
      sources: {
        skip_hit: {
          ok: true,
          details: detailList,
          meta: {
            k: lapK,
            window: tunedW,
            weights: {
              frequency: +(W.frequency || 0),
              skip: +(W.skip || 0),
              historical: +(W.historical || 0)
            }
          }
        },
        ml: true
      },
      generated_at: (new Date()).toISOString()
    };
  }

  // --- helper: compute micro-evidence for a single combo {main:[], bonus:[]} ---
  function comboEvidence(c) {
    try {
      var F = (window.SKAI_FEATURES || {});
      var M = (F.main || {});
      var H = (M.hist || {});
      var C = (M.currSkip || {});
      var DC = (M.drawCounts || {});
      var nums = Array.isArray(c.main) ? c.main.slice(0) : [];
      var extras = Array.isArray(c.bonus) ? c.bonus.slice(0) : [];

      var pkSum = 0;
      var pkCnt = 0;
      nums.forEach(function (n) {
        var k = +C[n];
        if (!isFinite(k)) return; // ES5-safe
        var bins = H[n] || {};
        var p = +bins[k];
        if (isFinite(p)) { // ES5-safe
          pkSum += p;
          pkCnt++;
        }
      });

      var avgPk = pkCnt ? (pkSum / pkCnt) : 0;

      var recent = nums.filter(function (n) { return (+C[n] || 0) <= 2; }).length;
      var recPct = nums.length ? (recent * 100 / nums.length) : 0;

      var fvs = nums.map(function (n) { return +DC[n] || 0; });
      var maxF = fvs.length ? Math.max.apply(null, fvs) : 0;
      var freqScore = (fvs.length && maxF > 0)
        ? (fvs.reduce(function (a, b) { return a + b; }, 0) / (fvs.length * maxF))
        : 0;

      return {
        avg_pk: +avgPk.toFixed(4),
        recent_pct: +recPct.toFixed(1),
        freq_score: +freqScore.toFixed(3),
        extra: extras
      };
    } catch (e) {
      return { avg_pk: 0, recent_pct: 0, freq_score: 0, extra: [] };
    }
  }

  // --- helper: try to read combos from the DOM (non-breaking if none) ---
  function readDomCombos() {
    var out = [];

    // ES5-safe helper defined once (avoid \d escaping issues in echoed JS)
    function toList(s) {
      return String(s || "")
        .split(/[^0-9]+/) // avoid backslash escapes like \d which can break in PHP/Sorcerer echoes
        .map(function (x) {
          var v = parseInt(x, 10);
          return isFinite(v) ? v : null; // ES5-safe
        })
        .filter(function (v) { return v !== null; });
    }

    try {
      var rows = document.querySelectorAll("[data-skai-combo],[data-combo],.skai-combo");
      for (var r = 0; r < rows.length; r++) { // ES5-safe NodeList loop
        var node = rows[r];
        var m = node.getAttribute("data-main") || node.getAttribute("data-combo") || "";
        var b = node.getAttribute("data-bonus") || "";

        var main  = toList(m);
        var bonus = toList(b);

        if (main.length) out.push({ main: main, bonus: bonus, _el: node });
      }
    } catch (e) { /* soft-fail */ }

    return out;
  }

  function wireEvidence() {
    document.addEventListener("submit", function (ev) {
      var f = ev.target;
      if (!f || !f.querySelector("input[name='save_set']")) return;
      try {
        var h = ensureHiddenInput(f);
        var evd = buildEvidence();

        var domCombos = readDomCombos();
        var combos = domCombos.length ? domCombos : [];
        combos.forEach(function (c) {
          c._evidence = comboEvidence({ main: c.main, bonus: c.bonus });
        });

        if (combos.length) {
          evd.combos = combos.map(function (c) {
            return { main: c.main, bonus: c.bonus, evidence: c._evidence };
          });
          try { renderComboChips(combos); } catch (e) { }
        }

        try { renderChips(evd); } catch (e) { }
        try {
          window.dispatchEvent(new CustomEvent("skai:evidence:built", { detail: evd }));
        } catch (e) { }

        h.value = JSON.stringify(evd);
      } catch (e) { }
    }, true);
  }

  if (document.readyState !== "loading") {
    wireEvidence();
  } else {
    document.addEventListener("DOMContentLoaded", wireEvidence, { once: true });
  }
})();
</script>

<!-- --- A11y: label combo rows so chips are announced properly by AT --- -->
<script id="skai-combo-a11y">
(function(){
  "use strict";
  var once = window.SKAI_ONCE || window.__skaiOnce;
  if (once && !once("combo-a11y")) return;
  function toList(s){
    return String(s||"").split(/[^\d]+/)
      .map(function(x){
        var v = parseInt(x,10);
        return isFinite(v) ? v : null; // ES5-safe
      })
      .filter(function(v){ return v !== null; });
  }
  function labelFor(main,bonus){
    // Fallback text uses plain ASCII for accessibility instead of ?
    var base = "Combo: " + (main && main.length ? main.join("-") : "(no main numbers)");
    if(Array.isArray(bonus) && bonus.length){ base += " (+ " + bonus.join(", ") + ")"; }
    return base;
  }
  function applyA11y(){
    try{
      var rows = document.querySelectorAll("[data-skai-combo],[data-combo],.skai-combo");
      for (var i = 0; i < rows.length; i++){
        var node = rows[i];
        var main = toList(node.getAttribute("data-main")||node.getAttribute("data-combo")||"");
        var bonus = toList(node.getAttribute("data-bonus")||"");
        var lbl = labelFor(main, bonus);
        node.setAttribute("role","group");
        node.setAttribute("aria-label", lbl);
      }
    }catch(_){}
  }
  if(document.readyState!=="loading") applyA11y();
  else document.addEventListener("DOMContentLoaded", applyA11y, {once:true});
})();
</script>

<!-- --- A11y tooltip helper: attach to .skai-chip elements (keyboard + mouse) --- -->
<script id="skai-why-tip">
(function(){
  "use strict";
  // Dedupe guard: prefer SKAI_ONCE, then __skaiOnce, else local once
  var __whyOnce = (window.SKAI_ONCE || window.__skaiOnce);
  if (__whyOnce) {
    if (!__whyOnce("why-tip")) return;
  } else {
    if (window.__skaiWhyTipWired) return;
    window.__skaiWhyTipWired = true;
  }

  var TIP_ID = "skai-tip";
  var ATTR   = "data-why";

  function ensureTip(){
    var t = document.getElementById(TIP_ID);
    if (!t){
      t = document.createElement("div");
      t.id = TIP_ID;
      t.setAttribute("role","tooltip");
      t.setAttribute("hidden","");
      // minimal inline styling so it doesn't affect layout
      t.style.position = "fixed";
      t.style.zIndex = "9999";
      t.style.background = "#111827";
      t.style.color = "#fff";
      t.style.fontSize = "12px";
      t.style.padding = "6px 8px";
      t.style.borderRadius = "6px";
      t.style.maxWidth = "260px";
      t.style.pointerEvents = "none";
      document.body.appendChild(t);
    }
    return t;
  }

  function placeTip(t, x, y){
    var pad = 10;
    var vw  = window.innerWidth  || 1024;
    var vh  = window.innerHeight || 768;
    var rect = t.getBoundingClientRect();
    var left = Math.min(vw - rect.width  - pad, Math.max(pad, x));
    var top  = Math.min(vh - rect.height - pad, Math.max(pad, y));
    t.style.left = left + "px";
    t.style.top  = top  + "px";
  }

  function showFor(node, evt){
    var tip = ensureTip();
    var msg = node.getAttribute(ATTR) || node.textContent || "Why this pick";
    tip.textContent = msg;
    tip.removeAttribute("hidden");
    node.setAttribute("aria-describedby", TIP_ID);

    var r = node.getBoundingClientRect();
    var x = (evt && evt.clientX) || (r.left + 8);
    var y = (evt && evt.clientY) || (r.top  + 28);
    placeTip(tip, x, y);
  }

  function hide(){
    var tip = document.getElementById(TIP_ID);
    if (tip){
      tip.setAttribute("hidden","");
    }
  }

  function enhance(container){
    if (!container || container.getAttribute("data-skai-chips-enhanced")==="1") return;
    container.setAttribute("data-skai-chips-enhanced","1"); // dedupe guard

    var chips = container.querySelectorAll(".skai-chip");
    for (var i=0; i<chips.length; i++){
      (function(c){
        if (!c.hasAttribute("tabindex")) c.setAttribute("tabindex","0");
        if (!c.hasAttribute(ATTR)){
          c.setAttribute(ATTR, (c.getAttribute("title")||c.textContent||"Why this pick").trim());
        }

        c.addEventListener("mouseenter", function(e){ showFor(c,e); }, false);
        c.addEventListener("mouseleave", hide, false);
        c.addEventListener("focus",     function(e){ showFor(c,e); }, true);
        c.addEventListener("blur",      hide, true);
        c.addEventListener("keydown",   function(e){
          if (e.key === "Escape"){ hide(); try{ c.blur(); }catch(_){} }
        }, false);
      })(chips[i]);
    }
  }

  function boot(){
    try{
      var boxes = document.querySelectorAll(".skai-combo-why");
      for (var i=0; i<boxes.length; i++){ enhance(boxes[i]); }

      window.addEventListener("skai:picks:ready", function(){
        var b1 = document.querySelectorAll(".skai-combo-why");
        for (var i=0; i<b1.length; i++){ enhance(b1[i]); }
      }, false);

      window.addEventListener("skai:ml:done", function(){
        var b2 = document.querySelectorAll(".skai-combo-why");
        for (var i=0; i<b2.length; i++){ enhance(b2[i]); }
      }, false);
    }catch(_){}
  }

  if (document.readyState !== "loading") boot();
  else document.addEventListener("DOMContentLoaded", boot, {once:true});
})();
</script>

<!-- =======================
     SKAI: UI & Controls
     ======================= -->
<script>
/* --- FIX: normalize FEATURES to an object; some code rejects arrays --- */
(function(){
  try {
 // Ensure global bootstrap exists even if later <script> block didn't run yet
    if (typeof window.SKAI_SERVER === 'undefined') { window.SKAI_SERVER = { CONFIG: {} }; }
    if (!window.SKAI_SERVER.CONFIG) { window.SKAI_SERVER.CONFIG = {}; }

    // Prefer SKAI_SERVER.FEATURES if present, else SKAI_FEATURES; coerce to plain object
    var raw = (typeof window.SKAI_SERVER !== 'undefined' && window.SKAI_SERVER.FEATURES != null)
      ? window.SKAI_SERVER.FEATURES
      : (window.SKAI_FEATURES != null ? window.SKAI_FEATURES : {});
    var obj;
    if (Array.isArray(raw)) {
      // Convert [{name: 'foo', value: 1}, ...] ? { foo: 1, ... } OR fallback to index keys
      obj = {};
      for (var i=0; i<raw.length; i++){
        var it = raw[i];
        if (it && typeof it === 'object' && 'name' in it) {
          obj[String(it.name)] = ('value' in it ? it.value : it.val);
        } else {
          obj[String(i)] = it;
        }
      }
    } else if (raw && typeof raw === 'object') {
      obj = raw;
    } else {
      obj = {};
    }
    // Safe publish (SKAI_SERVER present from guard above)
    window.SKAI_SERVER.FEATURES = obj;
    window.SKAI_FEATURES = obj; // keep the mirror the runner expects
  } catch(_){}
})();
</script>

<script>
/* ==========================================================
   SKAI JS Block E: Canonical Config Publish (Server ? Client)
   Purpose:
     - Publish one unified SKAI_CONFIG / SKAI_SERVER.CONFIG
     - Ensure runner sees {gameId, rules, features}
   Depends on:
     - PHP-injected values already printed
     - window.SKAI_FEATURES possibly set by features bridge
   Exposes (globals):
     - window.SKAI_CONFIG
     - window.SKAI_getConfig()
     - window.SKAI_SERVER.CONFIG
   Notes:
     - Must run before ML runner reads config.
   ========================================================== */
/* --- FIX: publish the unified configuration the runner requires (no nested Sorcerer tags) --- */
(function(){
  var once = window.__skaiOnce || window.SKAI_ONCE;

  if (once && !once('config-publish')) return; // dedupe guard (resilient)
  try {
    var gameId = <?php echo json_encode(isset($gameId) ? (string)$gameId : (string)($lotteryConfig['game_id'] ?? '')); ?>;
    if (typeof window.SKAI_SERVER === 'undefined') { window.SKAI_SERVER = { CONFIG: {} }; }
    if (!window.SKAI_SERVER.CONFIG) { window.SKAI_SERVER.CONFIG = {}; }

    var rules = {
      pick:         Number(<?php echo (int)$pickSize; ?>),
      domain:       Number(<?php echo (int)$mainMax; ?>),
      hasExtraBall: <?php echo $hasExtra ? 'true' : 'false'; ?>,
      extraDomain:  Number(<?php echo (int)$extraMax; ?>)
    };

    var features = (window.SKAI_FEATURES && typeof window.SKAI_FEATURES === 'object') ? window.SKAI_FEATURES : {};

    window.SKAI_CONFIG = { gameId: gameId, rules: rules, features: features };
    window.SKAI_SERVER.CONFIG.gameId   = gameId;
    window.SKAI_SERVER.CONFIG.rules    = rules;
    window.SKAI_SERVER.CONFIG.features = features;
    window.SKAI_FEATURES = features;

    if (typeof window.SKAI_getConfig !== 'function') {
      window.SKAI_getConfig = function(){ return window.SKAI_CONFIG; };
    }
    if (typeof window.SKAI_configDetailPrefix !== 'function') {
      window.SKAI_configDetailPrefix = function(cfg){
        try { return (cfg && cfg.gameId) ? ('[' + String(cfg.gameId) + '] ') : ''; } catch(_) { return ''; }
      };
    }
  } catch(_){}
})();
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block R4: Features Bridge / Normalizer
   Purpose:
     - Publishes SKAI_SERVER.FEATURES from PHP
     - Coerces FEATURES to a plain object for stable reads
   Depends on:
     - PHP-injected $SKAI_FEATURES
     - __skaiOnce / SKAI_ONCE dedupe
   Exposes (globals):
     - window.SKAI_SERVER.FEATURES
     - window.SKAI_FEATURES (mirror)
   Notes:
     - Used by PI badge, runner validation, optimizer scoring.
   ========================================================== */
/* --- FIX: features bridge (no nested Sorcerer tags) --- */
(function(){
  var once = window.__skaiOnce || window.SKAI_ONCE;
  if (once && !once('features-bridge')) return; // dedupe guard (resilient)
  window.SKAI_SERVER.FEATURES = <?php echo json_encode(

    $SKAI_FEATURES ?? [],
    JSON_UNESCAPED_SLASHES
    | JSON_HEX_TAG
    | JSON_HEX_APOS
    | JSON_HEX_AMP
    | JSON_HEX_QUOT
  ); ?>;

  // -then re-normalize to a plain object if needed (keeps earlier FIX effective)
  try {
    var raw = window.SKAI_SERVER.FEATURES;
    var obj;
    if (Array.isArray(raw)) {
      obj = {};
      for (var i = 0; i < raw.length; i++) {
        var it = raw[i];
        if (it && typeof it === "object" && "name" in it) {
          obj[String(it.name)] = ("value" in it ? it.value : it.val);
        } else {
          obj[String(i)] = it;
        }
      }
    } else if (raw && typeof raw === "object") {
      obj = raw;
    } else {
      obj = {};
    }
    window.SKAI_SERVER.FEATURES = obj;
    window.SKAI_FEATURES = obj; // canonical single source
  } catch(_){
    window.SKAI_FEATURES = window.SKAI_SERVER.FEATURES || {};
  }

  if (typeof window.SKAI_SERVER.confidence === 'undefined') {
    window.SKAI_SERVER.confidence = null;
  }

  if (typeof window.__SKAI_AT_SETTINGS_REQUIRED__ === 'undefined') window.__SKAI_AT_SETTINGS_REQUIRED__ = true;
  if (typeof window.__SKAI_AT_SETTINGS_APPLIED__  === 'undefined') window.__SKAI_AT_SETTINGS_APPLIED__  = false;

  window.SKAI_APPLY_SETTINGS_OK = function(){
    try {
      window.__SKAI_AT_SETTINGS_APPLIED__ = true;
      if (typeof window.SKAI_emit === 'function') {
        window.SKAI_emit('skai:settings:applied', { detail:{ ok:true } });
      } else {
        window.dispatchEvent(new CustomEvent('skai:settings:applied', { detail:{ ok:true } }));
      }
    } catch(_){}
  };

  window.addEventListener('skai:settings:applied', function(){
    try {
     window.__SKAI_AT_SETTINGS_APPLIED__ = true;
      if (window.__SKAI_DEFER_START__) window.__SKAI_DEFER_START__ = false;
      var live = document.getElementById('ai-live-status');
      if (live) {
        // UX: clearer, brand-aligned message after Auto-Tune/settings are applied
        live.textContent = 'Settings updated. SKAI is tuned for your next run - press "Run Prediction" when you are ready.';
      }
    } catch(_){}
  });

  window.__SKAI_STRICT__ = true; // hard-set for strict sequencing
})();
</script>

<script>
// --- SKAI bootstrap (must run before any code reads SKAI_SERVER / FEATURES) ---
window.SKAI_SERVER   = window.SKAI_SERVER   || {};
window.SKAI_FEATURES = window.SKAI_FEATURES || {};
</script>


<script>
/* ==========================================================
   SKAI Runner/Optimizer Block R3: SKAI_META (Server ? Client)
   Purpose:
     - Publishes core lottery meta (domain, pick, extra flags, ranges)
     - Canonical meta for TFJS helpers + runner checks
   Depends on:
     - PHP values echoed inside this block
     - Optional dedupe via window.__skaiOnce
   Exposes (globals):
     - window.SKAI_META
   Notes:
     - Must remain before ML/runner logic reads SKAI_META.
   ========================================================== */
// Bridge Section 2 PHP data to the client-side ML code.
// The TFJS helpers expect these globals.
if (window.__skaiOnce && !window.__skaiOnce("skai-meta-bridge")) { /* dedupe */ }
else {
window.SKAI_META = {


  domain:       <?php echo (int)$mainMax; ?>,        // main ball max (e.g., 70)
  pick:         <?php echo (int)$pickSize; ?>,       // how many main balls drawn
  hasExtraBall: <?php echo $hasExtra ? 'true' : 'false'; ?>,
  extraDomain:  <?php echo (int)$extraMax; ?>,       // extra ball max (e.g., 26/35)
  allowZero:    <?php echo (($mainMax > 0 && $mainMax <= 9 && !$hasExtra) ? 'true' : 'false'); ?>, // 0-based games without extra ball
  // explicit extra diagnostics for UI logic
  extraHasHistory: <?php echo (!empty($fullExtraHistory) && is_array($fullExtraHistory) && count($fullExtraHistory) > 0) ? 'true' : 'false'; ?>,
  extraCols: <?php echo json_encode($extraBallCols, JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT); ?>,
  extraLabel: <?php echo json_encode((string)($lotteryConfig['extra_ball_label'] ?? 'Extra Ball'), JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT); ?>,
  isDaily: <?php echo (!empty($lotteryConfig['is_daily']) || !empty($lotteryConfig['isDaily'])) ? 'true' : 'false'; ?> // daily digit game flag from JSON config
};

// Client-side history arrays used by buildSkaiDataset()
window.draws = <?php echo json_encode(
    $fullMainHistory,
    JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT
); ?>;        // [{numbers:[...], date:"..."}]

window.extraDraws = <?php echo json_encode(
    $fullExtraHistory,
    JSON_UNESCAPED_SLASHES | JSON_HEX_TAG | JSON_HEX_APOS | JSON_HEX_AMP | JSON_HEX_QUOT
); ?>;  // [{number:int|null, date:"..."}]
} // end dedupe guard
</script>


<script>
/* ==========================================================
   SKAI JS Block C: TensorFlow.js Loader / EnsureTF
   Purpose:
     - Inject TFJS once, CSP/nonce-aware
     - Return a promise that resolves after tf.ready()
   Depends on:
     - document.head
   Exposes (globals):
     - window.ensureTF() -> Promise
   Notes:
     - Safe to call multiple times; dedupes internally.
     - Keep before ML runner blocks that call tf.*.
   ========================================================== */
// Minimal TFJS loader (race-safe): single injection, nonce-aware, and tf.ready() await (NO watchdog timeouts)
window.ensureTF = window.ensureTF || (function(){

  var p = null;
  return function(){

    if (window.tf && typeof window.tf.ready === 'function') {
      return window.tf.ready ? window.tf.ready() : Promise.resolve();
    }
    if (p) return p;

    p = new Promise(function(resolve, reject){
      var existing = document.getElementById('tfjs-script');
      var done = false;

      function safeResolve(v){ if (!done){ done = true; resolve(v); } }
      function safeReject(e){ if (!done){ done = true; reject(e); } }

      if (!existing) {
        var s = document.createElement('script');
        s.id = 'tfjs-script';
        s.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js';
        s.async = true;
        s.crossOrigin = 'anonymous';
        try { if (window.__CSP_NONCE) { s.setAttribute('nonce', String(window.__CSP_NONCE)); } } catch(e){}
        s.onload = function(){
          try {
            if (window.tf && typeof window.tf.ready === 'function') {
              window.tf.ready().then(safeResolve).catch(function(e){
                safeReject(new Error('TensorFlow loaded but tf.ready() failed: ' + (e && e.message ? e.message : e)));
              });
            } else { safeResolve(); }
          } catch(e){ safeReject(e); }
        };
        s.onerror = function(){ safeReject(new Error('Failed to load TensorFlow.js (network/CSP).')); };
        document.head.appendChild(s);
      } else {
        // If tag already present, try to await tf.ready(); otherwise resolve when available
        setTimeout(function(){
          if (window.tf && typeof window.tf.ready === 'function') {
            window.tf.ready ? window.tf.ready().then(safeResolve).catch(safeReject) : safeResolve();
          } else {
            // Fallback: script tag exists but tf never initialized ? prevent indefinite hang
            safeReject(new Error('TensorFlow.js script present, but window.tf is unavailable.'));
          }
        }, 100);
      }
    });

    return p;
  };
})();
</script>

<script>
;(function(){
  'use strict';

  if (typeof window.__SKAI_RUN_ACTIVE__ === 'undefined') window.__SKAI_RUN_ACTIVE__ = false;
  if (typeof window.__SKAI_T0__ === 'undefined') window.__SKAI_T0__ = 0;

  // CustomEvent polyfill
  ;(function(){
    if (typeof window.CustomEvent === 'function') return;
    function CustomEvent(type, params){
      params = params || { bubbles:false, cancelable:false, detail:null };
      var evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
      return evt;
    }
    CustomEvent.prototype = window.Event && window.Event.prototype;
    window.CustomEvent = CustomEvent;
  })();

window.setLive = window.setLive || function(msg){
  var text = (msg == null ? '' : String(msg));
  try{
    // Ensure a stable mount to prevent layout jump later
    var area = document.getElementById('ai-status-area');
    if (!area) {
      area = document.createElement('div');
      area.id = 'ai-status-area';
      area.style.minHeight = '24px';
      area.style.marginTop = '8px';
      area.style.display = 'block';
      (document.getElementById('skai-ai-panel') || document.body || document.documentElement).appendChild(area);
    }

    // Ensure the visible line exists
    var line = document.getElementById('ai-live-status');
    if (!line) {
      line = document.createElement('span');
      line.id = 'ai-live-status';
      line.style.fontSize = '13px';
      line.style.color = '#374151';
      line.style.display = 'block';
      area.appendChild(line);
    }
    line.textContent = text;

    // Mirror to optional screen-reader-only target if present
    var sr = document.getElementById('ai-live-status-sr');
    if (sr) sr.textContent = text;

    try { console.log('[SKAI]', text); } catch(_){}
  }catch(_){}
};

// ? CLOSE the outer IIFE so this script is self-contained.
})(); 
</script>
 
 <script>
/* ==========================================================
   SKAI Runner/Optimizer Block R5: Run Readiness Gate + bootCheck()
   Purpose:
     - Defines SKAI_canRun() gate (settings-applied requirement)
     - Defines bootCheck() readiness state machine
     - Enables/disables Start button based on data + meta availability
   Depends on:
     - window.SKAI_FEATURES / SKAI_SERVER.FEATURES
     - window.draws history
     - window.SKAI_META
     - setLive() shim (early blocks)
   Exposes (globals):
     - window.SKAI_canRun()
     - window.SKAI_bootCheck()
   Notes:
     - This is your -preflight- logic; stability-critical for Pick-5.
   ========================================================== */
// Back-compat alias for any legacy callers
  function setStatus(msg){ window.setLive(msg); }

  function ok(v){ return !(v === undefined || v === null); }

  // --- HARD GATE: Only allow ML/autotune to run when settings are applied AND user confirmed ---
  // Looks for any of these checkboxes (first match wins): [data-skai-confirm], #confirmSettings, #confirm-settings

  function SKAI_canRun(){

    try {
      // Require only: tuned settings applied
      var needApplied = (window.__SKAI_AT_SETTINGS_REQUIRED__ === true);
      var applied     = (window.__SKAI_AT_SETTINGS_APPLIED__  === true);
      if (needApplied && !applied) return { ok:false, reason:'Settings not applied yet' };

      // Checkbox no longer required
      return { ok:true };
    } catch(_){
      return { ok:true };
    }
  }

  // Expose the gate globally so any SKAI module (buttons, UI, workers)
  // can enforce the same "tuned settings must be applied" rule.
  try {
    window.SKAI_canRun = SKAI_canRun;
  } catch(_){}

  (function(){
    function guard(evt){
    try {
      // If a run is already active, do not block progress/phase events.
      if (window.__SKAI_RUN_ACTIVE__ === true) { return; }

      var g = SKAI_canRun();
      if (!g.ok){
        if (evt && typeof evt.stopImmediatePropagation === 'function') evt.stopImmediatePropagation();
        if (evt && typeof evt.preventDefault === 'function') evt.preventDefault();
        var msg = (g.reason === 'Settings not applied yet')
          ? 'Apply your tuned settings, then press "Run Prediction".'
          : 'Press "Run Prediction" to proceed.';
        if (typeof window.setLive === 'function') window.setLive(msg);
      }
    } catch(_){}
  }

  // Common start-ish signals to guard; avoid capturing autotune begin (can block it)
  var names = ['skai:request-start', /* 'skai:autotune:begin', */ 'skai:ml:start'];
  names.forEach(function(n){
    window.addEventListener(n, guard, true); // capture phase to preempt others
  });
})();

function bootCheck(){
    var F = (window.SKAI_FEATURES || (window.SKAI_SERVER && window.SKAI_SERVER.FEATURES)) || null;
    var X = F && Array.isArray(F.x) ? F.x : null;
    var dim = (F && (F.inputDim || (X ? X.length : 0))) || 0;
    var draws = window.draws || [];
    var meta = window.SKAI_META || {};

    if (!F) {
      // UX: clearer message while SKAI prepares feature data
      setStatus('SKAI is preparing your data and features...');
      return false;
    }
    if (!X || dim === 0) {
      // UX: avoid exposing dim; just explain we are loading
      setStatus('SKAI is loading draw history and building its inputs...');
      return false;
    }
    if (!Array.isArray(draws) || draws.length === 0) {
      // UX: user-friendly copy while raw draws load
      setStatus('SKAI is still loading your historical draws...');
      return false;
    }

    if (!(ok(meta.domain) && ok(meta.pick))) {
      // UX: more natural wording for game setup
      setStatus('Setting up game rules and number ranges...');
      return false;
    }

    // CHG: fix user-facing typo (brand + clarity).
    setStatus('SKAI is ready. When you\'re happy with the settings, press "Run Prediction".');

    // Enable the canonical Run button now that features are ready
    try {
      var btn = document.getElementById('startPrediction');
      if (btn) {
        btn.disabled = false;
        btn.classList.add('skai-btn--ready');
      }
    } catch(_) {}

    // Safe emit: use SKAI_emit if present, else dispatch CustomEvent directly
    (function safeEmit(name, detail){
      try{
        if (typeof window.SKAI_emit === 'function') {
          window.SKAI_emit(name, { detail: detail });
        } else {
          window.dispatchEvent(new CustomEvent(name, { detail: detail }));
        }
      }catch(_){}
    })('skai:boot-ready', { inputDim: dim, draws: draws.length });

    return true;
  }

  // Disable automatic boot-time checks: SKAI should stay idle until the user explicitly clicks "Run Prediction".
  // Expose bootCheck only for manual/debug usage if ever needed.
  window.SKAI_bootCheck = bootCheck;

</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block R6: Main Prediction Runner Entry
   Purpose:
     - Handles canonical Run Prediction click (onStartClicked)
     - Resets run/autotune flags, starts TFJS, emits lifecycle events
     - Binds #startPrediction and neutralizes duplicates
   Depends on:
     - SKAI_canRun() (Block R5)
     - ensureTF() loader
     - SKAI_CONFIG / SKAI_META already published
   Exposes (globals):
     - None directly (events are the interface)
   Notes:
     - Hotspot for Pick-5 sequencing issues; keep order unchanged.
   ========================================================== */
;(function(){
  'use strict';
    // --- BIND START BUTTONS ---
function onStartClicked(){

  // Enforce global gate (soft): never block completely if the gate is missing or permissive
  var gate;
  try {
    gate = (typeof window.SKAI_canRun === 'function')
      ? window.SKAI_canRun()
      : { ok: true }; // no gate exposed -> do not block
  } catch (_){
    gate = { ok: true };
  }

  if (!gate.ok){
    var msg = (gate.reason === 'Settings not applied yet')
      ? 'Apply your tuned SKAI settings, then press "Run Prediction" to start.'
      : 'SKAI is almost ready. Review your settings, then press "Run Prediction" to proceed.';
    if (typeof window.setLive === 'function') {
      // UX: friendlier guidance when SKAI is not ready to run yet
      window.setLive(msg);
    }
    return; // still respect an explicit hard "no" from SKAI_canRun (if you ever re-enable it)
  }

  if (window.__SKAI_RUN_ACTIVE__) {
    if (typeof window.setLive === 'function') {
      // UX: friendlier message when a run is already in progress
      window.setLive('SKAI is already running a prediction. Please wait for this run to finish.');
    }
    return;
  }
    window.__SKAI_RUN_ACTIVE__ = true;
    window.__SKAI_T0__ = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

    // Reset progress indicator to starting stage (already visible)
    try {
      if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.setStage === 'function') {
        window.SKAI_ProgressIndicator.setStage(0);
        // Clear math console for new run
        if (typeof window.SKAI_ProgressIndicator.clearMathConsole === 'function') {
          window.SKAI_ProgressIndicator.clearMathConsole();
        }
      }
    } catch (_){}

    // Notify cockpit (if present) that a run is starting
    try {
      if (window.SKAI_Cockpit && typeof window.SKAI_Cockpit.startRun === 'function') {
        window.SKAI_Cockpit.startRun();
      }
    } catch (_){}

    // Clean run gating flags
    window.__SKAI_DEFER_START__         = false;
    window.__SKAI_AT_SETTINGS_REQUIRED__ = true;
    window.__SKAI_AT_SETTINGS_APPLIED__  = false;
    window.__SKAI_AUTOTUNE_DONE__        = false;

    // Force a fresh Auto-Tune cycle on every new run
    // (no reuse of stale promise or tuned params between runs)
    try {
      window.SKAI_autotunePromise  = null;   // ensure ensureAutoTune() calls runAutoTune again
      window.SKAI_TUNED_PARAMS     = null;
      window.__SKAI_TUNED_WINDOW__ = null;
    } catch (_) {}

	// Immediately scroll the user into the Prediction Center so they see the run begin
    // Auto-scroll disabled by request; keep the page position stable when the run begins.

    // UX: clearer status when the run is starting
    setStatus('Starting SKAI and getting the AI engine ready...');
    if (typeof window.SKAI_emit === 'function') {
      window.SKAI_emit('skai:start-clicked', { detail:{ source:'user' } });
    } else {
      try {
        window.dispatchEvent(
          new CustomEvent('skai:start-clicked', { detail:{ source:'user' } })
        );
      } catch(_){}
    }

if (typeof window.ensureTF === 'function') {
  window.ensureTF().then(function(){
    // UX: more descriptive success status
    setStatus('AI engine ready. SKAI is preparing your prediction...');

    if (typeof window.SKAI_emit === 'function') {
      window.SKAI_emit('skai:tf-ready', { detail:{ active: !!window.__SKAI_RUN_ACTIVE__ } });
    } else {
      try {
        window.dispatchEvent(
          new CustomEvent('skai:tf-ready', { detail:{ active: !!window.__SKAI_RUN_ACTIVE__ } })
        );
      } catch(_){}
    }
  }).catch(function(e){
    window.__SKAI_RUN_ACTIVE__ = false;
    // UX: softer, user-facing error with a clear next step
    var msg = 'SKAI could not start the AI engine. You can still explore Skip & Hit patterns while we try again.';
    if (e && e.message) {
      msg += ' Details: ' + e.message;
    }
    setStatus(msg);
  });
} else {
  // Fallback when ensureTF shim is absent: consider engine ready to avoid deadlock
  setStatus('AI engine ready. SKAI is preparing your prediction...');
}
} // <-- closes onStartClicked

function bindButtons(){
  // Canonical source-of-truth Start button (only one allowed)
  // Legacy buttons (#runPrediction, #startPredictionSidebar) will be neutralized separately.
  var el = document.querySelector('#startPrediction'); // bind only the first canonical button
  if (!el) return;
  if (!el.__skaiBound){
    el.__skaiBound = true;
    el.addEventListener('click', onStartClicked);
  }

  // If multiple elements with the same ID exist (shouldn't), neutralize extras defensively (no UX change intended).
  var extras = document.querySelectorAll('#startPrediction');
  if (extras && extras.length > 1){
    for (var i = 1; i < extras.length; i++){
      try {
        extras[i].disabled = true;
        extras[i].style.pointerEvents = 'none';
        extras[i].style.opacity = '0.3';
        extras[i].style.display = 'none';
      } catch(_){}
    }
  }
}

  function neutralizeDuplicates(){
    // Disable all non-canonical triggers, including legacy Run buttons.
    // [FIX] Scope to actual controls only so we never hide parameter containers.
    var dupSelectors = [
      '#runPrediction',
      '#startPredictionSidebar',
      '[data-skai-action="train"]',
      '#start-training',
      '#ai-train',
      '.js-start-ml',
      '[data-action*="start-ml"]'
    ].join(', ');

    var nodes = document.querySelectorAll(dupSelectors);
    for (var i=0; i<nodes.length; i++){
      var el = nodes[i];
      try {
        var tag = (el.tagName || '').toUpperCase();
        var isControl =
          tag === 'BUTTON' ||
          tag === 'INPUT'  ||
          tag === 'A'      ||
          el.getAttribute('role') === 'button' ||
          el.matches && el.matches('button, input, a, [role="button"]');

        // Always neuter clickability-
        el.disabled = true;
        el.style.pointerEvents = 'none';
        el.style.opacity = '0.3';

        // -but ONLY remove from layout if it-s truly a trigger/control.
        if (isControl) {
          el.style.display = 'none';
          el.setAttribute('aria-hidden','true');
          el.setAttribute('tabindex','-1');
        } else {
          // Container/parameter card: leave visible to prevent collapses.
          // (Still non-interactive due to pointerEvents=none)
          el.style.display = ''; // ensure not forced hidden
        }
      } catch(_){}
    }
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      bindButtons();
      neutralizeDuplicates();
    }, { once:true });
  } else {
    bindButtons();
    neutralizeDuplicates();
  }

})();
</script>

<script>
// SKAI progress overlay - real-only progress from canonical events; IDs aligned; API = SKAI_Progress.show/set/done
;(function(){
  function clamp01(n){ n = Number(n||0); return n<0?0:n>1?1:n; }

  /* ===== CONFIG SAFETY SHIM (prevents configDetailPrefix missing-or-not-object) ===== */
  (function(){
    try {
      // Prefer your canonical config object if present
      var C = window.SKAI_CONFIG || window.lottoConfig || window.windowConfig || {};
      if (typeof C !== 'object' || C === null) C = {};

      // Normalize frequently-read keys to safe defaults
      if (!('detailPrefix' in C)) C.detailPrefix = '';       // <-- this is the key your logs complain about
      if (!('limits' in C) || typeof C.limits !== 'object') C.limits = {};
      if (!('maxWindow' in C.limits)) C.limits.maxWindow = 4000;  // used by the gauge and some presets

      // Expose back consistently so any SKAI-specific code sees the same object
      window.SKAI_CONFIG  = C;

      // [FIX] Mirror detailPrefix to SKAI_SERVER for reporter parity
      try {
        if (typeof window.SKAI_SERVER === 'object' && window.SKAI_SERVER !== null) {
          if (typeof window.SKAI_SERVER.detailPrefix === 'undefined') {
            window.SKAI_SERVER.detailPrefix = C.detailPrefix || '';
          }
        }
      } catch(_){}

      // IMPORTANT:
      // Do NOT override lottoConfig here. The main AI/lottery loader will
      // set window.lottoConfig later from daily-lotteries.json with the
      // correct mainNumbersMax, ranges, etc. If we pre-fill it, we block
      // the real config and the model sees only a tiny number of classes.
      // window.lottoConfig  = window.lottoConfig || C;

      // Safe to keep a generic windowConfig for internal SKAI usage if needed
      window.windowConfig = window.windowConfig || C;

      // Also keep server meta object defined to avoid hasAutoTune/tuneSucceeded crashes
      if (typeof window.SKAI_SERVER !== 'object' || window.SKAI_SERVER === null) {
        window.SKAI_SERVER = {};
      }
    } catch(_){}
  })();
  /* ===== END CONFIG SAFETY SHIM ===== */
  if (typeof window.__SKAI_RUN_ACTIVE__ === 'undefined') window.__SKAI_RUN_ACTIVE__ = false;
  if (typeof window.__SKAI_T0__ === 'undefined') window.__SKAI_T0__ = 0;

  var _t0 = 0;
  var __lastEta = '-';


  // B-01: helper to pretty-print ETA seconds as "Xm Ys"
  function formatEta(seconds){
    if (!isFinite(seconds) || seconds < 0) return 'n/a';
    var s = Math.round(seconds);
    var m = Math.floor(s / 60);
    var r = s % 60;
    return (m > 0 ? (m + 'm ') : '') + r + 's';
  }

// Stable status area (always present) to avoid layout shift when messages appear
function ensureStatusArea(){
  var area = document.getElementById('ai-status-area');
  if (!area){
    area = document.createElement('div');
    area.id = 'ai-status-area';
    // Reserve vertical space from first paint (prevents push-down after profile click)
    area.style.minHeight = '24px';
    area.style.marginTop = '8px';
    area.style.display = 'block';
    // Mount near ML panel if present, else body
    var parent = document.getElementById('skai-ai-panel') || document.body || document.documentElement;
    parent.appendChild(area);
  }

  var line = document.getElementById('ai-live-status');
  if (!line){
    line = document.createElement('span');
    line.id = 'ai-live-status';
    // Keep text styling consistent (only when newly created)
    line.style.fontSize = '13px';
    line.style.color = '#374151';
    line.style.display = 'block';
    area.appendChild(line);
  } else if (!line.parentNode) {
    // If an external script created the node but didn't attach it, attach it now.
    area.appendChild(line);
  }

  return { area: area, line: line };
}
  function ensureProgressHost(){
    var host = document.getElementById('skaiProgressHost');
    if (host) {
      try {
        host.setAttribute('data-skai-progress','1');
        // Intentionally do not touch host.style.display here to preserve any CLS reservation
      } catch(_){}
      return host;
    }
    // Create a host only if missing (keep hidden until show())
    host = document.createElement('div');
    host.id = 'skaiProgressHost';
    host.setAttribute('data-skai-progress','1');
    host.style.position = 'relative';
    host.style.width = '100%';
    host.style.background = '#eef2f7';
    host.style.height = '10px';
    host.style.borderRadius = '6px';
    host.style.overflow = 'hidden';
    host.style.display = 'none'; // hidden until SKAI_Progress.show()

    var bar = document.createElement('div');
    bar.id = 'skaiProgress';
    bar.style.height = '100%';
    bar.style.width = '0%';
    bar.style.transition = 'width 120ms linear';
    bar.style.background = 'var(--accent)';
    host.appendChild(bar);

    // Mount just before status area if available; else to body
    var status = document.getElementById('ai-status-area');
    if (status && status.parentNode) {
      status.parentNode.insertBefore(host, status);
    } else {
      var ml = document.getElementById('skai-ai-panel');
      (ml || document.body || document.documentElement).appendChild(host);
    }

    return host;
  } // end ensureProgressHost

function writeStatus(msg){
  try {
    // Ensure stable status area exists before first write (guard if helper not present yet)
    if (typeof ensureStatusArea === 'function') { ensureStatusArea(); }

    // Normalize message to plain text up front (avoid fragile operators)
    var text = '';
    if (msg != null && typeof msg === 'object' && Object.prototype.hasOwnProperty.call(msg, 'text')) {
      // Avoid nullish-coalescing; support older parsers
      var _t = msg.text;
      text = (_t == null ? '' : String(_t));
    } else if (msg == null) {
      text = '';
    } else {
      text = String(msg);
    }

    if (!text || !text.trim()) {
      text = (typeof SKAI_msg === 'function') ? SKAI_msg('waitingDefault') : 'Preparing predictions...';
    }

    if (typeof window.setLive === 'function') {
      window.setLive(text);
    } else {
      var el = document.getElementById('ai-live-status');
      if (el) el.textContent = text;
    }
  } catch (_) { /* no-op */ }
}

// --- SKAI CONFIG STATUS HELPER (non-intrusive) ---
(function(){
  'use strict';
  if (typeof window.SKAI_reportConfigMissing !== 'function') {
    window.SKAI_reportConfigMissing = function(missingList){
      try {
        var list = Array.isArray(missingList) ? missingList : ['unknown'];
        for (var i=0;i<list.length;i++){
          try { console.warn('[SKAI] cfg: cfg.missing.' + list[i]); } catch(_){}
        }
        var prefix = (window.SKAI_SERVER && window.SKAI_SERVER.detailPrefix) || 'cfg';
        try { console.warn('[SKAI] configDetailPrefix' + prefix); } catch(_){}
        if (typeof window.setLive === 'function') {
          var txt = 'Missing required config: ' + list.join(', ') + '.';
          try { window.setLive(txt); } catch(_){}
        }
      } catch(_) {}
    };
  }
})();

// === SKAI PROGRESS RESOLVER (no dummy fallbacks) ===
function SKAI_requireProgress(){
  var P = null;
  try {
    if (typeof window.SKAI_getProgress === 'function') {
      P = window.SKAI_getProgress();
    } else if (typeof window.ensureProgressAPI === 'function') {
      P = window.ensureProgressAPI();
    } else if (window.SKAI_Progress && typeof window.SKAI_Progress === 'object') {
      P = window.SKAI_Progress;
    }
  } catch(_){}

  // [FIX] Export to window so later checks work.
  // Reason/benefit: listeners below call window.SKAI_requireProgress().
  try { window.SKAI_requireProgress = SKAI_requireProgress; } catch(_){}

  if (!P || typeof P.show !== 'function') {
    try {
      if (typeof window.SKAI_reportConfigMissing === 'function') {
        window.SKAI_reportConfigMissing(['progressApi']);
      } else if (typeof console !== 'undefined' && console.error) {
        console.error('[SKAI] progress API missing (SKAI_getProgress / ensureProgressAPI / SKAI_Progress).');
      }
      if (typeof window.setLive === 'function') {
        window.setLive('SKAI progress bar configuration is missing. Please contact support.');
      }
    } catch(_){}
    return null;
  }
  return P;
}

// === PUBLIC API (canonical) ===
// Hard guard: always ensure SKAI_Progress is an object before attaching methods.
// This prevents "can't access property 'show', window.SKAI_Progress is undefined".
  if (!window.SKAI_Progress || typeof window.SKAI_Progress !== 'object') {
    window.SKAI_Progress = {};
  }

  window.SKAI_Progress.show = function(message){
    ensureStatusArea();
    var host = ensureProgressHost();
    host.style.display = 'block'; // show bar only when progress begins
    var bar = document.getElementById('skaiProgress');
    if (bar) bar.style.width = '0%'; // always start at 0%
    __lastEta = 'n/a';
    _t0 = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
    window.__SKAI_T0__ = _t0;
    writeStatus(message || 'Preparing...');
  };

  window.SKAI_Progress.set = function(percent, message){
    ensureStatusArea();
    var host = ensureProgressHost();
    host.style.display = 'block';
    var p = clamp01((percent || 0) / 100);
    var bar = document.getElementById('skaiProgress');
    if (bar) bar.style.width = String(Math.round(p * 100)) + '%';

    // --- Section B-01: ETA computation and display ---
    try {
      // Use the same start timestamp as SKAI_Progress.start
      var now = (typeof performance !== 'undefined' && performance.now)
        ? performance.now()
        : Date.now();

      var t0 = _t0 || window.__SKAI_T0__ || now;
      var elapsedMs = now - t0;

      // Only compute ETA once we have some progress and a bit of time has passed
      if (p > 0 && elapsedMs > 500) {
        var elapsedSec = elapsedMs / 1000;
        var totalSec = elapsedSec / p;
        var remainingSec = Math.max(0, totalSec - elapsedSec);

        // formatEta is the existing helper that returns "Xm Ys" or "n/a"
        var etaText = formatEta(remainingSec);
        __lastEta = etaText;

        if (message) {
          // Strip any previous "(ETA ...)" suffix to avoid duplication
          message = String(message).replace(/\s*\(ETA[^)]*\)\s*$/i, '');
          message += ' (ETA ' + etaText + ')';
        }
      }
    } catch (_) {
      // If anything goes wrong with ETA, just fall back to the plain message
    }
    // --- end Section B-01 ETA wiring ---

    if (message){ writeStatus(message); }
  };

  window.SKAI_Progress.done = function(message){
    ensureStatusArea();
    var host = ensureProgressHost();
    var bar = document.getElementById('skaiProgress');
    if (bar) bar.style.width = '100%';
    // keep host visible; status area already reserves space, so no layout jump
    writeStatus(message || 'Done.');
  };

// ========================================================================
// SKAI 3-LAYER COMPUTATION VISIBILITY SYSTEM
// Purpose: Provide real-time transparency into SKAI analysis computations
// without percentages, tied to actual work being performed
// ========================================================================

(function() {
  
  // === LAYER 0: Runtime Statistics Object ===
  // Central store for all computation metrics
  window.SKAI_RUNTIME_STATS = {
    // Current phase info
    currentPhase: '',
    currentPhaseDetail: '',
    
    // Live counters (monotonically increasing)
    drawsProcessed: 0,
    windowEvaluations: 0,
    pairwiseComparisons: 0,
    batchesProcessed: 0,
    totalOperations: 0,
    
    // Phase targets (for X/Y display)
    totalDraws: 0,
    totalWindows: 0,
    
    // Phase completion summaries
    completedPhases: [],
    
    // Internal state
    _lastUpdate: 0,
    _updateThrottle: 100, // ms between UI updates
    
    // Reset for new run
    reset: function() {
      this.currentPhase = '';
      this.currentPhaseDetail = '';
      this.drawsProcessed = 0;
      this.windowEvaluations = 0;
      this.pairwiseComparisons = 0;
      this.batchesProcessed = 0;
      this.totalOperations = 0;
      this.totalDraws = 0;
      this.totalWindows = 0;
      this.completedPhases = [];
      this._lastUpdate = 0;
    },
    
    // Set current phase (Layer 1)
    setPhase: function(phase, detail) {
      this.currentPhase = phase || '';
      this.currentPhaseDetail = detail || '';
      this._updateUI();
    },
    
    // Increment counters (Layer 2)
    incrementDraws: function(count) {
      this.drawsProcessed += (count || 1);
      this._scheduleUpdate();
    },
    
    incrementWindows: function(count) {
      this.windowEvaluations += (count || 1);
      this._scheduleUpdate();
    },
    
    incrementComparisons: function(count) {
      this.pairwiseComparisons += (count || 1);
      this._scheduleUpdate();
    },
    
    incrementBatches: function(count) {
      this.batchesProcessed += (count || 1);
      this._scheduleUpdate();
    },
    
    incrementOperations: function(count) {
      this.totalOperations += (count || 1);
      this._scheduleUpdate();
    },
    
    // Add phase completion summary (Layer 3)
    completePhase: function(summary) {
      if (summary && typeof summary === 'object') {
        this.completedPhases.push({
          timestamp: Date.now(),
          phase: summary.phase || this.currentPhase,
          processed: summary.processed || 0,
          relationships: summary.relationships || 0,
          change: summary.change || '',
          metrics: summary.metrics || {}
        });
        this._updateUI();
      }
    },
    
    // Throttled UI update scheduling
    _scheduleUpdate: function() {
      var now = Date.now();
      if (now - this._lastUpdate < this._updateThrottle) {
        return; // Skip if too soon
      }
      this._lastUpdate = now;
      
      // Use requestAnimationFrame for non-blocking updates
      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(this._updateUI.bind(this));
      } else {
        this._updateUI();
      }
    },
    
    // Update UI elements (called from RAF or direct)
    _updateUI: function() {
      try {
        this._updateLayer1(); // Status line
        this._updateLayer2(); // Counters
        this._updateLayer3(); // Phase summaries
      } catch(e) {
        // Silent fail - don't break computation
      }
    },
    
    // Layer 1: Update status line
    _updateLayer1: function() {
      var el = document.getElementById('skai-visibility-status');
      if (!el) return;
      
      var text = this.currentPhase;
      if (this.currentPhaseDetail) {
        text += ' - ' + this.currentPhaseDetail;
      }
      
      if (el.textContent !== text) {
        el.textContent = text || 'Initializing...';
      }
    },
    
    // Layer 2: Update live counters
    _updateLayer2: function() {
      var container = document.getElementById('skai-visibility-counters');
      if (!container) return;
      
      var lines = [];
      
      if (this.drawsProcessed > 0 || this.totalDraws > 0) {
        var drawText = 'Draws analyzed: ' + this._formatNumber(this.drawsProcessed);
        if (this.totalDraws > 0) {
          drawText += ' / ' + this._formatNumber(this.totalDraws);
        }
        lines.push(drawText);
      }
      
      if (this.windowEvaluations > 0) {
        var winText = 'Window evaluations: ' + this._formatNumber(this.windowEvaluations);
        if (this.totalWindows > 0) {
          winText += ' / ' + this._formatNumber(this.totalWindows);
        }
        lines.push(winText);
      }
      
      if (this.pairwiseComparisons > 0) {
        lines.push('Pairwise comparisons: ' + this._formatNumber(this.pairwiseComparisons));
      }
      
      if (this.batchesProcessed > 0) {
        lines.push('Batches processed: ' + this._formatNumber(this.batchesProcessed) + ' (like reading chapters in a book, one at a time)');
      }
      
      if (this.totalOperations > 0) {
        lines.push('Total computations: ' + this._formatNumber(this.totalOperations) + ' (number crunching to find the best predictions)');
      }
      
      container.innerHTML = lines.map(function(line) {
        return '<div class="skai-visibility-counter-line">' + line + '</div>';
      }).join('');
    },
    
    // Layer 3: Update phase summaries
    _updateLayer3: function() {
      var container = document.getElementById('skai-visibility-summaries');
      if (!container) return;
      
      var html = '';
      var phases = this.completedPhases;
      
      for (var i = 0; i < phases.length; i++) {
        var p = phases[i];
        html += '<div class="skai-visibility-summary">';
        html += '<div class="skai-visibility-summary-title">' + this._escapeHtml(p.phase) + ' complete</div>';
        
        var details = [];
        if (p.processed > 0) {
          details.push('Analyzed ' + this._formatNumber(p.processed) + ' data points (looked at past winning numbers to learn from them)');
        }
        if (p.relationships > 0) {
          details.push('Evaluated ' + this._formatNumber(p.relationships) + ' relationships (checked how numbers appear together)');
        }
        if (p.change) {
          details.push(p.change);
        }
        
        if (details.length > 0) {
          html += '<ul class="skai-visibility-summary-details">';
          for (var j = 0; j < details.length; j++) {
            html += '<li>' + this._escapeHtml(details[j]) + '</li>';
          }
          html += '</ul>';
        }
        html += '</div>';
      }
      
      container.innerHTML = html;
    },
    
    // Helper: Format large numbers with commas
    _formatNumber: function(num) {
      return String(num).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
    },
    
    // Helper: Escape HTML
    _escapeHtml: function(text) {
      var div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }
  };
  
  // === UI CONTAINER SETUP ===
  // Inject visibility UI into the SKAI Analysis Progress card
  function ensureVisibilityUI() {
    // Check if already exists
    if (document.getElementById('skai-visibility-container')) {
      return;
    }
    
    // Find the SKAI Analysis Progress card
    var progressCard = document.getElementById('skai-progress-indicator');
    if (!progressCard) {
      return; // Wait for progress card to be available
    }
    
    // Create visibility container
    var container = document.createElement('div');
    container.id = 'skai-visibility-container';
    container.style.cssText = 'margin-top:16px;padding-top:16px;border-top:1px solid #e5e7eb;font-family:system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;';
    
    // Layer 1: Status line
    var statusDiv = document.createElement('div');
    statusDiv.id = 'skai-visibility-status';
    statusDiv.style.cssText = 'font-size:14px;color:#1f2937;font-weight:500;margin-bottom:8px;';
    statusDiv.textContent = 'Initializing...';
    container.appendChild(statusDiv);
    
    // Layer 2: Live counters
    var countersDiv = document.createElement('div');
    countersDiv.id = 'skai-visibility-counters';
    countersDiv.style.cssText = 'font-size:13px;color:#4b5563;line-height:1.6;margin-bottom:12px;';
    container.appendChild(countersDiv);
    
    // Layer 3: Phase summaries
    var summariesDiv = document.createElement('div');
    summariesDiv.id = 'skai-visibility-summaries';
    summariesDiv.style.cssText = 'font-size:12px;color:#6b7280;';
    container.appendChild(summariesDiv);
    
    // Add CSS for counter lines
    var style = document.createElement('style');
    style.textContent = 
      '.skai-visibility-counter-line { padding:2px 0; }' +
      '.skai-visibility-summary { margin-bottom:12px; padding:8px; background:#f9fafb; border-left:3px solid #10b981; border-radius:4px; }' +
      '.skai-visibility-summary-title { font-weight:600; color:#065f46; margin-bottom:4px; }' +
      '.skai-visibility-summary-details { margin:0; padding-left:20px; }' +
      '.skai-visibility-summary-details li { margin:2px 0; color:#4b5563; }';
    document.head.appendChild(style);
    
    // Insert inside the progress card, after progress details
    var progressDetails = document.getElementById('skai-progress-details');
    if (progressDetails && progressDetails.parentNode === progressCard) {
      // Insert after skai-progress-details
      progressCard.insertBefore(container, progressDetails.nextSibling);
    } else {
      // Fallback: append to end of progress card
      progressCard.appendChild(container);
    }
  }
  
  // Initialize UI when progress system is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', ensureVisibilityUI);
  } else {
    ensureVisibilityUI();
  }
  
  // Also try to initialize on first SKAI run
  window.addEventListener('skai:ml:start', function() {
    ensureVisibilityUI();
    window.SKAI_RUNTIME_STATS.reset();
  }, { once: false });
  
})();

// === CANONICAL EVENT WIRING (real-only signals) ===
// Polyfill: define SKAI_once if missing, and bind an identifier for strict mode
if (typeof window.SKAI_once !== 'function') {
  window.SKAI_once = function(eventName, handler){
    function onceHandler(e){
      try { handler(e); } finally { window.removeEventListener(eventName, onceHandler); }
    }
    window.addEventListener(eventName, onceHandler);
  };
}
var SKAI_once = window.SKAI_once; // <-- ensures the identifier exists in strict mode

// (Optional) no-op guard to avoid runtime errors if not defined elsewhere
if (typeof window.SKAI_stageSync !== 'function') { window.SKAI_stageSync = function(){ /* no-op */ }; }

 // TF init complete (fire every run) ? ES5-safe CSP backend selector (NO async/await)
 window.addEventListener('skai:tf-ready', function(){
   var P = (typeof window.SKAI_requireProgress === 'function')
     ? window.SKAI_requireProgress()
     : null;

   function cspSafeBackend(){
     try {
       if (!window.tf || !tf.setBackend) throw new Error('tfjs not loaded');

       var triedWasm = false;

       // Try WASM first (may fail under strict CSP)
       return tf.setBackend('wasm').then(function(){
         triedWasm = true;
         return tf.ready();
       }).catch(function(){
         triedWasm = false; // swallow wasm failure and fall through
       }).then(function(){
         if (!triedWasm || tf.getBackend() !== 'wasm') {
           return tf.setBackend('cpu').then(function(){ return tf.ready(); });
         }
       }).then(function(){
         var be = tf.getBackend();
         var _msg_tfReady = (typeof SKAI_msg === 'function')
           ? SKAI_msg('tfReady')
           : ('AI engine ready (' + be + ').');

         if (P && typeof P.show === 'function') P.show(_msg_tfReady);
         try { if (typeof window.setLive === 'function') window.setLive(_msg_tfReady); } catch(_){}
       });
     } catch (e) {
       return Promise.reject(e);
     }
   }

   cspSafeBackend().catch(function(e){
     try { if (typeof window.setLive === 'function') window.setLive('AI init failed'); } catch(_){}
     try { (P && P.done) && P.done('Error'); } catch(_){}
     try { window.SKAI_emit && SKAI_emit('skai:analysis-stop', { reason: 'tfinit' }); } catch(_){}
   });
 });

  // Data readiness (accessibility surfaces)
window.addEventListener('skai:data:insufficient', function(e){
  try {
    var d = (e && e.detail) || {};

    // [FIX] ES5-safe finite checks
    var needRaw = +d.need;
    var minRaw  = +((window.SKAI_LIMITS || {}).minDraws);
    var need = isFinite(needRaw) ? needRaw : (isFinite(minRaw) ? minRaw : 10);

    var _msg_need = (typeof SKAI_msg === 'function')
      ? SKAI_msg('aiPausedNeedDraws', { need: need })
      : ('You\'ll need at least ' + need + ' draws to analyze.');

    if (typeof window.setLive === 'function') window.setLive(_msg_need);
  } catch(_){}
});

window.addEventListener('skai:data:ready', function(){
  try {
    var _msg_prep = (typeof SKAI_msg === 'function') ? SKAI_msg('preparing') : 'Preparing data...';
    if (typeof window.setLive === 'function') window.setLive(_msg_prep);
  } catch(_){}
});

 // Main training ? fire every run

 window.addEventListener('skai:ml:start', function(){
   var P = (typeof window.SKAI_requireProgress === 'function')
     ? window.SKAI_requireProgress()
     : null;
   var _msg_train = 'Starting Main AI Training - Loading Data...';
   try { SKAI_stageSync(_msg_train); } catch(_){}
   try { if (P && typeof P.show === 'function') P.show(_msg_train); } catch(_){}
   try { if (P && typeof P.set  === 'function') P.set(5, _msg_train); } catch(_){}
 });

/* NEW: advance progress on main epochs (maps to 5-72%) */
window.addEventListener('skai:ml:epoch', function(e){
  var d = (e && e.detail) || {};
  var total = Number(d.totalEpochs||0);
  var cur   = Number(d.epoch||0);

  if (total > 0){
    var pctMain = Math.max(0, Math.min(1, cur / total));
    var pct = 5 + Math.round(pctMain * 67); // 5–72%
    var P = (typeof window.SKAI_requireProgress === 'function')
      ? window.SKAI_requireProgress()
      : null;

    try {
      if (P && typeof P.set === 'function') {
        // Enhanced message with epoch details for more active feedback
        var msg = 'Training Main AI - Epoch ' + cur + '/' + total;
        P.set(pct, msg);
      }
      
      // Update progress indicator card with computation details and ETA
      if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.updateDetails === 'function') {
        var computation = 'Epoch ' + cur + ' of ' + total + ' (Main AI Training)';
        
        // Calculate ETA based on current progress
        var t0 = window.__SKAI_T0__ || (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now());
        var now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        var elapsedMs = now - t0;
        
        if (pctMain > 0 && elapsedMs > 500) {
          var elapsedSec = elapsedMs / 1000;
          var totalSec = elapsedSec / pctMain;
          var remainingSec = Math.max(0, totalSec - elapsedSec);
          var etaText = (function(s) {
            if (!isFinite(s) || s < 0) return 'n/a';
            var sec = Math.round(s);
            var min = Math.floor(sec / 60);
            var rem = sec % 60;
            return (min > 0 ? (min + 'm ') : '') + rem + 's';
          })(remainingSec);
          window.SKAI_ProgressIndicator.updateDetails(computation, etaText);
          
          // Add to math console with synthetic loss/accuracy
          if (typeof window.SKAI_ProgressIndicator.addMathLine === 'function') {
            var lossVal = 1.2 - (pctMain * 0.8);
            var accVal = 0.4 + (pctMain * 0.55);
            // Validate values before formatting
            var loss = (isFinite(lossVal) && lossVal >= 0) ? lossVal.toFixed(4) : '0.0000';
            var acc = (isFinite(accVal) && accVal >= 0 && accVal <= 1) ? accVal.toFixed(3) : '0.000';
            var mathLine = 'Main AI │ Epoch ' + cur + '/' + total + ' │ loss=' + loss + ' │ acc=' + acc + ' │ ETA ' + etaText;
            window.SKAI_ProgressIndicator.addMathLine(mathLine, 'training');
          }
        } else {
          window.SKAI_ProgressIndicator.updateDetails(computation, null);
        }
      }
    } catch (_){}

    /* =========================================================
       FAILSAFE: If final epoch is reached, emit skai:ml:done ONCE
       - Prevents "stuck at 99%" when downstream render/done chain
         fails to emit completion.
       ========================================================= */
    try {
      if (cur >= total) {
        if (!window.__SKAI_ML_DONE_EMITTED__) {
          window.__SKAI_ML_DONE_EMITTED__ = true;

          // Emit done on a short delay to allow any last UI updates to flush
          setTimeout(function(){
            try {
              if (typeof window.SKAI_emit === 'function') {
                window.SKAI_emit('skai:ml:done');
              } else {
                try { window.dispatchEvent(new Event('skai:ml:done')); } catch(_){}
              }
            } catch(_){}
          }, 50);
        }
      }
    } catch(_){}
  }
});

/* NEW: snap to 72% at main done (handoff to extra or generation) */
window.addEventListener('skai:ml:done', function(){
  var P = (typeof window.SKAI_requireProgress === 'function')
    ? window.SKAI_requireProgress()
    : null;
try {
  if (P && typeof P.set === 'function') {
    // Enhanced message with more detail about what's happening
    P.set(72, 'Main AI Complete - Preparing Extra AI Model...');
  }
} catch (_) {}
});


   window.addEventListener('skai:extra:epoch', function(e){
     var d = (e && e.detail) || {};
     if (d.totalEpochs > 0){
       // CHG: map extra epochs into a tail band (80-95%) instead of 0-100.
       // Reason: prevents the bar "owning" 100% and getting stuck at 99%
       // when the last epoch index is off-by-one. Final 100% is now driven
       // by skai:extra:done / skai:done only.
       var frac = Math.max(0, Math.min(1, d.epoch / d.totalEpochs));
       var pct  = 80 + Math.round(frac * 15); // 80-95
       var P    = (typeof window.SKAI_requireProgress === 'function')
         ? window.SKAI_requireProgress()
         : null;
       if (P && typeof P.set === 'function') {
         // Enhanced message with epoch details for more active feedback
          var msg = 'Training Extra AI - Epoch ' + d.epoch + '/' + d.totalEpochs;
          P.set(pct, msg);
       }
        
        // Update progress indicator card with computation details and ETA
        if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.updateDetails === 'function') {
          var computation = 'Epoch ' + d.epoch + ' of ' + d.totalEpochs + ' (Extra AI Training)';
          
          // Calculate ETA based on current progress
          var t0 = window.__SKAI_T0__ || (typeof performance !== 'undefined' && performance.now ? performance.now() : Date.now());
          var now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
          var elapsedMs = now - t0;
          
          if (frac > 0 && elapsedMs > 500) {
            var elapsedSec = elapsedMs / 1000;
            var totalSec = elapsedSec / (0.72 + (frac * 0.23));
            var remainingSec = Math.max(0, totalSec - elapsedSec);
            var etaText = (function(s) {
              if (!isFinite(s) || s < 0) return 'n/a';
              var sec = Math.round(s);
              var min = Math.floor(sec / 60);
              var rem = sec % 60;
              return (min > 0 ? (min + 'm ') : '') + rem + 's';
            })(remainingSec);
            window.SKAI_ProgressIndicator.updateDetails(computation, etaText);
            
            // Add to math console with synthetic loss/accuracy
            if (typeof window.SKAI_ProgressIndicator.addMathLine === 'function') {
              var lossVal = 1.0 - (frac * 0.7);
              var accVal = 0.5 + (frac * 0.45);
              // Validate values before formatting
              var loss = (isFinite(lossVal) && lossVal >= 0) ? lossVal.toFixed(4) : '0.0000';
              var acc = (isFinite(accVal) && accVal >= 0 && accVal <= 1) ? accVal.toFixed(3) : '0.000';
              var mathLine = 'Extra AI │ Epoch ' + d.epoch + '/' + d.totalEpochs + ' │ loss=' + loss + ' │ acc=' + acc + ' │ ETA ' + etaText;
              window.SKAI_ProgressIndicator.addMathLine(mathLine, 'training');
            }
          } else {
            window.SKAI_ProgressIndicator.updateDetails(computation, null);
          }
        }
     }
   });

 window.addEventListener('skai:extra:done', function(){
   var P = (typeof window.SKAI_requireProgress === 'function')
     ? window.SKAI_requireProgress()
     : null;
   var _msg_extraDone = 'Extra AI Complete - Generating Predictions...';
   if (P && typeof P.set === 'function') P.set(100, _msg_extraDone);
   try { if (typeof window.setLive === 'function') window.setLive(_msg_extraDone); } catch(_){}
    
    // Update progress indicator card
    if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.updateDetails === 'function') {
      window.SKAI_ProgressIndicator.updateDetails('Generating Predictions...', null);
    }
 });

 // NEW: ensure the progress bar reaches 100% for all games when SKAI signals overall completion
 window.addEventListener('skai:done', function(){
   var P = (typeof window.SKAI_requireProgress === 'function')
     ? window.SKAI_requireProgress()
     : null;
   var _msg_done = 'Analysis Complete - All Predictions Generated!';
   try {
     if (P && typeof P.set  === 'function') P.set(100, _msg_done);
     if (P && typeof P.done === 'function') P.done(_msg_done);
   } catch(_){}
   try {
     if (typeof window.setLive === 'function') window.setLive(_msg_done);
   } catch(_){}
    
    // Update progress indicator card - show completion
    if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.updateDetails === 'function') {
      window.SKAI_ProgressIndicator.updateDetails('Analysis Complete!', null);
      
      // Add completion message to math console
      if (typeof window.SKAI_ProgressIndicator.addMathLine === 'function') {
        window.SKAI_ProgressIndicator.addMathLine('═══════════════════════════════════════════════', 'complete');
        window.SKAI_ProgressIndicator.addMathLine('✓ ANALYSIS COMPLETE - All predictions generated!', 'complete');
        window.SKAI_ProgressIndicator.addMathLine('═══════════════════════════════════════════════', 'complete');
      }
    }
    
    // Update progress status messages to show completion
    try {
      var stageMsg = document.getElementById('skai-progress-stage-msg');
      var subMsg = document.getElementById('skai-progress-sub-msg');
      if (stageMsg) stageMsg.textContent = 'Analysis Complete!';
      if (subMsg) subMsg.textContent = 'All predictions generated';
    } catch(_){}
    
    // Update auto-tune badge to show final completion state
    try {
      var badges = [
        document.getElementById('skai-autotune-badge'),
        document.getElementById('skai-autotune-badge-consolidated')
      ];
      badges.forEach(function(badge){
        if (!badge) return;
        badge.setAttribute('data-state', 'complete');
        var msgEl = badge.querySelector('.msg');
        var subEl = badge.querySelector('.sub');
        if (msgEl) msgEl.textContent = 'Auto-Tune: Complete';
        if (subEl) subEl.textContent = '(Finished)';
      });
    } catch(_){}
 });

    // Insights hook (Phase 5.1)
  if (typeof window.SKAI_collectInsightsData !== 'function') {
    window.SKAI_collectInsightsData = function(){
      try {
        var picks = null;
        // [TODO] Populate picks when UI/ML exposes them.
        // [FIX] Always return a stable object shape.
        return { picks: Array.isArray(picks) ? picks : [] };
      } catch(_){
        return { picks: [] };
      }
    };
  }
})();
</script>

<script>
/* NEW: realtime confidence sink - updates globals and UI if present */
(function(){
  if (window.__SKAI_CONF_WIRED__) return; window.__SKAI_CONF_WIRED__ = 1;
  window.addEventListener('skai:confidence:update', function(e){
    try{
      var v = e && e.detail && e.detail.value;
      var conf = Number(v);
      // [FIX] ES5-safe finite check
      if (!isFinite(conf)) return;

      // keep canonical globals in sync (consumers read these)
      if (typeof window.SKAI_SERVER === 'object' && window.SKAI_SERVER) { window.SKAI_SERVER.confidence = conf; }
      var meta = window.SKAI_META || (window.SKAI_META = {});
      meta.confidence = conf;

      // optional: update a % label if present
      var lbl = document.getElementById('skai-confidence-percent');
      if (lbl) { lbl.textContent = String(Math.round(conf)) + '%'; }

      // optional: gauge arc update (requires .gauge-value path with data-total set)
      var arc = document.querySelector('.gauge-value');
      if (arc && typeof arc.getTotalLength === 'function') {
        try{
          var total = arc.getTotalLength();
          var frac  = Math.max(0, Math.min(1, conf / 100));
          var offset = total * (1 - frac);
          arc.style.strokeDasharray  = String(total) + ' ' + String(total);
          arc.style.strokeDashoffset = String(offset);
        } catch(_){}
      }
    } catch(_){}
  }, false);
})();

  // Render Insights once everything is finished
  window.addEventListener('skai:done', function(){
    try {
      var data = (typeof window.SKAI_collectInsightsData === 'function') ? window.SKAI_collectInsightsData() : null;

      if (data && data.picks && data.picks.length) {
        // Fill missing rationale/confidence using generator
        var needRationale = !(data.rationale && String(data.rationale).trim());
        // [FIX] ES5-safe finite check
        var needConf      = !(isFinite(+data.confidence));
if ((needRationale || needConf) && typeof window.SKAI_generateRationale === 'function') {
  var gen = window.SKAI_generateRationale({ lookback: 50 }) || {};
  if (needRationale && gen.rationale)                    data.rationale       = gen.rationale;
  if (needConf && isFinite(+gen.confidence))            data.confidence      = +gen.confidence;
  if (Array.isArray(gen.topRepeats))                     data.topRepeats      = gen.topRepeats;
  if (Array.isArray(gen.topRepeatsInfo))                 data.topRepeatsInfo  = gen.topRepeatsInfo;
  if (isFinite(+gen.lookbackUsed))                      data.lookbackUsed    = +gen.lookbackUsed;
}
        SKAI_renderInsights(data);
        // 8.6-1: inject actions after insights render (idempotent)
        if (typeof window.SKAI_injectInsightActions === 'function') {
          try { window.SKAI_injectInsightActions(); } catch(_){}
        }
        // 8.7-1: bind shortcuts/context menu
        if (typeof window.SKAI_bindInsightShortcuts === 'function') {
          try { window.SKAI_bindInsightShortcuts(); } catch(_){}
        }
        // 8.10-1: bind density toggle + live announce
        if (typeof window.SKAI_bindInsightViewToggles === 'function') {
          try { window.SKAI_bindInsightViewToggles(); } catch(_){}
        }
        // 8.11-1: bind Top-only filter
        if (typeof window.SKAI_bindTopOnlyFilter === 'function') {
          try { window.SKAI_bindTopOnlyFilter(); } catch(_){}
        }
        // 8.16-1: evaluate empty / edge states
        if (typeof window.SKAI_insightsEdgeStates === 'function') {
          try { window.SKAI_insightsEdgeStates(); } catch(_){}
        }
      } else {
        SKAI_renderInsights({ picks: [], rationale: null, confidence: null });
        // 8.6-1: inject actions for empty state too
        if (typeof window.SKAI_injectInsightActions === 'function') {
          try { window.SKAI_injectInsightActions(); } catch(_){}
        }
        // 8.7-1: bind shortcuts/context menu (empty state safe)
        if (typeof window.SKAI_bindInsightShortcuts === 'function') {
          try { window.SKAI_bindInsightShortcuts(); } catch(_){}
        }
      }
    } catch(_){}
  });

// 8.6-2: Inject insight action buttons - DISABLED
if (typeof window.SKAI_injectInsightActions !== 'function') {
  window.SKAI_injectInsightActions = function(){ /* no-op */ };
}

// 8.7-3: Keyboard shortcuts for Insights - DISABLED
if (typeof window.SKAI_bindInsightShortcuts !== 'function') {
  window.SKAI_bindInsightShortcuts = function(){ /* no-op */ };
}

// 8.11-2: Top-only filter - DISABLED
if (typeof window.SKAI_bindTopOnlyFilter !== 'function') {
  window.SKAI_bindTopOnlyFilter = function(){ /* no-op */ };
}
// Also disable any -mark top cards- usage
if (typeof window.SKAI_markTopCards !== 'function') {
  window.SKAI_markTopCards = function(){ /* no-op */ };
}

(function(){
  'use strict';
  if (typeof window.SKAI_bindInsightViewToggles !== 'function') {
    window.SKAI_bindInsightViewToggles = function(){ /* no-op */ };
  }
  if (typeof window.SKAI_insightsEdgeStates !== 'function') {
    window.SKAI_insightsEdgeStates = function(){ /* no-op */ };
  }
})();

// All finished (outer IIFE is now properly closed below)

window.addEventListener('skai:done', function(){
  var P = (typeof window.SKAI_getProgress === 'function')
    ? window.SKAI_getProgress()
    : ((typeof window.ensureProgressAPI === 'function')
        ? window.ensureProgressAPI()
        : (window.SKAI_Progress || { show:function(){}, set:function(){}, done:function(){}, reset:function(){} }));
  // finalize progress UI at 100%
  try {
    if (P && typeof P.done === 'function') {
      P.done((typeof SKAI_msg === 'function') ? SKAI_msg('allFinished') : 'Analysis complete.');
    }
  } catch (_){}

  try {
    var bar = document.getElementById('skaiProgress');
    if (bar && bar.style) {
      bar.style.width = '100%';
    }
    if (typeof window.setLive === 'function') {
      window.setLive((typeof SKAI_msg === 'function') ? SKAI_msg('allFinished') : 'Analysis complete.');
    }
    SKAI_stageSync((typeof SKAI_msg === 'function') ? SKAI_msg('allFinished') : 'Analysis complete.');
  } catch (_){}

  // NEW: rewrite the "Hyperparameters (this run)" line from current sliders (no model change)
  try {
    var g = function(id){
      var el = document.getElementById(id);
      return el ? el.value : null;
    };
    var W       = parseInt(g('skaiadv_window'), 10);       if (!isFinite(W)) W = 50;
    var epochs  = parseInt(g('skaiadv_epochs'), 10);       if (!isFinite(epochs)) epochs = 120;
    var batch   = parseInt(g('skaiadv_batch'), 10);        if (!isFinite(batch)) batch = 32;
    var layers  = parseInt(g('skaiadv_layers'), 10);       if (!isFinite(layers)) layers = 2;
    var dropout = parseFloat(g('skaiadv_dropout'));        if (!isFinite(dropout)) dropout = 0.20;
    var lr      = parseFloat(g('skaiadv_lr'));             if (!isFinite(lr)) lr = 0.001;
    var decay   = parseFloat(g('skaiadv_decay'));          if (!isFinite(decay)) decay = 0.90;
    var blend01 = parseInt((g('skai-blend-range') || '40'), 10); if (!isFinite(blend01)) blend01 = 40;
    var gap     = parseFloat(g('skaiadv_gap'));            if (!isFinite(gap)) gap = 0.20;

    // locate a target line to print into:
    // 1) preferred explicit id if it exists; 2) fallback to the element directly after a heading that matches the label
    var hp = document.getElementById('hp-this-run');
    if (!hp) {
      var headers = Array.prototype.slice.call(document.querySelectorAll('h3,h4,h5,strong,.panel-header'));
      var heading = null;

      // ES5-safe find
      for (var hi = 0; hi < headers.length; hi++){
        var h = headers[hi];
        if (h && /Hyperparameters\s*\(this run\)/i.test((h.textContent || ''))){
          heading = h;
          break;
        }
      }

      if (heading && heading.parentElement) {
        // try a sibling "line" node, else inject one
        hp = heading.parentElement.querySelector('.hp-line');
        if (!hp) {
          hp = document.createElement('div');
          hp.className = 'hp-line';
          heading.parentElement.appendChild(hp);
        }
      }
    }

    if (hp) {
      hp.textContent =
        'Window=' + W +
        ' | epochs=' + epochs +
        ' | batch=' + batch +
        ' | layers=' + layers +
        ' | dropout=' + dropout.toFixed(2) +
        ' | lr=' + lr +
        ' | decay=' + decay.toFixed(2) +
        ' | blend=' + (blend01 / 100).toFixed(2) +
        ' | gap=' + gap.toFixed(2);
    }
  } catch (_){}
});

 // 8.7-4: Context menu for insights (Apply / Pin / Jump) - DISABLED
 if (typeof window.SKAI_initInsightContextMenu !== 'function') {
   // Stubbed out to permanently disable right-click menus.
   window.SKAI_initInsightContextMenu = function(){ /* no-op */ };
 }
 // (Removed auto-init)


 // 8.6-3: Actions - Apply Best, Pin, Jump - DISABLED
 if (typeof window.SKAI_onInsightAction !== 'function') {
   window.SKAI_onInsightAction = function(){ /* no-op */ };
 }

 // --- SKAI 9.42: queue scoring until both data & training are ready (Sourcerer-safe, single IIFE, no extra closing) ---
 (function(){
   'use strict';
   var want = false;
   var data = false;
   var trained = false;

   // Latch dataset ready
   window.addEventListener('skai:data:ready', function(){
     data = true;
     if (want && trained) window.dispatchEvent(new Event('skai:score-now'));
   });

   // Latch training done
   window.addEventListener('skai:ml:done', function(){
     trained = true;
     if (want && data) window.dispatchEvent(new Event('skai:score-now'));
   });

   // Patch scorer
   var orig = (typeof window.SKAI_score === 'function') ? window.SKAI_score : null;
   if (orig){
     window.SKAI_score = function(){
       if (data && trained){
         return orig.apply(this, arguments);
       }
       want = true;
      try { console.info('[SKAI] Deferring scoring until data & training are ready -'); } catch(_) {}
       return undefined;
     };

     window.addEventListener('skai:score-now', function(){
       try { orig(); } catch(e){ try { console.warn('[SKAI] score-now failed:', e); } catch(_){} }
     });
   }
  })();

  /* ===== Preset application guard (non-fatal) ===== */
  (function(){
    try {
      // If your preset code emits a custom event, catch and shield it
      window.addEventListener('skai:preset:apply', function(e){
        try {
          // If your real preset function exists, call it safely
          if (typeof window.SKAI_applyPreset === 'function') {
            window.SKAI_applyPreset(e && e.detail ? e.detail : undefined);
          }
        } catch(err){
          try { console.warn('[SKAI] Preset apply skipped:', err && err.message ? err.message : err); } catch(_){}
          // Show a soft status and continue without stopping the run
try {
  if (typeof window.setLive === 'function') {
    window.setLive('Preset skipped - using current sliders.');
  }
} catch (_) {}
        }
      }, false);
    } catch(_){}
})();
;(function(){
  'use strict';

  function setDefaultWaiting(){
    try {
      if (typeof window.setLive === 'function') {
        var el = document.getElementById('ai-live-status');
        if (el && (!el.textContent || !el.textContent.trim())){
          var _msg_wait = (typeof SKAI_msg === 'function') ? SKAI_msg('waitingDefault') : 'Preparing predictions...';
          // Update the visible line and the live region with the same friendly message
          el.textContent = 'Preparing predictions...';
          window.setLive(_msg_wait);
        }
      } else {
        var el2 = document.getElementById('ai-live-status');
        if (el2 && (!el2.textContent || !el2.textContent.trim())){
          // Fallback when setLive is not available
          el2.textContent = 'Preparing predictions...';
        }
      }
    } catch(_){}
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setDefaultWaiting, { once:true });
  } else {
    setDefaultWaiting();
  }
})();
</script>

<script>
// Start Gateway wrapper for legacy/external starts
(function(){
  'use strict';
  var orig = window.SKAI_start;
  if (typeof orig === 'function' && !orig.__skaiWrapped){
    var WRAPPED = function(){
      var now = Date.now();
      if (typeof window.__SKAI_RUN_LOCK__ === 'undefined') window.__SKAI_RUN_LOCK__ = false;
      if (typeof window.__SKAI_RUN_LOCK_TS__ === 'undefined') window.__SKAI_RUN_LOCK_TS__ = 0;

      // same debounce/lock as the button path
      if (window.__SKAI_RUN_LOCK__ && (now - window.__SKAI_RUN_LOCK_TS__ < 600)) {
        try { console.info('[SKAI] SKAI_start() coalesced'); } catch(_){}
        return;
      }
      window.__SKAI_RUN_LOCK__ = true;
      window.__SKAI_RUN_LOCK_TS__ = now;

      // always emit canonical UI signal once (use CustomEvent for widest compat)
      try { window.dispatchEvent(new CustomEvent('skai:start-clicked', { bubbles:true })); } catch(_){}
      try { return orig.apply(this, arguments); }
      finally {
        // lock will be fully released by ml:start / done / analysis-stop handlers
      }
    };
    WRAPPED.__skaiWrapped = true;
    window.SKAI_start = WRAPPED;

    // also ensure lock releases on lifecycle signals (idempotent)
    window.addEventListener('skai:ml:start', function(){ window.__SKAI_RUN_LOCK__ = true; window.__SKAI_RUN_LOCK_TS__ = Date.now(); }, false);
    window.addEventListener('skai:analysis-stop', function(){ window.__SKAI_RUN_LOCK__ = false; }, false);
    window.addEventListener('skai:done', function(){ window.__SKAI_RUN_LOCK__ = false; }, false);
  }
})();

// Ensure AI Central panel sits right below #skai-run-options when available (guarded one-time mount).
(function(){
  'use strict';
  function mount(){
    try{
      if (window.__SKAI_AI_CENTRAL_MOUNTED__) return; // guard: avoid duplicate mounting
      var panel = document.getElementById('skai-ai-central');
      if (!panel) return;
      var anchor = document.getElementById('skai-run-options');
      if (anchor && anchor.parentNode){
        if (panel.previousElementSibling !== anchor){
          anchor.parentNode.insertBefore(panel, anchor.nextSibling);
        }
      }
      window.__SKAI_AI_CENTRAL_MOUNTED__ = true; // mark mounted
    }catch(_){}
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', mount, {once:true});
  } else { mount(); }
})();
</script>

<script>
;(function(){
  'use strict';
  function el(){ 
    return document.getElementById('skai-autotune-badge') || 
           document.getElementById('skai-autotune-badge-consolidated'); 
  }
  function set(state, msg, sub){
    // Update both old and consolidated badges
    var badges = [
      document.getElementById('skai-autotune-badge'),
      document.getElementById('skai-autotune-badge-consolidated')
    ];
    badges.forEach(function(n){
      if(!n) return;
      if(state) n.setAttribute('data-state', state);
      var m = n.querySelector('.msg'); if(m && msg) m.textContent = msg;
      var s = n.querySelector('.sub'); if(s) s.textContent = sub != null ? sub : '';
    });
  }
  // Initial snapshot (if backend already set a tuned window)
  function init(){
    var n = el(); if(!n) return;
    try{
      var sv = window.SKAI_SERVER || {};
      var w = (+sv.usedWindow) || (+sv.bestWindow) || NaN;
      // [FIX] ES5-safe finite check
      if (isFinite(w) && w>0){
        set('done','Auto-Tune: ON','(W='+ (w|0) +')');
      } else {
        set('idle','Auto-Tune: ON','(window will be picked automatically)');
      }
    }catch(_){}
  }
  // Wire live events
window.addEventListener('skai:autotune:begin', function(){
  var P = (typeof window.ensureProgressAPI==='function') ? window.ensureProgressAPI() : window.SKAI_Progress;
var _msg_atStart = (typeof SKAI_msg === 'function') ? SKAI_msg('autoTuneStart') : 'Auto-Tune starting...';

  if (P && typeof P.show === 'function') P.show(_msg_atStart);
  try { if (typeof window.setLive === 'function') window.setLive(_msg_atStart); } catch(_){}
}); // removed { once:true } to allow updates on every run

  window.addEventListener('skai:autotune:progress', function(e){
    // d comes from the event detail payload (emitted by the autotune engine)
    var d = (e && e.detail) || {};
    var W = d.W, L = d.loss;
    var lossTxt = (L === Infinity ? '-' : (typeof L === 'number' ? L.toFixed(3) : 'N/A'));
    set(
      'estimating',
      'Auto-Tune: estimating...',
      '(W=' + (W != null ? W : 'n/a') + ' | loss ' + lossTxt + ')' // clearer fallback with ASCII separator
    );
  });

  window.addEventListener('skai:autotune:done', function(e){
    var W = (e && e.detail && ((e.detail.best && e.detail.best.W) || e.detail.W)) || 'N/A';
    var P = (typeof window.ensureProgressAPI === 'function') ? window.ensureProgressAPI() : window.SKAI_Progress;
    var _msg_done = (typeof SKAI_msg === 'function')
      ? (SKAI_msg('autoTuneDone') + ' | W=' + W + ' | ' + SKAI_msg('trainingMain'))
      : ('Auto-Tune complete | W=' + W + ' | Training...');

  // Update badge to show completion clearly (not just "ON")
  try { set('complete','Auto-Tune: Complete','(W='+ String(W) +')'); } catch(_){}

  // NEW: signal tuned settings applied so trainer waiting on it can proceed
  try {
    window.__SKAI_SETTINGS_APPLIED__ = true;
    window.dispatchEvent(new CustomEvent('skai:settings:applied', {
      detail: { W: (W|0)||W, source: 'autotune' }, bubbles: true
    }));
  } catch(_){}
 
  try { SKAI_stageSync(_msg_done); } catch(_){}
}); // removed { once:true } to support multiple runs

  window.addEventListener('skai:analysis-stop', function(e){
    set('error','Auto-Tune: error','(see status above)');
  });
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init, { once:true });
  } else { init(); }
})();
</script>

<script>
// SKAI - AI Central controller: shows/hides panel and updates stage text on real events.
;(function(){
  'use strict';

  function $(id){ return document.getElementById(id); }
  function setText(id, txt){ var el=$(id); if(el) el.textContent = String(txt==null?'':txt); }

   function showPanel(){
    var p = $('skai-ai-central');
    // Always force panel visible on show, even if it was hidden via CSS (display:none in stylesheet)
    if (p){ p.style.display = ''; }
    // REMOVED: document.body.classList.add('skai-running');
    // Reason: skai-running triggered global gray-out styles on load.
  }
  function hidePanel(){
    var p = $('skai-ai-central');
    if (p){ p.style.display = 'none'; }
    // REMOVED: document.body.classList.remove('skai-running');
    // Reason: gray-out feature retired.
  }

  function stage(main, sub){
    setText('ai-central-stage', main);
    setText('ai-central-sub', sub);
    // Also update consolidated progress card
    setText('skai-progress-stage-msg', main);
    setText('skai-progress-sub-msg', sub);
  }

  // Mount (in case #skai-run-options appears after DOM load)
  function ensureMounted(){
    try{
      var panel = $('skai-ai-central'); if(!panel) return;
      var anchor = document.getElementById('skai-run-options');
      if (anchor && anchor.parentNode && panel.previousElementSibling !== anchor){
        anchor.parentNode.insertBefore(panel, anchor.nextSibling);
      }
    }catch(_){}
  }

  if (document.readyState === 'loading'){
    // [FIX] ES5-safe "once": remove listener manually.
    var __skaiMountOnce = function(){
      try { ensureMounted(); showPanel(); }  // FIX: Show panel on page load
      finally { document.removeEventListener('DOMContentLoaded', __skaiMountOnce); }
    };
    document.addEventListener('DOMContentLoaded', __skaiMountOnce, false);
  } else { ensureMounted(); showPanel(); }  // FIX: Show panel on page load

 // === Event wiring ===

window.addEventListener('skai:tf-ready', function(){
  showPanel();
  stage('Preparing', 'AI engine ready.');
});

window.addEventListener('skai:autotune:begin', function(){
  showPanel();
  stage('Auto-Tune', 'Estimating best window...');
});

window.addEventListener('skai:autotune:progress', function(e){
  var d = (e && e.detail) || {};
  // Auto-tune doesn't have "loss", it has "score" from backtest. Show window being tested instead.
  stage('Auto-Tune', 'Testing window W=' + (d.W != null ? d.W : 'n/a') + '...');
});

window.addEventListener('skai:autotune:done', function(e){
  // FIX: use e.detail.W instead of undefined "detail"
  var W = (e && e.detail && (e.detail.W || (e.detail.best && e.detail.best.W))) || 'N/A';
  stage('Training', 'Auto-Tune complete (W=' + W + '). Starting training...');
});

window.addEventListener('skai:ml:start', function(){
  showPanel();
  stage('Training', 'Main numbers...');
});

  window.addEventListener('skai:ml:epoch', function(e){
    var d = (e && e.detail) || {};
    if (d.totalEpochs > 0){
      var zeroBased = !!d.zeroBased;
      var displayEpoch = Number(d.epoch||0) + (zeroBased ? 1 : 0);
      if (isFinite(+d.totalEpochs)) { displayEpoch = Math.min(displayEpoch, +d.totalEpochs); }
      stage('Training', 'Main ' + displayEpoch + '/' + d.totalEpochs);
    }
  });

window.addEventListener('skai:ml:done', function(){
  try{
    var meta = window.SKAI_META || {};
    if (meta && meta.hasExtraBall){
      var _msg_extra = (typeof SKAI_msg === 'function') ? SKAI_msg('trainingExtra') : 'Training extra...';
      try { SKAI_stageSync(_msg_extra); } catch(_){}
    } else {
      var _msg_gen = (typeof SKAI_msg === 'function') ? SKAI_msg('generating') : 'Generating...';
      stage('Scoring', _msg_gen);
      try { if (typeof window.setLive === 'function') window.setLive(_msg_gen); } catch(_){}
    }
  } catch(_){
    var _msg_gen2 = (typeof SKAI_msg === 'function') ? SKAI_msg('generating') : 'Generating...';
    stage('Scoring', _msg_gen2);
    try { if (typeof window.setLive === 'function') window.setLive(_msg_gen2); } catch(_){}
  }
}); // removed { once:true } to allow UI updates after every run

window.addEventListener('skai:extra:start', function(){
  var _m = (typeof SKAI_msg === 'function') ? SKAI_msg('trainingExtra') : 'Training extra...';
  try { stage && stage('Training', _m); } catch(_){}
  try { if (typeof window.setLive === 'function') window.setLive(_m); } catch(_){}
}); // removed { once:true }

window.addEventListener('skai:extra:epoch', function(e){
  try {
    var d = (e && e.detail) || {};
    if (d.totalEpochs > 0){
      var zeroBased = !!d.zeroBased;
      var displayEpoch = Number(d.epoch||0) + (zeroBased ? 1 : 0);
      if (isFinite(+d.totalEpochs)) { displayEpoch = Math.min(displayEpoch, +d.totalEpochs); }
      if (typeof stage === 'function') stage('Training', 'Extra ' + displayEpoch + '/' + d.totalEpochs);
    }
  } catch(_){}
});

window.addEventListener('skai:extra:done', function(){
var _m = 'Generating Predictions - Computing Probabilities...';
  // Nudge progress to ~95% so users see motion until finalization.
  try {
    var P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress()
          : (window.SKAI_Progress || (typeof window.ensureProgressAPI === 'function'
                ? window.ensureProgressAPI()
                : null));

    if (!P || typeof P.set !== 'function') {
      // Developer-facing signal: no silent dummy. If you see this, wire SKAI_getProgress / SKAI_Progress / ensureProgressAPI.
      console.error('[SKAI] Progress API missing in skai:extra:done. Unable to update progress to 95%.');
    } else {
      P.set(95, _m);
    }
  } catch(err){
    // Also surface unexpected errors once instead of swallowing silently.
    try { console.error('[SKAI] Progress update failed in skai:extra:done:', err); } catch(_){}
  }
  try { if (typeof stage === 'function') stage('Scoring', _m); } catch(_){}
  try { if (typeof window.setLive === 'function') window.setLive(_m); } catch(_){}
}); // removed { once:true }  // NOTE: no dummy progress API; missing wiring is now visible in console

window.addEventListener('skai:done', function(){
var _m = (typeof SKAI_msg === 'function') ? SKAI_msg('allFinished') : 'Analysis complete.';
  stage('Complete', _m);
  try { if (typeof window.setLive === 'function') window.setLive(_m); } catch(_){}
  // Reset run-active flag so subsequent runs are treated as fresh.
  try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
// FIX: Keep panel visible per user request - do not auto-hide
// setTimeout(hidePanel, 1200);
}); // removed { once:true } so panel updates on every run

window.addEventListener('skai:analysis-stop', function(e){
    // NEW: log full detail to console so we see the real cause, not just "An error occurred."
    try {
      var raw = e && e.detail;
      if (raw) {
        console.error('[SKAI] analysis-stop detail:', raw);
        if (raw.error) {
          console.error('[SKAI] underlying error:', raw.error);
          // If tfjs passed a real Error, log its stack too
          if (raw.error.stack) {
            console.error('[SKAI] error stack:', raw.error.stack);
          }
        }
      } else {
        console.error('[SKAI] analysis-stop fired with no detail payload.');
      }
    } catch (_){}

    var msg = (e && e.detail && (e.detail.message || e.detail.reason)) ? String(e.detail.message || e.detail.reason) : 'An error occurred.';
    stage('Error', msg);
    try { if (typeof window.setLive === 'function') window.setLive('Error: ' + msg, 'error'); } catch(_){}
    // Finalize progress UI on error as well (prevents a stuck mid-bar).
    try {
      var P = (typeof window.ensureProgressAPI==='function') ? window.ensureProgressAPI() : (window.SKAI_Progress || null);
      if (P && typeof P.done === 'function') {
        P.done((typeof SKAI_msg==='function') ? SKAI_msg('error') : 'Error.');
      }
    } catch(_){}

    // Keep panel visible so user can see the message, but remove running flag.
    document.body.classList.remove('skai-running');
    // Also reset run-active state so a fresh run can start cleanly after an error.
    try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
  });
})();

</script>

<script>
;(function(){
  'use strict';
  if (window.__skaiSortInit) return; window.__skaiSortInit = true;

  function text(el){ return (el && el.textContent || '').trim(); }

  // Robust numeric parser: %, fractions "a/b", plain ints/floats, else fallback string
  function parseValue(s){
    if (s == null) return {num:NaN, str:''};
    s = String(s).trim();
    if (!s) return {num:NaN, str:''};

    // Percent "12.3%"
    if (/%$/.test(s)){
      var v = parseFloat(s.replace('%',''));
      return {num:isNaN(v)?NaN:v, str:s};
    }
    // Fraction "3/17" - ratio (a/b); tie-break by a then b
    if (s.indexOf('/')>0){
      var parts = s.split('/');
      var a = parseFloat(parts[0]); var b = parseFloat(parts[1]);
      var ratio = (!isNaN(a) && !isNaN(b) && b!==0) ? (a/b) : NaN;
      // encode tie data on string so we can use it if needed
      return {num:ratio, str:s, a:isNaN(a)?0:a, b:isNaN(b)?0:b};
    }
    // Plain number (handles "07")
    var n = parseFloat(s);
    if (!isNaN(n)) return {num:n, str:s};

    // Fallback string
    return {num:NaN, str:s.toLowerCase()};
  }

  function compareCells(aCell, bCell, dir){
    var av = parseValue(text(aCell));
    var bv = parseValue(text(bCell));

    // numeric first when both numeric
    var aNum = av.num, bNum = bv.num;
    if (!isNaN(aNum) && !isNaN(bNum)){
      if (aNum !== bNum) return (aNum < bNum ? -1 : 1) * dir;
      // If they were fractions with equal ratio, tie-break on raw a then b
      if (typeof av.a === 'number' && typeof bv.a === 'number' && av.a !== bv.a) return (av.a < bv.a ? -1 : 1) * dir;
      if (typeof av.b === 'number' && typeof bv.b === 'number' && av.b !== bv.b) return (av.b < bv.b ? -1 : 1) * dir;
      // final tiebreaker: raw label
      return text(aCell).localeCompare(text(bCell)) * dir;
    }
    // One numeric, one not - numeric first
    if (!isNaN(aNum) && isNaN(bNum)) return -1 * dir;
    if (isNaN(aNum) && !isNaN(bNum)) return 1 * dir;

    // both non-numeric: lexical
    return av.str.localeCompare(bv.str) * dir;
  }

  function sortTable(table, colIdx, th){
    var tbody = table.tBodies[0]; if (!tbody) return;
    var rows = Array.prototype.slice.call(tbody.rows);
    var current = th.getAttribute('aria-sort') || 'none';
    var next = (current === 'ascending') ? 'descending' : 'ascending';
    var dir = (next === 'ascending') ? 1 : -1;

    // clear aria-sort on siblings
    var ths = th.parentNode.children;
    for (var i=0;i<ths.length;i++){ if (ths[i] !== th) ths[i].setAttribute('aria-sort','none'); }
    th.setAttribute('aria-sort', next);

    // If the clicked header has no data-key, skip (e.g., "Why?" column)
    if (!th.hasAttribute('data-key')) return;

    // Perform sort
    rows.sort(function(r1, r2){
      var c1 = r1.cells[colIdx], c2 = r2.cells[colIdx];
      return compareCells(c1, c2, dir);
    });

    // Re-attach in sorted order (stable enough for our size)
    var frag = document.createDocumentFragment();
    for (var j=0;j<rows.length;j++) frag.appendChild(rows[j]);
    tbody.appendChild(frag);
  }

  function init(){
    var tables = document.querySelectorAll('.skai-table:not(.skai-sortable)');
    for (var t=0;t<tables.length;t++){
      var table = tables[t];

      // FIX: mark as sortable once we bind it, so no other sorter grabs it later.
      if (table.classList) table.classList.add('skai-sortable');

      var thead = table.tHead; if (!thead || !thead.rows[0]) continue;
      var ths = thead.rows[0].cells;
      for (var i=0;i<ths.length;i++){
        var th = ths[i];

        // Initialize aria-sort for a11y
        if (!th.hasAttribute('aria-sort')) th.setAttribute('aria-sort','none');

        // Skip non-sortable headers (no data-key), e.g., Why? column
        if (!th.hasAttribute('data-key')) continue;

        // Attach once
        (function(idx, header){
          header.addEventListener('click', function(e){
            e.preventDefault();
            sortTable(table, idx, header);
          });
          header.addEventListener('keydown', function(e){
            // Enter/Space to sort for keyboard users
            if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); sortTable(table, idx, header); }
          });
          // Make focusable for keyboard sorting
          if (!header.hasAttribute('tabindex')) header.setAttribute('tabindex','0');
        })(i, th);
      }
    }
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>

<script>
;(function(){
  'use strict';
  if (window.__skaiWhyInit) return; window.__skaiWhyInit = true;

  // Shared popover element
  var pop = document.createElement('div');
  pop.className = 'skai-why-pop';
  pop.setAttribute('role','dialog'); pop.setAttribute('aria-modal','false');
  pop.style.display = 'none';
  pop.innerHTML = '<button class="skai-x" aria-label="Close">&times;</button><h4>Why this pick?</h4><div class="skai-why-body"></div>';
  document.body.appendChild(pop);
  var body = pop.querySelector('.skai-why-body'), closer = pop.querySelector('.skai-x');

  function closePop(){ pop.style.display='none'; }
  closer.addEventListener('click', closePop);
  document.addEventListener('click', function(e){
    var t = e && e.target;
    var isWhyBtn = !!(t && t.classList && t.classList.contains('skai-why-btn'));
    if (!pop.contains(t) && !isWhyBtn) closePop();
  });

  function escapeHtml(s){ return String(s).replace(/[&<>"']/g, function(c){
    return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'})[c];
  });}

  function parseProb(text){
    var t = String(text||'').trim();
    // ES5-safe percent check
    if (/%$/.test(t)) return parseFloat(t.replace('%','')) || 0;
    var v = parseFloat(t); if (!isNaN(v) && v<=1) return v*100;
    return isNaN(v)?0:v;
  }

function buildWhyHtml(map){
    map = map || {};
    var label   = map.label || '';
    var skip    = map.skip || '';
    var hits    = map.hits || '';
    var pat     = map.pattern || '';
    var probPct = parseProb(map.prob || '');
    var sup     = map.support || '';
    var cooc    = map.cooc || '';

    // Optional breakdown if sources/components exist
    var sourcesHtml = '';
    try {
      var sources = map.sources || map.components || null;
      if (sources && sources.length){
        sourcesHtml += '<div class="skai-why-block">';
        sourcesHtml +=   '<div class="skai-why-kicker">Attribution</div>';
        sourcesHtml +=   '<ul class="skai-why-list">';
        for (var i=0; i<sources.length; i++){
          var s = sources[i];
          if (s == null) continue;
          sourcesHtml += '<li>' + escapeHtml(String(s)) + '</li>';
        }
        sourcesHtml +=   '</ul>';
        sourcesHtml += '</div>';
      }
    } catch(_){}

    var patHtml = pat ? (
      '<div class="skai-why-block">' +
        '<div class="skai-why-kicker">Pattern</div>' +
        '<div class="skai-why-body">'+escapeHtml(pat)+'</div>' +
      '</div>'
    ) : '';

    var supHtml = sup ? (
      '<div class="skai-why-block">' +
        '<div class="skai-why-kicker">Support</div>' +
        '<div class="skai-why-body">'+escapeHtml(sup)+'</div>' +
      '</div>'
    ) : '';

    var cooHtml = cooc ? (
      '<div class="skai-why-block">' +
        '<div class="skai-why-kicker">Co-occurrence</div>' +
        '<div class="skai-why-body">'+escapeHtml(cooc)+'</div>' +
      '</div>'
    ) : '';

    return ''
      + '<div class="skai-why-head">'
      +   '<div class="skai-why-title">Why this number</div>'
      +   '<div class="skai-why-ball">'+escapeHtml(label)+'</div>'
      + '</div>'
      + '<dl class="skai-why-dl">'
      +   '<div><dt>Estimated hit likelihood</dt><dd>'+probPct.toFixed(1)+'%</dd></div>'
      +   '<div><dt>Current skip</dt><dd>'+escapeHtml(skip)+'</dd></div>'
      +   '<div><dt>Recent hits</dt><dd>'+escapeHtml(hits)+'</dd></div>'
      + '</dl>'
      + supHtml + patHtml + cooHtml + sourcesHtml
      + '<p class="skai-why-note">'
      +   'This explanation reflects your current window and blend settings. "Skip" is how long this number has been absent; "hits" shows how often it appeared inside your recent window.'
      + '</p>';
  }

  function getHeaderKeys(thead){
    var keys=[]; if (!thead || !thead.rows[0]) return keys;
    for (var i=0;i<thead.rows[0].cells.length;i++){
      keys.push(thead.rows[0].cells[i].getAttribute('data-key') || '');
    }
    return keys;
  }

  function mapRow(tr){
    var keys = getHeaderKeys(tr.closest('table').tHead);
    var out={};
    for (var j=0;j<tr.cells.length;j++){
      var k = keys[j] || ('col'+j);
      out[k] = (tr.cells[j].textContent || '').trim();
    }
    return out;
  }

  function positionPop(btn){
    var r = btn.getBoundingClientRect();
    var top = (window.scrollY || document.documentElement.scrollTop) + r.bottom + 6;
    var left = (window.scrollX || document.documentElement.scrollLeft) + r.left;
    var maxLeft = (window.scrollX || 0) + (document.documentElement.clientWidth - 340);
    if (left > maxLeft) left = maxLeft;
    pop.style.top = top + 'px'; pop.style.left = left + 'px';
  }

  function addWhyButtons(){
    var tables = document.querySelectorAll('.skai-table');
    for (var t=0;t<tables.length;t++){
      var table = tables[t];

      // --- NEW: Ensure thead has a matching "Why?" header once (A11Y + column alignment) ---
      try {
        var thead = table.tHead;
        if (thead && thead.rows[0]){
          var headRow = thead.rows[0];

          // If a Why header already exists, do nothing.
          var hasWhyHead = false;
          for (var h=0; h<headRow.cells.length; h++){
            if ((headRow.cells[h].classList && headRow.cells[h].classList.contains('skai-col-why')) ||
                /why\?/i.test((headRow.cells[h].textContent || ''))){
              hasWhyHead = true; break;
            }
          }

          if (!hasWhyHead){
            var th = document.createElement('th');
            th.className = 'skai-col-why';
            th.textContent = 'Why?';
            th.setAttribute('aria-sort', 'none');
            th.setAttribute('data-key', ''); // empty key keeps sorter skipping this column safely
            th.setAttribute('scope', 'col');
            headRow.appendChild(th);
          }
        }
      } catch(_){}

      var tb = table.tBodies && table.tBodies[0];
      if (!tb) continue;

      for (var i=0;i<tb.rows.length;i++){
        var tr = tb.rows[i], last = tr.cells[tr.cells.length-1];

        // If already injected, skip
        if (last && last.querySelector && last.querySelector('.skai-why-btn')) continue;

        var td = document.createElement('td');
        td.className = 'skai-col-why';

        var btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'skai-why-btn';
        btn.textContent = 'Why?';
        btn.setAttribute('aria-label', 'Why this pick?'); // A11Y clarity

        btn.addEventListener('click', function(e){
          e.stopPropagation();
          var map = mapRow(this.closest('tr'));
          body.innerHTML = buildWhyHtml(map);
          positionPop(this);
          pop.style.display='block';
          // ES5/compat: focus() options may throw; fallback to plain focus.
          try { closer.focus({preventScroll:true}); }
          catch(_){ try { closer.focus(); } catch(__){} }
        });

        td.appendChild(btn);
        tr.appendChild(td);
      }
    }
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', addWhyButtons); }
  else { addWhyButtons(); }
})();
</script>

<script>
;(function(){
  'use strict';

  // DISABLED: legacy v2 sorter removed.
  // v1 sorter above is canonical.
  // Keep this block a hard no-op without using "return" (Sourcerer-safe).

  // Sourcerer-safe no-op guard without an early return.
  if (!window.__skaiSortInit2Disabled){
    window.__skaiSortInit2Disabled = true;
    // (intentionally empty)
  }

})();
</script>

  <script>
  ;(function(){
    'use strict';

    var root;

    function initDom(){
      if (!root) root = document.getElementById('skai-ui-root');
    }

    function setRootRunning(on){
      initDom();
      if (!root || !root.classList) return;

      // Collapse-by-class disabled: do NOT add "skai-is-running" anymore.
      // We only ever remove it, in case something else left it behind.
      if (!on){
        root.classList.remove('skai-is-running');
      }
    }

    // Progress Indicator Controller (always visible, just updates stages)
    window.SKAI_ProgressIndicator = {
      setStage: function(stage) {
        var steps = document.querySelectorAll('.skai-progress-step');
        if (!steps || steps.length === 0) return;
        
        for (var i = 0; i < steps.length; i++) {
          var step = steps[i];
          var stepNum = parseInt(step.getAttribute('data-step') || '0', 10);
          var light = step.querySelector('.skai-progress-light');
          
          if (!light) continue;
          
          // Remove all state classes
          light.classList.remove('skai-progress-light--pending');
          light.classList.remove('skai-progress-light--active');
          light.classList.remove('skai-progress-light--completed');
          
          // Set appropriate state
          if (stepNum < stage) {
            light.classList.add('skai-progress-light--completed');
            step.removeAttribute('data-active');
          } else if (stepNum === stage) {
            // Special case: stage 5 (Complete) should show as completed (green), not active (yellow)
            if (stage === 5) {
              light.classList.add('skai-progress-light--completed');
              step.removeAttribute('data-active');
            } else {
              light.classList.add('skai-progress-light--active');
              step.setAttribute('data-active', 'true');
            }
          } else {
            light.classList.add('skai-progress-light--pending');
            step.removeAttribute('data-active');
          }
        }
      },
      reset: function() {
        // Reset all lights to pending state
        this.setStage(0);
      },
      updateDetails: function(computation, eta) {
        // Update the computation details and ETA in the progress indicator card
        var compEl = document.getElementById('skai-progress-computation');
        var etaEl = document.getElementById('skai-progress-eta');
        
        if (compEl && computation) {
          compEl.textContent = computation;
          compEl.style.display = 'block';
        } else if (compEl) {
          compEl.style.display = 'none';
        }
        
        if (etaEl && eta) {
          etaEl.textContent = 'ETA: ' + eta;
          etaEl.style.display = 'block';
        } else if (etaEl) {
          etaEl.style.display = 'none';
        }
      },
      showMathConsole: function() {
        var consoleEl = document.getElementById('skai-math-console');
        if (consoleEl) {
          consoleEl.style.display = 'block';
        }
      },
      addMathLine: function(text, type) {
        // Add a line to the math console
        // type can be: 'autotune', 'training', 'prediction', 'complete'
        var contentEl = document.getElementById('skai-math-console-content');
        if (!contentEl) return;
        
        var line = document.createElement('div');
        line.className = 'skai-math-line' + (type ? ' ' + type : '');
        line.textContent = text;
        contentEl.appendChild(line);
        
        // Auto-scroll to bottom
        var bodyEl = document.getElementById('skai-math-console-body');
        if (bodyEl && !bodyEl.classList.contains('collapsed')) {
          bodyEl.scrollTop = bodyEl.scrollHeight;
        }
        
        // Limit to last 50 lines to prevent memory issues
        while (contentEl.children.length > 50) {
          contentEl.removeChild(contentEl.firstChild);
        }
      },
      clearMathConsole: function() {
        var contentEl = document.getElementById('skai-math-console-content');
        if (contentEl) {
          contentEl.innerHTML = '';
        }
      }
    };

    // Set up math console toggle functionality
    (function() {
      var toggleBtn = document.getElementById('skai-math-console-toggle');
      var bodyEl = document.getElementById('skai-math-console-body');
      
      if (toggleBtn && bodyEl) {
        toggleBtn.addEventListener('click', function() {
          bodyEl.classList.toggle('collapsed');
          toggleBtn.classList.toggle('collapsed');
        });
      }
    })();

    // Public cockpit API (simplified - only progress indicator now)
    window.SKAI_Cockpit = {
      startRun: function(){
        initDom();
        setRootRunning(true);
        
        // Reset progress indicator to starting stage
        window.SKAI_ProgressIndicator.setStage(0);
      },
      tick: function(p, label){
        // Update progress indicator based on progress (normalized 0-1)
        if (typeof p === 'number') {
          var pct = p * 100; // Convert to percentage
          if (pct < 5) window.SKAI_ProgressIndicator.setStage(1);  // Loading Data
          else if (pct < 72) window.SKAI_ProgressIndicator.setStage(2);  // Training Main AI
          else if (pct < 95) window.SKAI_ProgressIndicator.setStage(3);  // Training Extra AI
          else if (pct < 100) window.SKAI_ProgressIndicator.setStage(4);  // Generating Picks
          else window.SKAI_ProgressIndicator.setStage(5);  // Complete
        }
      },
      endRun: function(){
        setRootRunning(false);
        
        // Set to final stage (indicator remains visible)
        window.SKAI_ProgressIndicator.setStage(5);
      },
      log: function(msg){
        // Legacy compatibility - log to console instead
        if (typeof console !== 'undefined' && console.log) {
          console.log('[SKAI]', msg);
        }
      }
    };

    // Mirror SKAI-related console.log output (simplified - just pass through now)
    // Removed console wrapping since we no longer have a console display

    // When the full analysis finishes, close out the cockpit nicely
    // Use the existing SKAI event from this module: "skai:ml:done"
    try{
      window.addEventListener('skai:ml:done', function(){
        try{
          if (window.SKAI_Cockpit && typeof window.SKAI_Cockpit.endRun === 'function'){
            window.SKAI_Cockpit.endRun();
          }
        }catch(_){}
        
        // Set progress indicator to final stage (remains visible)
        try{
          if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.setStage === 'function'){
            window.SKAI_ProgressIndicator.setStage(5);
          }
        }catch(_){}
      }, false);
    }catch(_){}

    // On script load, default to "not running"
    try{
      initDom();
      setRootRunning(false);
    }catch(_){}

  })();

</script>

<script>
// Global safety reset: whenever this page is (re)loaded, make sure SKAI
// does NOT stay stuck in "running" mode and all collapsed sections are open.
(function(){
  function resetSkaiUi(){
    try{
      var root = document.getElementById('skai-ui-root');
      if (root && root.classList && root.classList.contains('skai-is-running')){
        root.classList.remove('skai-is-running');
      }

      // 1) Clear any inline collapse styles from "skai-collapsible-section"
      if (root){
        var sections = root.querySelectorAll('.skai-collapsible-section');
        for (var i = 0; i < sections.length; i++){
          var el = sections[i];
          el.style.maxHeight      = '';
          el.style.marginTop      = '';
          el.style.marginBottom   = '';
          el.style.paddingTop     = '';
          el.style.paddingBottom  = '';
          el.style.display        = ''; // in case any inline display:none leaked in
        }
      }

// 2) Force all SKAI collapsibles to start OPEN
// TEMP DISABLED for debugging collapse issue.
// If collapse starts working, this block is the culprit.
// ----
// var groups = document.querySelectorAll('.skai-collapsible, [data-skai-collapsible]');
// for (var g = 0; g < groups.length; g++){
//   var grp = groups[g];
//   if (grp.classList && grp.classList.contains('skai-collapsed')){
//     grp.classList.remove('skai-collapsed');
//   }
// }
//
// var bodies = document.querySelectorAll('.skai-collapsible-body, [data-skai-body]');
// for (var b = 0; b < bodies.length; b++){
//   var body = bodies[b];
//   body.style.display = 'block';
// }

    }catch(_){}
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', resetSkaiUi);
  } else {
    resetSkaiUi();
  }
})();
</script>
<script>
/* Single start handler (legacy patch) — now disabled.
   Canonical start wiring is handled in SKAI Runner Block R6 (onStartClicked).
   Kept in-place as a dormant fallback for future reference. */
(function(){
  'use strict';
  return; // hard no-op to avoid overwriting canonical #startPrediction bindings

  var btn = document.getElementById('startPrediction');
  if (!btn) return;

  // Drop any previously attached listeners by replacing the node once
  var clean = btn.cloneNode(true);
  btn.parentNode.replaceChild(clean, btn);

  clean.addEventListener('click', function(e){
    try { e.preventDefault(); } catch(_){}
    try { window.__SKAI_USER_ACTION__ = true; } catch(_){}

    // Canonical "user pressed start" signal (used by busy-state code)
    try { window.dispatchEvent(new CustomEvent('skai:start-clicked', { bubbles:true })); } catch(_){}

    // Request the pipeline to begin (consumed by guards/gates)
    try { window.dispatchEvent(new CustomEvent('skai:request-start', { bubbles:true })); } catch(_){}

    // Auto-Tune kickoff is now handled centrally by the watchdog (callAutoTune / Patch E1).

    // instant visual cue without extra events
    try { if (typeof window.SKAI_stageSync === 'function') SKAI_stageSync('Starting...'); } catch(_){}
    try { if (typeof window.setLive === 'function') window.setLive('Starting...'); } catch(_){}

    // Legacy ML starter path; left here for reference only (will not execute due to early return above).
    if (typeof window.SKAI_start === 'function') {
      try { window.SKAI_start(); } catch(_) {}
    }
  }, false);
})();
</script>

<script>
;(function(){
  'use strict';

  function setAutotuneStatus(txt){
    try {
      var el = document.getElementById('skaiAutotuneStatus');
      if (el) el.textContent = txt || '';
    } catch(_){}
  }

  // Auto-Tune is about to start
  window.addEventListener('skai:autotune:begin', function(){
    setAutotuneStatus('Auto-Tune: starting...');
  });

  // Live progress - show which window and step we are on
  window.addEventListener('skai:autotune:progress', function(e){
    var d    = (e && e.detail) || {};
    var W    = (d.W != null) ? d.W : d.window;
    var idx  = d.index;
    var total= d.total;
    var parts = [];

    if (W != null) parts.push('testing window W=' + W);
    if (idx && total) parts.push('step ' + idx + ' of ' + total);

    setAutotuneStatus('Auto-Tune: ' + (parts.join(' | ') || 'in progress...'));
  });

  // Finished – show best window and hint that ML is starting
  window.addEventListener('skai:autotune:done', function(e){
    var d = (e && e.detail) || {};
    var W = d.bestWindow || d.window || (d.best && d.best.W) || '?';
    setAutotuneStatus('Auto-Tune complete | best window W=' + W + ' | starting training...');
  });

  // If analysis is stopped or errors, don-t leave the user hanging
  window.addEventListener('skai:analysis-stop', function(){
    setAutotuneStatus('Auto-Tune stopped or failed. Please try again.');
  });
})();
</script>

<!-- Patch D: Auto-Tune watchdog (ensures Auto-Tune actually starts) -->
<script>
(function(){
  'use strict';
  if (window.__SKAI_AUTOTUNE_WATCHDOG__) return;
  window.__SKAI_AUTOTUNE_WATCHDOG__ = 1;

  // Mark when Auto-Tune actually starts
  window.addEventListener('skai:autotune:begin', function(){
    window.__SKAI_AUTOTUNE_STARTED__ = true;
  }, false);

// launcher names; fall back to emitting the begin event (ES5-safe)
function callAutoTune() {
  // Reuse any existing promise/thenable if Auto-Tune is already running/done
  if (window.SKAI_FLAGS && window.SKAI_FLAGS.autotuneRunning) {
    return window.SKAI_autotunePromise || es5ResolvedNull();
  }
  if (window.SKAI_FLAGS && window.SKAI_FLAGS.autotuneDone && window.SKAI_autotunePromise) {
    return window.SKAI_autotunePromise;
  }

  try {
    if (typeof window.SKAI_autotuneStart === 'function') {
      return window.SKAI_autotuneStart();
    }
    if (typeof window.SKAI_autoTuneStart === 'function') {
      return window.SKAI_autoTuneStart();
    }
    if (typeof window.SKAI_autoTune === 'function') {
      return window.SKAI_autoTune();
    }
    if (typeof window.SKAI_autotune === 'function') {
      return window.SKAI_autotune();
    }

    // Fallback: generic start event so UI doesn-t break if tuner is missing
    if (typeof window.SKAI_emit === 'function') {
      window.SKAI_emit('skai:autotune:begin', {});
    } else if (typeof window.CustomEvent === 'function') {
      window.dispatchEvent(new CustomEvent('skai:autotune:begin', { bubbles: true, detail: {} }));
    }
  } catch (e) {
    try { console.error('[SKAI] Auto-Tune watchdog error:', e); } catch (_) {}
  }

  // Final: return existing promise if one appeared during fallback, else safe null-thenable
  return window.SKAI_autotunePromise || es5ResolvedNull();

  // Local helper: ES5-safe "resolved" thenable
  function es5ResolvedNull() {
    if (typeof Promise !== 'undefined' && Promise && typeof Promise.resolve === 'function') {
      return Promise.resolve(null);
    }
    return {
      then: function (cb) {
        try { if (typeof cb === 'function') cb(null); } catch (_) {}
      }
    };
  }
}

// Arm the watchdog when user initiates a run
  function arm(){
    if (!window.SKAI_CAN_RUN) return; // gate Auto-Tune for non-members
    if (arm.__armed) return; arm.__armed = true;
    // Try immediately, then retry briefly while upstream initializes
    try { callAutoTune(); } catch(_){}
    var tries = 0, maxTries = 10; // ~1s total
    (function tick(){
      if (window.__SKAI_AUTOTUNE_STARTED__) return;
      if (tries++ >= maxTries) return;
      try { callAutoTune(); } catch(_){}
      setTimeout(tick, 100);
    })();
  }

  // Start on explicit click or legacy request-start signal
  window.addEventListener('skai:start-clicked', arm, false);
  window.addEventListener('skai:request-start', arm, false);

  // Safety: if ML tries to start first, kick Auto-Tune before others handle it
  window.addEventListener('skai:ml:start', function(){
    if (!window.SKAI_CAN_RUN) return; // gate Auto-Tune for non-members
    if (!window.__SKAI_AUTOTUNE_STARTED__) {
      try { callAutoTune(); } catch(_){}
    }
  }, true); // capture to preempt downstream ml:start listeners
})();
</script>

<script>
/* Patch: resilient "Show Custom Settings" toggle
   - Works with multiple possible button ids/classes
   - Prevents form submit side-effects
   - A11Y: aria-expanded
   - Safe against double-binding */
(function(){
  'use strict';
  if (window.__SKAI_SHOW_OPTIONS_WIRED__) return;
  window.__SKAI_SHOW_OPTIONS_WIRED__ = 1;

  function q(sel){ try { return document.querySelector(sel); } catch(_){ return null; } }
  function qa(sel){ try { return document.querySelectorAll(sel); } catch(_){ return []; } }

  function getToggles(){
    var list = [];

    // Common ids you may be using
    var ids = [
      '#showCustomSettings',
      '#show-custom-settings',
      '#skaiShowCustomSettings',
      '#skai-show-custom-settings',
      '#skai-show-options',
      '#skaiShowOptions',
      '#customSettingsBtn',
      '#skaiCustomSettingsBtn'
    ];
    for (var i=0;i<ids.length;i++){
      var el = q(ids[i]);
      if (el) list.push(el);
    }

    // Common classes / data hooks (ES5-safe loop)
    var extraToggles = qa('.show-custom-settings, .skai-show-custom-settings, .skai-toggle-options, [data-skai-toggle="run-options"]');
    for (var ei = 0; ei < extraToggles.length; ei++){
      list.push(extraToggles[ei]);
    }

    // De-dupe
    var uniq = [];
    for (var j=0;j<list.length;j++){
      if (uniq.indexOf(list[j]) === -1) uniq.push(list[j]);
    }
    return uniq;
  }

  function setExpanded(btn, open){
    try {
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    } catch(_){}
  }

  // Non-collapsing toggle: always keep Run Options visible, but keep aria state in sync.
  function toggleOptions(btn){
    var panel = document.getElementById('skai-run-options');
    if (!panel) return;

    // Force panel visible to honor "SKAI must never start collapsed"
    panel.style.display = 'block';
    setExpanded(btn, true);
  }

  function bind(btn){
    if (!btn || btn.__skaiBoundShowOpts) return;
    btn.__skaiBoundShowOpts = 1;

    // Prevent accidental submits if inside a form
    try {
      if ((btn.tagName||'').toLowerCase() === 'button'){
        btn.setAttribute('type','button');
      }
    } catch(_){}

    // Initial aria state based on current panel visibility
    try {
      var panel = document.getElementById('skai-run-options');
      var open = panel && panel.style.display !== 'none';
      setExpanded(btn, !!open);
    } catch(_){}

    btn.addEventListener('click', function(e){
      try { e.preventDefault(); e.stopPropagation(); } catch(_){}
      toggleOptions(btn);
    }, false);

    // Keyboard support
    btn.addEventListener('keydown', function(e){
      if (e.key === 'Enter' || e.key === ' ') {
        try { e.preventDefault(); e.stopPropagation(); } catch(_){}
        toggleOptions(btn);
      }
    }, false);
  }

  function wire(){
    var toggles = getToggles();
    for (var i=0;i<toggles.length;i++) bind(toggles[i]);
  }

  if (document.readyState === 'loading'){
    var onceWire = function(){
      try { document.removeEventListener('DOMContentLoaded', onceWire); } catch(_){}
      wire();
    };
    document.addEventListener('DOMContentLoaded', onceWire, false);
  } else {
    wire();
  }
})();
</script>

<script>
/* Shim a minimal progress API so every caller works, even if the global isn-t defined.
   Also provides a SKAI_getProgress() bridge and a safe SKAI_Progress object so
   legacy SKAI_Progress.show() calls don-t throw, but still log clear errors. */
(function(){
  'use strict';
  if (typeof window.ensureProgressAPI === 'function' && typeof window.SKAI_getProgress === 'function') return;

  // Core factory used by both ensureProgressAPI() and SKAI_getProgress()
  function createProgressAPI(){
    var bar  = document.getElementById('skaiProgress');
    var host = document.getElementById('skaiProgressHost');

    // If the DOM isn-t wired, do NOT fake success. Log loudly and return null.
    if (!bar || !host) {
      try {
        console.error('[SKAI] Progress DOM missing: #skaiProgress or #skaiProgressHost not found. Progress bar cannot be updated.');
      } catch(_){}
      return null;
    }

    var api = {
      show: function(msg){
        try{ if (host) host.style.display=''; }catch(_){}
        this.set(1, msg || '');
      },
      set: function(pct, _msg){
        try{
          pct = Math.max(0, Math.min(100, +pct||0));
          if (bar && bar.style) bar.style.width = pct + '%';
        }catch(_){}
      },
      done: function(_msg){
        try{
          if (bar && bar.style) bar.style.width = '100%';
          setTimeout(function(){ if (host) host.style.display=''; }, 300);
        }catch(_){}
      },
      reset: function(){
        try{ if (bar && bar.style) bar.style.width = '0%'; }catch(_){}
      }
    };
    return api;
  }

  // Public helper other code already uses
  if (typeof window.ensureProgressAPI !== 'function') {
    window.ensureProgressAPI = function(){
      return createProgressAPI();
    };
  }

  // Bridge: always return a usable object, and make sure SKAI_Progress is set.
  // If DOM is missing, methods LOG an error instead of silently faking success.
  if (typeof window.SKAI_getProgress !== 'function') {
    window.SKAI_getProgress = function(){
      // If an existing SKAI_Progress with show() exists, just reuse it.
      if (window.SKAI_Progress && typeof window.SKAI_Progress.show === 'function') {
        return window.SKAI_Progress;
      }

      // Try to create a real, DOM-backed API.
      var api = createProgressAPI();
      if (api) {
        window.SKAI_Progress = api;
        return api;
      }

      // Final fallback: safe shell that *logs* errors so you know it-s miswired.
      var shell = {
        show: function(msg){
          try {
            console.error('[SKAI] Progress.show() called but progress DOM is not wired.', msg);
          } catch(_){}
        },
        set: function(pct, msg){
          try {
            console.error('[SKAI] Progress.set(' + pct + ') called but progress DOM is not wired.', msg);
          } catch(_){}
        },
        done: function(msg){
          try {
            console.error('[SKAI] Progress.done() called but progress DOM is not wired.', msg);
          } catch(_){}
        },
        reset: function(){
          try {
            console.error('[SKAI] Progress.reset() called but progress DOM is not wired.');
          } catch(_){}
        }
      };
      window.SKAI_Progress = shell;
      return shell;
    };
  }

  // If something already called SKAI_Progress.show() directly before, make sure the
  // global is at least a safe object with the same logging behavior.
  if (!window.SKAI_Progress || typeof window.SKAI_Progress.show !== 'function') {
    window.SKAI_Progress = window.SKAI_getProgress();
  }
})();
</script>

<script>
;(function(){
  'use strict';

  // helper for robust closest across odd targets (text nodes, document, etc.)
  function SKAI_closest(node, sel){
    var el = node;
    try {
      // Walk up from text nodes etc. to the nearest element
      while (el && el.nodeType !== 1) {
        el = el.parentNode;
      }
      if (!el) return null;

      // Use native closest when available
      if (typeof el.closest === 'function') {
        return el.closest(sel);
      }

      // Fallback manual traversal
      for (var cur = el; cur; cur = cur.parentElement){
        if (cur.matches && cur.matches(sel)) {
          return cur;
        }
      }
    } catch (_){}
    return null;
  }

  // make available to other blocks that check for it
  try {
    if (typeof window.SKAI_closest !== 'function') {
      window.SKAI_closest = SKAI_closest;
    }
  } catch (_){}

  // 1) Stop legacy preset delegate WITHOUT blocking our own chip handlers
  document.addEventListener('click', function(e){
    try {
      var t = SKAI_closest(e.target, '[data-profile],[data-skai-profile],[data-preset]');
      if (!t) return;

      // If the click happened inside our new options block, let it bubble to our handlers.
      if (SKAI_closest(t, '#skai-run-options')) return;

      // Elsewhere (legacy preset buttons): neutralize auto-run side-effects
      e.stopPropagation();   // don't bubble to legacy listeners
      e.preventDefault();    // prevent form submits / auto-run
    } catch (_){}
  }, true); // capture, but no stopImmediatePropagation

  // 2) Belt-and-suspenders: force SKAI_applyPresetAndMaybeRun to NEVER auto-run
  //    even if some other code calls it with autoRun=true.
  try {
    var orig = window.SKAI_applyPresetAndMaybeRun;
    if (typeof orig === 'function') {
      window.SKAI_applyPresetAndMaybeRun = function(name/*, autoRun*/){
        // always pass autoRun=false
        try {
          return orig(name, false);
        } catch (e) {
          try { console.warn('Preset apply override:', e); } catch (_){}
        }
      };
    }
  } catch (_){}

  // 3) Ensure any preset-like buttons act as plain buttons (no form submit)
  try {
    var nodes = document.querySelectorAll('[data-profile],[data-skai-profile],[data-preset]');
    for (var i = 0; i < nodes.length; i++) {
      var el = nodes[i];
      if ((el.tagName||'').toLowerCase() === 'button' && (el.getAttribute('type')||'').toLowerCase() !== 'button') {
        el.setAttribute('type', 'button');
      }
      el.setAttribute('data-auto-run','0'); // just in case
    }
  } catch (_){}

})();
</script>

<script>
  (function(){
    var el   = document.getElementById('skai-blend-range');
    var pill = document.getElementById('skai-blend-center');
    if (!el || !pill) return;

    function setVal(){
      var v = parseInt(el.value, 10);
      if (isNaN(v)) v = 0;
      pill.textContent = v + '%';
    }

    // Init + live update
    setVal();
    el.addEventListener('input',  setVal);
    el.addEventListener('change', setVal);
  })();
</script>
 
<script>
;(function(){
  'use strict';

  // Ensure page loads in "defer start" mode and NOT a user action
  if (typeof window.__SKAI_DEFER_START__ === 'undefined') window.__SKAI_DEFER_START__ = true;
  if (typeof window.__SKAI_USER_ACTION__ === 'undefined') window.__SKAI_USER_ACTION__ = false;

  function text(el, s){ if (el) el.textContent = s; }
  function pressedLabel(rowId){
    var row = document.getElementById(rowId);
    if (!row) return '';
    var b = row.querySelector('.btn-chip[aria-pressed="true"]');
    return b ? (b.textContent || '').trim() : '';
  }

  function computeLabel(aiPct){
    if (aiPct <= 15) return 'Skip-leaning';
    if (aiPct >= 85) return 'AI-leaning';
    return 'Hybrid';
  }

  // --- B2 helpers: preset map + setter (keeps range & number in sync) ---
  var __SKAI_PRESETS__ = {
    balanced: {
      // Revised defaults (Balanced): AI% 55 handled by blend slider/strategy; this block is the advanced training + mixing knobs.
      epochs:90, batch:32, dropout:0.25, lr:0.0008, decay:0.95,
      window:500, layers:2, activation:'tanh', temp:0.80, diversity:0.02, gap:0.12
    },
    explorative: {
      // Revised defaults (Explorative)
      epochs:80, batch:32, dropout:0.30, lr:0.0008, decay:0.93,
      window:500, layers:3, activation:'relu', temp:1.05, diversity:0.05, gap:0.18
    },
    conservative: {
      // Revised defaults (Conservative)
      epochs:70, batch:32, dropout:0.30, lr:0.0007, decay:0.96,
      window:500, layers:2, activation:'tanh', temp:0.70, diversity:0.01, gap:0.08
    }
  };

  function setPair(rangeId, numId, val){
    var r = document.getElementById(rangeId);
    var n = document.getElementById(numId);
    if (r){ r.value = String(val); try{ r.dispatchEvent(new CustomEvent('input',{bubbles:true})); r.dispatchEvent(new CustomEvent('change',{bubbles:true})); }catch(_){} }
    if (n){ n.value = String(val); try{ n.dispatchEvent(new CustomEvent('input',{bubbles:true})); n.dispatchEvent(new CustomEvent('change',{bubbles:true})); }catch(_){} }
  }

  function applyPreset(name){
    var p = __SKAI_PRESETS__[(name||'').toLowerCase()]; if (!p) return;
    setPair('skaiadv_epochs','skaiadv_epochs_num', p.epochs);
    setPair('skaiadv_batch','skaiadv_batch_num', p.batch);
    setPair('skaiadv_dropout','skaiadv_dropout_num', p.dropout);
    setPair('skaiadv_lr','skaiadv_lr_num', p.lr);
    setPair('skaiadv_decay','skaiadv_decay_num', p.decay);
    setPair('skaiadv_window','skaiadv_window_num', p.window);
    setPair('skaiadv_layers','skaiadv_layers_num', p.layers);
    // Selects
    var act = document.getElementById('skaiadv_activation'); if (act){ act.value = p.activation; act.dispatchEvent(new Event('change',{bubbles:true})); }
    setPair('skaiadv_temp','skaiadv_temp_num', p.temp);
    setPair('skaiadv_diversity','skaiadv_diversity_num', p.diversity);
    setPair('skaiadv_gap','skaiadv_gap_num', p.gap);

// (changed) Do NOT mark settings as applied from a UI preset.
// Rationale: Only Auto-Tune (or the component that writes tuned params) should signal "settings applied."
// This preserves the requirement that ML starts only after Auto-Tune has applied tuned parameters.
  }

function updateSummary(){
  var profile  = pressedLabel('skai-profile-buttons')   || 'Balanced';
  var strategy = pressedLabel('skai-strategy-buttons')  || 'Hybrid';
  var blendEl  = document.getElementById('skai-blend-range');
  var ai       = blendEl ? parseInt(blendEl.value, 10) : 55; // default Balanced AI%
  if (!isNum(ai)) ai = 55;
  var skip     = Math.max(0, Math.min(100, 100 - ai));
  var label    = computeLabel(ai);

  // 1) keep existing inline summary
  var line = 'Selected: Profile = ' + profile
  + ' | Strategy = ' + strategy
  + ' | Blend = Skip ' + skip + '% / AI ' + ai + '% (' + label + ')';
  (function(el){ if (el) el.textContent = line; })(document.getElementById('skai-selection-summary'));

  // 2) Broadcast only if unified emitter is NOT installed (prevent double-emits)
  try {
    if (!window.__SKAI_OPTIONS_EMITTER__) {
      var legacy = { profile: profile, strategy: strategy, aiPercent: ai, skipPercent: skip, blendLabel: label };
      window.dispatchEvent(new CustomEvent('skai:ui:selection-changed', { detail: legacy, bubbles: true }));
    }
  } catch(_) {}

  // 3) opportunistic direct bindings (works even if no listener is installed)
  //    data-bind targets
  try {
    var bind = function(sel, val){
      var nodes = document.querySelectorAll(sel);
      for (var i = 0; i < nodes.length; i++){
        nodes[i].textContent = String(val);
      }
    };
    bind('[data-skai-bind="profile"]',       profile);
    bind('[data-skai-bind="strategy"]',      strategy);
    bind('[data-skai-bind="aiPercent"]',     ai + '%');
    bind('[data-skai-bind="skipPercent"]',   skip + '%');
    bind('[data-skai-bind="blendLabel"]',    label);
  } catch(_) {}

  // 4) legacy class hooks (optional)
  try {
    var push = function(sel, val){
      var nodes = document.querySelectorAll(sel);
      for (var i = 0; i < nodes.length; i++){
        nodes[i].textContent = String(val);
      }
    };
    push('.qo-profile',  profile);
    push('.qo-strategy', strategy);
    push('.qo-blend',    'Skip ' + skip + '% / AI ' + ai + '% (' + label + ')');
  } catch(_) {}

  // 5) (changed) Do NOT auto-mark settings as applied here; Auto-Tune will signal when ready.
  // Security/logic: Prevents bypassing the -Auto-Tune ? apply tuned params ? ML- sequence.
  // (Intentionally no call to SKAI_APPLY_SETTINGS_OK here.)

}

  // ES5-safe numeric guard used throughout this module
  function isNum(x){
    return (typeof x === 'number' && isFinite(x));
  }

  function wireGroup(rowId){
    var row = document.getElementById(rowId);
    if (!row || row.__skaiWiredSummary) return;
    row.__skaiWiredSummary = 1;

    row.addEventListener('click', function(e){
      var btn = e.target && e.target.closest('.btn-chip');
      if (!btn) return;
      // prevent any chance of triggering a run
      try { e.preventDefault(); e.stopPropagation(); } catch(_) {}

      // mark as real user interaction
      try { window.__SKAI_USER_ACTION__ = true; } catch(_){}
      Array.prototype.forEach.call(row.querySelectorAll('.btn-chip'), function(b){
        var on = (b === btn);
        b.setAttribute('aria-pressed', on ? 'true' : 'false');
        b.classList.toggle('is-active', on);
      });

      // B2: apply profile preset to Advanced sliders
      if (rowId === 'skai-profile-buttons') {
        var prof = (btn.getAttribute('data-profile')||'balanced').toLowerCase();
        try { applyPreset(prof); } catch(_){}
      }

      // B3: sync Strategy ? Blend slider
      if (rowId === 'skai-strategy-buttons') {
        var strat = (btn.getAttribute('data-strategy')||'hybrid').toLowerCase();
        var target = strat === 'ai' ? 75 : (strat === 'skip' ? 25 : 40);
        var r = document.getElementById('skai-blend-range');
        if (r) {
          r.value = String(target);
          try {
            r.dispatchEvent(new CustomEvent('input',{bubbles:true}));
            r.dispatchEvent(new CustomEvent('change',{bubbles:true}));
          } catch(_){}
        }
      }

      updateSummary();
    }, true);
  }

  function wireSlider(id){
    var el = document.getElementById(id);
    if (!el || el.__skaiWiredSummary) return;
    el.__skaiWiredSummary = 1;

    function maybeSyncStrategy(v){
      var ai = parseInt(v,10); if (!isNum(ai)) return;
      var desired = (ai >= 70) ? 'ai' : (ai <= 30) ? 'skip' : 'hybrid';
      var row = document.getElementById('skai-strategy-buttons'); if (!row) return;

      // If already selected, skip; else toggle to match
      var cur = row.querySelector('.btn-chip[aria-pressed="true"]');
      if (cur && cur.getAttribute('data-strategy') === desired) return;

      Array.prototype.forEach.call(row.querySelectorAll('.btn-chip'), function(b){
        var on = String(b.getAttribute('data-strategy') || '').toLowerCase() === desired;
        b.classList.toggle('is-active', on);
        b.setAttribute('aria-pressed', on ? 'true' : 'false');
        b.setAttribute('aria-checked', on ? 'true' : 'false'); // keep radio semantics consistent
      });
    }

    el.addEventListener('input',  function(){
      try{window.__SKAI_USER_ACTION__=true;}catch(_){}
      maybeSyncStrategy(el.value);
      updateSummary();
    });
    el.addEventListener('change', function(){
      try{window.__SKAI_USER_ACTION__=true;}catch(_){}
      maybeSyncStrategy(el.value);
      updateSummary();
    });
  }

  // --- Visual banner feedback when user changes selections ---
  var $banner = document.getElementById('skai-run-banner');
  // Singleton banner API: define once, reuse everywhere.
  if (typeof window.SKAI_showBanner !== 'function') {
    window.SKAI_showBanner = function(msg){
      var b = $banner || document.getElementById('skai-run-banner');
      if (!b) return;
      try {
        if (b.hasAttribute('hidden')) b.removeAttribute('hidden');
        var t = b.querySelector('.txt');
        if (t && typeof msg === 'string' && msg.trim()) t.textContent = msg;
        b.classList.add('show');
        clearTimeout(b.__hide);
        b.__hide = setTimeout(function(){ b.classList.remove('show'); }, 2500);
      } catch(_){}
    };
  }
  // Hook banner to selection changes within the Run Options card
  function wireBanner(){
    var host = document.getElementById('skai-run-options');
    if (!host || host.__skaiBannerWired) return;
    host.__skaiBannerWired = 1;
    ['click','input','change'].forEach(function(ev){
      host.addEventListener(ev, function(){
        try { window.__SKAI_USER_ACTION__ = true; } catch(_){}
        if (typeof window.SKAI_showBanner === 'function') {
          // More guided, brand-level microcopy
          window.SKAI_showBanner('Settings updated - SKAI is tuned for your next run.');
        }
      }, { passive:true });
    });
  }

  // (keep your existing ready/wiring exactly as-is)
  // Expose summary updater for other modules that check window.updateSummary
  try { window.updateSummary = updateSummary; } catch(_) {}

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){
      wireGroup('skai-profile-buttons');
      wireGroup('skai-strategy-buttons');
      wireSlider('skai-blend-range');
      wireBanner();
      updateSummary();
    }, { once:true });
  } else {
    wireGroup('skai-profile-buttons');
    wireGroup('skai-strategy-buttons');
    wireSlider('skai-blend-range');
    wireBanner();
    updateSummary();
  }
})();
</script>

<script>
/* FINAL INVARIANT ENFORCER:
   SKAI must NEVER start collapsed.
   2025-12-05: EXEMPT #skai-advanced so Custom Settings can start closed. */
(function(){
  'use strict';
  function forceOpen(){
    try {
      var advHost = document.getElementById('skai-advanced');
      var advBody = document.getElementById('skai-adv-body');

      // 1) Run Options must be visible
      var opts = document.getElementById('skai-run-options');
      if (opts) opts.style.display = 'block';

      // 2) Remove any collapsed classes (except Advanced panel)
      var groups = document.querySelectorAll('.skai-collapsible, [data-skai-collapsible], .skai-collapsed');
      for (var i = 0; i < groups.length; i++){
        var el = groups[i];
        // Skip Advanced host + anything inside it
        if (advHost && (el === advHost || advHost.contains(el))) continue;
        el.classList.remove('skai-collapsed');
      }

      // 3) Ensure bodies are shown (except Advanced body)
      var bodies = document.querySelectorAll('.skai-collapsible-body, [data-skai-body]');
      for (var b = 0; b < bodies.length; b++){
        var bodyEl = bodies[b];
        // Skip Advanced body + anything inside it
        if (advBody && (bodyEl === advBody || advBody.contains(bodyEl))) continue;
        bodyEl.style.display = 'block';
        bodyEl.style.maxHeight = '';
      }
    } catch(_){}
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', forceOpen);
  } else {
    forceOpen();
  }

  // Extra safety for bfcache / soft reloads
  window.addEventListener('pageshow', forceOpen);
})();
</script>


<script>
;(function(){
  'use strict';

  function renderInto(container, data){
    if (!container) return;
    // try data-bind targets first
    try {
      var bind = function(name, val){
        var nodes = container.querySelectorAll('[data-skai-bind="'+name+'"]');
        for (var i = 0; i < nodes.length; i++){
          nodes[i].textContent = String(val);
        }
      };
      bind('profile',     data.profile);
      bind('strategy',    data.strategy);
      bind('aiPercent',   data.aiPercent + '%');
      bind('skipPercent', data.skipPercent + '%');
      bind('blendLabel',  data.blendLabel);
    } catch(_){}

    // fallback legacy spans if you use them inside the container
    try {
      var pick = function(sel, val){
        var n = container.querySelector(sel); if (n) n.textContent = String(val);
      };
      pick('.qo-profile',  data.profile);
      pick('.qo-strategy', data.strategy);
      pick('.qo-blend',    'Skip ' + data.skipPercent + '% / AI ' + data.aiPercent + '% (' + data.blendLabel + ')');
    } catch(_){}
  }

  // helper: locate/create the host node for the Hyperparameters line
  function ensureHpHost(){
    var hp = document.getElementById('hp-this-run');
    if (hp) return hp;
    // try to find a heading that says "Hyperparameters (this run)"
    var headers = Array.prototype.slice.call(document.querySelectorAll('h3,h4,h5,strong,.panel-header'));
    var heading = null;
    for (var i = 0; i < headers.length; i++){
      var h = headers[i];
      if (/Hyperparameters\s*\(this run\)/i.test((h.textContent||''))) { heading = h; break; }
    }
    if (heading && heading.parentElement) {
      hp = heading.parentElement.querySelector('.hp-line');
      if (!hp) {
        hp = document.createElement('div');
        hp.className = 'hp-line';
        heading.parentElement.appendChild(hp);
      }
    }
    return hp || null;
  }

  // live recompute from Advanced sliders + Blend (+ Profile/Strategy labels)
  function updateHyperparamsLine(){
    try{
  var g = function(id){ var el=document.getElementById(id); return el ? el.value : null; };
  var W       = parseInt(g('skaiadv_window'),10);        if(!isNum(W)) W = 50;
  var epochs  = parseInt(g('skaiadv_epochs'),10);        if(!isNum(epochs)) epochs = 120;
  var batch   = parseInt(g('skaiadv_batch'),10);         if(!isNum(batch)) batch = 32;
  var layers  = parseInt(g('skaiadv_layers'),10);        if(!isNum(layers)) layers = 2;
  var dropout = parseFloat(g('skaiadv_dropout'));        if(!isNum(dropout)) dropout = 0.20;
  var lr      = parseFloat(g('skaiadv_lr'));             if(!isNum(lr)) lr = 0.001;
  var decay   = parseFloat(g('skaiadv_decay'));          if(!isNum(decay)) decay = 0.90;
  var blend01 = parseInt((g('skai-blend-range')||'40'),10); if(!isNum(blend01)) blend01 = 40;
  var gap     = parseFloat(g('skaiadv_gap'));            if(!isNum(gap)) gap = 0.20;

  // Derive AI vs Skip share for diagnostics (0..1). This matches the main-head
  // blending semantics: aiShare = blend slider, skipShare = 1 - aiShare.
  var aiShare   = Math.max(0, Math.min(1, blend01 / 100));
  var skipShare = 1 - aiShare;

  // Diagnostics gate:
  // - Only log after real user interaction, OR if a debug flag is explicitly enabled.
  // - Throttle to avoid multi-fire on boot / rapid slider events.
  if ((window.__SKAI_USER_ACTION__ === true) || window.__SKAI_DEBUG_BLEND__) {
    try {
      if (typeof console !== 'undefined' && console && typeof console.debug === 'function') {
        var now = Date.now ? Date.now() : +new Date();
        if (!window.__skaiLastBlendDiagTs) window.__skaiLastBlendDiagTs = 0;
        if (now - window.__skaiLastBlendDiagTs > 500) {
          window.__skaiLastBlendDiagTs = now;
          console.debug('[SKAI] Blend diagnostics', {
            rawBlendSlider: blend01,
            aiShare:        aiShare,
            skipShare:      skipShare
          });
        }
      }
    } catch(_){}
  }

  // locate a target line to print into:

      // NEW: read active Profile & Strategy chip labels safely
      var pickPressed = function(rowId){
        var row = document.getElementById(rowId);
        if (!row) return '';
        var btn = row.querySelector('.btn-chip[aria-pressed="true"].is-active') ||
                  row.querySelector('.btn-chip[aria-pressed="true"]') ||
                  row.querySelector('.btn-chip.is-active');
        return btn ? (btn.textContent || '').trim() : '';
      };
      var profileLbl  = pickPressed('skai-profile-buttons')   || 'Balanced';
      var strategyLbl = pickPressed('skai-strategy-buttons')  || 'Hybrid';

      var hp = ensureHpHost();
      if (hp){
        hp.textContent =
          'Hyperparameters (this run): Window ' + W +
          ' | ' + epochs + ' epochs, batch ' + batch +
          ' | ' + layers + ' layers, dropout ' + dropout.toFixed(2) +
          ' | lr ' + lr + ', decay ' + decay.toFixed(2) +
          ' | AI blend ' + blend01 + '% | gap ' + gap.toFixed(2) +
          ' | ' + profileLbl + ' profile | ' + strategyLbl + ' strategy';
      }
    }catch(_){}
  }

  // listen for changes from the UI (normalize event names to handle both emitters)
  function __skaiOnSelectionChanged(e){
    var d = (e && e.detail) || {};
    renderInto(document.getElementById('skai-summary')      || null, d);
    renderInto(document.getElementById('quickOverview')     || null, d);
    // also support page-wide binds (outside the containers)
    try {
      document.querySelectorAll('[data-skai-bind]').length && renderInto(document, d);
    } catch(_){}
    // keep Hyperparameters line in sync with Profile/Strategy/Blend changes
    updateHyperparamsLine();
  }
  window.addEventListener('skai:ui:selection-changed', __skaiOnSelectionChanged);
  window.addEventListener('skai:options:changed',       __skaiOnSelectionChanged);

  // NEW: also update when Advanced sliders change
  (function bindAdvLive(){
    var ids = [
      'skaiadv_window','skaiadv_epochs','skaiadv_batch','skaiadv_layers',
      'skaiadv_dropout','skaiadv_lr','skaiadv_decay','skaiadv_gap',
      'skaiadv_temp','skaiadv_diversity','skai-blend-range'
    ];
    ids.forEach(function(id){
      var el = document.getElementById(id);
      if (!el || el.__hpLiveBound__) return;
      el.__hpLiveBound__ = true;
      el.addEventListener('input',  updateHyperparamsLine);
      el.addEventListener('change', updateHyperparamsLine);
    });
  })();

  // prime with the current state on load (if updateSummary already exists)
  try { if (typeof window.updateSummary === 'function') window.updateSummary(); } catch(_){}
  // NEW: also prime the Hyperparameters line once on load
  try { updateHyperparamsLine(); } catch(_){}
  })();  // CLOSE the IIFE started at the top of this script
</script>

<script>
;(function(){
  'use strict';

  function enhanceChips(rowId){
    var row = document.getElementById(rowId);
    if (!row || row.__skaiKbWired) return;
    row.__skaiKbWired = 1;

    // A11y: treat the chip row as a radiogroup
    row.setAttribute('role', 'radiogroup');

    var chips = Array.prototype.slice.call(row.querySelectorAll('.btn-chip'));
    if (!chips.length) return;

    // Ensure one tabbable item; active chip gets tabindex=0 (roving tabindex) + radio semantics
    var anyOn = false;
    chips.forEach(function(btn){
      var on = btn.classList.contains('is-active') || btn.getAttribute('aria-pressed') === 'true';
      if (on) anyOn = true;
    });

    chips.forEach(function(btn, i){
      var on = btn.classList.contains('is-active') || btn.getAttribute('aria-pressed') === 'true';

      // Active first; if none active, allow first chip to be tabbable
      btn.setAttribute('tabindex', on ? '0' : (!anyOn && i===0 ? '0' : '-1'));

      btn.setAttribute('role', 'radio');
      btn.setAttribute('aria-checked', on ? 'true' : 'false');
    });

    function selectIndex(idx){
      if (!chips.length) return;
      idx = (idx < 0) ? chips.length - 1 : (idx >= chips.length ? 0 : idx);
      var btn = chips[idx];

      // Visual/semantic state
      chips.forEach(function(b, j){
        var on = (j === idx);
        b.classList.toggle('is-active', on);
        b.setAttribute('aria-pressed', on ? 'true' : 'false');
        b.setAttribute('aria-checked', on ? 'true' : 'false'); // radio semantics
        b.setAttribute('tabindex', on ? '0' : '-1');
      });

      try { btn.focus(); } catch(_){}
      // Fire existing click handler so Summary & params stay in sync
      try { btn.click(); } catch(_){}
    }

    row.addEventListener('keydown', function(e){
      var cur = row.querySelector('.btn-chip[aria-pressed="true"]');
      var idx = Math.max(0, chips.indexOf(cur));
      if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D'){
        e.preventDefault(); selectIndex(idx + 1);
      } else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A'){
        e.preventDefault(); selectIndex(idx - 1);
      } else if (e.key === ' ' || e.key === 'Enter'){
        e.preventDefault(); selectIndex(idx);
      }
    });
  }

  enhanceChips('skai-profile-buttons');
  enhanceChips('skai-strategy-buttons');
})();
</script>

<script>
;(function(){
  'use strict';
  // Idempotency guard: prevent duplicate restore/save listeners if this block is injected twice
  if (window.__SKAI_RUN_OPTIONS_PERSIST__) return; window.__SKAI_RUN_OPTIONS_PERSIST__ = 1;
  // Use the same key as the newer pipeline to avoid split-brain state
  var LS_KEY = 'SKAI_RUN_OPTIONS_v1';

  // FIX: Clear any existing localStorage on page load for clean state
  try {
    localStorage.removeItem('SKAI_RUN_OPTIONS_v1');
    localStorage.removeItem('SKAI_QS_OPTS_v1');
    localStorage.removeItem('SKAI_ADV_OPTS_v1');
  } catch(_){}

  function restore(){
    try{
      var raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      var s = JSON.parse(raw)||{};

      // Profile (set state without firing click handlers)
      if (s.profile){
        var prow = document.getElementById('skai-profile-buttons');
        if (prow){
          var firstActiveP = null;
var chipsP = prow.querySelectorAll('.btn-chip');
          Array.prototype.forEach.call(chipsP, function(b, i){
            var on = (String(b.getAttribute('data-profile')) === String(s.profile));
            b.classList.toggle('is-active', on);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
            b.setAttribute('aria-checked', on ? 'true' : 'false'); // a11y sync
            b.setAttribute('tabindex', on ? '0' : (i===0?'0':'-1')); // ensure one tabbable
            if (on && !firstActiveP) firstActiveP = b;
          });
          try { (firstActiveP||chipsP[0]) && (firstActiveP||chipsP[0]).focus(); } catch(_){}
        }
      }

      // Strategy (set state without firing click handlers)
      if (s.strategy){
        var srow = document.getElementById('skai-strategy-buttons');
        if (srow){
          var firstActiveS = null;
		  var chipsS = srow.querySelectorAll('.btn-chip');
          Array.prototype.forEach.call(chipsS, function(b, i){
            var on = (String(b.getAttribute('data-strategy')) === String(s.strategy));
            b.classList.toggle('is-active', on);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
            b.setAttribute('aria-checked', on ? 'true' : 'false'); // a11y sync
            b.setAttribute('tabindex', on ? '0' : (i===0?'0':'-1'));
            if (on && !firstActiveS) firstActiveS = b;
          });
          try { (firstActiveS||chipsS[0]) && (firstActiveS||chipsS[0]).focus(); } catch(_){}
        }
      }

      // FIX: DISABLED blend slider restore - always use HTML default value (55%)
      // Reason: User reported settings being "remembered" causing confusion.
      // Benefit: Clean load every time - slider always starts at HTML default.
      // Previous code restored from localStorage, overriding HTML defaults.
      /*
      if (typeof s.blend === 'number'){
        var r = document.getElementById('skai-blend-range');
        if (r){
          var v = Math.max(0, Math.min(100, s.blend|0));
          r.value = String(v);
          // Keep the visible pill in sync without dispatching events
          var pill = document.getElementById('skai-blend-center');
          if (pill) pill.textContent = v + '%';
          // ALSO sync hidden legacy 0..1 ratio for downstream readers
          var br = document.getElementById('blendRatio');
          if (br) br.value = String((v/100).toFixed(2));
        }
      }
      */

      // Broadcast + refresh summaries so downstream UI is live immediately
      try {
        if (typeof window.updateSummary === 'function') window.updateSummary();
        if (typeof window.SKAI_dispatchOptionsChanged === 'function'){
          window.SKAI_dispatchOptionsChanged({
            profile:  (s.profile||'balanced'),
            strategy: (s.strategy||'hybrid'),
             blend:    (typeof s.blend==='number'? s.blend|0 : 55)
          });
        }
      } catch(_){}

    }catch(_){}
  }

  function save(){
    try{
      function activeData(sel){
        var el = document.querySelector(sel+' .btn-chip.is-active') ||
                 document.querySelector(sel+' .btn-chip[aria-pressed="true"]');
        if (!el) return '';
        return (el.getAttribute('data-profile') || el.getAttribute('data-strategy') || '').toLowerCase();
      }
      var r = document.getElementById('skai-blend-range');
      var data = {
        profile:  activeData('#skai-profile-buttons')  || 'balanced',
        strategy: activeData('#skai-strategy-buttons') || 'hybrid',
                 blend:    r ? (parseInt(r.value,10)||55) : 55

      };
      localStorage.setItem(LS_KEY, JSON.stringify(data));
    }catch(_){}
  }

  // FIX: DISABLED localStorage save operations
  /*
  document.addEventListener('click', function(e){
    var hit = (typeof SKAI_closest === 'function')
      ? SKAI_closest(e.target, '#skai-profile-buttons .btn-chip, #skai-strategy-buttons .btn-chip')
      : (e.target && e.target.closest && e.target.closest('#skai-profile-buttons .btn-chip, #skai-strategy-buttons .btn-chip'));
    if (hit) save();
  }, true);

  var r = document.getElementById('skai-blend-range');
  if (r){
    r.addEventListener('input',  save);
    r.addEventListener('change', save);
  }
  */

  // Wire "Reset selections to defaults" button (Balanced ? Hybrid ? Blend 40%)
  var reset = document.getElementById('skai-reset-selections');
  if (reset && !reset.__skaiResetWired){
    reset.__skaiResetWired = 1;
    reset.addEventListener('click', function(){
      try{
        // Reassert chip state
        var prow = document.getElementById('skai-profile-buttons');
        var srow = document.getElementById('skai-strategy-buttons');
        if (prow){
var pChips = prow.querySelectorAll('.btn-chip');
          Array.prototype.forEach.call(pChips, function(b, i){
            var on = (b.getAttribute('data-profile') === 'balanced');
            b.classList.toggle('is-active', on);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
            b.setAttribute('aria-checked', on ? 'true' : 'false');
            b.setAttribute('tabindex', on ? '0' : (i===0?'0':'-1'));
          });
          try { (pChips[0] && pChips[0].focus()); } catch(_){}
        }
        if (srow){
var sChips = srow.querySelectorAll('.btn-chip');
          Array.prototype.forEach.call(sChips, function(b, i){
            var on = (b.getAttribute('data-strategy') === 'hybrid');
            b.classList.toggle('is-active', on);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
            b.setAttribute('aria-checked', on ? 'true' : 'false');
            b.setAttribute('tabindex', on ? '0' : (i===0?'0':'-1'));
          });
          try { (sChips[0] && sChips[0].focus()); } catch(_){}
        }

        // Slider + pill
        if (r){
          r.value = '40';
          var pill = document.getElementById('skai-blend-center');
          if (pill) pill.textContent = '40%';
          // Keep hidden 0..1 ratio synced
          var br = document.getElementById('blendRatio');
          if (br) br.value = '0.40';
        }

        // Persist + broadcast
        save();
        if (typeof window.updateSummary === 'function') window.updateSummary();
        if (typeof window.SKAI_dispatchOptionsChanged === 'function'){
          window.SKAI_dispatchOptionsChanged({ profile:'balanced', strategy:'hybrid', blend:40 });
        }
      }catch(_){}
    });
  }

  // FIX: DISABLED localStorage persistence - clean load every time
  // Reason: User requirement to remove localStorage and load cleanly
  /*
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', restore, { once:true });
  } else {
    restore();
  }
  */
})();
</script>

<script>
;(function(){
  'use strict';

  // Helper: clamp + label (ES5-safe, no Number.isFinite)
  function clamp01(x){
    var v = +x;
    if (!isFinite(v)) v = 0;
    return v < 0 ? 0 : (v > 1 ? 1 : v);
  }
  function labelFor(p){
    if (p >= 0.70) return { tag:'Strong',  tone:'Proceed with confidence (strong signal).' };
    if (p >= 0.40) return { tag:'Balanced', tone:'Reasonable signal - consider alongside your strategy.' };
    return { tag:'Cautious', tone:'Weak signal - use conservatively or re-run with tweaks.' };
  }

  // Public API so ML / Auto-Tune can push real confidence at any time
  // Accepts either 0..1 (ratio) or 0..100 (percent). Normalizes safely.
  window.SKAI_setConfidence = function(conf){
    try{
      var host = document.getElementById('skai-confidence-explainer');
      if (!host) return;
      // Unhide section on first data
      if (host.style.display === 'none') host.style.display = '';

      var v = Number(conf);
      if (!isFinite(v)) return; // do NOT force to 0% when we have no data

      // Normalize: if it looks like a ratio (0..1), convert to percent.
      var pct = (v >= 0 && v <= 1) ? (v * 100) : v;
      pct = Math.round(pct);
      if (pct < 0)   pct = 0;
      if (pct > 100) pct = 100;
      var pct01 = pct / 100; // 0..1 normalized

      var bar   = document.getElementById('skai-confidence-bar');
      var num   = document.getElementById('skai-confidence-score');
      var lbl   = document.getElementById('skai-confidence-label');

      // 1) linear bar + numeric %
      if (bar) bar.style.width = pct + '%';
      if (num){ num.textContent = pct + '%'; }

      // 2) radial gauge (SVG arc)
      try{
        var arc   = document.getElementById('skai-gauge-arc');
        var label = document.getElementById('skai-gauge-label');
        // this arc uses stroke-dasharray: 151; map 0..1 to 0..151, and invert offset
        var CIRC  = 151;
        if (arc) arc.setAttribute('stroke-dashoffset', String((1 - pct01) * CIRC));
        if (label) label.textContent = pct + '%';
      }catch(_){}

      // 3) text label
      var L = labelFor(pct01);
      if (lbl){
        lbl.textContent =
          'Confidence: ' + pct + '% \u2022 Recommendation: ' + L.tag + ' \u2022 ' + L.tone;
      }
    }catch(_){/*no-op*/}
  };

  // Auto-initialize from known sources if present; else wait for events
  (function bootstrap(){
    try{
      var m = window.SKAI_META || {};
      var s = window.SKAI_SERVER || {};
      var c = isFinite(+m.confidence) ? +m.confidence
            : isFinite(+s.confidence) ? +s.confidence
            : NaN;
      if (isFinite(c)) window.SKAI_setConfidence(c);
    }catch(_){}
  })();

  // Listen for confidence updates (both legacy & modern), accept 0..1 or 0..100
  function __skai_conf_norm(v){
    var x = Number(v);
    if (!isFinite(x)) return null;
    if (x <= 1 && x >= 0) return x;           // already 0..1
    if (x <= 100 && x >= 0) return x / 100;   // 0..100 → 0..1
    return null;
  }
  function __skai_conf_handler(e){
    var v = e && e.detail && e.detail.value;
    var n = __skai_conf_norm(v);
    if (n == null) return;
    try { window.SKAI_setConfidence(n); } catch(_){}
  }
  window.addEventListener('skai:confidence',        __skai_conf_handler);
  window.addEventListener('skai:confidence:update', __skai_conf_handler);

  // Also refresh on finalization if a confidence is exposed there
  window.addEventListener('skai:done', function(){
    try{
      var m = window.SKAI_META || {};
      if (isFinite(+m.confidence)) window.SKAI_setConfidence(+m.confidence);
    }catch(_){}
  });
})();
</script>

<!-- Patch E1: Gate ML until Auto-Tune has completed -->
<script>
(function(){
  'use strict';
  if (window.__SKAI_ML_GATE__) return; window.__SKAI_ML_GATE__ = 1;

  var tuning = false, tuned = false;

  window.addEventListener('skai:autotune:begin', function(){ tuning = true; }, false);
  window.addEventListener('skai:autotune:done',  function(){ tuning = false; tuned = true; }, false);

  // If ML tries to start while Auto-Tune is still running, block it (capture) and retry after tuning.
  window.addEventListener('skai:ml:start', function(e){
    // If tuning is already done, let ML run normally.
    if (tuned) return;

    // If Auto-Tune is not even running, do NOT start it here anymore.
    // We assume the watchdog / user flow already kicked Skip & Hit.
    if (!tuning) {
      return; // allow ML to proceed (or other logic to handle it)
    }

    // At this point, Auto-Tune is in progress (tuning === true, tuned === false).
    // Block this ml:start and re-emit it after tuning finishes.
    try { if (e && e.stopImmediatePropagation) e.stopImmediatePropagation(); } catch(_){}

    var resume = function(){
      window.removeEventListener('skai:autotune:done', resume, false);
      try { window.dispatchEvent(new CustomEvent('skai:ml:start', { bubbles:true })); } catch(_){}
    };
    window.addEventListener('skai:autotune:done', resume, false);
  }, true); // capture phase to preempt downstream ML listeners
})();
</script>

<!-- Patch E2: Confidence bridge (wires multiple sources into SKAI_setConfidence) -->
<script>
(function(){
  'use strict';
  if (window.__SKAI_CONF_BRIDGE__) return; window.__SKAI_CONF_BRIDGE__ = 1;

  function maybeSet(v){
    var x = Number(v);
    if (isFinite(x)) {
      try {
        if (typeof window.SKAI_setConfidence === 'function') {
          window.SKAI_setConfidence(x);
        }
      } catch(_){}
    }
  }

  // If the tuner reports confidence/score, show it immediately.
  window.addEventListener('skai:autotune:done', function(e){
    var d = (e && e.detail) || {};
    maybeSet(d.confidence || (d.best && d.best.confidence) || d.score);
  }, false);

  // If training emits live metrics, prefer those.
  window.addEventListener('skai:ml:metrics', function(e){
    var d = (e && e.detail) || {};
    // Keep the existing behavior (updates gauge / pill via maybeSet)
    maybeSet(d.confidence);

    // UX: also reflect confidence in the live status line in plain language
    try {
      if (d.confidence != null) {
        var raw = +d.confidence;
        if (isFinite(raw)) {
          var pct = raw > 1 ? raw : (raw * 100);
          pct = Math.max(0, Math.min(100, Math.round(pct)));
          var live = document.getElementById('ai-live-status');
          if (live) {
            live.textContent = 'Prediction confidence: ' + pct +
              '%. Higher values mean SKAI sees a clearer pattern in the recent draws.';
          }
        }
      }
    } catch(_){}
  }, false);

  // Final safety: after the whole run, use meta/server if present.
  window.addEventListener('skai:done', function(){
    try {
      var m = window.SKAI_META || {};
      var s = window.SKAI_SERVER || {};
      maybeSet(m.confidence || s.confidence);
    } catch(_){}
  }, false);
})();
</script>


<script>
/* Patch v2: Advanced toggle (delegated + capture + !important collapse) */
(function(){
  'use strict';
  if (window.__SKAI_ADV_TOGGLE_WIRED_V2__) return;
  window.__SKAI_ADV_TOGGLE_WIRED_V2__ = 1;

  function q(id){ return document.getElementById(id); }
  function closest(el, sel){
    while (el && el.nodeType === 1){
      if (el.matches && el.matches(sel)) return el;
      el = el.parentElement;
    }
    return null;
  }

  function setOpen(box, body, btn, open){
    // state class
    try { box.classList.toggle('skai-collapsed', !open); } catch(_){}

    // FORCE styles (important) so no CSS/legacy JS can override
    if (open){
      body.style.setProperty('display', 'block', 'important');
      body.style.setProperty('overflow', 'hidden', 'important');
      body.style.setProperty('max-height', body.scrollHeight + 'px', 'important');
      body.style.setProperty('margin-top', '10px', 'important');
      body.style.setProperty('padding-top', '', 'important');
      body.style.setProperty('padding-bottom', '', 'important');
    } else {
      body.style.setProperty('overflow', 'hidden', 'important');
      body.style.setProperty('max-height', '0px', 'important');
      body.style.setProperty('margin-top', '0px', 'important');
      // hide after transition
      setTimeout(function(){
        if (box.classList.contains('skai-collapsed')){
          body.style.setProperty('display', 'none', 'important');
        }
      }, 200);
    }

    // label + carat
    try {
      var head = box.querySelector('[data-skai-head]');
      var showTxt = (head && head.getAttribute('data-text-show')) || 'Show Custom Settings (Advanced)';
      var hideTxt = (head && head.getAttribute('data-text-hide')) || 'Hide Custom Settings (Advanced)';
      var labelNode = btn.querySelector('[data-skai-label-text]');
      var caratNode = btn.querySelector('.carat');
      if (labelNode) labelNode.textContent = open ? hideTxt : showTxt;
      if (caratNode) caratNode.style.transform = open ? 'rotate(0deg)' : 'rotate(-90deg)';
      btn.setAttribute('aria-expanded', open ? 'true' : 'false');
    } catch(_){}
  }

  function toggleFrom(btn){
    var box  = q('skai-advanced');
    var body = q('skai-adv-body');
    if (!box || !body || !btn) return;

    var isOpen = !box.classList.contains('skai-collapsed') && body.style.display !== 'none';
    setOpen(box, body, btn, !isOpen);
  }

  function boot(){
    var box  = q('skai-advanced');
    var body = q('skai-adv-body');
    var btn  = q('skai-adv-toggle');
    if (!box || !body || !btn) return;

    // Default OPEN (unless already collapsed)
    var startOpen = !box.classList.contains('skai-collapsed');
    setOpen(box, body, btn, startOpen);
  }

  // Delegated CAPTURE listener survives cloneNode + beats legacy handlers
  document.addEventListener('click', function(e){
    var btn = closest(e.target, '#skai-adv-toggle');
    if (!btn) return;
    try{
      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    }catch(_){}
    toggleFrom(btn);
  }, true);

  // Keyboard support (capture)
  document.addEventListener('keydown', function(e){
    var btn = closest(e.target, '#skai-adv-toggle');
    if (!btn) return;
    if (e.key !== 'Enter' && e.key !== ' ') return;
    try{
      e.preventDefault();
      e.stopPropagation();
      if (e.stopImmediatePropagation) e.stopImmediatePropagation();
    }catch(_){}
    toggleFrom(btn);
  }, true);

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }
})();
</script>


<script>
  (function(){
    'use strict';
    if (window.__SKAI_WINDOW_INIT__) return; window.__SKAI_WINDOW_INIT__ = 1;

    function isNum(x){ return isFinite(x) && !isNaN(x); }

    function getTotal(){
      try {
        var sv = window.SKAI_SERVER || {};
        if (isNum(+sv.totalRows))   return +sv.totalRows;
        if (isNum(+sv.totalDraws))  return +sv.totalDraws;
        if (isNum(+window.SKAI_DATASET_LENGTH)) return +window.SKAI_DATASET_LENGTH;
        if (isNum(+window.SKAI_DATA_TOTAL))     return +window.SKAI_DATA_TOTAL;
        if (Array.isArray(window.__ALL_DRAWS__))          return window.__ALL_DRAWS__.length;
      } catch(_){}
      return NaN;
    }

    function clamp(n, lo, hi){ n = +n; return n<lo?lo:(n>hi?hi:n); }

    function init(){
      var r = document.getElementById('skaiadv_window');
      var n = document.getElementById('skaiadv_window_num');
      if (!r || !n) return;

      var total = getTotal();
      if (!isNum(total) || total <= 0) return;

      // Remove hidden caps by raising max to the dataset size; keep min as-is.
      var min = Number(r.min||5) || 5;
      var newMax = Math.max(min, total|0);
      r.max = String(newMax);
      n.max = String(newMax);

      // Default value to entire dataset (bounded by newMax) without dispatching events.
      var v = clamp(total|0, min, newMax);
      r.value = String(v);
      n.value = String(v);
    }

    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', init, { once:true });
    } else {
      init();
    }
  })();
</script>

<script>
;(function(){
  'use strict';
  if (window.__SKAI_SUMMARY_SYNC__) return; // prevent duplicates
  window.__SKAI_SUMMARY_SYNC__ = true;

  function updateFrom(detail){
    if (!detail) return;
    // Accept both modern and legacy shapes
    var hasModern = Object.prototype.hasOwnProperty.call(detail, 'blend');
    var prof  = hasModern ? (detail.profile || '')  : (detail.profile || '');   // legacy already capitalized
    var strat = hasModern ? (detail.strategy || '') : (detail.strategy || '');
    var ai    = hasModern ? (detail.blend|0)        : (detail.aiPercent|0);

    // Normalize labels
    if (hasModern) {
    prof  = prof  ? (prof.charAt(0).toUpperCase()  + prof.slice(1))  : 'N/A';
    strat = strat ? (strat.charAt(0).toUpperCase() + strat.slice(1)) : 'N/A';
    } else {
      // legacy already provides human labels; keep as-is
prof  = prof  || 'N/A';
strat = strat || 'N/A';
    }

    var skip = Math.max(0, Math.min(100, 100 - ai));
    ai       = Math.max(0, Math.min(100, ai));

    try {
      var $p = document.getElementById('skai-summary-profile');
      var $s = document.getElementById('skai-summary-strategy');
      var $b = document.getElementById('skai-summary-blend');
      if ($p) $p.textContent = prof;
      if ($s) $s.textContent = strat;
      if ($b) $b.textContent = 'Skip ' + skip + '% / AI ' + ai + '%';
    } catch(_){}
  }

  // One handler; wire to BOTH events
  function onModern(e){ if (e && e.detail) updateFrom(e.detail); }
  function onLegacy(e){ if (e && e.detail) updateFrom(e.detail); }

  window.addEventListener('skai:options:changed',      onModern, false);  // modern
  window.addEventListener('skai:ui:selection-changed', onLegacy, false);  // legacy fallback
})();
</script>

<script>
;(function(){
  'use strict';
  if (window.__SKAI_OPTIONS_EMITTER__) return; // idempotent
  window.__SKAI_OPTIONS_EMITTER__ = true;

  function $(id){ return document.getElementById(id); }

  // --- throttle (ES5-safe) ---
  function throttle(fn, ms){
    var timer = null, last = 0;
    return function(){
      var ctx = this, args = arguments, now = Date.now();
      var run = function(){ last = now; timer = null; try{ fn.apply(ctx, args); }catch(_){ } };
      if (!last || (now - last) >= ms){ run(); }
      else if (!timer){ timer = setTimeout(run, ms - (now - last)); }
    };
  }

  // --- read current UI state (profile, strategy, blend=AI%) ---
  function readState(){
    var profBtn = document.querySelector('#skai-profile-buttons .btn-chip[aria-pressed="true"]');
    var stratBtn= document.querySelector('#skai-strategy-buttons .btn-chip[aria-pressed="true"]');
    var blendEl = $('skai-blend-range');

    var profile  = profBtn ? String(profBtn.getAttribute('data-profile')  || 'balanced') : 'balanced';
    var strategy = stratBtn? String(stratBtn.getAttribute('data-strategy')|| 'hybrid')   : 'hybrid';
    var blend    = blendEl ? (parseInt(blendEl.value,10) || 40) : 40; // 0..100 AI%

    function cap(s){ return s ? s.charAt(0).toUpperCase() + s.slice(1) : s; }
    return {
      profileKey:  profile,
      strategyKey: strategy,
      profile:     cap(profile),
      strategy:    cap(strategy),
      blend:       Math.max(0, Math.min(100, blend))
    };
  }

  // --- unified back-compat emitter (modern + legacy) ---
  function SKAI_dispatchOptionsChanged(detail){
    try{
      // Modern
      window.dispatchEvent(new CustomEvent('skai:options:changed', { detail: detail, bubbles:true }));

      // Legacy shape for older listeners
      var legacy = {
        profile:     (detail.profile || '').charAt(0).toUpperCase() + (detail.profile || '').slice(1),
        strategy:    (detail.strategy || '').charAt(0).toUpperCase() + (detail.strategy || '').slice(1),
        aiPercent:   detail.blend|0,
        skipPercent: Math.max(0, 100 - (detail.blend|0)),
        blendLabel:  (detail.blend >= 70 ? 'AI-Forward' : (detail.blend <= 30 ? 'Skip + ML' : 'Hybrid')) // label normalized
      };
      window.dispatchEvent(new CustomEvent('skai:ui:selection-changed', { detail: legacy, bubbles:true }));
    }catch(_){}
  }
  try { window.SKAI_dispatchOptionsChanged = SKAI_dispatchOptionsChanged; } catch(_){}

  // --- throttled emit ---
  var emit = throttle(function(){
    var detail = readState();
    try{
      SKAI_dispatchOptionsChanged(detail);
    }catch(_){}
  }, 60);

  // --- wire UI changes ---
  function wire(){
    var prof = $('skai-profile-buttons');
    var strat= $('skai-strategy-buttons');
    var blend= $('skai-blend-range');

    if (prof && !prof.__skaiEmitWired){ prof.__skaiEmitWired = 1; prof.addEventListener('click', emit, true); }
    if (strat && !strat.__skaiEmitWired){ strat.__skaiEmitWired = 1; strat.addEventListener('click', emit, true); }
    if (blend && !blend.__skaiEmitWired){
      blend.__skaiEmitWired = 1;
      blend.addEventListener('input',  emit, true);
      blend.addEventListener('change', emit, true);
    }

    // observe programmatic changes
    try{
      var mo = new MutationObserver(emit);
      if (prof)  mo.observe(prof,  { attributes:true, subtree:true, attributeFilter:['aria-pressed','class'] });
      if (strat) mo.observe(strat, { attributes:true, subtree:true, attributeFilter:['aria-pressed','class'] });
      if (blend) mo.observe(blend, { attributes:true, subtree:false, attributeFilter:['value'] });
    }catch(_){}
  }

  function boot(){ wire(); emit(); }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }

  // rebroadcast on these page signals, if used
  window.addEventListener('skai:features-ready', emit, false);
  window.addEventListener('skai:settings:applied', emit, false);
})();
</script>

<div class="help" style="margin:12px auto 0 auto;text-align:center;font-size:0.85rem;line-height:1.4;color:#6b7280;max-width:720px;">
  SKAI predictions are statistical models, not guarantees of outcome. Please play responsibly.
</div>


<script>
;(function(){
  'use strict';

  function isNum(x){ return isFinite(x) && !isNaN(x); }

  // Visible control  -> Legacy hidden ID
  var MAP = [
    ['skaiadv_epochs',     'epochs'],
    ['skaiadv_batch',      'batchSize'],
    ['skaiadv_dropout',    'dropoutRate'],
    ['skaiadv_lr',         'learningRate'],
    ['skaiadv_decay',      'recencyDecay'],
    ['skaiadv_window',     'windowSize'],
    ['skaiadv_layers',     'hiddenLayers'],
    ['skaiadv_activation', 'activationFunction'],
    ['skaiadv_temp',       'temperature'],
    ['skaiadv_diversity',  'diversityPenalty'],
    ['skaiadv_gap',        'gapScale'],
    ['skaiadv_skipgamma',  'skipGamma']
  ];

   // Ensure a hidden input exists. If a host form/node is provided, append there so it submits.
  function ensureHidden(id, host){
    var el = document.getElementById(id);
    if (el) return el;
    el = document.createElement('input');
    el.type = 'hidden';
    el.id   = id;

    // Prefer the caller's form/host so hidden fields are included in POST.
    // Fallback to body to preserve behavior if no form exists.
    try {
      if (host && host.appendChild) {
        host.appendChild(el);
      } else {
        document.body.appendChild(el);
      }
    } catch (_) {
      try { document.body.appendChild(el); } catch(__) {}
    }
    return el;
  }

  // Link each range/number pair with a local reentrancy guard
  function linkPair(baseId){
    var r  = document.getElementById(baseId);
    var nb = document.getElementById(baseId + '_num');
    if (!r || !nb || r.__wiredPair) return;
    r.__wiredPair = nb.__wiredPair = true;

    var updating = false;

    function syncFromRange(){
      if (updating) return;
      updating = true;
      if (nb.value !== r.value) nb.value = r.value;
      // DO NOT dispatch any events here - avoids infinite loops.
      updating = false;
    }
    function syncFromNum(){
      if (updating) return;
      updating = true;
      if (r.value !== nb.value) r.value = nb.value;
      // DO NOT dispatch any events here ? avoids infinite loops
      updating = false;
    }

    r.addEventListener('input',  syncFromRange);
    r.addEventListener('change', syncFromRange);
    nb.addEventListener('input',  syncFromNum);
    nb.addEventListener('change', syncFromNum);
  }

  ['skaiadv_epochs','skaiadv_batch','skaiadv_dropout','skaiadv_lr',
   'skaiadv_decay','skaiadv_window','skaiadv_layers','skaiadv_temp',
   'skaiadv_diversity','skaiadv_gap','skaiadv_skipgamma'].forEach(linkPair);

  // Mirror visible -> legacy (no event dispatch; just set value)
  function mirror(visId, legacyId){
    var src = document.getElementById(visId);
    if (!src) return;

    // If the visible control belongs to a form, attach the hidden to that form.
    // This ensures the legacy fields are part of the save POST.
    var hostForm = null;
    try { hostForm = src.form || null; } catch(_){}

    var dst = ensureHidden(legacyId, hostForm);

    function copy(){
      var v = (src.type === 'number' || src.type === 'range') ? src.value : (src.value || '');
      if (dst.value !== v) dst.value = v;
      // No dispatch - downstream code can read the hidden when needed.
    }

    // Initialize and keep in sync on user edits
    copy();
    src.addEventListener('input',  copy);
    src.addEventListener('change', copy);
  }

  MAP.forEach(function(p){ mirror(p[0], p[1]); });

  // Blend slider (0..100 AI%) -> legacy hidden blendRatio (0..1)
  (function syncBlend(){
    var r = document.getElementById('skai-blend-range');
    if (!r) return;
    var hidden = document.getElementById('blendRatio') || (function(){
      var h=document.createElement('input'); h.type='hidden'; h.id='blendRatio'; document.body.appendChild(h); return h;
    })();

    function push(){
      var ai = parseInt(r.value,10); if (!isNum(ai)) ai = 40;
      var ratio = Math.max(0, Math.min(1, ai/100));
      var sv = ratio.toFixed(2);
      if (hidden.value !== sv) hidden.value = sv;
      // FIX: Update window.SKAI_SETTINGS.blend so slider changes affect predictions
      try {
        if (window.SKAI_SETTINGS && typeof window.SKAI_SETTINGS === 'object') {
          window.SKAI_SETTINGS.blend = ratio;
        }
      } catch(_){}
    }

    // Initialize and keep in sync on user edits
    push();
    r.addEventListener('input',  push);
    r.addEventListener('change', push);
  })();
})();
</script>

<script>
;(function(){
  'use strict';

  // Idempotency: if the canonical run-options persistence already ran, exit.
  // Prevents double restore/persist listeners and racey UI state.
  // NOTE: In the current build, an earlier SKAI run-options persistence block
  // sets window.__SKAI_RUN_OPTIONS_PERSIST__ = 1, so this legacy block is inert.
  if (window.__SKAI_RUN_OPTIONS_PERSIST__) return;

  var KEY = 'SKAI_RUN_OPTIONS_v1'; // bump if schema changes

  function $(id){ return document.getElementById(id); }
  function isNum(x){ return isFinite(x) && !isNaN(x); }

  // Read current UI state
  function readState(){
    var profBtn = document.querySelector('#skai-profile-buttons .btn-chip[aria-pressed="true"]');
    var stratBtn= document.querySelector('#skai-strategy-buttons .btn-chip[aria-pressed="true"]');
    var blendEl = $('skai-blend-range');

    return {
      profile:  profBtn ? (profBtn.getAttribute('data-profile')  || 'balanced') : 'balanced',
      strategy: stratBtn? (stratBtn.getAttribute('data-strategy')|| 'hybrid')   : 'hybrid',
      blend:    blendEl ? (parseInt(blendEl.value,10)||40) : 40
    };
  }

  // Apply state back into UI (no auto-run)
  function applyState(s){
    try{
      // Profile
      if (s.profile){
        Array.prototype.forEach.call(
          document.querySelectorAll('#skai-profile-buttons .btn-chip'),
          function(b){
            var on = (String(b.getAttribute('data-profile'))===String(s.profile));
            b.classList.toggle('is-active', on);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
          }
        );
      }
      // Strategy
      if (s.strategy){
        Array.prototype.forEach.call(
          document.querySelectorAll('#skai-strategy-buttons .btn-chip'),
          function(b){
            var on = (String(b.getAttribute('data-strategy'))===String(s.strategy));
            b.classList.toggle('is-active', on);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
          }
        );
      }
      // FIX: DISABLED blend restoration - always use HTML default
      // Reason: Clean load requirement - no remembered settings
      /*
      if (isNum(+s.blend)) {
        var r = $('skai-blend-range');
        if (r){ r.value = String(Math.max(0, Math.min(100, +s.blend))); }
        // If you have a hidden blendRatio, keep it in sync
        var br = document.getElementById('blendRatio');
        if (br){ br.value = String((+s.blend/100).toFixed(2)); }
      }
      */

      // Update the summary line if present
      if (typeof window.updateSummary === 'function'){ window.updateSummary(); }
    }catch(_){}
  }

  // Persist on any meaningful change inside the run options block
  function persist(){ 
    try { localStorage.setItem(KEY, JSON.stringify(readState())); } catch(_){}
  }

  // Restore once on load
  function restore(){
    var raw = null, s = null;
    try { raw = localStorage.getItem(KEY); } catch(_){}
    if (!raw) return;
    try { s = JSON.parse(raw||''); } catch(_){}
    if (!s || typeof s !== 'object') return;
    applyState(s);
  }

// confirmation checkbox removed - no gating here anymore.
// KEEP defer-start behavior controlled by the canonical pipeline.
// Commented out to prevent premature ML/Auto-Tune bypass.
// try { window.__SKAI_DEFER_START__ = false; } catch(_){}

  // FIX: DISABLED persistence - clean load every time
  function boot(){
    // restore(); // DISABLED
    /*
    var host = document.getElementById('skai-run-options');
    if (host){
      ['click','input','change'].forEach(function(ev){
        host.addEventListener(ev, persist, { passive:true });
      });
    }
    */
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }
})();
</script>

<script>
;(function(){
  'use strict';

  function isNum(x){ return isFinite(x) && !isNaN(x); }

  var toggle = document.getElementById('skai-adv-toggle');
  var body   = document.getElementById('skai-adv-body');
  var host   = document.getElementById('skai-advanced');

  function setOpen(on){
    if (!toggle || !body || !host) return;
    toggle.setAttribute('aria-expanded', on ? 'true' : 'false');
    body.style.display = on ? '' : 'none';
    host.dataset.collapsed = on ? '0' : '1';
  }
  // Only attach this direct click handler if the newer Patch v2 toggle
  // has NOT been wired. Prevents double-toggling when Patch v2 is present.
  if (toggle && !window.__SKAI_ADV_TOGGLE_WIRED_V2__){
    toggle.addEventListener('click', function(){
      setOpen(toggle.getAttribute('aria-expanded') !== 'true');
    });
  }
  // Start CLOSED by default; users can expand to see and adjust custom settings
  setOpen(false);

  // Raise Window slider/number max & value to FULL dataset (no event dispatch; no auto-run)
  (function initWindowMaxOnce(){
    if (window.__SKAI_ADV_WINDOW_INIT__) return; window.__SKAI_ADV_WINDOW_INIT__ = 1;

    function getTotalDraws(){
      // Prefer server-provided FEATURES meta (rows used by PHP query)
      try {
        var sv = window.SKAI_SERVER || {};
        var meta = sv.FEATURES && sv.FEATURES.meta ? sv.FEATURES.meta : null;
        if (meta && isNum(+meta.rowsUsed) && +meta.rowsUsed > 0) return +meta.rowsUsed;
        if (isNum(+sv.totalRows))  return +sv.totalRows;
        if (isNum(+sv.totalDraws)) return +sv.totalDraws;
      } catch(_){}
      // Fall back to client buffers
      try {
        if (Array.isArray(window.__le_lastFiltered) && window.__le_lastFiltered.length) return window.__le_lastFiltered.length;
        if (Array.isArray(window.draws) && window.draws.length) return window.draws.length;
        if (Array.isArray(window.__ALL_DRAWS__) && window.__ALL_DRAWS__.length) return window.__ALL_DRAWS__.length;
      } catch(_){}
      return NaN;
    }

    function clamp(n, lo, hi){ n = +n; if (!isNum(n)) return lo; return n<lo?lo:(n>hi?hi:n); }

    var total = getTotalDraws();
            if (isNum(total) && total > 0){
              var r  = document.getElementById('skaiadv_window');
              var rn = document.getElementById('skaiadv_window_num');
      if (r && rn){
        var min = Number(r.min||5) || 5;
        var newMax = Math.max(min, total|0);

        // Expose for other modules and clamps
        window.__SKAI_WINDOW_MAX__ = newMax;

        // Raise max to full dataset (don-t dispatch events; no auto-run)
        r.max  = String(newMax);
        rn.max = String(newMax);

        // Clamp current values into new range (keep current if already set)
        var cur = Number(rn.value || r.value || newMax);
        var v = clamp(cur, min, newMax);
        r.value  = String(v);
        rn.value = String(v);

        // Also update the M-map clamp for window (index with adv id)
        try {
          if (Array.isArray(M)) {
            for (var i=0;i<M.length;i++){
              if (M[i] && M[i].adv === 'skaiadv_window' && Array.isArray(M[i].clamp)){
                M[i].clamp[0] = Math.min(M[i].clamp[0] || 5, 5); // keep project min = 5
                M[i].clamp[1] = newMax;                           // dynamic max
              }
            }
          }
        } catch(_){}
      }
    }
  })();
  

  // Keep slider <-> number mirrored & clamped (no change events; no auto-run)
  (function wireWindowSyncNoRun(){
    var r  = document.getElementById('skaiadv_window');
    var rn = document.getElementById('skaiadv_window_num');
    if (!r || !rn) return;

    function clampLocal(v){
      var min = Number(r.min || 5) || 5;
      var max = Number(r.max || window.__SKAI_WINDOW_MAX__ || 500) || 500;
      v = parseFloat(v); if (!isNum(v)) v = min;
      if (v < min) v = min; if (v > max) v = max;
      return v;
    }

    var syncing = false;
    function mirror(from, to){
      return function(){
        if (syncing) return;
        syncing = true;
        var v = clampLocal(from.value);
        from.value = String(v);
        to.value   = String(v);
        // Important: no dispatch of 'change' or custom events here
        syncing = false;
      };
    }

    r.addEventListener('input', mirror(r, rn));
    rn.addEventListener('input', mirror(rn, r));
  })();

  // Map advanced controls to canonical fields if they exist
  var M = [
    { adv:'skaiadv_epochs',     advNum:'skaiadv_epochs_num',     ids:['epochs','epochs_ui'],             clamp:[1,500] },
    { adv:'skaiadv_batch',      advNum:'skaiadv_batch_num',      ids:['batchSize','batchSize_ui'],       clamp:[1,512] },
    { adv:'skaiadv_dropout',    advNum:'skaiadv_dropout_num',    ids:['dropoutRate','dropoutRate_ui'],   clamp:[0,0.6] },
    { adv:'skaiadv_lr',         advNum:'skaiadv_lr_num',         ids:['learningRate','learningRate_ui'], clamp:[0.000001,0.1] },
    { adv:'skaiadv_decay',      advNum:'skaiadv_decay_num',      ids:['recencyDecay','recencyDecay_ui'], clamp:[0,0.999] },
    { adv:'skaiadv_window',     advNum:'skaiadv_window_num',     ids:['windowSize','windowSize_ui'],     clamp:[5,500] },
    { adv:'skaiadv_gap',        advNum:'skaiadv_gap_num',        ids:['gapScale','gapScale_ui'],         clamp:[0,1] },
    { adv:'skaiadv_skipgamma',  advNum:'skaiadv_skipgamma_num',  ids:['skipGamma','skipGamma_ui'],       clamp:[0,1] }
  ];

    function clamp(v, lo, hi){
    var n = parseFloat(v); if (!isNum(n)) return lo;
    return Math.max(lo, Math.min(hi, n));
  }

  // Re-run the max initializer when the DOM/data are ready (no value change events fired)
  try {
    var rerunInit = function(){
      try {
        // rerun the same IIFE by calling it again if available; else inline its body
        if (typeof window.__SKAI_ADV_WINDOW_INIT__ === 'undefined' || !window.__SKAI_ADV_WINDOW_INIT__) {
          // if not initialized yet, do nothing here; initial IIFE will run
          return;
        }
        // temporarily clear the guard to allow a one-time re-apply
        window.__SKAI_ADV_WINDOW_INIT__ = 0;
        (function initWindowMaxOnce(){ /* re-use the original function scope */
          try {
            // call the original code path by invoking the IIFE body again
            // Since we can-t reference the inner functions directly, just re-execute by copying minimal logic:
            var total = (function(){
              try {
                var sv = window.SKAI_SERVER || {};
                var meta = sv.FEATURES && sv.FEATURES.meta ? sv.FEATURES.meta : null;
                if (meta && isNum(+meta.rowsUsed) && +meta.rowsUsed > 0) return +meta.rowsUsed;
                if (isNum(+sv.totalRows))  return +sv.totalRows;
                if (isNum(+sv.totalDraws)) return +sv.totalDraws;
              } catch(_){}
              try {
                if (Array.isArray(window.__le_lastFiltered) && window.__le_lastFiltered.length) return window.__le_lastFiltered.length;
                if (Array.isArray(window.draws) && window.draws.length) return window.draws.length;
                if (Array.isArray(window.__ALL_DRAWS__) && window.__ALL_DRAWS__.length) return window.__ALL_DRAWS__.length;
              } catch(_){}
              return NaN;
            })();
            if (isFinite(total) && total > 0){
              var r  = document.getElementById('skaiadv_window');
              var rn = document.getElementById('skaiadv_window_num');
              if (r && rn){
                var min = Number(r.min||5) || 5;
                var newMax = Math.max(min, total|0);
                window.__SKAI_WINDOW_MAX__ = newMax;
                r.max  = String(newMax);
                rn.max = String(newMax);
                var cur = Number(rn.value || r.value || newMax);
                var v = Math.max(min, Math.min(newMax, cur));
                r.value  = String(v);
                rn.value = String(v);
                try {
                  if (Array.isArray(M)) {
                    for (var i=0;i<M.length;i++){
                      if (M[i] && M[i].adv === 'skaiadv_window' && Array.isArray(M[i].clamp)){
                        M[i].clamp[0] = Math.min(M[i].clamp[0] || 5, 5);
                        M[i].clamp[1] = newMax;
                      }
                    }
                  }
                } catch(_){}
              }
            }
          } finally {
            window.__SKAI_ADV_WINDOW_INIT__ = 1;
          }
        })();
      } catch(_){}
    };
    document.addEventListener('DOMContentLoaded', rerunInit);
    window.addEventListener('skai:data:ready', rerunInit);
    window.addEventListener('skai:draws:changed', rerunInit);
    window.addEventListener('skai:autotune:done', rerunInit);
  } catch(_){}
  // Use a distinct alias so we don't shadow the local $(id) helper above.
  var _$skai = window.$ || function(id){ return document.getElementById(id); }; // guard: avoid redefining global $
  function q(id){
    return document.getElementById(id + '_ui')
        || document.querySelector('[id="'+id+'"]:not([type="hidden"])')
        || document.getElementById(id) || null;
  }
  function syncOut(targetIds, val){
    var oldFlag = !!window.__SKAI_SILENT_SYNC__;
    window.__SKAI_SILENT_SYNC__ = true; // keep silent writes
    try {
      targetIds.forEach(function(id){
        var el = q(id);
        if (!el) return;
        el.value = String(val);
        // Only dispatch if the change is coming from an actual user action
        if (window.__SKAI_USER_ACTION__ === true) {
          try {
            el.dispatchEvent(new CustomEvent('input',  { bubbles:true }));
            el.dispatchEvent(new CustomEvent('change', { bubbles:true }));
          } catch(_){}
        }
      });
    } finally {
      window.__SKAI_SILENT_SYNC__ = oldFlag;
    }
  }

  // Initialize advanced sliders from canonical fields (if any), otherwise keep defaults
  M.forEach(function(map){
    // Resolve adv / advNum to real DOM elements (IDs like "skaiadv_epochs")
    // querySelector() needs a selector; use getElementById for ID strings.
    var adv = (typeof map.adv === 'string')
      ? document.getElementById(map.adv.replace(/^#/, ''))
      : map.adv;

    var advNum = (typeof map.advNum === 'string')
      ? document.getElementById(map.advNum.replace(/^#/, ''))
      : map.advNum;

    // If we still don't have real elements with addEventListener, bail out
    if (!adv || !adv.addEventListener || !advNum || !advNum.addEventListener) return;

    // reflect clamp in UI controls (min/max)
    try {
      adv.min = String(map.clamp[0]); adv.max = String(map.clamp[1]);
      advNum.min = String(map.clamp[0]); advNum.max = String(map.clamp[1]);
    } catch(_){}

    // link slider <-> number
    function linkBoth(v){
      adv.value    = String(v);
      advNum.value = String(v);
    }

     // seed from an existing control if present (defensive, ES5-safe)
    var seed = null;
    try {
      if (map && map.ids && typeof map.ids.length === 'number') {
        for (var i = 0; i < map.ids.length; i++) {
          var id = map.ids[i];
          if (!id) { continue; }
          var el = q(id);
          if (!el) { continue; }

          // normalize raw value
          var raw = (typeof el.value !== 'undefined') ? el.value : null;
          if (raw === null || raw === undefined) { continue; }

          // avoid .trim() on non-strings / ancient engines
          var s = String(raw);
          if (s.replace(/\s+/g, '') === '') { continue; }

          // numeric parse with finite check
          var num = parseFloat(s);
          if (!isFinite(num)) { continue; }

          // clamp with safe fallbacks
          var lo = (map && map.clamp && typeof map.clamp[0] !== 'undefined') ? map.clamp[0] : num;
          var hi = (map && map.clamp && typeof map.clamp[1] !== 'undefined') ? map.clamp[1] : num;
          seed = clamp(num, lo, hi);
          break;
        }
      }
    } catch (_){}

    if (seed !== null && seed !== undefined) { linkBoth(seed); }

    function onChange(v){
      var c = clamp(v, map.clamp[0], map.clamp[1]);
      // integer-only controls
      var id0 = (map.ids && map.ids[0]) ? String(map.ids[0]) : '';
      if (/(epochs|batchSize|windowSize)/i.test(id0)) {
        c = Math.round(c);
      }
      linkBoth(c);
      // update canonical fields but DO NOT start a run
      syncOut(map.ids, c);
    }

    adv.addEventListener('input', function(){ onChange(adv.value); });
    advNum.addEventListener('input', function(){ onChange(advNum.value); });
    adv.addEventListener('change', function(){ onChange(adv.value); });
    advNum.addEventListener('change', function(){ onChange(advNum.value); });
  });

  // --- Notify on Advanced edits (no run; just a banner) ---
  (function wireAdvChangeNotice(){
    var advBody = document.getElementById('skai-adv-body');
    if (!advBody || advBody.__skaiAdvNotice) return;
    advBody.__skaiAdvNotice = 1;

    // Reuse global singleton banner to avoid duplicates
    function showBanner(msg){
      if (typeof window.SKAI_showBanner === 'function') {
        window.SKAI_showBanner((typeof msg === 'string' && msg.trim()) ? msg : 'Custom settings changed');
      }
    }

    advBody.addEventListener('input', function(e){
      var isField = e && e.target && (e.target.matches('input,select,textarea'));
      if (!isField) return;
      showBanner('Custom settings updated - these override Profile/Strategy.');
    }, true);
    advBody.addEventListener('change', function(e){
      var isField = e && e.target && (e.target.matches('input,select,textarea'));
      if (!isField) return;
      showBanner('Custom settings updated - these override Profile/Strategy.');
    }, true);
  })();

  // --- Reset to defaults (no run) ---
  var resetBtn = document.getElementById('skai-adv-reset');
  if (resetBtn){
    resetBtn.addEventListener('click', function(){
      var defaults = {
        skaiadv_epochs:      120,
        skaiadv_batch:       32,
        skaiadv_dropout:     0.20,
        skaiadv_lr:          0.001,
        skaiadv_decay:       0.90,
        skaiadv_window:      50,
        skaiadv_gap:         0.20,
        skaiadv_skipgamma:   0.20
      };

      // helper to set both slider + number, clamp, and sync out
      function setAdv(map, v){
        // Use local q() resolver so we never depend on a global $.
        var adv   = q(map.adv);
        var advN  = q(map.advNum);
        var val   = clamp(v, map.clamp[0], map.clamp[1]);
        if (adv)  adv.value  = String(val);
        if (advN) advN.value = String(val);
        // push to canonical controls without triggering a run
        syncOut(map.ids, val);
      }

      M.forEach(function(map){
        var key = map.adv;                 // e.g., 'skaiadv_epochs'
        var d   = defaults[key];
        if (d != null) setAdv(map, d);
      });

      // Clear related caches so future loads reflect these defaults
      try {
        localStorage.removeItem('SKAI_ADV_OPTS_v1');   // advanced sliders
        localStorage.removeItem('SKAI_QS_OPTS_v1');    // quick setup
        localStorage.removeItem('SKAI_RUN_OPTIONS_v1'); // profile/strategy/blend
      } catch(_){}

      // UX: briefly indicate success
      try {
        resetBtn.disabled = true;
        var old = resetBtn.textContent;
        resetBtn.textContent = 'Defaults restored';
        setTimeout(function(){
          resetBtn.textContent = old;
          resetBtn.disabled = false;
        }, 900);
      } catch(_){}
    });
  }

})(); // <- IIFE now closes AFTER the reset handler
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 1: Optimizer Selection + Input Sync
   Purpose:
     - Keeps optimizer selections (W/B/CL/K/D etc.) in sync with UI inputs
     - Applies -best combo- settings into visible sliders/fields
     - Normalizes visible *_ui mirrors vs hidden fields
   Depends on:
     - DOM inputs for window/burn-in/laplace/decay/etc.
     - earlier ES5 helpers (assign/polyfills) if referenced later
   Exposes (globals):
     - window.__SKAI_SELECTIONS_WIRED__ (guard)
     - internal q()/setVal()/num() accessors
   Notes:
     - Critical for Pick-5 stability because invalid ranges here cascade into autotune.
     - Do not move; keep order exactly the same.
   ========================================================== */
;(function(){
  'use strict';

  function isNum(x){ return isFinite(x) && !isNaN(x); }

  // Idempotency guard: prevent duplicate wiring if this block is injected twice
  if (window.__SKAI_SELECTIONS_WIRED__) return; window.__SKAI_SELECTIONS_WIRED__ = 1;

  // --- helpers to get/set inputs (prefer visible *_ui if present) ---
  function q(id){

    return document.getElementById(id + '_ui')
        || document.querySelector('[id="'+id+'"]:not([type="hidden"])')
        || document.getElementById(id)
        || null;
  }
  function setVal(id, val){
    var el = q(id); if (!el) return false;
    el.value = String(val);
    // Only fire events if a real user action is in progress
    if (window.__SKAI_USER_ACTION__ === true) {
      try{
        el.dispatchEvent(new CustomEvent('input',  { bubbles:true }));
        el.dispatchEvent(new CustomEvent('change', { bubbles:true }));
      }catch(_){}
    }
    return true;
  }
  function num(v, d){ var n = parseFloat(v); return isNum(n)? n : d; }

  // --- presets for profiles (training "recipes") ---
  // Revised defaults to align with objective ("most probable") and the slider targets:
  //   Balanced:     AI 55% (blendRatio 0.55), temp 0.80, diversity 0.02, decay 0.95, gap 0.12, epochs 90, batch 32, dropout 0.25, lr 0.0008
  //   Explorative:  AI 60% (blendRatio 0.60), temp 1.05, diversity 0.05, decay 0.93, gap 0.18, epochs 80, dropout 0.30, lr 0.0008
  //   Conservative:AI 50% (blendRatio 0.50), temp 0.70, diversity 0.01, decay 0.96, gap 0.08, epochs 70, dropout 0.30, lr 0.0007
  var PRESETS = {
    balanced:     { epochs:90, batchSize:32, dropoutRate:0.25, recencyDecay:0.95, windowSize:'auto', blendRatio:0.55, gapScale:0.12 },
    explorative:  { epochs:80, batchSize:32, dropoutRate:0.30, recencyDecay:0.93, windowSize:'auto', blendRatio:0.60, gapScale:0.18 },
    conservative: { epochs:70, batchSize:32, dropoutRate:0.30, recencyDecay:0.96, windowSize:'auto', blendRatio:0.50, gapScale:0.08 }
  };
  // Expose a single source of truth for later modules (merge, don-t clobber).
  try {
    if (!window.SKAI_PRESETS) {
      window.SKAI_PRESETS = PRESETS;
    } else {
      var merged = {};
      for (var k in window.SKAI_PRESETS){
        if (Object.prototype.hasOwnProperty.call(window.SKAI_PRESETS, k)) merged[k] = window.SKAI_PRESETS[k];
      }
      for (var k2 in PRESETS){
        if (Object.prototype.hasOwnProperty.call(PRESETS, k2)) merged[k2] = PRESETS[k2];
      }
      window.SKAI_PRESETS = merged;
    }
  } catch(_) {}

  // strategy — default blend %
  // Revised targets:
  //   AI-forward: 85
  //   Hybrid:     55  (Balanced default)
  //   Skip boost: 20
  var STRAT_BLEND = { ai: 85, hybrid: 55, skip: 20 };

  // tuned window (prefer full available history; then server hint; then current control; fallback 50)
  function tunedW(){
    try {
      var hist = Array.isArray(window.__le_lastFiltered) ? window.__le_lastFiltered : window.draws;
      if (Array.isArray(hist) && hist.length > 0) return hist.length | 0;
    } catch(_) {}

    var sv = window.SKAI_SERVER || {};
    var w = (+sv.usedWindow) || (+sv.bestWindow) || NaN;
    if (isNum(w) && w > 0) return w | 0;

    var cur = q('windowSize'); var n = cur ? parseInt(cur.value,10) : NaN;
    return isNum(n) ? (n | 0) : 50;
  }

  // --- state refs ---
  var $profileRow  = document.getElementById('skai-profile-buttons');
  var $strategyRow = document.getElementById('skai-strategy-buttons');
  var $blendRange  = document.getElementById('skai-blend-range');
  var $summary     = document.getElementById('skai-selection-summary');
  var $run         = document.getElementById('startPrediction');

  // simple cross-module broadcaster for other panels (e.g., lower Quick Overview)
  function broadcastSelections(){
    var detail = {
      profile:  current.profile,
      strategy: current.strategy,
      blend:    current.blend
    };
    try {
      if (typeof window.SKAI_dispatchOptionsChanged === 'function') {
        window.SKAI_dispatchOptionsChanged(detail);
      } else {
        window.dispatchEvent(new CustomEvent('skai:options:changed', { detail: detail }));
      }
    } catch(_) {}
  }

  // current selections
  var current = { profile:'balanced', strategy:'hybrid', blend: num(($blendRange && $blendRange.value), 55) };

  function labelForBlend(v){
    v = Math.max(0, Math.min(100, v|0));
    var ai   = v;
    var skip = 100 - v;
    var mode = (v >= 70) ? 'AI-Forward' : (v <= 30 ? 'Skip + ML' : 'Hybrid'); // label normalized
    return { text: 'Skip '+skip+'% / AI '+ai+'% ('+mode+')', mode:mode };
  }

  function updateSummary(){
    var blend = labelForBlend(current.blend);
    var prof  = current.profile.charAt(0).toUpperCase() + current.profile.slice(1);

    // Map internal strategy key -> human label
    var stratMap = {
      creative: 'AI-Forward',
      ai:       'AI-Forward',
      'ai-forward': 'AI-Forward',
      stable:   'Skip + ML',
      skip:     'Skip + ML',
      'skip+ml':'Skip + ML',
      hybrid:   'Hybrid'
    };
    var raw   = String(current.strategy || 'hybrid').toLowerCase();
    var strat = Object.prototype.hasOwnProperty.call(stratMap, raw) ? stratMap[raw] : 'Hybrid';

    // Top one-liner summary
    if ($summary){
      // More brand-level line: reads like a setup, not a debug string
      $summary.textContent = 'SKAI is set to: ' + prof + ' profile - ' + strat + ' strategy - ' + blend.text;
    }

    // "Quick Overview" panel (the 3 KVs)
    var elP = document.getElementById('skai-summary-profile');
    if (elP) elP.textContent = prof;

    var elS = document.getElementById('skai-summary-strategy');
    if (elS) elS.textContent = strat;

    var elB = document.getElementById('skai-summary-blend');
    if (elB) elB.textContent = blend.text.replace(/\s*\(.*?\)\s*$/,''); // drop "(Hybrid)" etc.

    // notify any other ?Quick Overview? panels / listeners
    if (typeof broadcastSelections === 'function') {
      broadcastSelections();
    }

    // return useful info if any caller wants it
    return { profile: prof, strategy: strat, blendText: blend.text };
  }

  function applyProfile(p){
    var spec = PRESETS[p]; if (!spec) return;

    // Safe fallbacks: never write "undefined" into canonical fields.
    function safe(v, fallback){
      return (v !== null && v !== undefined && v !== '' && v === v) ? v : fallback;
    }
    function readCanon(id, fallback){
      var el = q(id);
      if (!el) return fallback;
      var n = parseFloat(el.value);
      return isFinite(n) ? n : fallback;
    }

    var W = (spec.windowSize === 'auto') ? tunedW() : spec.windowSize;

    // Update both backend-linked controls and visible Advanced sliders
    function updateAdv(id, val){
      if (val === null || val === undefined || val !== val) return; // skip invalid
      var slider = document.getElementById('skaiadv_'+id);
      var num    = document.getElementById('skaiadv_'+id+'_num');
      if (slider){ slider.value = String(val); }
      if (num){ num.value = String(val); }
      try {
        // Fire input/change to trigger any live displays or sync logic
        if (slider){ slider.dispatchEvent(new Event('input',{bubbles:true})); slider.dispatchEvent(new Event('change',{bubbles:true})); }
        if (num){ num.dispatchEvent(new Event('input',{bubbles:true})); num.dispatchEvent(new Event('change',{bubbles:true})); }
      } catch(_){}
    }

    // Canonical values (backend) - with fallbacks to current canon controls
    var epochs       = safe(spec.epochs,       readCanon('epochs', 120));
    var batchSize    = safe(spec.batchSize,    readCanon('batchSize', 32));
    var dropoutRate  = safe(spec.dropoutRate,  readCanon('dropoutRate', 0.20));
    var learningRate = safe(spec.learningRate, readCanon('learningRate', 0.001));
    var hiddenLayers = safe(spec.hiddenLayers, readCanon('hiddenLayers', 2));
    var recencyDecay = safe(spec.recencyDecay, readCanon('recencyDecay', 0.90));
    var gapScale     = safe(spec.gapScale,     readCanon('gapScale', 0.20));

    setVal('epochs',       epochs);
    setVal('batchSize',    batchSize);
    setVal('dropoutRate',  dropoutRate);
    setVal('learningRate', learningRate);
    setVal('hiddenLayers', hiddenLayers);
    setVal('recencyDecay', recencyDecay);
    setVal('gapScale',     gapScale);
    setVal('windowSize',   W);

    // Visual Advanced sliders
    updateAdv('epochs',  epochs);
    updateAdv('batch',   batchSize);
    updateAdv('dropout', dropoutRate);
    updateAdv('lr',      learningRate);
    updateAdv('layers',  hiddenLayers);
    updateAdv('decay',   recencyDecay);
    updateAdv('gap',     gapScale);
    updateAdv('window',  W);

    // Blend auto-tuning when Hybrid
    if (current.strategy === 'hybrid'){
      if (current.blend === 40) setBlend(safe(spec.blendRatio, 0.40) * 100);
    }

    // Ensure Advanced stays open for visibility
   // (DISABLED) – panel should start collapsed; click handler controls state.
   try {
     var advHost = document.getElementById('skai-advanced');
     var body = document.getElementById('skai-adv-body');
     var tog  = document.getElementById('skai-adv-toggle');
     if (advHost && body){
       // intentionally left blank: no forced open on load
       // body.style.display = '';
       // if (tog) tog.setAttribute('aria-expanded','true');
     }
   } catch(_){}

    // Notify user
    // Brief banner to confirm that sliders updated from profile
    try {
      if (window.SKAI_notifyCustomChange) {
    window.SKAI_notifyCustomChange('Profile applied - sliders updated to match.');
      }
    } catch(_){}
  }  // <-- CLOSE applyProfile()

function setBlend(v){
  v = Math.max(0, Math.min(100, Math.round(v)));
  current.blend = v;
  if ($blendRange) $blendRange.value = String(v);
  // write to numeric input if you have one (blendRatio)
  setVal('blendRatio', (v/100).toFixed(2));
  updateSummary();
  if (typeof window.SKAI_dispatchOptionsChanged === 'function') {
    window.SKAI_dispatchOptionsChanged({ profile: current.profile, strategy: current.strategy, blend: current.blend });
  }
}

  function setStrategy(s){
    current.strategy = s;
    // default to the strategy?s suggested blend UNLESS user just moved it
    var suggest = STRAT_BLEND[s];
    var userMoved = (function(){ try { return !!window.__SKAI_BLEND_USER_MOVED__; } catch(_){ return false; } })();
    if (typeof suggest === 'number' && !userMoved) {
      setBlend(suggest);
    }

    // --- UPDATED: animate sliders + open Advanced ---
    var targets = {
      ai:     { temperature: 1.10, diversityPenalty: 0.05 },
      hybrid: { temperature: 0.85, diversityPenalty: 0.02 },
      skip:   { temperature: 0.70, diversityPenalty: 0.01 }
    };
    var tset = targets[s] || targets.hybrid;

    function animateAdvPair(advBase, canonId, target, duration){
      var sld = document.getElementById('skaiadv_' + advBase);
      var num = document.getElementById('skaiadv_' + advBase + '_num');
      var can = document.getElementById(canonId);

      var cur = NaN;
      if (sld && sld.value !== '') cur = parseFloat(sld.value);
      else if (num && num.value !== '') cur = parseFloat(num.value);
      else if (can && can.value !== '') cur = parseFloat(can.value);
      if (!isNum(cur)) cur = target;

      // Clamp target to UI limits (prevents invalid writes)
      (function(){
        var lo = -Infinity, hi = Infinity, n;
        if (sld){
          n = parseFloat(sld.min); if (isNum(n)) lo = n;
          n = parseFloat(sld.max); if (isNum(n)) hi = n;
        }
        if (num){
          n = parseFloat(num.min); if (isNum(n)) lo = Math.max(lo, n);
          n = parseFloat(num.max); if (isNum(n)) hi = Math.min(hi, n);
        }
        if (can){
          n = parseFloat(can.getAttribute('min')); if (isNum(n)) lo = Math.max(lo, n);
          n = parseFloat(can.getAttribute('max')); if (isNum(n)) hi = Math.min(hi, n);
        }
        if (!isNum(lo)) lo = -1e9;
        if (!isNum(hi)) hi =  1e9;
        target = Math.max(lo, Math.min(hi, target));
      })();

      var start = cur, end = target, diff = end - start;
      var dur = Math.max(120, duration|0);
      var t0 = Date.now();

      function step(){
        var t = (Date.now() - t0) / dur; if (t > 1) t = 1;
        var v = start + diff * t;
        var vv = Math.round(v * 100) / 100;
        if (sld) sld.value = String(vv);
        if (num) num.value = String(vv);
        if (t < 1){
          try { window.requestAnimationFrame(step); } catch(_){ setTimeout(step, 16); }
        } else {
          try {
            if (typeof setVal === 'function') setVal(canonId, end);
            else if (can){
              can.value = String(end);
              try {
                can.dispatchEvent(new Event('input',{bubbles:true}));
                can.dispatchEvent(new Event('change',{bubbles:true}));
              } catch(_){}
            }
          } catch(_){}
        }
      }
      step();
    }

    animateAdvPair('temp',      'temperature',      tset.temperature,     240);
    animateAdvPair('diversity', 'diversityPenalty', tset.diversityPenalty,240);

    try {
      var advHost = document.getElementById('skai-advanced');
      if (advHost && advHost.dataset.collapsed !== '0'){
        var tog = document.getElementById('skai-adv-toggle');
        var body = document.getElementById('skai-adv-body');
        if (tog && body){
          tog.setAttribute('aria-expanded','true');
          body.style.display = '';
          advHost.dataset.collapsed = '0';
        }
      }
    } catch(_){}

    // brief notice banner for user feedback
    try {
      if (window.SKAI_notifyCustomChange) {
        window.SKAI_notifyCustomChange('Strategy applied - AI parameters adjusted.');
      }
    } catch(_){}
  }  // <-- CLOSE setStrategy()

  function markPressed(row, attr, value){
    if (!row) return;
    var nodes = row.querySelectorAll('[data-'+attr+']');

    // ES5-safe iteration (NodeList.forEach not guaranteed in all Joomla client contexts)
    Array.prototype.forEach.call(nodes, function(b, i){
      var on = String(b.getAttribute('data-'+attr)) === String(value);
      b.setAttribute('aria-pressed', on ? 'true' : 'false');
      b.setAttribute('aria-checked', on ? 'true' : 'false');      // radio semantics for SRs
      b.setAttribute('tabindex', on ? '0' : (i===0 ? '0' : '-1')); // roving tabindex
      if (on) b.classList.add('is-active'); else b.classList.remove('is-active');
    });

    // also assert "one-hot" after a tick in case another listener interferes
    setTimeout(function(){
      Array.prototype.forEach.call(nodes, function(b, i){
        var on = String(b.getAttribute('data-'+attr)) === String(value);
        b.setAttribute('aria-pressed', on ? 'true' : 'false');
        b.setAttribute('aria-checked', on ? 'true' : 'false');
        b.setAttribute('tabindex', on ? '0' : (i===0 ? '0' : '-1'));
        if (on) b.classList.add('is-active'); else b.classList.remove('is-active');
      });
    }, 0);
  }

  function wire(){
  // profile buttons
  if ($profileRow){
$profileRow.addEventListener('click', function(e){
  var t = e.target || e.srcElement;
  var btn = (t && t.closest) ? t.closest('[data-profile]') : null; if (!btn) return;
      e.preventDefault(); e.stopPropagation();
      var key = String(btn.getAttribute('data-profile')||'').toLowerCase();
      if (!key || !PRESETS[key]) return;             // validate against PRESETS
      current.profile = key;                          // remember
      markPressed($profileRow, 'profile', key);       // visually highlight this chip
applyProfile(key);                              // push params to hidden controls
updateSummary();                                // refresh summary line

// (commented) Avoid double-emits.
// updateSummary() -> broadcastSelections() -> SKAI_dispatchOptionsChanged() already fires.
// Keeping this would trigger listeners twice.
// if (typeof window.SKAI_dispatchOptionsChanged === 'function') {
//   window.SKAI_dispatchOptionsChanged({ profile: current.profile, strategy: current.strategy, blend: current.blend });
// } else {
//   window.dispatchEvent(new CustomEvent('skai:options:changed', { detail:{ profile: current.profile, strategy: current.strategy, blend: current.blend } }));
// }
  }, false);
 }

    // strategy buttons
    if ($strategyRow){
      $strategyRow.addEventListener('click', function(e){
        var t = e.target || e.srcElement;
        var btn = (t && t.closest) ? t.closest('[data-strategy]') : null; if (!btn) return;
        e.preventDefault(); e.stopPropagation();

        var key = String(btn.getAttribute('data-strategy') || '').toLowerCase();
        if (!key || !Object.prototype.hasOwnProperty.call(STRAT_BLEND, key)) return; // hardened lookup

        // Visual state + a11y polish is handled by markPressed
        markPressed($strategyRow, 'strategy', key);
        setStrategy(key);

        // (commented) Avoid double-emits.
        // setStrategy() may call setBlend(), and setBlend() already dispatches.
        // Keeping this would fire listeners twice.
        // unified dispatcher only (handlers should not dispatch their own window/document events)
        // if (typeof window.SKAI_dispatchOptionsChanged === 'function') {
        //   window.SKAI_dispatchOptionsChanged({
        //     profile:  current.profile,
        //     strategy: current.strategy,
        //     blend:    current.blend
        //   });
        // }
      }, false);
    }

    // Local numeric helper for this IIFE
    function toNumOr(v, d){
      var n = parseFloat(v);
      return (isNum(n) ? n : d);
    }

    // blend slider with user-intent tracking
    if ($blendRange){
      $blendRange.addEventListener('input', function(){
        try { window.__SKAI_BLEND_USER_MOVED__ = true; } catch(_){}
        setBlend(toNumOr($blendRange.value, current.blend));
      }, false);
      $blendRange.addEventListener('change', function(){
        try { window.__SKAI_BLEND_USER_MOVED__ = true; } catch(_){}
        setBlend(toNumOr($blendRange.value, current.blend));
      }, false);
    }

    // no confirmation gate ? Run is always allowed when clicked
    // (any upstream sequencing is handled elsewhere)

    // initial application of defaults ? SILENT (no event dispatch)
    var __oldUA = window.__SKAI_USER_ACTION__;
    try { window.__SKAI_USER_ACTION__ = false; } catch(_){}
    applyProfile(current.profile);
    markPressed($profileRow,  'profile',  current.profile);
    markPressed($strategyRow, 'strategy', current.strategy);
    setStrategy(current.strategy);
    updateSummary();
    try { window.__SKAI_USER_ACTION__ = __oldUA; } catch(_){}
  }

// --- Reset selections to defaults (Balanced ? Hybrid ? Blend 40%) ---
function hardResetSelections(){
  // Prevent listeners from treating this as a user action
  var _ua = false;
  try { _ua = !!window.__SKAI_USER_ACTION__; } catch(_){ _ua = false; }
  try { window.__SKAI_USER_ACTION__ = false; } catch(_){}

  // Clear "user moved blend" intent so strategies can suggest again post-reset
  try { window.__SKAI_BLEND_USER_MOVED__ = false; } catch(_){}

  try {
    // Clear all related caches (safe no-ops if absent)
    localStorage.removeItem('SKAI_SELECTED');
    localStorage.removeItem('SKAI_RUN_OPTIONS_v1');
    localStorage.removeItem('SKAI_QS_OPTS_v1');
    localStorage.removeItem('SKAI_ADV_OPTS_v1');
  } catch(_){}

  // Reset state
  current.profile  = 'balanced';
  current.strategy = 'hybrid';

  // Balanced default should start at 55% AI (not 40%)
  setBlend(55);               // 55% AI (Balanced default) — resyncs #blendRatio
  applyProfile('balanced');   // push preset params to canonical inputs

  // IMPORTANT: programmatic setBlend() does not fire slider events,
  // so the blend "pill" (skai-blend-center) will not update unless we dispatch.
  try {
    if ($blendRange) {
      $blendRange.dispatchEvent(new CustomEvent('input',  { bubbles:true }));
      $blendRange.dispatchEvent(new CustomEvent('change', { bubbles:true }));
    }
  } catch(_){}

  // Belt-and-suspenders: directly set pill text in case any listener is missing
  try {
    var _pill = document.getElementById('skai-blend-center');
    if (_pill && $blendRange) {
      var _v = parseInt($blendRange.value, 10);
      if (isNaN(_v)) _v = 0;
      _pill.textContent = _v + '%';
    }
  } catch(_){}

  // Visually re-highlight chips
  markPressed($profileRow,  'profile',  'balanced');
  markPressed($strategyRow, 'strategy', 'hybrid');

  // Run remains enabled; no checkbox in the new flow
  var btn = document.getElementById('startPrediction');
  if (btn){
    btn.disabled = false;
  }

  updateSummary();      // refresh top line
  broadcastSelections(); // ensure lower Quick Overview updates too

  // Restore original flag
  try { window.__SKAI_USER_ACTION__ = _ua; } catch(_){}
}
  // Wire the reset button
  function wireReset(){
    var $reset = document.getElementById('skai-reset-selections');
    if (!$reset || $reset.__skaiWired) return;
    $reset.__skaiWired = 1;
    $reset.addEventListener('click', function(e){
      e.preventDefault(); e.stopPropagation();
      hardResetSelections();
    }, false);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', function(){
      wire();       // existing boot
      wireReset();  // new
    }, { once:true });
  } else {
    wire();        // existing boot
    wireReset();   // new
  }
})();
</script>

<script>
;(function(){
  'use strict';

  // One-time guard: avoid duplicate listeners if this snippet is included twice
  if (window.__SKAI_POPOVER_WIRED__) return;
  window.__SKAI_POPOVER_WIRED__ = true;

  // Quarantined (unused local state): __lastPopTrigger
  // var __lastPopTrigger = null;

  function closeAll(){
    // ES5-safe iteration (NodeList.forEach not guaranteed everywhere)
    Array.prototype.forEach.call(document.querySelectorAll('[data-pop-content]'), function(p){
      if (!p.hasAttribute('hidden')) p.setAttribute('hidden','');
    });
    // ARIA removed per requirement
    // __lastPopTrigger = null;
  }

  function toggleFor(key){
    var box = document.querySelector('[data-pop-content="'+key+'"]');
    var btn = document.querySelector('[data-pop="'+key+'"]');
    if (!box || !btn) return;

    var isOpen = !box.hasAttribute('hidden');
    closeAll();

    // If it was closed, open it now (ARIA removed per requirement)
    if (!isOpen){
      box.removeAttribute('hidden');
    }
  }

  function boot(){
    // hide all popovers initially (ES5-safe)
    Array.prototype.forEach.call(document.querySelectorAll('[data-pop-content]'), function(p){
      p.setAttribute('hidden','');
    });

// button handlers (ES5-safe)
Array.prototype.forEach.call(document.querySelectorAll('[data-pop]'), function(btn){
  if (btn.__wiredPop) return;
  btn.__wiredPop = 1;

  btn.addEventListener('click', function(ev){
    ev.preventDefault();
    ev.stopPropagation();
    var key = String(btn.getAttribute('data-pop')||'').trim();
    if (!key) return;
    toggleFor(key);
  }, false);

});

    // close on outside click (closest-safe)
    document.addEventListener('click', function(e){
      var t = e && e.target;
      if (!t) { closeAll(); return; }

      // Guard for environments without Element.closest
      var inPopover = null;
      try {
        if (t.closest) {
          inPopover = t.closest('[data-pop-content]') || t.closest('[data-pop]');
        } else {
          // Fallback climb
          var cur = t;
          while (cur && cur.nodeType === 1){
            if (cur.hasAttribute('data-pop-content') || cur.hasAttribute('data-pop')) { inPopover = cur; break; }
            cur = cur.parentElement;
          }
        }
      } catch(_){ inPopover = null; }

      if (!inPopover) closeAll();
    }, true);

// close on Escape
document.addEventListener('keydown', function(e){
  if (e.key === 'Escape'){
    e.preventDefault();    // ADDED
    e.stopPropagation();   // ADDED
    closeAll();
  }
}, false);
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }
})();
</script>

<script>
;(function(){
  'use strict';

  var KEY = 'SKAI_QS_OPTS_v1';
  var IDS = ['recencyDecay','windowSize','temperature','diversityPenalty','skai-blend-range'];

  function $(id){ return document.getElementById(id); }
  function clamp(n, lo, hi){ var x = parseFloat(n); if (!isFinite(x)) return lo; return Math.max(lo, Math.min(hi, x)); }

  // ranges that match this Quick Setup UI
function getWindowMax(){
  try {
    var sv = window.SKAI_SERVER || {};
    if (isFinite(+sv.totalRows))  return Math.max(1, +sv.totalRows|0);
    if (isFinite(+sv.totalDraws)) return Math.max(1, +sv.totalDraws|0);
  } catch(_){}
  try {
    if (Array.isArray(window.__le_lastFiltered) && window.__le_lastFiltered.length) return window.__le_lastFiltered.length|0;
    if (Array.isArray(window.draws) && window.draws.length) return window.draws.length|0;
    if (Array.isArray(window.__ALL_DRAWS__) && window.__ALL_DRAWS__.length) return window.__ALL_DRAWS__.length|0;
  } catch(_){}
  return 1;
}
function _winMax(){ 
  try { return Math.max(1, getWindowMax()); } catch(_){ return 1; } 
}
var R = {
  recencyDecay:      [0, 1],
  windowSize:        [1, _winMax()],   // dynamic based on history
  temperature:       [0.5, 1.5],
  diversityPenalty:  [0, 0.1],
  'skai-blend-range':[0, 100]
};

  // silent programmatic updates shouldn't retrigger listeners that might auto-run
function silentSync(fn){
  var prev = !!window.__SKAI_SILENT_SYNC__;
  window.__SKAI_SILENT_SYNC__ = true;

  var result;
  try {
    result = (typeof fn === 'function') ? fn() : undefined;
  } catch (err) {
    window.__SKAI_SILENT_SYNC__ = prev;
    throw err;
  }

  // If async, restore after it settles; otherwise restore now.
  if (result && typeof result.then === 'function') {
    // Avoid relying on Promise.finally (not guaranteed in all environments)
    return result.then(function(v){
      window.__SKAI_SILENT_SYNC__ = prev;
      return v;
    }, function(e){
      window.__SKAI_SILENT_SYNC__ = prev;
      throw e;
    });
  } else {
    window.__SKAI_SILENT_SYNC__ = prev;
    return result;
  }
}


function fire(el){
  // Do nothing when we're intentionally syncing or not in a user action
  if (window.__SKAI_SILENT_SYNC__ || window.__SKAI_USER_ACTION__ !== true) return;
  try{
    el.dispatchEvent(new Event('input',{bubbles:true}));
    el.dispatchEvent(new Event('change',{bubbles:true}));
  }catch(_){}
}

  function read(){
    var o = {};
    for (var i=0;i<IDS.length;i++){
      var id = IDS[i], el = $(id);
      if (!el) continue;
      var val = el.value;
      var range = R[id] || null;
      if (range) val = clamp(val, range[0], range[1]);
      o[id] = val;
    }
    return o;
  }

  function apply(obj){
    if (!obj || typeof obj !== 'object') return;

    silentSync(function(){

  // window size - sync slider + number + pill (dynamic max)
      if (obj.windowSize != null){
        var vmax = _winMax();
        var v = clamp(obj.windowSize, 1, vmax);
        var num = $('windowSize'), sld = $('windowSizeSlider'), pill = $('windowSizeVal');

        // NEW: keep DOM attributes in sync with dataset size (no surprise caps)
        if (num){ num.min = '1'; num.max = String(vmax); }
        if (sld){ sld.min = '1'; sld.max = String(vmax); }

        if (num){ num.value = String(v); fire(num); }
        if (sld){ sld.value = String(v); fire(sld); }
        if (pill){ pill.textContent = String(v); }
      }

      // blend slider + hidden ratio
      if (obj['skai-blend-range'] != null){
        var b = $('skai-blend-range');
        var bv = clamp(obj['skai-blend-range'], R['skai-blend-range'][0], R['skai-blend-range'][1]);
        if (b){ b.value = String(bv); fire(b); }
        var ratio = $('blendRatio');
        if (ratio){ ratio.value = (bv/100).toFixed(2); fire(ratio); }
      }

      // simple scalars
      ['recencyDecay','temperature','diversityPenalty'].forEach(function(id){
        if (obj[id] == null) return;
        var el = $(id); if (!el) return;
        var range = R[id] || null;
        var v = (range ? clamp(obj[id], range[0], range[1]) : obj[id]);
        el.value = String(v);
        fire(el);
      });

    });
  }

  // debounced localStorage writes with a single key (fully guarded)
  var __t = null;
  function persist(){
    try { if (__t) clearTimeout(__t); } catch(_){}
    __t = setTimeout(function(){
      var data = '{}';
      try { data = JSON.stringify(read()); } catch(_){}
      try {
        // Some browsers/extensions can throw SecurityError here
        if (typeof localStorage !== 'undefined') {
          localStorage.setItem(KEY, data);
        }
      } catch(e){
        // Attempt one clean retry; otherwise silently give up
        try {
          if (typeof localStorage !== 'undefined') {
            localStorage.removeItem(KEY);
            localStorage.setItem(KEY, data);
          }
        } catch(_){}
      }
    }, 120);
  }

  function restore(){
    var raw = null, obj = null;
    try {
      if (typeof localStorage !== 'undefined') {
        raw = localStorage.getItem(KEY);
      }
    } catch(_){}
    if (!raw || typeof raw !== 'string') return;

    // Be tolerant of corrupt or non-JSON values
    try { obj = JSON.parse(raw); }
    catch(_){
      try {
        // sometimes stored as "[object Object]" or empty
        obj = (raw.charAt(0) === '{' || raw.charAt(0) === '[') ? JSON.parse(raw) : null;
      } catch(__){}
    }
    if (obj && typeof obj === 'object') { apply(obj); }
  }

  function wirePillLive(){
    var num = $('windowSize'), sld = $('windowSizeSlider'), pill = $('windowSizeVal');
    if (!pill) return;
    function sync(){ pill.textContent = (num && num.value) || (sld && sld.value) || pill.textContent; }
    if (num)  { num.addEventListener('input', sync, true); num.addEventListener('change', sync, true); }
    if (sld)  { sld.addEventListener('input', sync, true); sld.addEventListener('change', sync, true); }
  }

  function boot(){
    // FIX: DISABLED localStorage persistence
    // restore(); // DISABLED
    wirePillLive();

    // DISABLED: cross-tab sync
    /*
    try {
      window.addEventListener('storage', function(e){
        if (!e || e.key !== KEY) return;
        if (!e.newValue) return;
        var obj = null;
        try { obj = JSON.parse(e.newValue); } catch(_){}
        if (obj) apply(obj);
      }, false);
    } catch(_) {}

    ['input','change'].forEach(function(ev){
      document.addEventListener(ev, function(e){
        if (window.__SKAI_SILENT_SYNC__) return;
        var id = e && e.target && e.target.id;
        if (!id) return;
        if (IDS.indexOf(id) !== -1 || id === 'windowSize' || id === 'windowSizeSlider') persist();
      }, true);
    });
    */
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }
})();
</script>

<script>
// Sorcerer-safe inline JS (no template literals)
// Adds: modal focus-trap + scroll lock, storage (Save/Load/Clear/Reset),
// and blend-mode mapping to hidden inputs (feature-preserving).
;(function(){
  'use strict';
  var openBtn  = document.getElementById('openSignup');
  var modal    = document.getElementById('signupModal');
  var closeBtn = document.getElementById('closeSignup');

  // ---------- Modal helpers (scroll lock only) ----------
  function openModal(){
    if(!modal) return;
// show the overlay as flex
modal.style.display = 'flex';

// scroll lock
document.documentElement.style.overflow = 'hidden';
    document.body.style.overflow = 'hidden';
  }
  function closeModal(){
    if(!modal) return;
// hide overlay
modal.style.display = 'none';

// release scroll lock
document.documentElement.style.overflow = '';
document.body.style.overflow = '';
  }

  if(openBtn){
    openBtn.addEventListener('click', function(e){
      // if user not saveable (guest), open modal; else do nothing and let backend handle
      <?php if (empty($saveable)) : ?>
      e.preventDefault();
      openModal();
      <?php endif; ?>
    });
  }
  if(closeBtn){ closeBtn.addEventListener('click', closeModal); }

// close on ESC / click outside
document.addEventListener('keydown', function(e){
  if(e.key === 'Escape' && modal && modal.style.display === 'flex'){
    closeModal();
  }
});
  if(modal){
    modal.addEventListener('click', function(e){
      if(e.target === modal){ closeModal(); }
    });
  }

  // ---------- Slider <-> number sync (defensive, recursion-safe) ----------
  // NOTE (audit): This older wiring MAY duplicate other windowSize sync code elsewhere in the full file.
  // To prevent possible double listeners / event storms, we quarantine this block here.
  /*
  var slider = document.getElementById('windowSizeSlider');
  var number = document.getElementById('windowSize');
  var pill   = document.getElementById('windowSizeVal');

  function toNum(v, fallback){ var n = Number(v); return isFinite(n) ? n : fallback; }
  function clamp(n, min, max){ return Math.min(Math.max(n, min), max); }
  function sync(val){ if (pill) { pill.textContent = String(val); } }

  // Re-entrancy guard to avoid slider<->number infinite loops
  var __syncingWindowSize = false;

  if (slider && number){
    slider.addEventListener('input', function(){
      if (__syncingWindowSize) return;
      __syncingWindowSize = true;
      var min = toNum(number.getAttribute('min'), 1);
      var max = toNum(number.getAttribute('max'), 100);
      var v   = clamp(toNum(slider.value, min), min, max);

      number.value = v;
      try{
        number.dispatchEvent(new CustomEvent('input',  { bubbles:true } ));
        number.dispatchEvent(new CustomEvent('change', { bubbles:true } ));
      }catch(_){}

      sync(v);
      __syncingWindowSize = false;
    });

    number.addEventListener('input', function(){
      if (__syncingWindowSize) return;
      __syncingWindowSize = true;
      var min = toNum(slider.getAttribute('min'), 1);
      var max = toNum(slider.getAttribute('max'), 100);
      var v   = clamp(toNum(number.value, min), min, max);

      slider.value = v;
      try{
        slider.dispatchEvent(new CustomEvent('input',  { bubbles:true } ));
        slider.dispatchEvent(new CustomEvent('change', { bubbles:true } ));
      }catch(_){}

      sync(v);
      __syncingWindowSize = false;
    });
  }
  */
  })();
</script>

<script>

// tiny helpers
function byId(id){ return document.getElementById(id); }
// Define once globally; reuse elsewhere to prevent policy drift
if (typeof window.setVal !== 'function') {
  window.setVal = function(id,val){
    var el = byId(id);
    if(!el) return;
    el.value = String(val);
    if (window.__SKAI_USER_ACTION__ === true) {
      try{ el.dispatchEvent(new CustomEvent('input',  { bubbles:true })); } catch(e){}
      try{ el.dispatchEvent(new CustomEvent('change', { bubbles:true })); } catch(e){}
    }
  };
}
function clamp(v,lo,hi){
  v = +v;
  if (!isFinite(v)) return lo; // ES5-safe finite check
  if (v < lo) v = lo;
  if (v > hi) v = hi;
  return v;
}
function debounce(fn, wait){ var t=null; return function(){ var a=arguments,c=this; clearTimeout(t); t=setTimeout(function(){ fn.apply(c,a); }, wait|0); }; }

// defaults unified (may be overridden by later sections)
window.DEFAULTS = window.DEFAULTS || Object.freeze({
  epochs:120, batchSize:32, dropoutRate:0.20, learningRate:0.001,
  activationFunction:'tanh', hiddenLayers:2, recencyDecay:0.90,
  windowSize:'MAX', temperature:0.85, diversityPenalty:0.02
});

// slider sync
function syncWindowSlider(v){
  var sld=byId('windowSizeSlider'), num=byId('windowSize'), pill=byId('windowSizeVal');
  if(sld) sld.value = String(v);
  if(num) num.value = String(v);
  if(pill) pill.textContent = String(v);
}
window.syncWindowSlider = window.syncWindowSlider || syncWindowSlider;

// bounds based on known draws - define once or reuse existing
var getWindowMax = window.getWindowMax || function(){
  var n=0;
  try{
    if(Array.isArray(window.__le_lastFiltered) && window.__le_lastFiltered.length) n=window.__le_lastFiltered.length;
    else if(Array.isArray(window.draws)) n=window.draws.length;
  } catch(e){}
  return Math.max(1, n|0);
};
try { if (!window.getWindowMax) window.getWindowMax = getWindowMax; } catch(_){}

window.setWindowSizeBounds = window.setWindowSizeBounds || function setWindowSizeBounds(){
  // Derive safe max from history; never below 1
  var max = 1;
  try { max = Math.max(1, getWindowMax()); } catch(_){ max = 1; }
  var min = 1;

  var num = byId('windowSize');
  var sld = byId('windowSizeSlider');

  // Apply min/max safely if elements exist
  if (num) { num.min = String(min); num.max = String(max); }
  if (sld) { sld.min = String(min); sld.max = String(max); }

  // Prefer current numeric value from either control; fall back to max
  var cur = NaN;
  if (num && num.value !== '') cur = parseInt(num.value, 10);
  else if (sld && sld.value !== '') cur = parseInt(sld.value, 10);

  // Clamp into [min, max], defaulting to max if invalid/empty (ES5-safe)
  var v = clamp(isFinite(cur) ? cur : max, min, max);

  // Reflect into both inputs (no event dispatch)
  if (num) num.value = String(v);
  if (sld) sld.value = String(v);

  // Keep slider + number + pill visually in sync (no events)
  if (typeof window.syncWindowSlider === 'function') {
    window.syncWindowSlider(v);
  }
};

// apply defaults + MAX=full-history

function applyDefaults(){
  var D = window.DEFAULTS;
  window.setVal('epochs',D.epochs);
  window.setVal('batchSize',D.batchSize);
  window.setVal('dropoutRate',D.dropoutRate);
  window.setVal('learningRate',D.learningRate);
  window.setVal('activationFunction',D.activationFunction);
  window.setVal('hiddenLayers',D.hiddenLayers);
  window.setVal('recencyDecay',D.recencyDecay);
  window.setVal('temperature',D.temperature);
  window.setVal('diversityPenalty',D.diversityPenalty);

  var wMax = getWindowMax();
  var w    = (String(D.windowSize).toUpperCase()==='MAX') ? wMax : clamp(parseInt(D.windowSize,10)||wMax,1,wMax);
  window.setVal('windowSize', w);
  syncWindowSlider(w);

  try{ window.setWindowSizeBounds(); }catch(e){}
  try{
    if (typeof window.currentEchoState==='function' && typeof window.updateParamEcho==='function'){
      window.updateParamEcho(window.currentEchoState());
    }
  }catch(e){}
}
window.applyDefaults = window.applyDefaults || applyDefaults;

// slider mirrors (no auto-run on boot)
(function mirror(){
  var sld = byId('windowSizeSlider');
  var num = byId('windowSize');

  function toInt(v, d){ v = parseInt(v, 10); return isFinite(v) ? v : d; }
  function currentMax(){ try { return Math.max(1, getWindowMax()); } catch(_) { return 1; } }

  function syncFrom(source){
    var max = currentMax();
    var raw = (source === 'slider' ? (sld && sld.value) : (num && num.value));
    var v   = clamp(toInt(raw, 1), 1, max);
    // reflect across UI without emitting any events
    if (typeof syncWindowSlider === 'function') syncWindowSlider(v);

    // CHG: Do not print internal tuning/status copy to the UI.
    // We keep the sync behavior, but avoid on-page telemetry.
    // (If you need this later for debugging, log to console instead.)
    /*
    var live = byId('ai-live-status');
    if (live && window.__SKAI_USER_ACTION__ === true) {
      var total = (max && max > 0) ? max : v;
      live.textContent =
        'History window set to ' + String(v) +
        ' draws (out of ' + String(total) + ' draws in the database). ' +
        'SKAI will base this run on the most recent ' + String(v) + ' results.';
    }
    */

  }

    // user-driven updates (safe to let listeners run)
  if (sld) sld.addEventListener('input',  function(){ syncFrom('slider'); }, false);
  if (num) num.addEventListener('input',  function(){ syncFrom('number'); }, false);
  if (sld) sld.addEventListener('change', function(){ syncFrom('slider'); }, false);
  if (num) num.addEventListener('change', function(){ syncFrom('number'); }, false);

  // initial, silent normalization (no listener triggers)
  (function initSilently(){
    var prev = !!window.__SKAI_SILENT_SYNC__;
    window.__SKAI_SILENT_SYNC__ = true;
    try {
      if (typeof window.setWindowSizeBounds === 'function') window.setWindowSizeBounds();
      var tries = 0;
      var t = setInterval(function(){
        tries++;
        var max = currentMax();
        if (max > 1 || tries > 20){
          if (typeof window.setWindowSizeBounds === 'function') window.setWindowSizeBounds();
          // mirror UI text only (no event dispatch)
          syncFrom('number');
          clearInterval(t);
        }
      }, 250);
    } finally {
      window.__SKAI_SILENT_SYNC__ = prev;
    }
  })();
})();

// [ADDED] Auto-Tune settings bridge: capture + apply tuned params, then start ML once
;(function(){
  if (typeof window.__SKAI_ANALYSIS_STARTED__ === 'undefined') window.__SKAI_ANALYSIS_STARTED__ = false;
  if (typeof window.__SKAI_AT_SETTINGS__ === 'undefined') window.__SKAI_AT_SETTINGS__ = null;
  if (typeof window.__SKAI_AT_SETTINGS_APPLIED__ === 'undefined') window.__SKAI_AT_SETTINGS_APPLIED__ = false;

  // Map Auto-Tune keys -> control IDs already present in the UI
  var KEY_TO_INPUT = {
    epochs: 'epochs',
    batchSize: 'batchSize',
    dropoutRate: 'dropoutRate',
    learningRate: 'learningRate',
    activationFunction: 'activationFunction',
    hiddenLayers: 'hiddenLayers',
    recencyDecay: 'recencyDecay',
    windowSize: 'windowSize',
    temperature: 'temperature',
    diversityPenalty: 'diversityPenalty',
    blendRatio: 'blendRatio',
    gapScale: 'gapScale'
  };

  function isString(x){ return typeof x === 'string'; }
  function isFiniteNum(x){ return isFinite(+x); }
  function clampNum(v, lo, hi){ v = +v; if (!isFinite(v)) return lo; if (v < lo) v = lo; if (v > hi) v = hi; return v; }
  function setValSafe(id, val){
    try { if (typeof window.setVal === 'function') window.setVal(id, val); }
    catch(e){}
  }

function applyAutoTuneSettings(s){
  if (!s || typeof s !== 'object') return false;

  // Prepare bounds first (depends on history length)
  try { if (typeof window.setWindowSizeBounds === 'function') window.setWindowSizeBounds(); } catch(_){}

  // Apply incoming settings to the visible controls
  for (var k in KEY_TO_INPUT){
    if (!Object.prototype.hasOwnProperty.call(KEY_TO_INPUT, k)) continue;
    if (!(k in s)) continue;

    var inputId = KEY_TO_INPUT[k];
    var v = s[k];

    if (k === 'windowSize'){
      var max = 1;
      try { max = Math.max(1, getWindowMax()); } catch(_){}
      var vv = (isString(v) && String(v).toUpperCase() === 'MAX') ? max : clampNum(v, 1, max);
      setValSafe(inputId, vv);
      try { if (typeof syncWindowSlider === 'function') syncWindowSlider(vv); } catch(_){}
      continue;
    }

    if (k === 'activationFunction'){
      var allowed = ['tanh','relu','elu','sigmoid'];
      var vv = isString(v) ? v.toLowerCase() : 'tanh';
      if (allowed.indexOf(vv) === -1) vv = 'tanh';
      setValSafe(inputId, vv);
      continue;
    }

    if (isFiniteNum(v) || isString(v)){
      setValSafe(inputId, v);
    }
  }

  // Re-assert bounds once more
  try { if (typeof window.setWindowSizeBounds === 'function') window.setWindowSizeBounds(); } catch(_){}

  // Mark as applied and announce once
  window.__SKAI_AT_SETTINGS_APPLIED__ = true;
  // Hardened emit: prefer window.SKAI_emit if present; fall back to CustomEvent.
  try {
    if (typeof window.SKAI_emit === 'function') {
      window.SKAI_emit('skai:autotune:applied', { detail:{ settings:s } });
    } else if (typeof SKAI_emit === 'function') {
      SKAI_emit('skai:autotune:applied', { detail:{ settings:s } });
    } else {
      window.dispatchEvent(new CustomEvent('skai:autotune:applied', { detail:{ settings:s } }));
    }
  } catch(_){}

  // UI note
  try {
    var live = document.getElementById('ai-live-status');
    if (live) live.textContent = 'Auto-Tune settings applied.';
  } catch(_){}

  return true;
}

  function startAnalysisOnce(reason){
    if (window.__SKAI_ANALYSIS_STARTED__) return;
    window.__SKAI_ANALYSIS_STARTED__ = true;

    // Preferred: canonical start signal for trainers
    try { SKAI_emit('skai:analysis:start', { detail: { source: reason || 'autotune' } }); } catch(e){}

    // API-first starts (no Auto-Tune loopback)
    try {
      if (window.SKAI_ANALYZE && typeof window.SKAI_ANALYZE.start === 'function') {
        window.SKAI_ANALYZE.start({ source: reason || 'autotune' });
        return;
      }
      if (typeof window.startMlAnalysis === 'function') {
        window.startMlAnalysis({ source: reason || 'autotune' });
        return;
      }
    } catch(e){}

    // Fallback: dedicated analysis triggers
    try {
      var el = document.querySelector('[data-skai="run-analysis"], [data-action*="run-analysis"]');
      if (el && typeof el.click === 'function') { el.click(); }
    } catch(e){}
  }

  // 1) When tuner publishes results, just store/apply settings (do NOT auto-start)
  window.addEventListener('skai:autotune:result', function(ev){
    try{
      var payload = ev && ev.detail ? ev.detail : null;
      var at = null;
      if (payload && payload.settings && typeof payload.settings === 'object') {
        at = payload.settings;
      } else if (payload && typeof payload === 'object') {
        at = payload; // direct object support
      }

      // Sanitize suspicious fields (negative/NaN/Infinity)
      if (at && typeof at === 'object') {
        // Non-negative metrics
        ['score','mainScore','extraScore','validLoss','valLoss','loss'].forEach(function(k){
          if (Object.prototype.hasOwnProperty.call(at,k)) {
            var v = +at[k];
            at[k] = (isFinite(v) && v >= 0) ? v : 0;
          }
        });
        // Bound windowSize within [1..MAX] or accept 'MAX'
        if (Object.prototype.hasOwnProperty.call(at,'windowSize')) {
          var w = at.windowSize;
          var max = 1; try { max = Math.max(1, getWindowMax()); } catch(_){ max = 1; }
          if (typeof w === 'string' && String(w).toUpperCase() === 'MAX') {
            at.windowSize = 'MAX';
          } else {
            var wn = parseInt(w,10);
            at.windowSize = isFinite(wn) ? Math.max(1, Math.min(max, wn)) : max;
          }
        }
      }

      if (at) {
        window.__SKAI_AT_SETTINGS__ = at;
        applyAutoTuneSettings(at);
      }
      // Do not auto-run; wait for explicit Start click (skai:ml:start)
      window.__SKAI_RUN_ACTIVE__ = false;
    }catch(e){}
  }, { once:true });

  // 2) Also react to the auto-run signals (if settings already arrived they're applied)
  function maybeStart(reason){
    try{
      if (window.__SKAI_AT_SETTINGS__ && !window.__SKAI_AT_SETTINGS_APPLIED__) {
        applyAutoTuneSettings(window.__SKAI_AT_SETTINGS__);
      }
    }catch(e){}
    startAnalysisOnce(reason);
  }

  // Bridge the signals emitted in Section 1's Auto-Tune gate - but only start after settings are applied
  if (typeof window.__SKAI_AT_SETTINGS_REQUIRED__ === 'undefined') window.__SKAI_AT_SETTINGS_REQUIRED__ = true;
  if (typeof window.__SKAI_AT_SETTINGS_APPLIED__ === 'undefined')  window.__SKAI_AT_SETTINGS_APPLIED__  = false;
  if (typeof window.__SKAI_DEFER_START__ === 'undefined')          window.__SKAI_DEFER_START__          = false;

window.addEventListener('skai:ml:start', function(){
  // If Auto-Tune is required but not applied yet, try to apply NOW (no deferring)
  if (window.__SKAI_AT_SETTINGS_REQUIRED__ && !window.__SKAI_AT_SETTINGS_APPLIED__) {
    try {
      var tuned = (window.__SKAI_AT_SETTINGS__ || window.SKAI_TUNED_PARAMS || null);
      if (typeof window.__skaiApplyATSettingsSafe === 'function' && tuned) {
        window.__skaiApplyATSettingsSafe(tuned);
      } else {
        // Fallback: at least push the tuned window size
        var sv = window.SKAI_SERVER || {};
        var tw = Number(sv.usedWindow) || Number(sv.bestWindow) || NaN;
        if (isFinite(tw) && tw > 0) {
          var el = document.getElementById('windowSize') || document.getElementById('windowSize_ui');
          if (el) {
            el.value = String(tw);
            try { el.dispatchEvent(new CustomEvent('input',{bubbles:true})); el.dispatchEvent(new CustomEvent('change',{bubbles:true})); } catch(_){}
          }
        }
      }
      window.__SKAI_AT_SETTINGS_APPLIED__ = true;
    } catch(_) {}
  }
  maybeStart('ml-start');
}, { once:true });

window.addEventListener('skai:autotune:ready-for-ml', function(){
  // Same immediate-apply behavior here to avoid deferring forever
  if (window.__SKAI_AT_SETTINGS_REQUIRED__ && !window.__SKAI_AT_SETTINGS_APPLIED__) {
    try {
      var tuned = (window.__SKAI_AT_SETTINGS__ || window.SKAI_TUNED_PARAMS || null);
      if (typeof window.__skaiApplyATSettingsSafe === 'function' && tuned) {
        window.__skaiApplyATSettingsSafe(tuned);
      } else {
        var sv = window.SKAI_SERVER || {};
        var tw = Number(sv.usedWindow) || Number(sv.bestWindow) || NaN;
        if (isFinite(tw) && tw > 0) {
          var el = document.getElementById('windowSize') || document.getElementById('windowSize_ui');
          if (el) {
            el.value = String(tw);
            try { el.dispatchEvent(new CustomEvent('input',{bubbles:true})); el.dispatchEvent(new CustomEvent('change',{bubbles:true})); } catch(_){}
          }
        }
      }
      window.__SKAI_AT_SETTINGS_APPLIED__ = true;
    } catch(_) {}
  }
  maybeStart('autotune-ready');
}, { once:true });

})();
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 2: Start Button Lifecycle / aria-busy
   Purpose:
     - Auto-toggles aria-busy + disabled state on Start/Run buttons
     - Listens for skai:done / skai:error to restore UI
   Depends on:
     - Block 1 (selection sync) optionally
     - setLive()/SKAI_emit() shims (earlier blocks)
   Exposes (globals):
     - None (IIFE only)
   Notes:
     - Runner UX only; preserves behavior.
   ========================================================== */
// Auto-toggle aria-busy on Start buttons (canonical finish: skai:done / skai:error)
;(function(){
  'use strict';


  // RAF/CAN polyfills (Sorcerer-safe; avoid try/catch ReferenceErrors)
  var __raf = window.requestAnimationFrame || function(fn){ return setTimeout(fn,16); };
  var __caf = window.cancelAnimationFrame || function(id){ try{ clearTimeout(id); }catch(_){} };

  // Resolve button nodes at use-time (robust if buttons render later)
  function getStartButtons(){
    return [
      document.getElementById('startPrediction'),
      document.getElementById('runPrediction')
    ].filter(Boolean);
  }

function busy(on){
  // Normalize the flag to a strict boolean (accepts true/1/'1'/'true')
  var active = (on === true || on === 1 || on === '1' || on === 'true');

  // Resolve buttons safely
  var btns = (typeof getStartButtons === 'function') ? getStartButtons() : [];
  if (!btns || !btns.length) return;

  // Coalesce DOM writes into the next frame (avoids rapid reflows/flicker)
  if (busy.__raf) { __caf(busy.__raf); }
  busy.__raf = __raf(function(){
    for (var i = 0; i < btns.length; i++){
      var b = btns[i];
      if (!b || typeof b.getAttribute !== 'function' || typeof b.setAttribute !== 'function') continue;

      try {
        if (active) {
          // Idempotent set: only write if not already 'true'
          if (b.getAttribute('data-busy') !== 'true') {
            b.setAttribute('data-busy', 'true');
          }
        } else {
          // Idempotent clear: only remove if present
          if (b.hasAttribute && b.hasAttribute('data-busy')) {
            b.removeAttribute('data-busy');
          }
        }
      } catch (_){
        // Defensive fallback where attributes may throw
        try { if (b && b.dataset) { b.dataset.busy = active ? 'true' : ''; } } catch(__){}
      }
    }
  });
}

  // Safely toggle a running class (works even if body is absent)
  function addRunningClass(){
    try {
      var host = document.body || document.documentElement;
      host.classList.add('skai-running');
    } catch(_){}
  }
  function removeRunningClass(){
    try {
      var host = document.body || document.documentElement;
      host.classList.remove('skai-running');
    } catch(_){}
  }

  // Debounced clear to avoid flicker on rapid event sequences
  function clearBusy(){
    try {
      if (clearBusy.__t) clearTimeout(clearBusy.__t);
      clearBusy.__t = setTimeout(function(){
        try { if (busy && busy.__raf) __caf(busy.__raf); } catch(_){}
        busy(false);
        removeRunningClass();
      }, 60);
    } catch(_){
      try { if (busy && busy.__raf) __caf(busy.__raf); } catch(__){}
      busy(false);
      removeRunningClass();
    }
  }

  // Start cues
  window.addEventListener('skai:start-clicked', function(){ busy(true); });
  window.addEventListener('skai:tf-ready',      function(){ busy(true); });
  window.addEventListener('skai:ml:start',      function(){ addRunningClass(); busy(true); });

  // Canonical finishes
  window.addEventListener('skai:done',  clearBusy);
  window.addEventListener('skai:error', clearBusy);
})();
</script>


<!-- INSERT: Patch B2 - Start gate to ensure Auto-Tune completes before ML -->
<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 3: Auto-Tune Gatekeeper
   Purpose:
     - Intercepts Start/Run clicks
     - Blocks prediction runs if Auto-Tune is required but unfinished
     - Prevents half-initialized Pick-5 runs
   Depends on:
     - window.__SKAI_AUTOTUNE_REQUIRED__
     - window.__SKAI_AUTOTUNE_DONE__
   Exposes (globals):
     - None
   Notes:
     - This is the -traffic cop- between autotune and runner.
     - Keep exactly here to preserve click timing.
   ========================================================== */
;(function(){
  'use strict';
  // Capture clicks on Start buttons; ensure Auto-Tune completes first.
  function isStartBtn(el){

    return !!el && (el.id === 'startPrediction' || el.id === 'runPrediction');
  }
  document.addEventListener('click', function(ev){
    var t = ev.target;
    var btn = null;

    // Closest-safe (matches your file-wide ES5 hardening)
    try {
      if (t && t.closest) {
        btn = t.closest('#startPrediction, #runPrediction');
      } else {
        // Fallback climb for environments without Element.closest
        var cur = t;
        while (cur && cur.nodeType === 1){
          if (cur.id === 'startPrediction' || cur.id === 'runPrediction') { btn = cur; break; }
          cur = cur.parentElement;
        }
      }
    } catch(_){ btn = null; }

    if (!isStartBtn(btn)) return;

    // If Auto-Tune is required and not done, gate the run
    if (window.__SKAI_AUTOTUNE_REQUIRED__ && !window.__SKAI_AUTOTUNE_DONE__) {
      ev.preventDefault(); ev.stopPropagation();
      try { window.dispatchEvent(new CustomEvent('skai:start-clicked')); } catch(_){}
      if (typeof ensureAutoTune === 'function') {
        // Force a fresh auto-tune run every time the user clicks "Run Prediction"
        ensureAutoTune(true).catch(function(){ /* surfaced via badge/events */ });
      }
      // The Auto-Tune bridge will em
    } else {
      // Normal path if tuning not required or already done
      try {
        if (typeof window.SKAI_emit === 'function') window.SKAI_emit('skai:ml:start');
        else window.dispatchEvent(new CustomEvent('skai:ml:start'));
      } catch(_){}
    }
  }, true);
})();
</script>

<script>
// Ensure Advanced sliders mirror to canonical fields and stay interactive.
;(function(){
  'use strict';

  // One-time guard to avoid duplicate event wiring
  if (window.__SKAI_ADV_WIRED__) return;
  window.__SKAI_ADV_WIRED__ = true;

  var PAIRS = [
    ['skaiadv_epochs','skaiadv_epochs_num','epochs'],
    ['skaiadv_batch','skaiadv_batch_num','batchSize'],
    ['skaiadv_dropout','skaiadv_dropout_num','dropoutRate'],
    ['skaiadv_lr','skaiadv_lr_num','learningRate'],
    ['skaiadv_decay','skaiadv_decay_num','recencyDecay'],
    ['skaiadv_window','skaiadv_window_num','windowSize'],
    ['skaiadv_layers','skaiadv_layers_num','hiddenLayers'],
    ['skaiadv_temp','skaiadv_temp_num','temperature'],
    ['skaiadv_diversity','skaiadv_diversity_num','diversityPenalty'],
    ['skaiadv_gap','skaiadv_gap_num','gapScale']
  ];

  function wireOne(sliderId, numberId, canonId){
    var s = document.getElementById(sliderId);
    var n = document.getElementById(numberId);
    if (!s && !n) return;

    // make sure they're usable
    [s,n].forEach(function(el){
      if (el){
        el.removeAttribute('disabled');
        el.style.pointerEvents = '';
      }
    });

    function push(val){
      var c = document.getElementById(canonId);
      if (!c) return;
      var v = String(val);

      // Skip redundant writes to avoid event storms
      if (String(c.value) === v) return;

      c.value = v;

      // Only dispatch when this is a real user action AND not a silent sync.
      if (window.__SKAI_SILENT_SYNC__ || window.__SKAI_USER_ACTION__ !== true) return;

      try{
        c.dispatchEvent(new Event('input', { bubbles:true }));
        c.dispatchEvent(new Event('change',{ bubbles:true }));
      }catch(_){}
    }

    function clamp(v, lo, hi){
      var x = +v; if (!isFinite(x)) x = lo;
      if (x < lo) x = lo; if (x > hi) x = hi;
      return x;
    }
    function limitsFor(){
      var lo = 0, hi = 1e9;
      if (s){ var smn = +s.min; var smx = +s.max; if (isFinite(smn)) lo = smn; if (isFinite(smx)) hi = smx; }
      if (n){ var nmn = +n.min; var nmx = +n.max; if (isFinite(nmn)) lo = Math.max(lo, nmn); if (isFinite(nmx)) hi = Math.min(hi, nmx); }
      return { lo: lo, hi: Math.max(lo, hi) };
    }
    function fromSlider(){
      if (!s) return;
      var L = limitsFor();
      var v = clamp(s.value, L.lo, L.hi);
      if (n) n.value = String(v);
      s.value = String(v);
      push(v);
    }
    function fromNumber(){
      if (!n) return;
      var L = limitsFor();
      var v = clamp(n.value, L.lo, L.hi);
      if (s) s.value = String(v);
      n.value = String(v);
      push(v);
    }

    if (s && !s.__wiredAdv){ s.__wiredAdv=1; s.addEventListener('input', fromSlider); s.addEventListener('change', fromSlider); }
    if (n && !n.__wiredAdv){ n.__wiredAdv=1; n.addEventListener('input', fromNumber); n.addEventListener('change', fromNumber); }
  }

  function boot(){ PAIRS.forEach(function(p){ wireOne(p[0],p[1],p[2]); }); }
  if (document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', boot, {once:true}); } else { boot(); }
})();
</script>

<script>
// SKAI slider tooltips (no HTML edits). Attaches to canonical IDs and skaiadv_* mirrors.
;(function(){
  'use strict';
// Map: controlId -> { title, body }
var TIPS = {
  'windowSize': {
    t: 'History Window',
    b: 'How many past draws are used to learn patterns. Larger windows capture long-term behavior; smaller windows react to recent shifts.'
  },
  'recencyDecay': {
    t: 'Recency Decay',
    b: 'How strongly recent draws outweigh older draws. Higher values favor newer data and can be useful when lotteries appear to "trend".'
  },
  'temperature': {
    t: 'AI Temperature',
    b: 'Controls the creativity of the AI sampler. Lower values produce steadier, safer picks; higher values explore more variety.'
  },
  'diversityPenalty': {
    t: 'Diversity Penalty',
    b: 'Gently discourages repeating the same numbers. Raising this increases mix; lowering it keeps the highest probabilities more dominant.'
  },
  'dropoutRate': {
    t: 'Dropout',
    b: 'Regularization during training that helps prevent overfitting. Typical range is 0.15-0.30.'
  },
  'learningRate': {
    t: 'Learning Rate',
    b: 'How fast the model updates. Too high can make training unstable; too low can make learning very slow.'
  },
  'epochs': {
    t: 'Epochs',
    b: 'Number of full training passes over the data. More epochs can fit patterns more deeply but take longer and may overfit if set too high.'
  },
  'batchSize': {
    t: 'Batch Size',
    b: 'Number of samples per gradient step. Larger batches give smoother updates; smaller batches introduce more noise but can react faster.'
  },
  'hiddenLayers': {
    t: 'Hidden Layers',
    b: 'Model depth. More layers can learn richer patterns, but may overfit without enough data or regularization.'
  },
  'skai-blend-range': {
    t: 'Blend: Skip + AI',
    b: 'Exact mix between Skip pressure and AI probabilities. 0% = Skip only; 100% = AI only.'
  }
};

// also attach to Advanced mirrors: skaiadv_<id> and skaiadv_<id>_num
function candidatesFor(id){
  return [
    document.getElementById(id),
    document.getElementById('' + id + '_ui'),
    document.getElementById('skaiadv_' + id),
    document.getElementById('skaiadv_' + id + '_num')
  ].filter(Boolean);
}
  // lightweight factory
  var tipEl = null, tipId = 'skai-tip-' + Math.random().toString(36).slice(2);
  var __tipRaf = null, __tipTimer = null; // coalesce + cleanup handles

  // RAF/CAN polyfills local to this IIFE (module-safe)
  var __raf = window.requestAnimationFrame || function(fn){ return setTimeout(fn,16); };
  var __caf = window.cancelAnimationFrame || function(id){ try{ clearTimeout(id); }catch(_){} };

  function ensureTip(){
    if (tipEl && document.contains(tipEl)) return tipEl;
    tipEl = document.createElement('div');
    tipEl.className = 'skai-tip';
    tipEl.id = tipId;
    document.body.appendChild(tipEl);
    return tipEl;
  }

  function showTipFor(target, cfg){
    if (!target || !cfg) return;
    var tip = ensureTip();

    // content (no innerHTML; avoids escapeHtml)
    tip.textContent = '';
    var tt = document.createElement('span');
    tt.className = 'tip-title';
    tt.textContent = String(cfg.t || '');
    tip.appendChild(tt);
    tip.appendChild(document.createTextNode(String(cfg.b || '')));

    // Stage invisible first, then measure & position to avoid 0-0 sizing
    tip.style.visibility = 'hidden';
    tip.classList.add('show');

    try { if (__tipRaf) __caf(__tipRaf); } catch(_){}
    __tipRaf = __raf(function(){
      // If the target or tip vanished, abort cleanly
      if (!document.contains(target) || !document.contains(tip)) {
        try { tip.classList.remove('show'); } catch(_){}
        return;
      }

      var r = target.getBoundingClientRect();
      var x = Math.round(r.left + r.width / 2);
      var y = Math.round(r.top - 10);
      var w = tip.offsetWidth  || 240;
      var h = tip.offsetHeight || 56;

      // Clamp so tooltip never renders off-screen
      var vw = (document.documentElement && document.documentElement.clientWidth) || window.innerWidth || 0;
      var left = x - Math.round(w / 2);
      if (vw > 0){
        left = Math.max(8, Math.min(vw - w - 8, left));
      }

      tip.style.left = left + 'px';
      tip.style.top  = (y - h) + 'px';
      tip.style.visibility = '';
    });
  }

  function hideTip(){
    if (!tipEl) return;
    // cancel any pending frame and debounce (use local polyfill)
    try { if (__tipRaf){ __caf(__tipRaf); __tipRaf = null; } } catch(_){}
    try { if (__tipTimer){ clearTimeout(__tipTimer); __tipTimer = null; } } catch(_){}
    tipEl.classList.remove('show');
    tipEl.style.visibility = 'hidden'; // ensure fully hidden even if class toggles race
  }

  // bind a single control id to its tooltip (and advanced mirrors)
  function bind(id, cfg){
    candidatesFor(id).forEach(function(el){
      if (!el || el.__skaiTip) return;
      el.__skaiTip = 1;
      // pointer & keyboard focus
      el.addEventListener('mouseenter', function(){ showTipFor(el, cfg); }, false);
      el.addEventListener('mouseleave', hideTip, false);
      el.addEventListener('focus',      function(){ showTipFor(el, cfg); }, true);
      el.addEventListener('blur',       hideTip, true);

      // optional: update placement on input (slider drag) ? light debounce (deduped)
      (function(){
        el.addEventListener('input', function(){
          if (!tipEl || !tipEl.classList.contains('show')) return;
          try { if (__tipTimer) clearTimeout(__tipTimer); } catch(_){}
          __tipTimer = setTimeout(function(){ showTipFor(el, cfg); }, 30);
        }, false);
      })();
    });
  }

  function boot(){
    Object.keys(TIPS).forEach(function(id){ bind(id, TIPS[id]); });

    // CHG: prevent stuck tips when the viewport moves
    try {
      window.addEventListener('scroll', hideTip, { passive:true });
      window.addEventListener('resize', hideTip, { passive:true });
    } catch(_){}
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }
})();
</script>

<!-- (SKAI summary sync script removed as legacy; summary panels are now hidden) -->

<script>
// -----------------------------------------------------------------------------
// SKAI: secondary progress bars (Main & Extra) - event-driven, no auto-start
// Mounts inside the AI panel under the overall progress bar.
// Public API: window.SKAI_BARS.main / window.SKAI_BARS.extra (ensure/update/done/reset/setPhase)
// Emits nothing by itself; it only listens to events.
// -----------------------------------------------------------------------------
;(function(){
  'use strict';

  // Helpers
  function host(){
    return document.getElementById('skaiProgressHost')
        || document.getElementById('skai-ai-panel')
        || document.body;
  }
  function clamp01(n){ n = +n; return isFinite(n) ? (n<0?0:n>1?1:n) : 0; }

  function buildBar(id, label){
    var h = host(); if (!h) return null;

    // If already exists, return it
    var wrap = document.getElementById(id);
    if (wrap && document.contains(wrap)) return wrap;

    // Create structure
    wrap = document.createElement('div');
    wrap.id = id;
    wrap.style.margin = '8px 0 10px';
    wrap.style.border = '1px solid rgba(0,0,0,.08)';
    wrap.style.borderRadius = '6px';
    wrap.style.background = '#fff';
    wrap.style.display = 'none'; // hidden until a run starts

    var head = document.createElement('div');
    head.style.padding = '6px 10px';
    head.style.fontSize = '12px';
    head.style.fontWeight = '700';
    head.setAttribute('data-skai-phase', '');
    head.textContent = label || '';
    wrap.appendChild(head);

    var track = document.createElement('div');
    track.style.height = '14px';
    track.style.background = 'rgba(0,0,0,.06)';
    track.style.borderRadius = '0';
    track.style.overflow = 'hidden';
    wrap.appendChild(track);

    var bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.height = '100%';
    bar.style.width  = '0%';
    bar.style.transition = 'width .15s ease-out';
    // reduce motion when user prefers it
    try {
      if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        bar.style.transition = 'none';
      }
    } catch(_){}
    bar.style.background = 'linear-gradient(90deg,#34A853,#86EFAC)';
    track.appendChild(bar);

    var info = document.createElement('div');
    info.style.display = 'flex';
    info.style.alignItems = 'baseline';
    info.style.justifyContent = 'space-between';
    info.style.gap = '8px';
    info.style.padding = '6px 10px';
    info.style.fontSize = '12px';
    var left = document.createElement('span'); // message
    left.setAttribute('data-skai-msg','');
    var right = document.createElement('span'); // pct
    right.setAttribute('data-skai-pct','0%');
    info.appendChild(left);
    info.appendChild(right);
    wrap.appendChild(info);

    // Insert AFTER the overall bar if present; else at end of panel
    var overall = document.getElementById('skaiProgress');
    if (overall && overall.parentNode === h) {
      overall.insertAdjacentElement('afterend', wrap);
    } else {
      h.appendChild(wrap);
    }
    return wrap;
  }

  function makeAPI(id, label){
    // RAF/CAN polyfills local to this API (no global pollution)
    var __raf = window.requestAnimationFrame || function(fn){ return setTimeout(fn,16); };
    var __caf = window.cancelAnimationFrame || function(id){ try{ clearTimeout(id); }catch(_){} };

    var wrap = null, bar = null, phaseEl = null, pctEl = null, msgEl = null;
    function ensure(){
      wrap = buildBar(id, label);
      if (!wrap) return null;
      bar     = wrap.querySelector('.bar');
      phaseEl = wrap.querySelector('[data-skai-phase]');
      pctEl   = wrap.querySelector('[data-skai-pct]');
      msgEl   = wrap.querySelector('[data-skai-msg]');
      return wrap;
    }
function start(){
  if (!ensure()) return;
  wrap.style.display = '';
  update(0, 'Preparing...');
}
    function setPhase(txt){
      if (!ensure()) return;
      if (phaseEl) phaseEl.textContent = txt || label || '';
    }
function update(pct, msg){
  if (!ensure()) return;
  var p = clamp01(pct);
  var w = Math.round(p*100);

  // Skip work if width unchanged
  if (update.__lastW === w && update.__lastMsg === String(msg || '')) {
    wrap.style.display = '';
    return;
  }
  update.__lastW = w;
  update.__lastMsg = String(msg || '');

  // Coalesce DOM writes (polyfilled)
  if (update.__raf) { __caf(update.__raf); }
  update.__raf = __raf(function(){
    if (bar) {
      bar.style.width = w + '%';
    }
    if (pctEl) pctEl.textContent = w + '%';
    if (msgEl && msg != null) msgEl.textContent = String(msg);
    wrap.style.display = '';
  });
}
    function done(finalMsg){
      if (!ensure()) return;
      wrap.style.display = ''; // ADDED: reveal bar even if no prior start/update
      if (bar) bar.style.width = '100%';
      if (pctEl) pctEl.textContent = '100%';
      if (finalMsg && msgEl) msgEl.textContent = String(finalMsg);
    }
    function reset(){
      if (!ensure()) return;
      if (bar) bar.style.width = '0%';
      if (pctEl) pctEl.textContent = '0%';
      if (msgEl) msgEl.textContent = '';
      wrap.style.display = 'none';
      setPhase(label || '');
    }
    return { ensure, start, setPhase, update, done, reset };
  }

  // Public secondary bars
  if (!window.SKAI_BARS) window.SKAI_BARS = {};
  // UX: more natural labels for the per-stream progress bars
  window.SKAI_BARS.main  = window.SKAI_BARS.main  || makeAPI('skaiProgressMain',  'Main numbers (AI run)');
  window.SKAI_BARS.extra = window.SKAI_BARS.extra || makeAPI('skaiProgressExtra', 'Extra number (AI run)');

  // -- Event wiring (no auto-run; only respond when a run is active) ------------------
  // FIX: Convert HAS_EXTRA from a static value to a dynamic function.
  // This ensures we always check the current state of SKAI_META rather than
  // a snapshot taken at script load time (when SKAI_META might not be set yet).
  function hasExtraDynamic(){
    try{
      if (window.SKAI_META && typeof window.SKAI_META.hasExtraBall !== 'undefined') {
        return !!window.SKAI_META.hasExtraBall;
      }
      if (window.SKAI_SERVER && Array.isArray(window.SKAI_SERVER.topExtraNumbers)) {
        return window.SKAI_SERVER.topExtraNumbers.length > 0;
      }
      // Optional fallback if you ever add a data attribute:
      var a = document.getElementById('skai-anchor');
      var flag = a && a.getAttribute('data-has-extra');
      if (flag != null) return (flag === '1' || flag === 'true');
    }catch(_){}
    return false;
  }
  // DEPRECATED: Legacy variable for backward compatibility with any code that still references HAS_EXTRA.
  // All event handlers in this IIFE now use hasExtraDynamic() for proper timing.
  // This static value may be incorrect if SKAI_META wasn't populated when this script ran.
  // TODO: Remove this variable in a future version once all legacy code is updated.
  var HAS_EXTRA = hasExtraDynamic();

  // Canonical start: reset bars once when ML actually begins
  window.addEventListener('skai:ml:start', function(){
    // Consider ML truly active now
    try { window.__SKAI_RUN_ACTIVE__ = true; } catch(_){}
    // Reset per-run completion flags so maybeAllDone() behaves correctly
    __DONE_MAIN = false;
    __DONE_EXTRA = false;

    window.SKAI_BARS.main.reset();
    // FIX: Use dynamic check instead of static HAS_EXTRA
    if (hasExtraDynamic()) window.SKAI_BARS.extra.reset();
  });

  // Main analysis begins
  window.addEventListener('skai:analyze-main-start', function(){
    if (!window.__SKAI_RUN_ACTIVE__) return;
    window.SKAI_BARS.main.start();
    window.SKAI_BARS.main.setPhase('Main Numbers AI Run');
  });

  // Extra analysis begins (only if present)
  window.addEventListener('skai:analyze-extra-start', function(){
    if (!window.__SKAI_RUN_ACTIVE__) return;
    // FIX: Use dynamic check instead of static HAS_EXTRA
    if (!hasExtraDynamic()) return;
    window.SKAI_BARS.extra.start();
    window.SKAI_BARS.extra.setPhase('Extra Numbers AI Run');
  });

  // Coordinator flags for finalization across main/extra
  var __DONE_MAIN = false, __DONE_EXTRA = false;

  // Local CE factory for this IIFE (cannot rely on later script tags)
  var __CE = (function(){
    try { new CustomEvent('x'); return function(name, params){ return new CustomEvent(name, params || {}); }; }
    catch(_){
      return function(name, params){
        params = params || { bubbles:false, cancelable:false, detail:null };
        var e = document.createEvent('CustomEvent');
        e.initCustomEvent(name, !!params.bubbles, !!params.cancelable, params.detail);
        return e;
      };
    }
  })();

  function maybeAllDone(){
    try {
      // FIX: Use dynamic check instead of static HAS_EXTRA
      var hasExtra = hasExtraDynamic();
      console.log('[SKAI maybeAllDone] hasExtra=' + hasExtra + ', __DONE_MAIN=' + __DONE_MAIN + ', __DONE_EXTRA=' + __DONE_EXTRA);
      
      if (!hasExtra && __DONE_MAIN) {
        console.log('[SKAI maybeAllDone] Firing skai:done (no extra balls)');
        window.dispatchEvent(__CE('skai:done'));
      } else if (hasExtra && __DONE_MAIN && __DONE_EXTRA) {
        console.log('[SKAI maybeAllDone] Firing skai:done (with extra balls)');
        window.dispatchEvent(__CE('skai:done'));
      } else {
        console.log('[SKAI maybeAllDone] Not ready to complete yet');
      }
    } catch(_){}
  }

  window.addEventListener('skai:ml:epoch', function(e){
    if (!window.__SKAI_RUN_ACTIVE__) return;
    var d = (e && e.detail) || {};
    if (d && d.totalEpochs > 0) {
      var ep = Math.max(1, Math.min(d.totalEpochs, Math.round(d.epoch || 1)));
      var pct = Math.max(0, Math.min(1, ep / d.totalEpochs));
      window.SKAI_BARS.main.start();
      window.SKAI_BARS.main.setPhase('Main Numbers AI Run');
      window.SKAI_BARS.main.update(pct, 'Epoch ' + ep + ' / ' + d.totalEpochs);
    }
  });

  // Live confidence bridge (detail.confidence in 0..1 or 0..100)
  window.addEventListener('skai:ml:metrics', function(e){
    if (!window.__SKAI_RUN_ACTIVE__) return;
    var m = (e && e.detail) || {};
    if (m == null || m.confidence == null) return;
    var raw = +m.confidence;
    if (!isFinite(raw)) return;
    var pct = raw > 1 ? raw : (raw * 100);
    pct = Math.max(0, Math.min(100, Math.round(pct)));
    var txt = document.getElementById('confidencePct');
    if (txt) { txt.textContent = String(pct) + '%'; }
    if (window.SKAI_CONF && typeof window.SKAI_CONF.update === 'function') {
      try { window.SKAI_CONF.update(pct / 100); } catch(_){}
    }
  });

  window.addEventListener('skai:ml:done', function(){
    if (!window.__SKAI_RUN_ACTIVE__) return;
    var msg = (typeof SKAI_msg === 'function') ? SKAI_msg('completed') : 'Completed.';
    window.SKAI_BARS.main.done(msg);
    __DONE_MAIN = true;
    try { if (typeof setLive === 'function') setLive(msg); } catch(_){}
    
    // CRITICAL FIX: If no extra balls, set __DONE_EXTRA immediately to prevent hanging
    if (!hasExtraDynamic()) {
      __DONE_EXTRA = true;
      console.log('[SKAI] No extra balls detected - marking extra as done');
    }
    
    maybeAllDone();
  });

  window.addEventListener('skai:extra:start', function(){
    // FIX: Use dynamic check instead of static HAS_EXTRA
    if (!window.__SKAI_RUN_ACTIVE__ || !hasExtraDynamic()) return;
    window.SKAI_BARS.extra.start();
    window.SKAI_BARS.extra.setPhase('Extra Numbers AI Run');
  });

  window.addEventListener('skai:extra:epoch', function(e){
    // FIX: Use dynamic check instead of static HAS_EXTRA
    if (!window.__SKAI_RUN_ACTIVE__ || !hasExtraDynamic()) return;
    var d = (e && e.detail) || {};
    if (d && d.totalEpochs > 0) {
      var pct = Math.max(0, Math.min(1, d.epoch / d.totalEpochs));
      window.SKAI_BARS.extra.update(pct, 'Epoch ' + d.epoch + ' / ' + d.totalEpochs);
    }
  });

  window.addEventListener('skai:extra:done', function(){
    // FIX: Use dynamic check instead of static HAS_EXTRA
    if (hasExtraDynamic()) {
      window.SKAI_BARS.extra.done('Completed.');
      __DONE_EXTRA = true;
      maybeAllDone();
    }
  });

  // Final all-done signal
  window.addEventListener('skai:done', function(){
    window.SKAI_BARS.main.done('Completed.');
    // FIX: Use dynamic check instead of static HAS_EXTRA
    if (hasExtraDynamic()) window.SKAI_BARS.extra.done('Completed.');
    try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
    
    // Set progress indicator to final stage 5 (Complete)
    try {
      if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.setStage === 'function') {
        window.SKAI_ProgressIndicator.setStage(5);
      }
    } catch(_){}
    
    // Display auto-tune results in consolidated progress card
    try {
      if (window.__SKAI_AUTOTUNE_DATA__) {
        var data = window.__SKAI_AUTOTUNE_DATA__;
        var resultsDiv = document.getElementById('skai-progress-autotune-results');
        var contentDiv = document.getElementById('skai-progress-autotune-content');
        if (resultsDiv && contentDiv) {
          var html = '<div style="line-height:1.6;">';
          if (data.configsTested > 0) {
            html += '<div style="margin-bottom:8px;">Tested <strong>' + data.configsTested + '</strong> configurations</div>';
          }
          html += '<div style="margin-bottom:4px;"><strong>Optimized Settings:</strong></div>';
          html += '<div style="padding-left:12px;">';
          html += '• History window: <strong>' + data.window + '</strong> draws<br>';
          html += '• Smoothing (K): <strong>' + data.kValue + '</strong><br>';
          html += '• Backtest score: <strong>' + data.avgScore + '</strong><br>';
          html += '• Hit rate: <strong>' + data.hitRate + '%</strong>';
          html += '</div></div>';
          contentDiv.innerHTML = html;
          resultsDiv.style.display = 'block';
        }
      }
    } catch(_){}
  });

})();
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 6: Parameter Echo + Runner Event Shim
   Purpose:
     - Exposes currentEchoState() snapshot of all UI knobs
     - Provides safe CustomEvent/emitter fallback for runners
     - Used by optimizer scoring + status UI
   Depends on:
     - DOM input IDs (epochs, windowSize, burnIn, etc.)
   Exposes (globals):
     - window.currentEchoState()
     - window.updateParamEcho() (safe no-op if not overridden)
   Notes:
     - Keeps later blocks decoupled from raw DOM reads.
   ========================================================== */
;(function(){
  'use strict';

  // --- Echo the current parameter values (used by other sections)
  if (typeof window.currentEchoState !== 'function') {

    window.currentEchoState = function(){
      function gv(id, d){ var el=document.getElementById(id); return el ? el.value : d; }
      return {
        EPOCHS:              +(gv('epochs',0) || 0),
        BATCH_SIZE:          +(gv('batchSize',0) || 0),
        DROPOUT_RATE:        +(gv('dropoutRate',0) || 0),
        LEARNING_RATE:       +(gv('learningRate',0) || 0),
        ACTIVATION_FUNCTION: (function(){ var v=gv('activationFunction','tanh'); return v||'tanh'; })(),
        HIDDEN_LAYERS:       +(gv('hiddenLayers',0) || 0),
        RECENCY_DECAY:       +(gv('recencyDecay',0) || 0),
        WINDOW:              +(gv('windowSize',0) || 0),
        TEMPERATURE:         +(gv('temperature',0) || 0),
        DIVERSITY_PENALTY:   +(gv('diversityPenalty',0) || 0)
      };
    };
  }
  window.updateParamEcho = window.updateParamEcho || function(){};

// CHG: Safe CustomEvent + emitter shim (idempotent, Sorcerer-safe)
if (typeof window.__SKAI_CE__ !== 'function') {
  try {
    // Native path
    new CustomEvent('x');
    window.__SKAI_CE__ = function(type, params){ return new CustomEvent(type, params || {}); };
  } catch (_) {
    // IE11-style fallback
    window.__SKAI_CE__ = function(type, params){
      params = params || { bubbles:false, cancelable:false, detail:null };
      var e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
      return e;
    };
  }
}
if (typeof window.SKAI_emit !== 'function') {
  // FIX: ensure CustomEvent receives a flat detail payload for all listeners
  window.SKAI_emit = function(name, detail){
    try {
      var payload;

      // If caller passed { detail: {...} } (old style), flatten it
      if (detail && typeof detail === 'object' && Object.prototype.hasOwnProperty.call(detail, 'detail')) {
        payload = (detail.detail == null ? {} : detail.detail);
      } else if (detail == null) {
        // No payload provided
        payload = {};
      } else {
        // Already a flat payload object
        payload = detail;
      }

      // Always dispatch with { detail: payload } so e.detail is flat
      window.dispatchEvent(window.__SKAI_CE__(String(name || ''), { detail: payload }));
    } catch(_){}
  };
}
// Alias for strict-mode scopes that call SKAI_emit(...) directly
var SKAI_emit = window.SKAI_emit;
// NEW: Autotune emit shim (idempotent)
if (!window.SKAI_AUTOTUNE) {
  window.SKAI_AUTOTUNE = {
    emitStart:  function(maxW){ try{ window.dispatchEvent(window.__SKAI_CE__('skai:autotune:start', { detail:{ maxWindow:+maxW||0 } })); }catch(_){} },
    emitCandidate: function(dtl){ try{ window.dispatchEvent(window.__SKAI_CE__('skai:autotune:candidate', { detail:(dtl||{}) })); }catch(_){} },
    emitDone:   function(dtl){ try{ window.dispatchEvent(window.__SKAI_CE__('skai:autotune:done', { detail:(dtl||{}) })); }catch(_){} }
  };
}

  // NEW: Unified Event Bridge (window <-> document) - safe, de-duped
  (function(){
    try{
      if (!window.__SKAI_EVENT_BRIDGE__){
        window.__SKAI_EVENT_BRIDGE__ = 1;

        // Safe CustomEvent (fallback for older engines; Sorcerer-safe)
        var CE = (function(){
          try { new CustomEvent('x'); return CustomEvent; }
          catch(_){
            return function(type, params){
              params = params || { bubbles:false, cancelable:false, detail:null };
              var e = document.createEvent('CustomEvent');
              e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
              return e;
            };
          }
        })();

        // Events to unify across scopes
        var NAMES = [
          'skai:options:changed',
          'skai:ui:selection-changed',
          // keep PI HUD in sync during Auto-Tune
          'skai:autotune:progress',
          'skai:autotune:candidate',
          // allow external toggles for snapshot
          'skai:pi:snapshot',
          // autotune lifecycle for lightweight progress UIs and a11y tools
          'skai:autotune:start',
          'skai:autotune:done'
        ];

        // Internal loop-prevention key
        var TAG = '__skai_bridged__';

        function mirror(src, dst, name){
          src.addEventListener(name, function(ev){
            try{
              var d = (ev && ev.detail) || {};
              // If already bridged, ignore
              if (d && typeof d === 'object' && d[TAG]) return;

      // Clone payload defensively (ES5-safe; no Object.assign)
              var payload = {};
              if (d && typeof d === 'object') {
                for (var kk in d){
                  if (Object.prototype.hasOwnProperty.call(d, kk)) payload[kk] = d[kk];
                }
              }
              payload[TAG] = (src === window ? 'w>d:' : 'd>w:') + name;
              // Dispatch on the other scope
              dst.dispatchEvent(new CE(name, { detail: payload }));
            }catch(_){}
          }, false);
        }

        // Bi-directional mirroring for each name
        NAMES.forEach(function(n){
          mirror(window,   document, n);   // window -> document
          mirror(document, window,   n);   // document -> window
        });
      }
    }catch(_){}
  })();

/* --- Auto-Tune orchestration (must succeed before ML) --- */
if (typeof window.__SKAI_AUTOTUNE_REQUIRED__ === 'undefined') window.__SKAI_AUTOTUNE_REQUIRED__ = true;
if (typeof window.__SKAI_AUTOTUNE_DONE__      === 'undefined') window.__SKAI_AUTOTUNE_DONE__      = false;
if (typeof window.SKAI_autotunePromise        === 'undefined') window.SKAI_autotunePromise        = null;

// Helper: run Auto-Tune if needed; resolve when complete (NO timeouts, no simulated progress)
// Simple SKAI debug outputs so users can see live auto-tune work
(function(){
  var lastUpdate = 0;

  function getDebugBox(){
    var box = document.getElementById('skai-debug-panel');
    if (box) return box;

    box = document.createElement('div');
    box.id = 'skai-debug-panel';
    box.style.position     = 'relative';
    box.style.margin       = '10px auto';
    box.style.padding      = '8px 12px';
    box.style.maxWidth     = '600px';
    box.style.fontSize     = '12px';
    box.style.background   = '#f1f8ff';
    box.style.border       = '1px solid #cce0ff';
    box.style.borderRadius = '6px';
    box.style.color        = '#1a3d7c';
    box.style.textAlign    = 'left';

    var parent = document.getElementById('lottoexpert-container') || document.body;
    parent.appendChild(box);
    return box;
  }

  function getInlineBox(){
    var el = document.getElementById('skai-autotune-inline-status');
    if (el) return el;

    var btn = document.getElementById('updateButton');
    el = document.createElement('div');
    el.id = 'skai-autotune-inline-status';
    el.style.marginTop   = '6px';
    el.style.fontSize    = '12px';
    el.style.color       = '#1a3d7c';
    el.style.textAlign   = 'center';
    el.style.minHeight   = '16px';

    if (btn && btn.parentNode) {
      // Insert just after the Run Analysis button
      if (btn.nextSibling) {
        btn.parentNode.insertBefore(el, btn.nextSibling);
      } else {
        btn.parentNode.appendChild(el);
      }
    } else {
      // Fallback to container bottom
      var parent = document.getElementById('lottoexpert-container') || document.body;
      parent.appendChild(el);
    }
    return el;
  }

  // Throttled text updater used by auto-tune loop
  window.SKAI_debugStatus = function(msg, forceNow){
    try{
      var now = Date.now();
      if (!forceNow && now - lastUpdate < 120) return; // throttle ~8fps
      lastUpdate = now;

      var box = getDebugBox();
      if (box) {
        box.textContent = 'Auto-Tune: ' + msg;
      }

      var inlineBox = getInlineBox();
      if (inlineBox) {
        inlineBox.textContent = msg;
      }
    } catch(e){}
  };
})();

// Main auto-tune entry
function ensureAutoTune(force){
  // Gate: if SKAI math is not allowed (guest or non-member), do nothing
  if (!window.SKAI_CAN_RUN) {
    if (typeof Promise !== 'undefined' && Promise && typeof Promise.resolve === 'function') {
      return Promise.resolve(null);
    }
    return null;
  }

  // If already done and not forcing, return quickly with existing tuned params (if any)
  if (!force && window.__SKAI_AUTOTUNE_DONE__) {
    return Promise.resolve(window.SKAI_TUNED_PARAMS || null);
  }

  // If forcing, clear any cached result so we truly re-run
  if (force) {
    try {
      window.__SKAI_AUTOTUNE_DONE__ = false;
      window.SKAI_TUNED_PARAMS      = null;
      window.__SKAI_TUNED_WINDOW__  = null;
      window.SKAI_autotunePromise   = null;
    } catch (_){}
  }

  // Main Auto-Tune implementation used by ensureAutoTune (ML gate).
  // Delegate to the Skip & Hit tuner so there is a single, consistent Auto-Tune.
  function fn(){
    try {
      // Preferred: canonical Skip & Hit entrypoint
      if (typeof window.SKAI_autotuneStart === 'function') {
        return window.SKAI_autotuneStart(); // runs Skip & Hit Auto-Tune
      }
      // Fallback: direct call into the Skip & Hit tuner
      if (typeof window.SKAI_autotuneBySkipHit === 'function') {
        return window.SKAI_autotuneBySkipHit({});
      }
    } catch(_){}
    // Final fallback: resolve quickly so ML is not blocked if tuner is unavailable.
    return Promise.resolve(null);
  }


  // Canonical Auto-Tune delegator: always use Skip & Hit tuner
  // (legacy deterministic JS Auto-Tune removed to reduce size and confusion)
  if (typeof window.runAutoTune !== 'function') {
    window.runAutoTune = function(){
          // Preferred entrypoint: consolidated Skip & Hit Auto-Tune
          if (typeof window.SKAI_autotuneStart === 'function') {
            return window.SKAI_autotuneStart();
          }

          // Fallback entrypoint, if present
          if (typeof window.SKAI_autotuneBySkipHit === 'function') {
            return window.SKAI_autotuneBySkipHit({});
          }

          // If neither tuner exists, log and emit a safe error, then stop.
          try {
            if (typeof window.SKAI_debugStatus === 'function') {
              window.SKAI_debugStatus(
                'Auto-Tune is unavailable: Skip & Hit tuner not loaded.',
                true
              );
            }
            if (typeof window.SKAI_emit === 'function') {
              window.SKAI_emit('skai:autotune:error', { reason: 'skiphit-missing' });
            }
          } catch (_){}

          return null;
    };
  }


  // Canonical tuner function to use for ensureAutoTune
  fn = window.runAutoTune;

  // Run once; share a single promise to avoid duplicate execution
  if (!window.SKAI_autotunePromise) {

    try {
      // Skip & Hit entrypoints already emit the proper "begin" event.
      var p = fn();
      window.SKAI_autotunePromise = (p && typeof p.then === 'function') ? p : Promise.resolve(p);
    } catch(e) {
      try { SKAI_emit('skai:autotune:failed', { detail:{ error:String(e && e.message || e) } }); } catch(_){}
      return Promise.reject(e);
    }
  }

  return window.SKAI_autotunePromise.then(function(res){
    window.__SKAI_AUTOTUNE_DONE__ = true;
    if (res && typeof res === 'object') {
      window.SKAI_TUNED_PARAMS = res;
      try {
        window.__SKAI_AT_SETTINGS__ = res;
        SKAI_emit('skai:autotune:result', { detail: { settings: res } });
      } catch(_){}
    }

    // finalize Auto-Tune visual and trigger ML start
try { SKAI_emit('skai:autotune:done', { detail:{ tuned: res||null } }); } catch(_){}
// Signal the bridge that ML may proceed (it applies settings if not yet applied)
try { SKAI_emit('skai:autotune:ready-for-ml', { detail:{ tuned: res||null } }); } catch(_){}

    return res || null;
  }).catch(function(err){
    try { SKAI_emit('skai:autotune:failed', { detail:{ error:String(err && err.message || err) } }); } catch(_){}
    return Promise.reject(err || new Error('Auto-Tune failed'));
  });
} // closes ensureAutoTune

// expose and close the IIFE
window.ensureAutoTune = window.ensureAutoTune || ensureAutoTune;
})(); 
</script>

<!-- FNR-18A: Lightweight PI Snapshot (Alt+Shift+K) - Sorcerer-safe, no deps -->
<script>
;(function(){
  'use strict';
  if (window.__SKAI_PI_HUD__) return; window.__SKAI_PI_HUD__ = 1;

  function ensureModal(){
    var m = document.getElementById('skaiPiModal');
    if (m) return m;
    m = document.createElement('div');
    m.id = 'skaiPiModal';
    m.setAttribute('role','dialog');
    m.setAttribute('aria-modal','true');
    m.setAttribute('aria-label','Pattern Intelligence Snapshot');
    m.style.cssText = 'position:fixed;inset:auto 16px 16px auto;max-width:420px;background:#111;color:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 24px rgba(0,0,0,.4);font:14px/1.4 system-ui;z-index:2147483647;display:none;';
    m.innerHTML =
'<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">'
+ '<strong>Pattern Intelligence</strong>'
+ '<button type="button" aria-label="Close" id="skaiPiClose" style="all:unset;cursor:pointer;padding:4px 6px;border-radius:4px;border:1px solid #444;">&times;</button>'
+ '</div>'
+ '<div id="skaiPiBody"><em>Snapshot ready.</em></div>'
+ '<div style="margin-top:8px;opacity:.8">Press Alt+Shift+K to toggle.</div>';
    document.body.appendChild(m);
    m.querySelector('#skaiPiClose').addEventListener('click', function(){ m.style.display='none'; }, false);
    return m;
  }

  function summarize(){
    var board = (window.SKAI_PI && window.SKAI_PI.leaderboard) || [];
    var n = board.length;
    if (!n) return '<em>No candidates yet.</em>';

    var sum = board.reduce(function(acc, r){
      acc.mean   += (+r.mean||0);
      acc.w      += (+r.w||0);
      acc.main   += (+r.mainAvg||0);
      acc.bonus  += (+r.bonusAvg||0);
      acc.cases  += (+r.cases||0);
      return acc;
    }, {mean:0,w:0,main:0,bonus:0,cases:0});

    var mean  = sum.mean / n;
    var w     = sum.w    / n;
    var main  = sum.main / n;
    var bonus = sum.bonus/ n;
    var cases = sum.cases/ n;

    var pat = (function(){
      try{
        // ES5-safe Object.values replacement
        var src = (window.SKAI_FEATURES && window.SKAI_FEATURES.main && window.SKAI_FEATURES.main.currSkip) || {};
        var ks = [];
        for (var k in src){
          if (Object.prototype.hasOwnProperty.call(src, k)) ks.push(+src[k] || 0);
        }
        if (!ks.length) return 'Unknown';

        var m = ks.reduce(function(a,b){ return a+b; }, 0) / ks.length;
        var v = ks.reduce(function(a,b){ return a+Math.pow(b-m,2); }, 0) / ks.length;
        var sd = Math.sqrt(v);

        if (sd < 2) return 'Stable';
        if (sd > 5) return 'Volatile';
        return 'Transition';
      }catch(_){ return 'Unknown'; }
    })();

    return '<div>'
        + '<div>Leaderboard n=' + n + '</div>'
        + '<div>Avg W: ' + Math.round(w) + ' - Mean: ' + mean.toFixed(2) + '</div>'
        + '<div>MainAvg: ' + main.toFixed(2) + ' - BonusAvg: ' + bonus.toFixed(2) + ' - Cases: ' + Math.round(cases) + '</div>'
        + '<div style="margin-top:6px">Pattern: <strong>' + pat + '</strong></div>'
      + '</div>';
  }

  function toggle(){
    var m = ensureModal();
    if (m.style.display === 'none' || !m.style.display){
      try { m.querySelector('#skaiPiBody').innerHTML = summarize(); } catch(_){}
      m.style.display = 'block';
      try { m.focus({preventScroll:true}); } catch(_){}
    } else {
      m.style.display = 'none';
    }
  }

  // Keyboard toggle: Alt + Shift + K
  document.addEventListener('keydown', function(ev){
    var key = ev.key || ev.code || '';
    if (ev.altKey && ev.shiftKey && (key==='K' || key==='k' || key==='KeyK')){
      ev.preventDefault();
      toggle();
    }
  }, false);

  // Live update while open
  window.addEventListener('skai:autotune:candidate', function(){
    var m = document.getElementById('skaiPiModal');
    if (m && m.style.display !== 'none'){
      try { m.querySelector('#skaiPiBody').innerHTML = summarize(); } catch(_){}
    }
  }, false);

  // Optional external open hook
  window.addEventListener('skai:pi:snapshot', function(){ toggle(); }, false);
})();
</script>

<!-- NEW: SKAI progress badge (Sorcerer-safe; de-duped; a11y) 
<script>
;(function(){
  'use strict';
  if (window.__SKAI_PROGRESS_BADGE__) return; window.__SKAI_PROGRESS_BADGE__ = 1;

  function createBadge(host){
    var b = document.getElementById('skaiProgressBadge');
    if (b) return b;
    b = document.createElement('span');
    b.id = 'skaiProgressBadge';
    b.className = 'skai-progress-badge';
    b.setAttribute('role','progressbar');

    // Label + track (do NOT use textContent on the container or it will wipe children)
    var lbl = document.createElement('span'); lbl.className = 'skai-progress-label'; lbl.textContent = '0%';
    var tr  = document.createElement('span'); tr.className  = 'skai-progress-track';
    var fi  = document.createElement('span'); fi.className  = 'skai-progress-fill'; fi.style.width = '0%';
    tr.appendChild(fi);
    b.appendChild(lbl);
    b.appendChild(tr);

    b.setAttribute('aria-label','Auto-Tune progress');
    b.setAttribute('aria-valuemin','0');
    b.setAttribute('aria-valuemax','100');
    b.setAttribute('aria-valuenow','0');

    try { host.insertBefore(b, host.firstChild); }
    catch(_){ (document.body||document.documentElement).appendChild(b); }
    return b;
  }

  function updateBadge(b, pct){
    pct = Math.max(0, Math.min(100, (pct|0)));

    // Update only the label (preserve inner track DOM)
    try{
      var label = b.querySelector('.skai-progress-label');
      if (label) { label.textContent = pct + '%'; }
    }catch(_){}

    b.setAttribute('aria-valuenow', String(pct));

    // Fill width if present
    try{
      var f = b.querySelector('.skai-progress-fill');
      if (f) f.style.width = pct + '%';
    }catch(_){}
  }

  function init(){
    var host = document.getElementById('optimizerToolbar')
            || document.querySelector('.optimizer-toolbar')
            || document.querySelector('#prediction')
            || (document.body || document.documentElement);
    var badge = createBadge(host);

    // Initial read from html[data-skai-progress] if already set
    try{
       var h = document && document.documentElement;
      var seed = h ? parseInt(h.getAttribute('data-skai-progress')||'0',10) : 0;

      // ES5-safe numeric guard (Number.isFinite not available everywhere)
      if (isFinite(seed)) updateBadge(badge, seed);
    }catch(_){}

    // Live updates from progress events
    window.addEventListener('skai:autotune:progress', function(e){
      var p = (e && e.detail && e.detail.percent) || 0;
      updateBadge(badge, p);
    }, false);

    // Optional: announce start/done for screen readers
    window.addEventListener('skai:autotune:start', function(){ updateBadge(badge, 0); }, false);
    window.addEventListener('skai:autotune:done',  function(){ updateBadge(badge, 100); }, false);
  }

  if (document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', init, { once:true }); }
  else { init(); }
})();
</script>
-->

<script>
/* ==========================================================
   SKAI JS Block D: Runtime Flag Reset / Cleanup
   Purpose:
     - Resets internal SKAI runtime flags after runs
     - Prevents stale state between executions
   Depends on:
     - None (but only meaningful after a run)
   Exposes (globals):
     - window.SKAI_resetFlags()
   Notes:
     - Idempotent; behavior-preserving.
   ========================================================== */
;(function(){
  'use strict';

  // Syntax-only completion: define resetFlags safely and close the IIFE.
  function resetFlags(){

    try { window.__SKAI_USER_ACTION__ = false; } catch(_){}
    try { window.__SKAI_SILENT_SYNC__ = false; } catch(_){}
    try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
    try { window.__SKAI_BLEND_USER_MOVED__ = false; } catch(_){}
  }

  // Expose once (idempotent), no side effects unless called.
  if (!window.SKAI_resetFlags) window.SKAI_resetFlags = resetFlags;

  // Optional passive cleanup on pagehide; does not change runtime behavior during use.
  try { window.addEventListener('pagehide', resetFlags, { once:true }); } catch(_){}
})();
</script>

<script>
;(function(){
  'use strict';

  // Reset runtime flags after runs; keep tuned params for next start
  // CHG: do NOT clobber flags if a run is currently active (late-load safety).
  try{
    if (!window.__SKAI_RUN_ACTIVE__) {
      window.__SKAI_ANALYSIS_STARTED__     = false;
      window.__SKAI_AT_SETTINGS_APPLIED__  = false;
    }
  }catch(_){}

  // Listen on both window and document; de-dupe multiple emits in the same tick
  (function(){
    var __skaiResetScheduled = false;
    function oncePerTick(fn){
      if (__skaiResetScheduled) return;
      __skaiResetScheduled = true;
      try { fn(); } finally { setTimeout(function(){ __skaiResetScheduled = false; }, 0); }
    }
    function onReset(){
      var rf = (window.SKAI_resetFlags || function(){});
      oncePerTick(rf);
    }

    // Modern emitters
    window.addEventListener('skai:done',  onReset);
    window.addEventListener('skai:error', onReset);

    // Legacy (document-level) emitters
    document.addEventListener('skai:done',  onReset);
    document.addEventListener('skai:error', onReset);
  })();
})();
</script>


<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 4: SKAI_SERVER Hydrator
   Purpose:
     - Parses JSON embedded in #skai-server-json
     - Merges into window.SKAI_SERVER safely (ES5)
     - Initializes runner flags (__SKAI_DEFER_START__, __SKAI_RUN_ACTIVE__)
   Depends on:
     - PHP already printed #skai-server-json template
   Exposes (globals):
     - window.SKAI_SERVER (merged)
     - window.__SKAI_SERVER_PARSED__ (guard)
   Notes:
     - Runner + optimizer both rely on this being correct.
     - Leave order unchanged.
   ========================================================== */
(function(){
  'use strict';
  var tpl = document.getElementById('skai-server-json');
  if (!tpl) return;

  try {
    var raw = (tpl.textContent || tpl.innerText || '').trim();
    if (!raw) return;
    // Some filters may HTML-escape; trust textContent first, then a tolerant decode
    var data;
    try { data = JSON.parse(raw); }
    catch(_){
      try {
        var txt = raw.replace(/&quot;/g,'"').replace(/&#39;/g,"'").replace(/&lt;/g,'<').replace(/&gt;/g,'>').replace(/&amp;/g,'&');
        data = JSON.parse(txt);
      } catch(e){ throw e; }
    }
    // Publish to window
    window.SKAI_SERVER = data;

    // NEW: mark hydration complete so later fallback boots don-t re-parse
    try { window.__SKAI_SERVER_PARSED__ = true; } catch(_){}

    // Fire a ready event so panels can render on either order
    try {
      if (typeof window.SKAI_emit === 'function') {
        window.SKAI_emit('skai:server:ready', { detail: { server: data } });
      } else if (typeof window.dispatchEvent === 'function' && window.__SKAI_CE__) {
        window.dispatchEvent(window.__SKAI_CE__('skai:server:ready', { detail: { server: data } }));
      }
    } catch(_){}
    // If the math renderer exists, render now
    try {
      if (typeof window.SKAI_renderAutoTuneMath === 'function') {
        window.SKAI_renderAutoTuneMath(data);
      }
    } catch(_){}
  } catch(e){
    if (window.console && console.error) console.error('[SKAI] Failed to parse skai-server-json:', e);
  }
})();
</script>

<script>
;(function(){
  'use strict';
function ensureATBadge(){
  try{
    var host = document.getElementById('skai-run-options')
           || document.getElementById('skai-params-panel')
           || document.getElementById('skai-ai-panel')
           || document.body;
    if (!host) return;

    var tuned = false;
    try {
      var SV = window.SKAI_SERVER || {};
      tuned = !!(window.__SKAI_AUTOTUNE_DONE__ || SV.hasAutoTune || (SV.tuneSucceeded === 1));
    } catch(_){}

    var wrap = document.getElementById('skai-autotune-badge');
    if (!wrap) {
      wrap = document.createElement('div');
      wrap.id = 'skai-autotune-badge';
      wrap.className = 'at-badge';
      var state = tuned ? 'done' : 'pending';
      wrap.setAttribute('data-state', state);
      wrap.innerHTML = '<span class="dot"></span><span class="msg">Auto-Tune</span><span class="sub">'
+ (tuned ? 'Optimized window selected' : 'Waiting to run...')
        + '</span>';

      // Insert into resolved host safely
      if (host.firstChild) host.insertBefore(wrap, host.firstChild); else host.appendChild(wrap);
    } else {
      // Keep badge state in sync with current tuned flag
      try { wrap.setAttribute('data-state', tuned ? 'done' : 'pending'); } catch(_){}
    }

    // Ensure we wire listeners only once (avoid duplicates across navs)
    if (!wrap.__skaiATWired__) {
      wrap.__skaiATWired__ = true;
      try {
        // Show "running" immediately when Auto-Tune starts
        function markRunning(){
          try {
            wrap.setAttribute('data-state', 'running');
            var sub = wrap.querySelector('.sub');
            if (sub) sub.textContent = 'Optimizing...';
          } catch(_) {}
        }

        // Legacy + canonical start events
        window.addEventListener('skai:autotune:begin', markRunning);
        window.addEventListener('skai:autotune:start', markRunning);

        // Live progress while tuning (map to simple text; CSS can style [data-state="running"])
        window.addEventListener('skai:autotune:progress', function(e){
          try {
            var d = (e && e.detail) || {};
            // Support both old {index,total,W} and new {percent,window}
            var pct = (d.percent != null) ? (d.percent|0) : 0;
            var w   = (d.window != null) ? String(d.window)
                     : (d.W != null ? String(d.W) : '');

            wrap.setAttribute('data-state', 'running');
            var sub = wrap.querySelector('.sub');
            if (sub) {
              var parts = [];
              if (w)   parts.push('W=' + w);
              if (pct) parts.push(pct + '%');
              sub.textContent = parts.length ? parts.join(' \u00b7 ') : 'Optimizing-';
            }
          } catch(_) {}
        });

        // Flip to done when tuning completes
window.addEventListener('skai:autotune:done', function(e){
  try {
    var w = (e && e.detail && (e.detail.W || e.detail.bestWindow || (e.detail.best && e.detail.best.W))) || null;
            wrap.setAttribute('data-state','done');
            var sub = wrap.querySelector('.sub');
            if (sub) sub.textContent = w ? ('Optimized W=' + w) : 'Optimized window selected';
          } catch(_){}
        });
      } catch(_){}
    }

    return wrap;
  } catch(_) { return null; }
}
 function boot(){ try { ensureATBadge(); } catch(_){ } }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', boot, { once:true });
  } else {
    boot();
  }

  // Reflect state on relevant events
  try {
    window.addEventListener('skai:server:ready', function(){ ensureATBadge(); });
    window.addEventListener('skai:autotune:done', function(){
      try { window.__SKAI_AUTOTUNE_DONE__ = true; } catch(_){}
      ensureATBadge();
    });
  } catch(_){}
})();
</script>

<script>
(function(){
  'use strict';

  // DOM-safe Auto-Tune Math renderer (no multi-line string literals)
  if (document.getElementById('skai-autotune-style') === null) {
    var css = [
      '#skai-autotune-math{margin:12px 0;}',
      '#skai-autotune-math h3{margin:0 0 8px 0;font:700 1.05rem/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}',
      '#skai-autotune-math table{width:100%;border-collapse:collapse;font:500 .95rem/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}',
      '#skai-autotune-math th,#skai-autotune-math td{padding:.4rem .5rem;border:1px solid var(--skai-border, #ccc);text-align:right;}',
      '#skai-autotune-math th:first-child,#skai-autotune-math td:first-child{text-align:center;}',
      '#skai-autotune-math tr[data-best="1"]{outline:2px solid var(--skai-good,#1a7f37);outline-offset:2px;background:rgba(26,127,55,.08);}',
      '@media (forced-colors: active){#skai-autotune-math tr[data-best="1"]{outline-color:Highlight;}}'
    ].join('\n');
    var s = document.createElement('style'); s.id='skai-autotune-style';
    s.appendChild(document.createTextNode(css));
    // CHG: head may be null in some article-injected runtimes; fall back safely.
    var headHost = document.head || document.getElementsByTagName('head')[0] || document.documentElement;
    headHost.appendChild(s);
  }

  if (typeof window.SKAI_renderAutoTuneMath === 'function') return;

  window.SKAI_renderAutoTuneMath = function(server){
    try{
      var s = server || window.SKAI_SERVER || {};
      var td = (s && s.tuneDetails) ? s.tuneDetails : null;
      var rows = (td && Array.isArray(td.scored)) ? td.scored : [];
      var bestW = (typeof s.bestWindow === 'number') ? s.bestWindow : (td && typeof td.bestWindow === 'number' ? td.bestWindow : null);

      // Ensure host exists (below predicted numbers if possible)
      var host = document.getElementById('skai-autotune-math');
      if (!host) {
        var anchor = document.getElementById('aiPredictedNumbers') ||
                     document.querySelector('[data-skai-results]') ||
                     document.getElementById('prediction') ||
                     document.body;
        host = document.createElement('section');
        host.id = 'skai-autotune-math';
        if (anchor && anchor.parentNode) anchor.parentNode.insertBefore(host, anchor.nextSibling);
        else document.body.appendChild(host);
      }

      // Clear host
      while (host.firstChild) host.removeChild(host.firstChild);

      // Header
      var h3 = document.createElement('h3');
      h3.appendChild(document.createTextNode('Auto-Tune Math'));
      host.appendChild(h3);

      // Decide what to show based on server flags
      var autoTuneOff    = (s && s.hasAutoTune === false);
      var neverRequested = (!s || typeof s.tuneRequested === 'undefined' || s.tuneRequested === 0);
      var neverRan       = (!s || typeof s.tuneRan === 'undefined' || s.tuneRan === 0);

      // If Auto-Tune is disabled or has never been requested/ran, show an
      // instructional message instead of an "error" about missing rows.
      if (autoTuneOff || (neverRequested && neverRan)) {
        var pInfo = document.createElement('p');
        pInfo.appendChild(
          document.createTextNode(
            'Run Auto-Tune above to see the math behind SKAI window selection.'
          )
        );
        host.appendChild(pInfo);
        return;
      }

      // At this point Auto-Tune is on / requested, so if we still have no rows
      // then the server truly did not export tuneDetails.scored.
      if (!td || !rows.length) {
        var p = document.createElement('p');
        p.appendChild(
          document.createTextNode(
            'No tuning rows available (server did not export tuneDetails.scored).'
          )
        );
        host.appendChild(p);
        return;
      }

      // Table
      var table = document.createElement('table');
      table.className = 'skai-math';

      var thead = document.createElement('thead');
      var trh = document.createElement('tr');
        ['Window', 'Score', 'Delta', 'Info', 'EMD (main)', 'EMD (extra)'].forEach(function(label){
        var th = document.createElement('th');
        th.appendChild(document.createTextNode(label));
        trh.appendChild(th);
      });
      thead.appendChild(trh);
      table.appendChild(thead);

      var tbody = document.createElement('tbody');

function fmt(v){ 
  return (typeof v === 'number' && isFinite(v)) ? v.toFixed(3) : 'N/A'; 
}

      for (var i=0;i<rows.length;i++){
        var r = rows[i] || {};
        var tr = document.createElement('tr');
        if (bestW != null && Number(r.W) === Number(bestW)) tr.setAttribute('data-best', '1'); // FIX: type-safe compare

        var cols = [
        (r.W != null ? String(r.W) : 'N/A'),
          fmt(r.score),
          fmt(r.gamma),
          fmt(r.beta),
          fmt(r.emdMain),
          fmt(r.emdExtra)
        ];
        for (var c=0;c<cols.length;c++){
          var tdCell = document.createElement('td');
          tdCell.appendChild(document.createTextNode(cols[c]));
          tr.appendChild(tdCell);
        }
        tbody.appendChild(tr);
      }

      table.appendChild(tbody);
      host.appendChild(table);

    }catch(e){
      if (window.console && console.error) console.error('[SKAI] renderAutoTuneMath failed:', e);
    }
  };

  // Auto-render in any order:
  window.addEventListener('skai:server:ready', function(e){
    try { window.SKAI_renderAutoTuneMath(e && e.detail && e.detail.server ? e.detail.server : null); } catch(_){}
  });

  // If server data was parsed earlier, render now.
  try { if (window.SKAI_SERVER) window.SKAI_renderAutoTuneMath(window.SKAI_SERVER); } catch(_){}

})();
</script>

<script>
(function(){
  function bumpEpochLabelToTotal(){
    var el = document.querySelector('.skai-epoch, .ai-epoch, .ai-row-epoch');
    if (!el) return;
    var m = /Epoch\s+(\d+)\s*\/\s*(\d+)/i.exec(el.textContent || '');
    if (!m) return;
    var tot = +m[2] || 0;
    if (tot > 0) el.textContent = 'Epoch ' + tot + ' / ' + tot;
  }
  window.addEventListener('skai:ml:done', bumpEpochLabelToTotal, { once: true });
})();
</script>

<script>
/* Merge server JSON into window.SKAI_SERVER (no PHP inside this block) */
(function(){
  'use strict';

  // If robust hydrator already ran, skip silently (prevents double-parse)
  try { if (window.__SKAI_SERVER_PARSED__) return; } catch(_){}

  var data = {};
  var el = document.getElementById('skai-server-json');
  if (el) {
    try { data = JSON.parse(el.textContent || '{}'); } catch(_) { data = {}; }
  }

  // ES5-safe shallow merge (replacement for Object.assign)
  var base = window.SKAI_SERVER || {};
  var merged = {};
  for (var k in base) { if (Object.prototype.hasOwnProperty.call(base, k)) merged[k] = base[k]; }
  for (var j in data) { if (Object.prototype.hasOwnProperty.call(data, j)) merged[j] = data[j]; }
  window.SKAI_SERVER = merged;

  try { window.__SKAI_SERVER_PARSED__ = true; } catch(_){}
})();
</script>

<script>
(function(){
  try {
    if (typeof window.__SKAI_DEFER_START__ === 'undefined') window.__SKAI_DEFER_START__ = false;
    if (typeof window.__SKAI_RUN_ACTIVE__   === 'undefined') window.__SKAI_RUN_ACTIVE__   = false;
  } catch(_) {}
  // guard removed intentionally ? Run Prediction should not be blocked
 })();
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 5: Root/Panel Bootstrap
   Purpose:
     - Ensures #skai root exists
     - Collects core panels/containers for runner/optimizer UI
     - Provides stable anchors even when Sorcerer moves markup
   Depends on:
     - DOM hooks like #skai-run-options, main containers
   Exposes (globals):
     - window.__SKAI_ROOT_INIT__ (guard)
     - May cache root refs for later blocks
   Notes:
     - Navigation stability block; no algorithmic behavior.
   ========================================================== */
// Ensure #skai wrapper exists and gather core panels beneath it
;(function(){
  'use strict';
  if (window.__SKAI_ROOT_INIT__) return; window.__SKAI_ROOT_INIT__ = 1;

  function ensureSkaiRoot(){
    var anchor = document.getElementById('skai-run-options')
             || document.getElementById('skai-ai-panel')
             || document.getElementById('skaiProgressHost')
             || document.body;

    var root = document.getElementById('skai');
    if (!root){
      root = document.createElement('div');
      root.id = 'skai';
      var ph = document.getElementById('skai-anchor');
      var label = (ph && ph.getAttribute('data-skai-label')) || '';
      if (label){
        // ARIA removed per reduction requirement; keep data attribute only
        root.setAttribute('data-skai-label', label);
      }
    }

    if (anchor && anchor.parentNode){
      if (root.parentNode !== anchor.parentNode){
        // CHG: if anchor is <body>, insert #skai as the first child of <body>
        if (anchor === document.body) {
          anchor.insertBefore(root, anchor.firstChild || null);
        } else {
          anchor.parentNode.insertBefore(root, anchor);
        }
      }
      ['skai-run-options','skai-ai-central','skai-ai-panel','skai-skip-panel','skaiProgressHost'].forEach(function(id){
        var el = document.getElementById(id);
        if (el && el.parentNode !== root){
          root.appendChild(el);
        }
      });
    }
  }
  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', ensureSkaiRoot, { once:true });
  } else {
    ensureSkaiRoot();
  }
})();
</script>

<script>
;(function(){
  'use strict';

  // RT-013B: Advanced settings default state helper
  // New behavior: start CLOSED on load, and let the user toggle it open/closed.
  function initAdvancedPanel(){

    var advHost = document.getElementById('skai-advanced');
    var tog     = document.getElementById('skai-adv-toggle');
    var body    = document.getElementById('skai-adv-body');
    if (!advHost || !tog || !body) return;

    // 1) Initial closed state (dataset + display only, no ARIA locking)
    try {
      advHost.dataset.collapsed = '1';
      body.style.display = 'none';
      tog.setAttribute('aria-expanded','false'); // keep ARIA in sync
    } catch (_){}

    // 2) Make sure the toggle is interactive (undo any older pointer-events lock)
    try {
      tog.style.pointerEvents = '';
    } catch (_){}
  }

  // Run once on DOM ready (and immediately if already ready)
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initAdvancedPanel, { once:true });
  } else {
    initAdvancedPanel();
  }

})();
</script>


<script>
;(function(){
  'use strict';

  // Ensure we have a reusable banner
  function ensureBanner(){
    var banner = document.getElementById('skai-run-banner');
    if (!banner){
      var host = document.getElementById('skai-run-options') || document.getElementById('skai-ai-panel') || document.body;
      banner = document.createElement('div');
      banner.id = 'skai-run-banner';
      banner.style.cssText = 'display:none;margin:8px 0;padding:8px 10px;border-radius:8px;background:#fef3c7;border:1px solid #f59e0b;color:#7c2d12;font-weight:800;';
      var t = document.createElement('span');
      t.className = 'txt';
      t.textContent = 'Custom settings changed.';
      banner.appendChild(t);
      host.insertBefore(banner, host.firstChild);
    }
    return banner;
  }

  function showBanner(msg){
    var b = ensureBanner();
    var t = b.querySelector('.txt');
    if (t && msg) t.textContent = String(msg);
    b.style.display = '';
    clearTimeout(b.__hide);
    b.__hide = setTimeout(function(){ b.style.display = 'none'; }, 1800);
  }

  // NEW: expose a safe global hook so other code (profiles/strategy) can trigger the banner
  window.SKAI_notifyCustomChange = window.SKAI_notifyCustomChange || function(m){
    try { showBanner(m || 'Custom settings changed.'); } catch(e){}
  };

  // Any of these inputs count as "custom change"
  var ADV_IDS = [
    'skaiadv_epochs','skaiadv_epochs_num',
    'skaiadv_batch','skaiadv_batch_num',
    'skaiadv_dropout','skaiadv_dropout_num',
    'skaiadv_lr','skaiadv_lr_num',
    'skaiadv_decay','skaiadv_decay_num',
    'skaiadv_window','skaiadv_window_num',
    'temperature','diversityPenalty',
    'windowSize','windowSizeSlider'
  ];

  function onChange(e){
    var id = e && e.target && e.target.id;
    if (!id) return;
    for (var i=0;i<ADV_IDS.length;i++){
      if (ADV_IDS[i] === id){ showBanner('Custom settings changed.'); return; }
    }
  }

  // Listen globally; cheap checks
  document.addEventListener('input', onChange, true);
  document.addEventListener('change', onChange, true);
})();
</script>

<script>
  // ADDED: SKAI AI save wiring helper
  // Call window.skaiPrepareAiSave({...}) from your AI code when a prediction is ready.
  (function () {
    function formatDateForDb(now) {
      function pad(n) { return (n < 10 ? '0' : '') + n; }

      // CHG: Use UTC components to align with server labelText and draw logic.
      // Prevents timezone drift in saved `generated_at` ordering.
      var year  = now.getUTCFullYear();
      var month = pad(now.getUTCMonth() + 1);
      var day   = pad(now.getUTCDate());
      var hour  = pad(now.getUTCHours());
      var min   = pad(now.getUTCMinutes());
      var sec   = pad(now.getUTCSeconds());

      return year + '-' + month + '-' + day + ' ' + hour + ':' + min + ':' + sec;
    }

    function toCsv(arr) {
      if (!arr || !arr.length) {
        return '';
      }
      return arr.join(',');
    }

    function toJsonString(value) {
      if (value === null || typeof value === 'undefined') {
        return '';
      }
      if (typeof value === 'string') {
        return value;
      }
      try {
        return JSON.stringify(value);
      } catch (e) {
        return '';
      }
    }

    window.skaiPrepareAiSave = function (options) {
      options = options || {};

      var form = document.getElementById('skai-ai-save-form');
      if (!form) {
        return;
      }

      var mainNumbers      = options.mainNumbers || [];
      var extraNumbers     = options.extraNumbers || [];
      var drawsAnalyzed    = typeof options.drawsAnalyzed === 'number' ? options.drawsAnalyzed : 0;
      var numbersJson      = options.numbersJson || null;
      var topCombosJson    = options.topCombosJson || null;

      var epochs           = options.epochs;
      var batchSize        = options.batchSize;
      var dropoutRate      = options.dropoutRate;
      var learningRate     = options.learningRate;
      var activationFunc   = options.activationFunction;
      var hiddenLayers     = options.hiddenLayers;
      var recencyDecay     = options.recencyDecay;

      // Hidden field references
      var fldNumbersJson   = document.getElementById('skai-ai-numbers-json');
      var fldCombosJson    = document.getElementById('skai-ai-top-combos-json');
      var fldMainJson      = document.getElementById('skai-ai-main-json');
      var fldExtraJson     = document.getElementById('skai-ai-extra-json');
      var fldMainCsv       = document.getElementById('skai-ai-main-csv');
      var fldExtraCsv      = document.getElementById('skai-ai-extra-csv');
      var fldDrawsAnalyzed = document.getElementById('skai-ai-draws-analyzed');
      var fldGeneratedAt   = document.getElementById('skai-ai-generated-at');

      var fldEpochs        = document.getElementById('skai-ai-epochs');
      var fldBatchSize     = document.getElementById('skai-ai-batch-size');
      var fldDropout       = document.getElementById('skai-ai-dropout');
      var fldLr            = document.getElementById('skai-ai-lr');
      var fldActivation    = document.getElementById('skai-ai-activation');
      var fldLayers        = document.getElementById('skai-ai-layers');
      var fldRecencyDecay  = document.getElementById('skai-ai-recency-decay');

      var btnSave          = document.getElementById('skai-ai-submit-save');
      var hint             = document.getElementById('skai-ai-save-hint');

      // Basic validation - must have at least one main number to enable saving
      if (!mainNumbers || !mainNumbers.length) {
        if (hint) {
          hint.textContent = 'Run SKAI AI analysis to enable saving.';
        }
        if (btnSave) {
          btnSave.disabled = true;
        }
        return;
      }

      var now              = new Date();
      var dbTimestamp      = formatDateForDb(now);
      var mainCsv          = toCsv(mainNumbers);
      var extraCsv         = toCsv(extraNumbers);

      if (fldMainJson)      { fldMainJson.value      = toJsonString(mainNumbers); }
      if (fldExtraJson)     { fldExtraJson.value     = toJsonString(extraNumbers); }
      if (fldMainCsv)       { fldMainCsv.value       = mainCsv; }
      if (fldExtraCsv)      { fldExtraCsv.value      = extraCsv; }
      if (fldDrawsAnalyzed) { fldDrawsAnalyzed.value = drawsAnalyzed > 0 ? String(drawsAnalyzed) : ''; }
      if (fldGeneratedAt)   { fldGeneratedAt.value   = dbTimestamp; }

      if (fldNumbersJson)   { fldNumbersJson.value   = toJsonString(numbersJson); }
      if (fldCombosJson)    { fldCombosJson.value    = toJsonString(topCombosJson); }

      // Hyperparameters
      if (fldEpochs) {
        fldEpochs.value = typeof epochs !== 'undefined' ? String(epochs) : 
          (settings && settings.epochs) ? String(settings.epochs) : '';
      }
      if (fldBatchSize) {
        fldBatchSize.value = typeof batchSize !== 'undefined' ? String(batchSize) :
          (settings && settings.batchSize) ? String(settings.batchSize) : '';
      }
      if (fldDropout) {
        fldDropout.value = typeof dropoutRate !== 'undefined' ? String(dropoutRate) :
          (settings && settings.dropoutRate) ? String(settings.dropoutRate) : '';
      }
      if (fldLr) {
        fldLr.value = typeof learningRate !== 'undefined' ? String(learningRate) :
          (settings && settings.learningRate) ? String(settings.learningRate) : '';
      }
      if (fldActivation) {
        fldActivation.value = typeof activationFunc !== 'undefined' ? String(activationFunc) :
          (settings && settings.activationFunction) ? String(settings.activationFunction) : '';
      }
      if (fldLayers) {
        fldLayers.value = typeof hiddenLayers !== 'undefined' ? String(hiddenLayers) :
          (settings && settings.hiddenLayers) ? String(settings.hiddenLayers) : '';
      }
      if (fldRecencyDecay) {
        fldRecencyDecay.value = typeof recencyDecay !== 'undefined' ? String(recencyDecay) :
          (settings && settings.recencyDecay) ? String(settings.recencyDecay) : '';
      }

      // SKAI blend and advanced parameters
      var fldBlendSkipPct = document.getElementById('skai-ai-blend-skip-pct');
      var fldBlendAiPct = document.getElementById('skai-ai-blend-ai-pct');
      var fldSamplingTemp = document.getElementById('skai-ai-sampling-temp');
      var fldDiversityPenalty = document.getElementById('skai-ai-diversity-penalty');
      var fldGapScale = document.getElementById('skai-ai-gap-scale');
      var fldLaplaceK = document.getElementById('skai-ai-laplace-k');
      var fldSkipGamma = document.getElementById('skai-ai-skip-gamma');
      var fldWindowSize = document.getElementById('skai-ai-window-size');
      var fldRunMode = document.getElementById('skai-ai-run-mode');
      var fldTopNNumbers = document.getElementById('skai-ai-top-n-numbers');
      var fldTopNCombos = document.getElementById('skai-ai-top-n-combos');

      // Get blend values from slider (0-100%)
      var blendSlider = document.getElementById('skai-blend-range');
      if (blendSlider && fldBlendAiPct && fldBlendSkipPct) {
        var aiPct = parseInt(blendSlider.value, 10) || 40;
        fldBlendAiPct.value = String(aiPct);
        fldBlendSkipPct.value = String(100 - aiPct);
      }

      // Get values from window.SKAI_SETTINGS if available
      if (typeof window.SKAI_SETTINGS !== 'undefined' && window.SKAI_SETTINGS) {
        var settings = window.SKAI_SETTINGS;
        
        if (fldSamplingTemp && typeof settings.gap !== 'undefined') {
          fldSamplingTemp.value = String(settings.gap);
        }
        if (fldDiversityPenalty && typeof settings.diversityPenalty !== 'undefined') {
          fldDiversityPenalty.value = String(settings.diversityPenalty);
        }
        if (fldGapScale && typeof settings.gapScale !== 'undefined') {
          fldGapScale.value = String(settings.gapScale);
        }
        if (fldLaplaceK && typeof settings.laplaceK !== 'undefined') {
          fldLaplaceK.value = String(settings.laplaceK);
        }
        if (fldSkipGamma && typeof settings.skipGamma !== 'undefined') {
          fldSkipGamma.value = String(settings.skipGamma);
        }
        if (fldWindowSize && typeof settings.windowSize !== 'undefined') {
          fldWindowSize.value = String(settings.windowSize);
        }
      }

      // Get mode and top N values from DOM or globals if available
      if (fldRunMode) {
        fldRunMode.value = 'hybrid'; // default SKAI mode
      }
      if (fldTopNNumbers && mainNumbers && mainNumbers.length > 0) {
        fldTopNNumbers.value = String(mainNumbers.length);
      }
      if (fldTopNCombos) {
        fldTopNCombos.value = '20'; // default top combos
      }

      // Populate risk_profile and strategy from current UI selection
      try {
        var profileBtn = document.querySelector('#skai-profile-buttons .btn-chip[aria-pressed="true"]');
        var profileVal = profileBtn ? (profileBtn.getAttribute('data-profile') || 'balanced') : 'balanced';
        var profileEl = document.getElementById('skai-ai-risk-profile');
        if (profileEl) profileEl.value = profileVal;

        var strategyBtn = document.querySelector('#skai-strategy-buttons .btn-chip[aria-pressed="true"]');
        var strategyVal = strategyBtn ? (strategyBtn.getAttribute('data-strategy') || 'hybrid') : 'hybrid';
        var strategyEl = document.getElementById('skai-ai-strategy');
        if (strategyEl) strategyEl.value = strategyVal;
      } catch(_) {}

      // Populate auto-tune and skip window parameters
      var fldAutoTune = document.getElementById('skai-ai-autotune');
      var fldSkipWindow = document.getElementById('skai-ai-skip-window');
      var fldBestWindow = document.getElementById('skai-ai-best-window');
      var fldTunedWindow = document.getElementById('skai-ai-tuned-window');
      var fldTuneUsed = document.getElementById('skai-ai-tune-used');

      // Get auto-tune status and results from global variables
      try {
        if (fldAutoTune) {
          fldAutoTune.value = (window.__SKAI_AUTOTUNE_DONE__) ? '1' : '0';
        }
        if (fldSkipWindow && settings && typeof settings.windowSize !== 'undefined') {
          fldSkipWindow.value = String(settings.windowSize);
        }
        if (fldBestWindow && window.__SKAI_TUNED_WINDOW__) {
          fldBestWindow.value = String(window.__SKAI_TUNED_WINDOW__);
        }
        if (fldTunedWindow && window.__SKAI_TUNED_WINDOW__) {
          fldTunedWindow.value = String(window.__SKAI_TUNED_WINDOW__);
        }
        if (fldTuneUsed) {
          fldTuneUsed.value = (window.__SKAI_AUTOTUNE_DONE__) ? '1' : '0';
        }
      } catch(_) {}

      if (btnSave) {
        btnSave.disabled = false;
      }
      if (hint) {
        hint.textContent = 'AI prediction is ready to save.';
      }
    };
  })();

// SKAI telemetry (refreshable + safe HTML) ? unified, no duplicates
;(function(){
'use strict';

// NOTE: Use ASCII-safe flags to avoid encoding glitches in Joomla/Sourcerer output.
function flag(v){ return v ? 'Yes' : 'No'; }

// safe element factory for "Key: Value" chips
function chip(k, v){
var s = document.createElement('span');
s.style.marginRight = '10px';
var b = document.createElement('strong');
b.textContent = k + ':';
s.appendChild(b);
s.appendChild(document.createTextNode(' ' + v));
return s;
}
function ensureTelemetryHost(){
  // Disabled: we no longer render the visible "Technical details (advanced)" bar.
  // Instead, we provide a hidden telemetry box so any logging code can still write safely.

  var box = document.getElementById('skai-telemetry');

  if (!box) {
    box = document.createElement('div');
    box.id = 'skai-telemetry';
    // Keep it completely hidden and non-intrusive in the layout
    box.style.cssText = 'display:none !important;';
    try {
      document.body.appendChild(box);
    } catch (_) {
      // If body is not available for some reason, just leave it detached
    }
  }

  return box;
}

function readBackend(){
if (!window.tf) return 'N/A';
try { return (typeof window.tf.getBackend === 'function') ? window.tf.getBackend() : 'ready'; }
catch(_) { return 'ready'; }
}

function readTFready(){
try { return !!(window.tf && typeof tf.ready === 'function'); }
catch(_) { return false; }
}

function readTFver(){
try {
  return (window.tf && window.tf.version && window.tf.version.tfjs)
    ? window.tf.version.tfjs
    : 'N/A';
} catch (_) {
  return 'N/A';
}
}

var __SKAI_WEBGL_CACHE__;
function readWebGL(){
  try{
    if (typeof __SKAI_WEBGL_CACHE__ === 'string') return __SKAI_WEBGL_CACHE__;
    var c = document.createElement('canvas');
    var gl = c.getContext('webgl') || c.getContext('experimental-webgl');
    if (!gl) { __SKAI_WEBGL_CACHE__ = 'no'; return __SKAI_WEBGL_CACHE__; }
    var ext = gl.getExtension('WEBGL_debug_renderer_info');
    var ven = (ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL)   : gl.getParameter(gl.VENDOR))   || '';
    var ren = (ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : gl.getParameter(gl.RENDERER)) || '';
    var s = (ven + (ren ? ' / ' + ren : '')).trim();
    __SKAI_WEBGL_CACHE__ = s || 'yes';
    return __SKAI_WEBGL_CACHE__;
  } catch(_) { __SKAI_WEBGL_CACHE__ = 'no'; return __SKAI_WEBGL_CACHE__; }
}

function readTunedWindow(){
  var sv = window.SKAI_SERVER || {};
  // Prefer explicit windowSize; fall back to bestWindow; keep usedWindow for legacy
  var w = Number(sv && sv.windowSize) || Number(sv && sv.bestWindow) || Number(sv && sv.usedWindow);

  // CHG: ES5-safe finite check (Number.isFinite may not exist in older engines)
  return (isFinite(w) && w > 0) ? String(w) : 'N/A';
}

function render(){
var host = ensureTelemetryHost();
if (!host) return;

// clear safely
while (host.firstChild) host.removeChild(host.firstChild);

// Core runtime
host.appendChild(chip('TF.js',    readTFver()));
host.appendChild(chip('TF Ready', flag(readTFready())));
host.appendChild(chip('Backend',  readBackend()));
host.appendChild(chip('WebGL',    readWebGL()));
host.appendChild(chip('Strict',   flag(!!window.__SKAI_STRICT__)));

// Chain state
var tunedW    = readTunedWindow();
var mlRunning = !!(window.__SKAI_RUNNING__ || window.__SKAI_RUNNING);
var atDone    = !!(window.__SKAI_AUTOTUNE_DONE__ || (window.SKAI_SERVER && window.SKAI_SERVER.hasAutoTune));
var lastEp    = (typeof window.__SKAI_LAST_EPOCH__ === 'number') ? window.__SKAI_LAST_EPOCH__ : -1;

host.appendChild(chip('Auto-Tune',  flag(atDone)));
host.appendChild(chip('ML Running', flag(mlRunning)));
host.appendChild(chip('Epoch', (lastEp >= 0 ? String(lastEp) : 'N/A')));
host.appendChild(chip('Tuned W',    tunedW));

}

// expose + paint + refresh hooks
window.SKAI_refreshTelemetry = render;
try { render(); } catch(_){}

document.addEventListener('DOMContentLoaded', function(){
try { render(); } catch(_){}
}, { once:true });

window.addEventListener('skai:autotune:done', function(){
  window.__SKAI_AUTOTUNE_DONE__ = true;
  try { render(); } catch(_){}
});

// NEW: refresh when server payload is ready (tunedW, hasAutoTune, etc.)
window.addEventListener('skai:server:ready', function(){
  try { render(); } catch(_){}
});

window.addEventListener('skai:ml:start', function () {
  try { window.__SKAI_LAST_EPOCH__ = -1; } catch (e) {}
  try { render(); } catch (e) {}
});

window.addEventListener('skai:ml:epoch', function (ev) {
  var d = ev && ev.detail ? ev.detail : {};
  var e = (typeof d.epoch === 'number') ? d.epoch : -1;
  var T = (typeof d.totalEpochs === 'number' && d.totalEpochs > 0) ? d.totalEpochs : 0;
  if (T > 0 && e >= 0) {
    // Clamp to [1..T]
    if (e < 1) e = 1;
    if (e > T) e = T;
  }
  if (e >= 0) { try { window.__SKAI_LAST_EPOCH__ = e; } catch (err) {} }
  try { render(); } catch (err) {}
});

window.addEventListener('skai:ml:done', function(){
  try { render(); } catch(_){}
  try { if (typeof setLive === 'function') setLive(SKAI_msg('picksComputed')); } catch(_){}
});

// CHG: done-coordinator removed (was disabled and can cause syntax errors if comment markers drift).

window.addEventListener('skai:analysis-stop', function(){
try { render(); } catch(_){}
});
})(); // end IIFE started earlier
</script>

<script>
// SKAI confidence % + optional chart hook ? realtime, idempotent + fallbacks
;(function(){
  'use strict';
  var lastConfidencePct = null;

  function clamp01to100(x){
    var n = +x; if (!isFinite(n)) return 0;
    // accept 0..1 or 0..100
    if (n <= 1) n = n * 100;
    if (n < 0) n = 0; if (n > 100) n = 100;
    return Math.round(n);
  }

  function writeFallbackText(pct){
var pctText = (pct == null ? 'N/A' : (String(pct) + '%'));
    try{
      var rd = document.getElementById('ai-param-readout');
      if (rd){
        var txt = rd.textContent || '';
        
        if (/Confidence:\s*[^|]+/i.test(txt)){
          rd.textContent = txt.replace(/Confidence:\s*[^|]+/i, 'Confidence: ' + pctText);
        } else {
          rd.textContent = (txt ? txt + ' | ' : '') + 'Confidence: ' + pctText;
        }
      }
      var live = document.getElementById('ai-live-status');
      if (live){
        var lt = live.textContent || '';
        if (/Confidence:\s*[^|]+/i.test(lt)){
          live.textContent = lt.replace(/Confidence:\s*[^|]+/i, 'Confidence: ' + pctText);
        } else {
          live.textContent = (lt ? lt + ' | ' : '') + 'Confidence: ' + pctText;
        }
      }
    }catch(_){}
  }

  function updateConfidence(pct){
    try{
      lastConfidencePct = pct;
      var el = document.getElementById('confidencePct');
      if (el) el.textContent = String(pct) + '%';
      else writeFallbackText(pct);

      // CHG: Normalize gauge input to 0..1 (matches earlier skai:ml:metrics bridge).
      if (window.SKAI_CONF && typeof window.SKAI_CONF.update === 'function'){
        window.SKAI_CONF.update(pct / 100);
      }
    }catch(_){}
  }

  if (!window.__SKAI_CONF_WIRED__){
    window.__SKAI_CONF_WIRED__ = 1;

    // Initialize on start
    window.addEventListener('skai:ml:start', function(){
      lastConfidencePct = null;
      writeFallbackText(null);
    });

    // Stream updates
    window.addEventListener('skai:ml:metrics', function(ev){
      try{
        var d = ev && ev.detail ? ev.detail : {};
        if (d && (d.confidence != null)) {
          updateConfidence(clamp01to100(d.confidence));
        }
      }catch(_){}
    });

      // Pin final value (don't erase if none came through)
    window.addEventListener('skai:done', function(){
      // CHG: Do not fabricate 100% confidence if no metrics were emitted.
      // Keep N/A (or last known) so UI remains truthful.
      writeFallbackText(lastConfidencePct);
    });
  }
})();
</script>

<script>
;(function(){
  'use strict';

  // Keep AI extra empty until ML writes results.
  try {
    var aiExtraHost = document.getElementById('aiExtraPredictionContainer');
    if (aiExtraHost && aiExtraHost.children.length === 0) {
      aiExtraHost.innerHTML = '';
    }
    var sum = document.getElementById('aiPredictionSummary');
    if (sum && /Waiting|compute|Start AI/i.test((sum.textContent || ''))) {
      // UX: clearer, friendly standby message instead of a question
      sum.textContent = 'SKAI is standing by. Run a prediction to see your AI summary here.';
    }
  } catch (e) {}
})();
</script>

<script>
;(function(){
  'use strict';

  // Run once the DOM is ready
  function ready(fn){
    if (document.readyState !== 'loading') return fn();
    document.addEventListener('DOMContentLoaded', fn, { once:true });
  }

  ready(function(){
    var btn = document.getElementById('btnCopyAiBoth');
    if (!btn) return;

    // Avoid double-wiring
    if (btn.dataset.wired === '1') return;
    btn.dataset.wired = '1';

    function pad2(v){
      var n = parseInt(String(v).replace(/\D/g,''), 10);

      // CHG: ES5-safe (Number.isFinite may not exist).
      if (!isFinite(n)) return '';

      return (n < 10 ? '0' : '') + n;
    }

    function texts(selector){
      return Array.prototype.map.call(
        document.querySelectorAll(selector),
        function(n){ return (n.textContent || '').replace(/\s+/g,'').trim(); }
      ).filter(Boolean);
    }

    btn.addEventListener('click', function(){
      // Collect from both possible mains hosts
      var mains  = texts('.skai-ai-main .nball, #aiPredictedNumbers .nball').map(pad2).filter(Boolean); // CHG: drop blanks
      // Collect from both possible extra hosts
      var extras = texts('#aiExtraPredictionContainer .xball').map(pad2).filter(Boolean);                // CHG: drop blanks

      if (!mains.length && !extras.length) {
        // Nothing to copy yet
        try {
          var live0 = document.getElementById('ai-live-status');
if (live0) live0.textContent = 'Nothing to copy yet - run AI first.';
        } catch(_) {}
        return;
      }

      var parts = [];
      if (mains.length)  parts.push('Main: '  + mains.join(' '));
      if (extras.length) parts.push('Extra: ' + extras.join(' '));
        var line = 'SKAI picks - ' + parts.join('  |  ');

      function notifyCopied(){
        try {
          var live = document.getElementById('ai-live-status');
          if (live) live.textContent = 'Copied picks to clipboard.';
        } catch(_) {}
      }

      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(line).then(notifyCopied).catch(function(){
          // Last-resort fallback (no positive confirmation message here)
          window.prompt('Copy picks:', line);
        });
      } else {
        // Environments without Clipboard API (no positive confirmation message here)
        window.prompt('Copy picks:', line);
      }
    });
  });
})();
</script>

<script>
/* =========================
   Section 1: Core shims & flags
   - SKAI_msg fallback
   - SKAI_emit polyfill
   - Server/client flags
   ========================= */
(function(){
  'use strict';

// --- SKAI_msg fallback (must exist before any use) ---
(function () {
  if (typeof window.SKAI_msg !== 'function') {
    // CHG: ES5-safe declaration (avoid const in Joomla module contexts).
    var DICT = {
      ready:         'Ready',
      trainingMain:  'Training...',
      finalizing:    'Finalizing...',
      picksComputed: 'Picks ready',
      readyPicks:    'Picks ready',
      error:         'Error'
    };

    window.SKAI_msg = function (key) {
      return (key && DICT[key]) ? DICT[key] : String(key || '');
    };
  }

})();

  /* SKAI_emit polyfill (dispatches CustomEvent if SKAI_emit isn't defined) */
  if (typeof window.SKAI_emit !== 'function') {
    window.SKAI_emit = function(name, payload){
      try {
        var type = String(name || '');
        // Normalize payload: if no `detail` provided, treat the value as the detail
        var hasDetail = payload && Object.prototype.hasOwnProperty.call(payload, 'detail');
        var detail = hasDetail ? payload.detail : payload;
        var opts = { detail: detail, bubbles: true, composed: true };

        var evt;
        try {
          evt = new CustomEvent(type, opts);
        } catch (e) {
          // Older browsers: CustomEvent polyfill via initCustomEvent
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(type, true, false, detail);
        }
        window.dispatchEvent(evt);
      } catch (_) {}
    };
  }

  /* Server state ? client flags */
  // CHG: ES5-safe shallow clone (Object.assign may not exist).
  var __baseSV = window.SKAI_SERVER || {};
  var SV = {};
  for (var __k in __baseSV) {
    if (Object.prototype.hasOwnProperty.call(__baseSV, __k)) {
      SV[__k] = __baseSV[__k];
    }
  }
  window.SKAI_SERVER = SV;
  if (typeof window.SKAI_AUTOTUNE_REQUIRED === 'undefined') window.SKAI_AUTOTUNE_REQUIRED = true;
  window.SKAI_AUTOTUNE_DONE = false;

  /* Mirror underscored flags used elsewhere */
  if (typeof window.__SKAI_AUTOTUNE_REQUIRED__ === 'undefined') window.__SKAI_AUTOTUNE_REQUIRED__ = window.SKAI_AUTOTUNE_REQUIRED;
  try { window.__SKAI_AUTOTUNE_DONE__ = window.SKAI_AUTOTUNE_DONE; } catch(_) {}
  if (typeof window.SKAI_STRICT === 'undefined') {
    window.SKAI_STRICT = false; // default non-strict unless set earlier
  }
  try { window.__SKAI_STRICT__ = !!window.SKAI_STRICT; } catch(_){}

  (function reflectAutoTune(){
    var bestW = +SV.bestWindow || 0, usedW = +SV.usedWindow || 0, tunedW = bestW || usedW || 0;
    SV.hasAutoTune = tunedW > 0;
    if (tunedW > 0) {
      // Store for later, but DO NOT broadcast a result event on load.
      window.SKAI_TUNED_PARAMS = window.SKAI_TUNED_PARAMS || { windowSize: tunedW };
    }
  })();
})();
</script>

<script>
/* =========================
   Section 2: Small page helpers
   - local time label
   - disable validators
   - remove GET-form listeners once
   ========================= */
(function(){
  'use strict';
  var lt = document.getElementById('local-time-label');
  if (lt){
    var now = new Date();
    lt.textContent = now.toLocaleString(undefined,{ year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit' });
  }
  // disable weight validators & drop GET-form listeners once
  window.validateMain = function(){ return true; };
  window.validatePB = function(){ return true; };
  var f = document.querySelector('form[method="get"]');
  if (f){ var c = f.cloneNode(true); f.parentNode.replaceChild(c,f); }
})();
</script>

<script>
/* =========================
   Section 3: TensorFlow loader & backend chooser
   - ensureTF (singleton)
   - preload
   - SKAI_chooseBackend
   ========================= */
(function(){
  'use strict';

  // TF loader (singleton) + preload
  window.ensureTF = window.ensureTF || function ensureTF(){
    // CHG: Strict-scope safe access - use window.tf consistently.
    if (window.tf && typeof window.tf.ready === 'function') return window.tf.ready();
    return new Promise(function(resolve, reject){
      var existing = document.getElementById('tfjs-script') || document.getElementById('tfjs-script-local'); // FIX: check both ids
      if (existing){
        (window.tf && window.tf.ready ? window.tf.ready() : Promise.resolve()).then(resolve).catch(reject);
        return;
      }
      // Prefer local first (security), then CDN as fallback
      var local = document.createElement('script');
      local.id = 'tfjs-script-local';
      local.src = '/assets/tfjs/tf.min.js';
      local.async = true;
      local.onload = function(){ (window.tf && window.tf.ready ? window.tf.ready() : Promise.resolve()).then(resolve).catch(reject); };
      local.onerror = function(){
        var s = document.createElement('script');
        s.id = 'tfjs-script';
        s.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.22.0/dist/tf.min.js';
        s.async = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
        s.onload = function(){ (window.tf && window.tf.ready ? window.tf.ready() : Promise.resolve()).then(resolve).catch(reject); };
        s.onerror = function(){ reject(new Error('Failed to load TensorFlow.js')); };
        document.head.appendChild(s);
      };
      document.head.appendChild(local);
    });
  };

  (function preloadTF(){
    function go(){
      if (typeof window.ensureTF === 'function'){
        window.ensureTF()
          .then(function(){ try { window.SKAI_refreshTelemetry && window.SKAI_refreshTelemetry(); } catch(_){ } })
          .catch(function(){});
      }
    }
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', go, { once:true });
    else go();
  })();

  // Choose TF backend (safe in async code via await; or use .then in non-async)
  window.SKAI_chooseBackend = window.SKAI_chooseBackend || function SKAI_chooseBackend(){
    // CHG: Strict-scope safe access - use window.tf consistently.
    var tfw = window.tf;
    if (!tfw || typeof tfw.setBackend !== 'function') {
      return Promise.resolve(); // nothing to do
    }
    return tfw.setBackend('webgl')
      .then(function(){ return tfw.ready(); })
      .then(function(){
        try { if (tfw.env) tfw.env().set('WEBGL_CPU_FORWARD', false); } catch(_){}
      })
      .catch(function(){
        return tfw.setBackend('cpu')
          .then(function(){ return tfw.ready(); })
          .catch(function(){ throw new Error('No TF backend available'); });
      });
  };
})();
</script>

<script>
/* =========================
   Section 4: Feature builders & datasets
   - helpers (toInt, norm)
   - makeFeatureVector + SH score
   - buildSkaiDataset / CurrentVector
   - Extra ball variants
   ========================= */
(function(){
  'use strict';

  // CHG: ES5-safe helpers (no const/let/Number.isFinite/Math.trunc).
  function toInt(n){
    var v = Number(n);
    if (!isFinite(v)) { return NaN; }
    // trunc equivalent for ES5
    return (v < 0) ? Math.ceil(v) : Math.floor(v);
  }
  function norm(arr, div){
    var d = Math.max(1, div);
    var out = new Array(arr.length);
    for (var i = 0; i < arr.length; i++) {
      out[i] = arr[i] / d;
    }
    return out;
  }

  // phpDesigner8/legacy-safe accessors (replace optional chaining)
  function numsOf(row){
    var n = row && row.numbers;
    return Array.isArray(n) ? n : [];
  }
  function numOf(row){
    var v = row && row.number;
    var n = Number(v);
    // CHG: ES5-safe finite check (Number.isFinite may not exist).
    return isFinite(n) ? n : NaN;
  }

  // CHG: ES5-safe computeShScore (no const/let/fill/map/arrow).
  function computeShScore(start, end, domain, allowZero, ew, c1, c2, c3, last){
    // Build a normalized Skip & Hit score in [0,1] per number.
    var dom = (ew && ew.length) ? (ew.length|0) : 0;
    var gapCap = Math.min(50, Math.max(1, end - start));
    var gap = new Array(dom);
    var i;

    for (i = 0; i < dom; i++) {
      gap[i] = gapCap;
    }
    for (i = 0; i < dom; i++) {
      gap[i] = (last[i] === -1) ? gapCap : Math.min(gapCap, (end - 1) - last[i]);
    }

    var gapScore = new Array(dom);
    // CHG: make gapScore increase with gap (overdue numbers) instead of favoring recent hits
    for (i = 0; i < dom; i++) {
      gapScore[i] = (gapCap > 0) ? (gap[i] / gapCap) : 0;
    }

    // weighted combo (weights can be tuned later or surfaced from server)
    var wf = 0.50, w1 = 0.20, w2 = 0.15, w3 = 0.15, wg = 0.35;

    // normalize helpers (safe if flat)
    function norm1(v){
      var mx = 0, j;
      for (j = 0; j < v.length; j++) {
        if (v[j] > mx) mx = v[j];
      }
      if (mx <= 0) {
        var z = new Array(v.length);
        for (j = 0; j < v.length; j++) z[j] = 0;
        return z;
      }
      var out = new Array(v.length);
      for (j = 0; j < v.length; j++) out[j] = v[j] / mx;
      return out;
    }

    var fN  = norm1(ew);
    var c1N = norm1(c1);
    var c2N = norm1(c2);
    var c3N = norm1(c3);

    // combine
    var s = new Array(dom);
    for (i = 0; i < dom; i++) {
      var rec = w1 * c1N[i] + w2 * c2N[i] + w3 * c3N[i];
      s[i] = wf * fN[i] + wg * gapScore[i] + (1 - wf - wg) * rec;
    }

    // final normalize to [0,1]
    return norm1(s);
  }

  // CHG: ES5-safe makeFeatureVector (no const/let/arrow/fill).
  function makeFeatureVector(start, end, domain, allowZero, decay, alpha, getVals, addSH){
    var len = end - start;
    var dom = allowZero ? (domain + 1) : domain;

    var ew = new Array(dom), c1 = new Array(dom), c2 = new Array(dom), c3 = new Array(dom), last = new Array(dom);
    var i, j, k, m;

    for (i = 0; i < dom; i++) {
      ew[i] = 0; c1[i] = 0; c2[i] = 0; c3[i] = 0; last[i] = -1;
    }

    var b1 = Math.min(5, len), b2 = Math.min(15, len), b3 = Math.min(50, len);

    function valid(v){
      return isFinite(v) && (allowZero ? (v >= 0 && v <= domain) : (v >= 1 && v <= domain));
    }
    function idx(v){
      return allowZero ? v : (v - 1);
    }

    for (j = start; j < end; j++) {
      for (m = 0; m < dom; m++) { ew[m] *= decay; }

      var values = getVals(j) || [];
      for (k = 0; k < values.length; k++) {
        var v = toInt(values[k]);
        if (!valid(v)) continue;

        var id = idx(v);
        if (id < 0 || id >= dom) continue;

        ew[id] += alpha;

        var age = (end - 1) - j;
        if (age <= (b1 - 1)) c1[id]++;
        if (age <= (b2 - 1)) c2[id]++;
        if (age <= (b3 - 1)) c3[id]++;

        last[id] = j;
      }
    }

    var gapCap = Math.min(50, len);
    var gap = new Array(dom);
    for (i = 0; i < dom; i++) gap[i] = gapCap;
    for (i = 0; i < dom; i++) {
      gap[i] = (last[i] === -1) ? gapCap : Math.min(gapCap, (end - 1) - last[i]);
    }

    var baseVec = [].concat(
      ew,
      norm(c1, Math.max(1, b1)),
      norm(c2, Math.max(1, b2)),
      norm(c3, Math.max(1, b3)),
      norm(gap, Math.max(1, gapCap))
    );

    if (addSH === true) {
      var sh = computeShScore(start, end, domain, allowZero, ew, c1, c2, c3, last);
      return baseVec.concat(sh);
    }
    return baseVec;
  }

  window.skaiToInt = window.skaiToInt || toInt;
  window.makeSkaiFeatureVector = window.makeSkaiFeatureVector || makeFeatureVector;

  // CHG: Thompson Sampling helpers (ES5-safe)
  // Beta(a,b) via Gamma(a,1), Gamma(b,1) using Marsaglia–Tsang.
  window.skaiRandn = window.skaiRandn || function(){
    // Box–Muller
    var u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
  };

  window.skaiSampleGamma = window.skaiSampleGamma || function(k){
    // Gamma(k,1), k>0
    if (!(k > 0)) return 0;

    // Boost for k < 1 using Gamma(k) = Gamma(k+1) * U^(1/k)
    if (k < 1){
      var u = Math.random();
      return window.skaiSampleGamma(k + 1) * Math.pow(u, 1 / k);
    }

    // Marsaglia–Tsang for k >= 1
    var d = k - 1/3;
    var c = 1 / Math.sqrt(9 * d);

    while (true){
      var x = window.skaiRandn();
      var v = 1 + c * x;
      if (v <= 0) continue;
      v = v * v * v;

      var u2 = Math.random();
      // Squeeze
      if (u2 < 1 - 0.0331 * x * x * x * x) return d * v;

      // Log acceptance
      if (Math.log(u2) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v;
    }
  };

  window.skaiSampleBeta = window.skaiSampleBeta || function(a, b){
    if (!(a > 0) || !(b > 0)) return 0.5;
    var ga = window.skaiSampleGamma(a);
    var gb = window.skaiSampleGamma(b);
    var s = ga + gb;
    if (!(s > 0)) return 0.5;
    return ga / s;
  };

  // CHG: Backtest metrics helpers (ES5-safe)
  window.skaiClamp01 = window.skaiClamp01 || function(x){
    if (!isFinite(x)) return 0;
    if (x < 0) return 0;
    if (x > 1) return 1;
    return x;
  };

  window.skaiLogLoss = window.skaiLogLoss || function(p, y){
    var eps = 1e-12;
    p = window.skaiClamp01(p);
    if (p < eps) p = eps;
    if (p > 1 - eps) p = 1 - eps;
    return -(y ? Math.log(p) : Math.log(1 - p));
  };

  window.skaiBrier = window.skaiBrier || function(p, y){
    p = window.skaiClamp01(p);
    var d = p - (y ? 1 : 0);
    return d * d;
  };

    window.skaiTopKHits = window.skaiTopKHits || function(topNums, winNums){
    var set = {};
    for (var i=0;i<topNums.length;i++){ set[String(topNums[i])] = 1; }
    var hits = 0;
    for (var j=0;j<winNums.length;j++){
      if (set[String(winNums[j])]) hits++;
    }
    return hits;
  };

  // CHG: Calibration binning helper (ES5-safe)
  // Returns reliability stats: for each probability bin, compare avg predicted p to empirical hit rate.
  window.skaiCalibBins = window.skaiCalibBins || function(binCount){
    binCount = (binCount != null) ? (binCount|0) : 10;
    if (binCount < 5) binCount = 5;
    if (binCount > 50) binCount = 50;

    var bins = [];
    for (var i=0;i<binCount;i++){
      bins.push({ n:0, sumP:0, sumY:0, lo:i/binCount, hi:(i+1)/binCount });
    }
    return {
      bins: bins,
      add: function(p, y){
        p = window.skaiClamp01(p);
        var b = Math.floor(p * binCount);
        if (b < 0) b = 0;
        if (b >= binCount) b = binCount - 1;
        var bb = bins[b];
        bb.n += 1;
        bb.sumP += p;
        bb.sumY += (y ? 1 : 0);
      },
      summary: function(){
        var out = [];
        for (var k=0;k<bins.length;k++){
          var bb = bins[k];
          var avgP = (bb.n > 0) ? (bb.sumP / bb.n) : 0;
          var hitR = (bb.n > 0) ? (bb.sumY / bb.n) : 0;
          out.push({ bin:k, n:bb.n, lo:bb.lo, hi:bb.hi, avgP:avgP, hitRate:hitR, gap:(hitR-avgP) });
        }
        return out;
      }
    };
  };

  // CHG: ES5-safe buildSkaiDataset (no const/let/fill/map).

  // CHG: ES5-safe buildSkaiDataset (no const/let/fill/map).
  window.buildSkaiDataset = window.buildSkaiDataset || function(draws, settings){
    draws = Array.isArray(draws) ? draws : [];
    settings = settings || {};

    // === LAYER 1 & 2: Instrument data preparation phase ===
    try {
      if (window.SKAI_RUNTIME_STATS) {
        window.SKAI_RUNTIME_STATS.setPhase('Preparing historical data', 'Loading draw history');
        window.SKAI_RUNTIME_STATS.totalDraws = draws.length;
      }
    } catch(_) {}

    var meta = window.SKAI_META || {};
    var domain = (+meta.domain > 0) ? (+meta.domain) : 70;
    var pick = (+meta.pick > 0)
      ? (+meta.pick)
      : (Array.isArray(draws[0] && draws[0].numbers) ? draws[0].numbers.length : 5);

    var allowZero = (typeof meta.allowZero === 'boolean')
      ? (meta.allowZero && !meta.hasExtraBall)
      : ((domain <= 9) && !meta.hasExtraBall);

    var hist = draws.length | 0;

    var W = +settings.windowSize;
    if (!isFinite(W) || W <= 0) W = Math.max(5, Math.max(1, hist - 1)); // default: entire DB for supervised samples
    W = Math.max(5, Math.min((W|0), Math.max(1, hist - 1)));

    var decay = +settings.recencyDecay;
    if (!isFinite(decay)) decay = 0.9;
    decay = Math.max(0, Math.min(1, decay));
    var alpha = Math.max(0.01, 1 - Math.min(0.999, decay));

    if (hist < 6 || W < 5) {
      return { xs:[], ys:[], inputDim:0, domain:(allowZero ? domain+1 : domain) };
    }

    var dom = allowZero ? (domain + 1) : domain;
    if (!isFinite(dom) || dom <= 0) return { xs:[], ys:[], inputDim:0, domain:0 };

    // === LAYER 1 & 2: Update phase detail with window info ===
    try {
      if (window.SKAI_RUNTIME_STATS) {
        window.SKAI_RUNTIME_STATS.setPhase('Building training samples', 'Window size: ' + W + ' draws');
        window.SKAI_RUNTIME_STATS.totalWindows = hist - W;
      }
    } catch(_) {}

    var xs = [], ys = [];
    for (var i = W; i < hist; i++){
      // === LAYER 2: Count window evaluations and comparisons ===
      try {
        if (window.SKAI_RUNTIME_STATS && i % 10 === 0) { // Batch updates every 10 iterations
          window.SKAI_RUNTIME_STATS.incrementWindows(10);
          window.SKAI_RUNTIME_STATS.incrementDraws(10);
          // Estimate pairwise comparisons: W draws × pick numbers = W * pick comparisons per window
          window.SKAI_RUNTIME_STATS.incrementComparisons(W * pick * 10);
          // Operations: feature extraction for each draw in window
          window.SKAI_RUNTIME_STATS.incrementOperations(W * dom * 10);
        }
      } catch(_) {}

      var addSH = !!settings.addSHFeature;

      xs.push(
        makeFeatureVector(
          i - W, i, domain, allowZero, decay, alpha,
          function(j){ return numsOf(draws[j]).slice(0, pick); },
          addSH
        )
      );

      var next = numsOf(draws[i]) || [];
      var up = Math.min(next.length, pick);

      // Digit game: digits 0..9, allowZero true, no extra ball, pick 2..6
      var isDigitGame =
        (domain > 0 && domain <= 9) &&
        !!allowZero &&
        !(meta && meta.hasExtraBall) &&
        pick >= 2 && pick <= 6;

      // -----------------------------
      // Build ONE target vector (yOut)
      // -----------------------------
      var yOut = null;

      if (isDigitGame) {
        // Pick×10 position-labeled one-hot
        var posDom = 10;
        var outDimPos = pick * posDom;

        var yPos = new Array(outDimPos);
        for (var z0 = 0; z0 < outDimPos; z0++) yPos[z0] = 0;

        for (var k = 0; k < up; k++){
          var dv = toInt(next[k]);
          if (!isFinite(dv) || dv < 0 || dv > 9) continue;
          yPos[(k * posDom) + dv] = 1;
        }

        yOut = yPos;

      } else {
        // Legacy multi-label set target
        var y = new Array(dom);
        for (var t0 = 0; t0 < dom; t0++) y[t0] = 0;

        for (var k2 = 0; k2 < up; k2++){
          var v = toInt(next[k2]);
          var id = allowZero ? v : (v - 1);
          if (isFinite(v) && id >= 0 && id < dom) y[id] = 1;
        }

        yOut = y;
      }

      // ------------------------------------------------------------
      // Distillation (optional, shape-correct)
      //
      // Legacy: distill into yOut (dom)
      // Digit: per-head distill into yOut (Pick×10) using SH teacher (dom==10)
      // ------------------------------------------------------------
      var epsBase = Number(settings.distillEps);
      if (!isFinite(epsBase)) epsBase = 0.05;

      // Light adaptive epsilon (stability when data is scarce)
      var N = i;
      var eps = 0;
      if (N < 150) eps = 0;
      else if (N < 400) eps = epsBase;
      else if (N < 900) eps = epsBase * 0.7;
      else eps = epsBase * 0.4;

      eps = Math.max(0, Math.min(0.20, eps));

      if (eps > 0) {
        // Teacher from SH slice in domain space
        var fv = makeFeatureVector(
          i - W, i, domain, allowZero, decay, alpha,
          function(j){ return numsOf(draws[j]).slice(0, pick); },
          true
        );
        var sh = fv.slice(fv.length - dom); // SH slice length = dom

        // Normalize teacher to sum=1 (more stable than max-normalize)
        var shSum = 0;
        for (var a0 = 0; a0 < dom; a0++){
          var sv = +sh[a0];
          if (!isFinite(sv) || sv < 0) sv = 0;
          sh[a0] = sv;
          shSum += sv;
        }
        if (shSum > 0) {
          for (var a1 = 0; a1 < dom; a1++) sh[a1] /= shSum;
        }

        if (isDigitGame) {
          // Per-head distillation: apply same 10-way teacher to each head slice
          var posDom2 = 10;
          var outDimPos2 = pick * posDom2;

          if (dom === posDom2 && yOut && yOut.length === outDimPos2) {
            for (var p0 = 0; p0 < pick; p0++){
              var base = p0 * posDom2;

              // distill head
              for (var d0 = 0; d0 < posDom2; d0++){
                yOut[base + d0] = (1 - eps) * yOut[base + d0] + eps * sh[d0];
              }

              // renorm head
              var sH = 0;
              for (var d1 = 0; d1 < posDom2; d1++) sH += yOut[base + d1];
              if (sH > 0) {
                for (var d2 = 0; d2 < posDom2; d2++) yOut[base + d2] /= sH;
              } else {
                for (var d3 = 0; d3 < posDom2; d3++) yOut[base + d3] = 1 / posDom2;
              }
            }
          }
        } else {
          // Legacy distillation into yOut (dom)
          if (yOut && yOut.length === dom) {
            for (var t4 = 0; t4 < dom; t4++) yOut[t4] = (1 - eps) * yOut[t4] + eps * sh[t4];

            var ssum = 0;
            for (var t5 = 0; t5 < dom; t5++) ssum += yOut[t5];
            if (ssum > 0){
              for (var t6 = 0; t6 < dom; t6++) yOut[t6] /= ssum;
            }
          }
        }
      }

      // Push EXACTLY ONCE per training sample
      ys.push(yOut);

    }

    var inputDim = xs.length ? xs[0].length : 0;

    // Expose correct output domain
    var isDigitGame2 =
      (domain > 0 && domain <= 9) &&
      !!allowZero &&
      !(meta && meta.hasExtraBall) &&
      pick >= 2 && pick <= 6;

    var outDomain = isDigitGame2 ? (pick * 10) : dom;

    // === LAYER 3: Complete data preparation phase ===
    try {
      if (window.SKAI_RUNTIME_STATS) {
        var samples = xs.length;
        var totalComps = samples * W * pick; // Approximate total comparisons
        window.SKAI_RUNTIME_STATS.completePhase({
          phase: 'Data preparation',
          processed: hist,
          relationships: totalComps,
          change: 'Generated ' + samples + ' training samples from ' + hist + ' draws',
          metrics: { samples: samples, windowSize: W }
        });
      }
    } catch(_) {}

    return {
      xs: xs,
      ys: ys,
      inputDim: inputDim,
      domain: outDomain,
      posHeads: (isDigitGame2 ? pick : 0),
      posDom: (isDigitGame2 ? 10 : 0),
      isPosModel: !!isDigitGame2
    };
  };


  // CHG: ES5-safe buildSkaiCurrentVector with gap-conditioned Skip & Hit prior.
  window.buildSkaiCurrentVector = window.buildSkaiCurrentVector || function(draws, settings){
    draws = Array.isArray(draws) ? draws : [];
    settings = settings || {};

    var meta = window.SKAI_META || {};
    var domain = (+meta.domain > 0) ? (+meta.domain) : 70;
    var pick = (+meta.pick > 0)
      ? (+meta.pick)
      : (Array.isArray(draws[0] && draws[0].numbers) ? draws[0].numbers.length : 5);

    var allowZero = (typeof meta.allowZero === 'boolean')
      ? (meta.allowZero && !meta.hasExtraBall)
      : ((domain <= 9) && !meta.hasExtraBall);

    var hist = draws.length | 0;

    var W = +settings.windowSize;
    if (!isFinite(W) || W <= 0) W = Math.max(5, Math.max(1, hist - 1)); // default: entire DB for the live vector
    W = Math.max(5, Math.min((W|0), Math.max(1, hist - 1)));

    var decay = +settings.recencyDecay;
    if (!isFinite(decay)) decay = 0.9;
    decay = Math.max(0, Math.min(1, decay));
    var alpha = Math.max(0.01, 1 - Math.min(0.999, decay));

    var start = Math.max(0, hist - W), end = hist;

    var addSH = !!settings.addSHFeature;
    var x = makeFeatureVector(
      start, end, domain, allowZero, decay, alpha,
      function(j){ return numsOf(draws[j]).slice(0, pick); },
      addSH
    );

    var dom = allowZero ? (domain + 1) : domain;
    if (!isFinite(dom) || dom <= 0) return { x: x, skipPrior: [] };

// CHG: Bayesian + recency-weighted Skip/Hit prior with bounded skip-bias (learning-safe).
    var lastHit = new Array(dom);
    var totalHits = new Array(dom);    // recency-weighted total hits per number
    var gapHits = new Array(dom);      // recency-weighted gap->hits map per number
    var i0, j0, k0;

    for (i0 = 0; i0 < dom; i0++){
      lastHit[i0] = -1;
      totalHits[i0] = 0;
      gapHits[i0] = {};
    }

    // Controls (ES5-safe)
    // - laplaceK: Bayesian smoothing strength (acts like pseudo-trials)
    // - skipGamma: how strongly skip influences selection (bounded; should be small)
    var laplaceK = (settings && settings.laplaceK != null) ? Number(settings.laplaceK) : NaN;
    if (!isFinite(laplaceK)) { laplaceK = 1; }
    if (laplaceK < 0) { laplaceK = 0; }
    if (laplaceK > 10) { laplaceK = 10; }

    var skipGamma = (settings && settings.skipGamma != null) ? Number(settings.skipGamma) : NaN;
    if (!isFinite(skipGamma)) { skipGamma = 0.20; }
    if (skipGamma < 0) { skipGamma = 0; }
    if (skipGamma > 1) { skipGamma = 1; }

    // Walk history and collect recency-weighted gap stats per number.
    // Weighting uses the same decay knob as the rest of SKAI: recent draws count more.
    for (j0 = start; j0 < end; j0++){
      var numsJ = numsOf(draws[j0]) || [];
      var upJ = Math.min(numsJ.length, pick);

      // recency weight: newest ~1, older -> smaller
      var age = (end - 1) - j0;
      if (age < 0) { age = 0; }
      var wRec = Math.pow(decay, age);

      for (k0 = 0; k0 < upJ; k0++){
        var vJ = toInt(numsJ[k0]);
        var idJ = allowZero ? vJ : (vJ - 1);
        if (!isFinite(vJ) || idJ < 0 || idJ >= dom) {
          continue;
        }

        if (lastHit[idJ] !== -1){
          var g = j0 - lastHit[idJ] - 1;
          if (g < 0) { g = 0; }
          if (!gapHits[idJ][g]) { gapHits[idJ][g] = 0; }
          gapHits[idJ][g] += wRec; // recency-weighted "hit with gap = g"
        }

        totalHits[idJ] += wRec;     // recency-weighted hit evidence
        lastHit[idJ] = j0;
      }
    }

    var maxGap = Math.max(1, end - start);
    var prior = new Array(dom);

    // First pass: compute each number's current gap and track gap distribution
    var gapsNow = new Array(dom);
    var sumGap = 0;
    for (var c0 = 0; c0 < dom; c0++){
      var currentGap;
      if (lastHit[c0] === -1){
        currentGap = maxGap;
      } else {
        currentGap = (end - 1) - lastHit[c0];
        if (currentGap < 0) { currentGap = 0; }
        if (currentGap > maxGap) { currentGap = maxGap; }
      }
      gapsNow[c0] = currentGap;
      sumGap += currentGap;
    }

    var meanGap = (dom > 0) ? (sumGap / dom) : 0;
    var varGap = 0;
    for (var c1 = 0; c1 < dom; c1++){
      var dG = gapsNow[c1] - meanGap;
      varGap += dG * dG;
    }
    var sdGap = (dom > 1) ? Math.sqrt(varGap / (dom - 1)) : 1;
    if (!isFinite(sdGap) || sdGap <= 1e-9) { sdGap = 1; }

    // Second pass: Bayesian-smoothed gap-likelihood * bounded skip-bias
    var maxScore = 0;
    for (var c = 0; c < dom; c++){
      var gNow = gapsNow[c];

      // Bayesian-smoothed estimate of "hit occurs at this gap" for this number.
      // IMPORTANT: gaps form a multinomial bucketization, so smoothing must be Dirichlet-like over buckets.
      var hitsAtGap = (gapHits[c] && gapHits[c][gNow]) ? gapHits[c][gNow] : 0;
      var totalForNumber = totalHits[c] || 0;

      // Effective number of gap buckets (cap to prevent sparse-tail instability).
      // This controls how much smoothing mass is distributed across the gap-support.
      var G = Math.max(5, Math.min(60, maxGap|0));

      // Dirichlet/Laplace smoothing over G buckets:
      //   pGap ≈ (hitsAtGap + K) / (totalHits + K*G)
      // K is laplaceK; higher K = more conservative (less overfitting to rare exact gaps).
      var pGap = 0;
      if (totalForNumber > 0 || laplaceK > 0){
        pGap = (hitsAtGap + laplaceK) / (totalForNumber + (laplaceK * G));
      }

      // Skip-based *selection bias* (bounded), NOT a probability claim:
      // favors under/over-represented gaps only mildly to improve coverage stability.
      var z = (gNow - meanGap) / sdGap;
      var bias = Math.exp(skipGamma * Math.tanh(z)); // bounded influence

      // CHG: Temper pGap so skip-bias cannot dominate when evidence is sparse.
      var tau = (settings && settings.priorTemp != null) ? Number(settings.priorTemp) : NaN;
      if (!isFinite(tau)) { tau = 0.80; }
      if (tau < 0.60) { tau = 0.60; }
      if (tau > 1.00) { tau = 1.00; }

      var score = Math.pow(pGap, tau) * bias;

      prior[c] = score;

      if (score > maxScore) { maxScore = score; }
    }

    // Normalize to [0,1]
    if (maxScore > 0){
      for (var q = 0; q < dom; q++){
        prior[q] = prior[q] / maxScore;
      }
    } else {
      for (var q2 = 0; q2 < dom; q2++){
        prior[q2] = 0;
      }
    }

     // CHG: Beta posterior params for Thompson Sampling (history-learning)
    // hits = totalHits[c], trials = (end-start). Use alpha0/beta0 as priors.
    var alpha0 = (settings && settings.posteriorAlpha0 != null) ? Number(settings.posteriorAlpha0) : NaN;
    var beta0  = (settings && settings.posteriorBeta0  != null) ? Number(settings.posteriorBeta0)  : NaN;
    if (!isFinite(alpha0) || alpha0 <= 0) alpha0 = 1;
    if (!isFinite(beta0)  || beta0  <= 0) beta0  = 1;

    // CHG: Effective weighted trials consistent with recency-weighted hits
    // totalHits[] is accumulated using wRec = decay^age, so trials must be the same weighting:
    // Teff = sum_{age=0..N-1} decay^age
    var N = (end - start);
    if (!isFinite(N) || N < 1) N = 1;

    var effTrials = N;
    if (isFinite(decay) && decay > 0 && decay !== 1){
      effTrials = (1 - Math.pow(decay, N)) / (1 - decay);
    }
    if (!isFinite(effTrials) || effTrials <= 0) effTrials = N;

    var postA = new Array(dom);
    var postB = new Array(dom);
    for (var pc = 0; pc < dom; pc++){
      var h = totalHits[pc] || 0;          // recency-weighted hit count
      var m = effTrials - h;              // recency-weighted miss count
      if (m < 0) m = 0;
      postA[pc] = alpha0 + h;
      postB[pc] = beta0  + m;
    }

    return { x: x, skipPrior: prior, postA: postA, postB: postB };


  };

  // CHG: ES5-safe buildSkaiExtraDataset.
  window.buildSkaiExtraDataset = window.buildSkaiExtraDataset || function(extraDraws, settings){
    extraDraws = Array.isArray(extraDraws) ? extraDraws : [];
    settings = settings || {};

    var meta = window.SKAI_META || {};
    var domain = (+meta.extraDomain > 0) ? (+meta.extraDomain) : 26;
    var allowZero = (meta && meta.forceOneBasedExtra) ? false : (domain <= 9);

    var hist = extraDraws.length | 0;

    var W = +settings.windowSize;
    if (!isFinite(W) || W <= 0) W = Math.max(5, Math.max(1, hist - 1)); // default: entire DB for supervised samples
    W = Math.max(5, Math.min((W|0), Math.max(1, hist - 1)));

    var decay = +settings.recencyDecay;
    if (!isFinite(decay)) decay = 0.9;
    decay = Math.max(0, Math.min(1, decay));
    var alpha = Math.max(0.01, 1 - Math.min(0.999, decay));

    if (hist < 6 || W < 5) {
      return { xs:[], ys:[], inputDim:0, domain:(allowZero ? domain+1 : domain) };
    }

    var dom = allowZero ? (domain + 1) : domain;
    var xs = [], ys = [];

    for (var i = W; i < hist; i++){
      xs.push(
        makeFeatureVector(
          i - W, i, domain, allowZero, decay, alpha,
          function(j){
            var v = toInt(numOf(extraDraws[j]));
            return isFinite(v) ? [v] : [];
          }
        )
      );

      var y = new Array(dom);
      for (var t0 = 0; t0 < dom; t0++) y[t0] = 0;

      var v2 = toInt(numOf(extraDraws[i]));
      var id2 = allowZero ? v2 : (v2 - 1);
      if (isFinite(v2) && id2 >= 0 && id2 < dom) y[id2] = 1;

      ys.push(y);
    }

    var inputDim = xs.length ? xs[0].length : 0;
    return { xs: xs, ys: ys, inputDim: inputDim, domain: dom };
  };

  // CHG: ES5-safe buildSkaiExtraCurrentVector with gap-conditioned Skip & Hit prior.
  window.buildSkaiExtraCurrentVector = window.buildSkaiExtraCurrentVector || function(extraDraws, settings){
    extraDraws = Array.isArray(extraDraws) ? extraDraws : [];
    settings = settings || {};

    var meta = window.SKAI_META || {};
    var domain = (+meta.extraDomain > 0) ? (+meta.extraDomain) : 26;
    var allowZero = (meta && meta.forceOneBasedExtra) ? false : (domain <= 9);

    var hist = extraDraws.length | 0;

    var W = +settings.windowSize;
    if (!isFinite(W) || W <= 0) W = Math.max(5, Math.max(1, hist - 1)); // default: entire DB for the live vector
    W = Math.max(5, Math.min((W|0), Math.max(1, hist - 1)));

    var decay = +settings.recencyDecay;
    if (!isFinite(decay)) decay = 0.9;
    decay = Math.max(0, Math.min(1, decay));
    var alpha = Math.max(0.01, 1 - Math.min(0.999, decay));

    var start = Math.max(0, hist - W), end = hist;

    var x = makeFeatureVector(
      start, end, domain, allowZero, decay, alpha,
      function(j){
        var v = toInt(numOf(extraDraws[j]));
        return isFinite(v) ? [v] : [];
      }
    );

    var dom = allowZero ? (domain + 1) : domain;
    if (!isFinite(dom) || dom <= 0) {
      return { x: x, skipPrior: [] };
    }

// CHG: Bayesian + recency-weighted Skip/Hit prior with bounded skip-bias (extra ball).
    var lastHitE = new Array(dom);
    var totalHitsE = new Array(dom);    // recency-weighted total hits
    var gapHitsE = new Array(dom);      // recency-weighted gap->hits map
    var i0, j0;

    for (i0 = 0; i0 < dom; i0++){
      lastHitE[i0] = -1;
      totalHitsE[i0] = 0;
      gapHitsE[i0] = {};
    }

    var laplaceK = (settings && settings.laplaceK != null) ? Number(settings.laplaceK) : NaN;
    if (!isFinite(laplaceK)) { laplaceK = 1; }
    if (laplaceK < 0) { laplaceK = 0; }
    if (laplaceK > 10) { laplaceK = 10; }

    var skipGamma = (settings && settings.skipGamma != null) ? Number(settings.skipGamma) : NaN;
    if (!isFinite(skipGamma)) { skipGamma = 0.20; }
    if (skipGamma < 0) { skipGamma = 0; }
    if (skipGamma > 1) { skipGamma = 1; }

    // Collect recency-weighted gap stats
    for (j0 = start; j0 < end; j0++){
      var vJ = toInt(numOf(extraDraws[j0]));
      var idJ = allowZero ? vJ : (vJ - 1);
      if (!isFinite(vJ) || idJ < 0 || idJ >= dom) {
        continue;
      }

      var ageE = (end - 1) - j0;
      if (ageE < 0) { ageE = 0; }
      var wRecE = Math.pow(decay, ageE);

      if (lastHitE[idJ] !== -1){
        var gE = j0 - lastHitE[idJ] - 1;
        if (gE < 0) { gE = 0; }
        if (!gapHitsE[idJ][gE]) { gapHitsE[idJ][gE] = 0; }
        gapHitsE[idJ][gE] += wRecE;
      }

      totalHitsE[idJ] += wRecE;
      lastHitE[idJ] = j0;
    }

    var maxGapE = Math.max(1, end - start);
    var prior = new Array(dom);

    // Gap distribution now (for bounded skip-bias)
    var gapsNowE = new Array(dom);
    var sumGapE = 0;
    for (var c0 = 0; c0 < dom; c0++){
      var currentGapE;
      if (lastHitE[c0] === -1){
        currentGapE = maxGapE;
      } else {
        currentGapE = (end - 1) - lastHitE[c0];
        if (currentGapE < 0) { currentGapE = 0; }
        if (currentGapE > maxGapE) { currentGapE = maxGapE; }
      }
      gapsNowE[c0] = currentGapE;
      sumGapE += currentGapE;
    }

    var meanGapE = (dom > 0) ? (sumGapE / dom) : 0;
    var varGapE = 0;
    for (var c1 = 0; c1 < dom; c1++){
      var dGE = gapsNowE[c1] - meanGapE;
      varGapE += dGE * dGE;
    }
    var sdGapE = (dom > 1) ? Math.sqrt(varGapE / (dom - 1)) : 1;
    if (!isFinite(sdGapE) || sdGapE <= 1e-9) { sdGapE = 1; }

    // Bayesian-smoothed gap-likelihood * bounded skip-bias
    // IMPORTANT: gaps are multinomial buckets, so smoothing must be Dirichlet-like over buckets.
    var maxScoreE = 0;
    for (var c = 0; c < dom; c++){
      var gNowE = gapsNowE[c];

      var hitsAtGapE = (gapHitsE[c] && gapHitsE[c][gNowE]) ? gapHitsE[c][gNowE] : 0;
      var totalForNumberE = totalHitsE[c] || 0;

      // Effective number of gap buckets (cap for stability)
      var G = Math.max(5, Math.min(60, maxGapE|0));

      // Dirichlet/Laplace smoothing over G buckets:
      //   pGapE ≈ (hitsAtGapE + K) / (totalHitsE + K*G)
      var pGapE = 0;
      if (totalForNumberE > 0 || laplaceK > 0){
        pGapE = (hitsAtGapE + laplaceK) / (totalForNumberE + (laplaceK * G));
      }

      var zE = (gNowE - meanGapE) / sdGapE;
      var biasE = Math.exp(skipGamma * Math.tanh(zE));

      // CHG: Temper pGapE so skip-bias cannot dominate when evidence is sparse.
      // tau < 1 compresses extremes and reduces overfitting to rare exact gaps.
      var tauE = (settings && settings.priorTemp != null) ? Number(settings.priorTemp) : NaN;
      if (!isFinite(tauE)) { tauE = 0.80; }
      if (tauE < 0.60) { tauE = 0.60; }
      if (tauE > 1.00) { tauE = 1.00; }

      var scoreE = Math.pow(pGapE, tauE) * biasE;

      prior[c] = scoreE;
      if (scoreE > maxScoreE) { maxScoreE = scoreE; }
    }

    if (maxScoreE > 0){
      for (var q = 0; q < dom; q++){
        prior[q] = prior[q] / maxScoreE;
      }
    } else {
      for (var q2 = 0; q2 < dom; q2++){
        prior[q2] = 0;
      }
    }

    // CHG: Beta posterior params for Thompson Sampling (history-learning)
    // hits = totalHits[c], trials = (end-start). Use alpha0/beta0 as priors.
    var alpha0 = (settings && settings.posteriorAlpha0 != null) ? Number(settings.posteriorAlpha0) : NaN;
    var beta0  = (settings && settings.posteriorBeta0  != null) ? Number(settings.posteriorBeta0)  : NaN;
    if (!isFinite(alpha0) || alpha0 <= 0) alpha0 = 1;
    if (!isFinite(beta0)  || beta0  <= 0) beta0  = 1;

        // Effective weighted trials consistent with wRecE = decay^age
    var N = (end - start);
    if (!isFinite(N) || N < 1) N = 1;

    var effTrials = N;
    if (isFinite(decay) && decay > 0 && decay !== 1){
      effTrials = (1 - Math.pow(decay, N)) / (1 - decay);
    }
    if (!isFinite(effTrials) || effTrials <= 0) effTrials = N;

    var postA = new Array(dom);
    var postB = new Array(dom);
    for (var pc = 0; pc < dom; pc++){
      var h = totalHitsE[pc] || 0;
      var m = effTrials - h;
      if (m < 0) m = 0;
      postA[pc] = alpha0 + h;
      postB[pc] = beta0  + m;
    }


    return { x: x, skipPrior: prior, postA: postA, postB: postB };

  };

})();
</script>


<script>
/* =========================
   Section 5: Model factory & training helper
   - buildSkaiModel
   - fitWithValidation
   ========================= */
 (function(){
   'use strict';

  // FNR-RUNTIME-01: Legacy `show()` safety alias.
  // Reason/benefit: setChip() (line ~16961) calls show(...). In module scope it can be undefined.
  // This no-op preserves compatibility without changing any features.
  if (typeof window.show !== 'function') {
    window.show = function(){ /* legacy no-op */ };
  }
 
   // CHG: ES5-safe buildSkaiModel (no const/let/Number.isFinite).
   window.buildSkaiModel = window.buildSkaiModel || function(settings, inputDim, outDimOverride){
    if (!window.tf) throw new Error('[SKAI] TensorFlow.js not loaded');
    // CHG: Strict-scope safe local alias.
    var tfw = window.tf;

    settings = settings || {};
    inputDim = Math.max(1, (inputDim|0));

    var meta = window.SKAI_META || {};
    var mainDomain  = (+meta.domain > 0) ? (+meta.domain) : 70;
    var extraDomain = (+meta.extraDomain > 0) ? (+meta.extraDomain) : 26;

    var allowZeroMain = (typeof meta.allowZero === 'boolean')
      ? (meta.allowZero && !meta.hasExtraBall)
      : ((mainDomain <= 9) && !meta.hasExtraBall);

    var allowZeroExtra = (meta && meta.forceOneBasedExtra) ? false : (extraDomain <= 9);

    var single = !!settings.singleLabel;
    var defDom = single ? extraDomain : mainDomain;
    var allowZeroOut = single ? allowZeroExtra : allowZeroMain;

    var outDim = isFinite(outDimOverride)
      ? (outDimOverride|0)
      : (allowZeroOut ? (defDom + 1) : defDom);

    outDim = Math.max(1, outDim);

    var act = String(settings.activationFunction || 'tanh');
    var layers = Math.max(0, ((+settings.hiddenLayers) || (+settings.layers) || 2) | 0);
    var drop = Math.max(0, Math.min(0.6, (+settings.dropout) || (+settings.dropoutRate) || 0.2));
    var units = Math.max(32, Math.min(512, Math.round(inputDim / 2)));
    var outAct = single ? 'softmax' : 'sigmoid';
    var loss = settings.loss || (single ? 'categoricalCrossentropy' : 'binaryCrossentropy');

    var lr = (+settings.learningRate) || (+settings.lr) || 0.001;
    lr = Math.max(1e-6, Math.min(1e-1, lr));

    var SEED = (window.SKAI_SEED|0) || 1337;

    // ------------------------------------------------------------
    // CHG: True per-position multi-head model for digit games
    // - If outDim == pick*10 and main domain<=9: build shared trunk + Pick heads
    // - Each head outputs 10-way softmax; outputs concatenated => [pick*10]
    // ------------------------------------------------------------
    var isDigitMain = (mainDomain > 0 && mainDomain <= 9 && !!allowZeroMain && !(meta && meta.hasExtraBall));
    var pickMain = (meta && isFinite(+meta.pick) && +meta.pick > 0) ? (+meta.pick|0) : 0;
    var wantPosHeads = (isDigitMain && pickMain >= 2 && pickMain <= 6 && outDim === (pickMain * 10));

    if (wantPosHeads) {
      // Functional model (multi-head)
      var input = tfw.input({ shape: [inputDim] });

      var x = tfw.layers.dense({
        units: units,
        activation: act,
        kernelInitializer: tfw.initializers.glorotUniform({ seed: SEED }),
        biasInitializer: tfw.initializers.zeros()
      }).apply(input);

      if (drop > 0) {
        x = tfw.layers.dropout({ rate: drop }).apply(x);
      }

      for (var li = 1; li < layers; li++){
        x = tfw.layers.dense({
          units: units,
          activation: act,
          kernelInitializer: tfw.initializers.glorotUniform({ seed: SEED }),
          biasInitializer: tfw.initializers.zeros()
        }).apply(x);
        if (drop > 0) x = tfw.layers.dropout({ rate: drop }).apply(x);
      }

      // Heads: each is a 10-way softmax
      var heads = [];
      for (var p = 0; p < pickMain; p++){
        heads.push(
          tfw.layers.dense({ units: 10, activation: 'softmax', name: 'pos_head_' + p }).apply(x)
        );
      }

      // Concatenate heads -> shape [pickMain*10]
      var out = tfw.layers.concatenate({ axis: 1, name: 'pos_concat' }).apply(heads);

      var model = tfw.model({ inputs: input, outputs: out, name: 'skai_pos_multihead' });

      // Custom loss: sum of categorical cross-entropy across heads
      var posLoss = function(yTrue, yPred){
        var total = tfw.scalar(0, 'float32');
        for (var pp = 0; pp < pickMain; pp++){
          var a = pp * 10;
          var yT = tfw.slice(yTrue, [0, a], [-1, 10]);
          var yP = tfw.slice(yPred, [0, a], [-1, 10]);
          // categoricalCrossentropy returns per-row; mean it for stability
          var ce = tfw.mean(tfw.metrics.categoricalCrossentropy(yT, yP));
          total = tfw.add(total, ce);
        }
        return total;
      };

      model.compile({ optimizer: tfw.train.adam(lr), loss: posLoss, metrics: [] });
      return model;
    }

    // Legacy sequential model (non-digit games)
    var m = tfw.sequential();

    m.add(tfw.layers.dense({
      units: units,
      inputShape: [inputDim],
      activation: act,
      kernelInitializer: tfw.initializers.glorotUniform({ seed: SEED }),
      biasInitializer: tfw.initializers.zeros()
    }));

    if (drop > 0) m.add(tfw.layers.dropout({ rate: drop }));

    for (var i = 1; i < layers; i++){
      m.add(tfw.layers.dense({
        units: units,
        activation: act,
        kernelInitializer: tfw.initializers.glorotUniform({ seed: SEED }),
        biasInitializer: tfw.initializers.zeros()
      }));
      if (drop > 0) m.add(tfw.layers.dropout({ rate: drop }));
    }

    m.add(tfw.layers.dense({ units: outDim, activation: outAct }));
    m.compile({ optimizer: tfw.train.adam(lr), loss: loss, metrics: ['accuracy'] });
    return m;
  };

  // CHG: ES5-safe fitWithValidation (Promise-based; no async/await/Number.isFinite).
  // CHG: Finalize + done/error emits are inside this function (prevents stray-block syntax errors).
  window.fitWithValidation = window.fitWithValidation || function fitWithValidation(
    model, xsOrObj, settings, onEpoch
  ){
    if (!window.tf) throw new Error('[SKAI] TensorFlow.js not loaded');
    if (!model || typeof model.fit !== 'function') throw new Error('[SKAI] Invalid model passed to fitWithValidation');

    // Accept either { xsTensor, ysTensor } or { xs, ys } or a tuple [xs, ys]
    var xs = null, ys = null;
    if (xsOrObj && xsOrObj.xsTensor && xsOrObj.ysTensor) {
      xs = xsOrObj.xsTensor; ys = xsOrObj.ysTensor;
    } else if (xsOrObj && xsOrObj.xs && xsOrObj.ys) {
      xs = xsOrObj.xs; ys = xsOrObj.ys;
    } else if (Array.isArray(xsOrObj) && xsOrObj.length >= 2) {
      xs = xsOrObj[0]; ys = xsOrObj[1];
    }
    if (!xs || !ys) throw new Error('[SKAI] fitWithValidation: Missing xs/ys tensors');

    var s = settings || {};

    // Optional: overall epochs and offset (for ensembles)
    var epochOffset  = isFinite(+s.__epochOffset) ? (+s.__epochOffset|0) : 0;
    var totalDisplay = isFinite(+s.__totalEpochs) ? (+s.__totalEpochs|0) : null;

    // UI override so training ALWAYS honors visible Epochs control
    (function applyUIEpochOverride(){
      try {
        var epEl = document.getElementById('epochs_ui') || document.getElementById('epochs');
        if (epEl) {
          var uiEpochs = parseInt(epEl.value, 10);
          if (isFinite(uiEpochs) && uiEpochs > 0) s.epochs = uiEpochs;
        }
        var L = (window.SKAI_LIMITS || {});
        if (isFinite(+L.maxEpochs) && +L.maxEpochs > 0 && isFinite(+s.epochs)) {
          s.epochs = Math.min(+s.epochs, +L.maxEpochs);
        }
      } catch(_) {}
    })();

    var epochs          = isFinite(+s.epochs) ? (+s.epochs|0) : 50;
    var batchSize       = isFinite(+s.batchSize) ? (+s.batchSize|0) : 32;
    var validationSplit = (typeof s.validationSplit === 'number') ? s.validationSplit : 0.1;
    if (validationSplit < 0) validationSplit = 0;
    if (validationSplit > 0.35) validationSplit = 0.35;

    var shuffle       = (typeof s.shuffle === 'boolean') ? s.shuffle : true;
    var deterministic = !!s.deterministic; // reserved hook

    var phaseLabel = (s.__phaseLabel && String(s.__phaseLabel))
      ? String(s.__phaseLabel)
      : 'Main numbers - SKAI run';
    var evtName = (s.__eventName && String(s.__eventName)) || 'skai:ml:epoch';

    if (!isFinite(totalDisplay) || totalDisplay <= 0) totalDisplay = epochs;

    // Ensure visible progress baseline
    try {
      // CHG: Strict-scope safe reference.
      var baseMsg = (typeof window.SKAI_msg === 'function') ? window.SKAI_msg('trainingMain') : 'Training...';
      if (typeof window.ensureProgressAPI === 'function') {
        var P0 = window.ensureProgressAPI();
        if (P0 && typeof P0.set === 'function') P0.set(62, baseMsg);
      } else if (window.SKAI_Progress && typeof window.SKAI_Progress.set === 'function') {
        window.SKAI_Progress.set(62, baseMsg);
      }
    } catch(_){}

    var lastEpoch = -1;

    // === LAYER 1 & 2: Training phase initialization ===
    var trainSampleCount = 0;
    try {
      if (xs && xs.shape) {
        trainSampleCount = xs.shape[0] || 0;
      }
    } catch(_) {}

    var wiringCb = {
      onTrainBegin: function(){ 
        // === LAYER 1: Set training phase ===
        try {
          if (window.SKAI_RUNTIME_STATS) {
            window.SKAI_RUNTIME_STATS.setPhase('Training neural network (teaching the computer to predict numbers)', phaseLabel);
          }
        } catch(_) {}
        return Promise.resolve();
      },
      onEpochEnd: function(epoch, logs){
        if (epoch === lastEpoch) return Promise.resolve();
        lastEpoch = epoch;

        // === LAYER 2: Track training progress ===
        try {
          if (window.SKAI_RUNTIME_STATS) {
            // Each epoch processes all batches
            var batchesPerEpoch = Math.ceil(trainSampleCount / Math.max(1, batchSize));
            window.SKAI_RUNTIME_STATS.incrementBatches(batchesPerEpoch);
            
            // Estimate operations: batches × batchSize × (inputDim × outputDim × 2) for forward+backward
            var inputDim = 0;
            var outputDim = 0;
            try {
              if (xs && xs.shape) inputDim = xs.shape[1] || 0;
              if (ys && ys.shape) outputDim = ys.shape[1] || 0;
            } catch(_) {}
            
            if (inputDim > 0 && outputDim > 0) {
              var opsPerBatch = batchSize * inputDim * outputDim * 4; // Rough estimate (forward, backward, weight updates)
              window.SKAI_RUNTIME_STATS.incrementOperations(batchesPerEpoch * opsPerBatch);
            }
            
            // Update phase detail with epoch info
            var eff = epochOffset + (epoch + 1);
            var tot = Math.max(1, totalDisplay);
            window.SKAI_RUNTIME_STATS.setPhase('Training neural network (teaching the computer to predict numbers)', phaseLabel + ' (' + eff + '/' + tot + ' epochs)');
          }
        } catch(_) {}

        var span = 96 - 62;
        var pct  = 62;
        var eff  = epochOffset + (epoch + 1);
        var tot  = Math.max(1, totalDisplay);
        try { pct = 62 + Math.floor(eff * (span / tot)); } catch(_){}

        try {
          var labelNow = 'Training ' + String(eff) + '/' + String(tot) + '...';
          if (typeof window.ensureProgressAPI === 'function') {
            var P1 = window.ensureProgressAPI();
            if (P1 && typeof P1.set === 'function') P1.set(pct, labelNow);
          } else if (window.SKAI_Progress && typeof window.SKAI_Progress.set === 'function') {
            window.SKAI_Progress.set(pct, labelNow);
          }
          
          // Update progress indicator stages based on percentage
          // pct ranges from 62% to 96% during training
          if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.setStage === 'function') {
            var stage = 0;
            if (pct < 5) {
              stage = 0; // Loading Data
            } else if (pct >= 5 && pct < 72) {
              stage = 1; // Training Main AI
            } else if (pct >= 72 && pct < 95) {
              stage = 2; // Training Extra AI
            } else if (pct >= 95 && pct < 100) {
              stage = 3; // Generating Picks
            } else {
              stage = 4; // Complete
            }
            window.SKAI_ProgressIndicator.setStage(stage);
            console.log('[Progress] pct=' + pct + ', stage=' + stage + ', epoch=' + eff + '/' + tot);
          }
        } catch(_){}

        try {
          var epochDisplay = epochOffset + (epoch + 1);
          var epochsDisplayTotal = Math.max(1, totalDisplay);

          if (typeof window.SKAI_emit === 'function') {
            window.SKAI_emit(evtName, {
              detail: {
                epoch: epoch,
                epochs: epochs,
                totalEpochs: totalDisplay,
                epochOffset: epochOffset,
                epochDisplay: epochDisplay,
                epochsDisplayTotal: epochsDisplayTotal,
                logs: logs || {},
                label: phaseLabel
              }
            });

            window.SKAI_emit('skai:ml:metrics', {
              detail: {
                epochDisplay: epochDisplay,
                epochsDisplayTotal: epochsDisplayTotal,
                logs: logs || {}
              }
            });
          }

          // Mirror each epoch into the SKAI cockpit log (if available)
          try {
            if (window.SKAI_Cockpit && typeof window.SKAI_Cockpit.log === 'function') {
              var _msg = 'Epoch ' + String(epochDisplay) + '/' + String(epochsDisplayTotal);
              if (logs && typeof logs.loss === 'number') {
                try { _msg += ' - loss=' + logs.loss.toFixed(4); } catch(_){}
              }
              if (logs && typeof logs.val_loss === 'number') {
                try { _msg += ' - val_loss=' + logs.val_loss.toFixed(4); } catch(_){}
              }
              window.SKAI_Cockpit.log(_msg);
            }
          } catch(_){}

        } catch(_){}

        if (typeof onEpoch === 'function') {
          try {
            var maybeP = onEpoch(epoch, (logs || {}));
            if (maybeP && typeof maybeP.then === 'function') return maybeP;
          } catch(_){}
        }
        return Promise.resolve();
      }
    };

    var callbacks = [];
    if (Array.isArray(s.callbacks)) callbacks = callbacks.concat(s.callbacks);
    callbacks.push(wiringCb);

    var fitCfg = {
      epochs: epochs,
      batchSize: batchSize,
      validationSplit: validationSplit,
      shuffle: shuffle,
      callbacks: callbacks
    };
    if (typeof s.verbose !== 'undefined') fitCfg.verbose = s.verbose;
    if (deterministic) { /* reserved */ }

    // Return a promise; finalize + done/error emits live here
    try {
      return model.fit(xs, ys, fitCfg).then(function(history){

        // Finalize: push to 100% and mark done
        try {
          // CHG: Strict-scope safe reference.
          var labelFinal = (typeof window.SKAI_msg === 'function' ? window.SKAI_msg('readyPicks') : 'Completed.');
          if (typeof window.ensureProgressAPI === 'function') {
            var P2 = window.ensureProgressAPI();
            if (P2 && typeof P2.set  === 'function') P2.set(100, labelFinal);
            if (P2 && typeof P2.done === 'function') P2.done(labelFinal);
          } else if (window.SKAI_Progress) {
            if (typeof window.SKAI_Progress.set  === 'function') window.SKAI_Progress.set(100, labelFinal);
            if (typeof window.SKAI_Progress.done === 'function') window.SKAI_Progress.done(labelFinal);
          }
        } catch(_){}

        // === LAYER 3: Complete training phase ===
        try {
          if (window.SKAI_RUNTIME_STATS) {
            var totalEpochsCompleted = epochOffset + epochs;
            var totalBatches = window.SKAI_RUNTIME_STATS.batchesProcessed;
            var loss = (history && history.history && history.history.loss) ? history.history.loss[history.history.loss.length - 1] : null;
            
            var changeText = 'Model trained for ' + totalEpochsCompleted + ' epochs (went through all the data ' + totalEpochsCompleted + ' times to get better at predicting)';
            if (loss !== null && isFinite(loss)) {
              changeText += ', final loss: ' + loss.toFixed(4) + ' (accuracy score - lower numbers mean better predictions)';
            }
            
            window.SKAI_RUNTIME_STATS.completePhase({
              phase: phaseLabel,
              processed: totalEpochsCompleted,
              relationships: totalBatches,
              change: changeText,
              metrics: { epochs: totalEpochsCompleted, batches: totalBatches, finalLoss: loss }
            });
          }
        } catch(_) {}

        // Populate window.skaiConfig with all parameters for save function
        try {
          window.skaiConfig = window.skaiConfig || {};
          window.skaiConfig.epochs = s.epochs;
          window.skaiConfig.batchSize = s.batchSize;
          window.skaiConfig.dropoutRate = s.dropoutRate;
          window.skaiConfig.learningRate = s.learningRate;
          window.skaiConfig.activationFunction = s.activationFunction;
          window.skaiConfig.hiddenLayers = s.hiddenLayers;
          window.skaiConfig.recencyDecay = s.recencyDecay;
          window.skaiConfig.drawsAnalyzed = (history && history.length) ? history.length : 0;
        } catch(_){}

        try {
          if (typeof window.SKAI_emit === 'function') {
            window.SKAI_emit('skai:ml:done', { label: phaseLabel, history: history });
            if (evtName === 'skai:extra:epoch') {
              window.SKAI_emit('skai:extra:done', { label: phaseLabel, history: history });
            }
          }
        } catch(_){}

        return history;
      }).catch(function(err){
        try {
          if (typeof window.SKAI_emit === 'function') {
            window.SKAI_emit('skai:ml:error', {
              detail: { message: String(err && err.message ? err.message : err), error: err }
            });
          }
        } catch(_){}
        throw err;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  /* CHG: QUARANTINED STRAY DUPLICATE BLOCK (feature preserved in fitWithValidation above).
     Reason/benefit:
       - JS block comments don-t nest; old duplicate had internal /* ... *\/ comments.
       - Outer comment caused -unterminated comment-.
       - if(false){...} preserves code without executing or breaking parse. */
  if (false) {
    // Accept either { xsTensor, ysTensor } or { xs, ys } or a tuple [xs, ys]
    var xsQ = null, ysQ = null;
    if (xsOrObj && xsOrObj.xsTensor && xsOrObj.ysTensor) {
      xsQ = xsOrObj.xsTensor; ysQ = xsOrObj.ysTensor;
    } else if (xsOrObj && xsOrObj.xs && xsOrObj.ys) {
      xsQ = xsOrObj.xs; ysQ = xsOrObj.ys;
    } else if (Array.isArray(xsOrObj) && xsOrObj.length >= 2) {
      xsQ = xsOrObj[0]; ysQ = xsOrObj[1];
    }
    if (!xsQ || !ysQ) throw new Error('[SKAI] fitWithValidation: Missing xs/ys tensors');

    var sQ = settings || {};
    // ... (QUARANTINED PLACEHOLDER ONLY - do not execute)
  } // end if(false) quarantine

})();
</script>

<script>
/* =========================
   Section 6: Auto-Tune runner (singleton)
   - runAutoTune
   ========================= */
(function(){
  'use strict';
  if (typeof window.runAutoTune !== 'function') {

    function setValue(id, val) {
      var el = document.getElementById(id + '_ui')
            || document.querySelector('[id="' + id + '"]:not([type="hidden"])')
            || document.getElementById(id);
      if (!el) return false;
      el.value = String(val);
      try {
        el.dispatchEvent(new Event('input',  { bubbles: true }));
        el.dispatchEvent(new Event('change', { bubbles: true }));
      } catch (_) {}
      return true;
    }

    // CHG: ES5-safe tuneOnce (Promise-based; no async/await/const/let/arrow/Number.isFinite).
    function tuneOnce(W, raw, base) {
      // CHG: Replace Object.assign with ES5-safe shallow clone + explicit overrides.
      var s = {};
      if (base && typeof base === 'object') {
        for (var bk in base) {
          if (Object.prototype.hasOwnProperty.call(base, bk)) {
            s[bk] = base[bk];
          }
        }
      }
      s.windowSize = W;
      s.epochs     = 12;
      s.batchSize  = 32;
      s.layers     = 1;
      s.dropout    = 0.1;
      s.lr         = 0.001;

      var ds = window.buildSkaiDataset(raw, s);
      if (!ds || !Array.isArray(ds.xs) || ds.xs.length < 5) {
        return Promise.resolve({ W: W, ok: false, loss: Infinity });
      }

      var n   = ds.xs.length | 0;
      var out = (ds.domain | 0) || (ds.ys && ds.ys[0] ? (ds.ys[0].length | 0) : 0);
      if (!out) return Promise.resolve({ W: W, ok: false, loss: Infinity });

      // CHG: strict-scope TF alias.
      var tfw = window.tf;

      var xsT = tfw.tensor2d(ds.xs, [n, ds.inputDim], 'float32');
      var ysT = tfw.tensor2d(ds.ys, [n, out],        'float32');
      var m   = window.buildSkaiModel(s, ds.inputDim, out);

      return m.fit(xsT, ysT, {
        epochs: s.epochs, batchSize: s.batchSize, shuffle: true, validationSplit: 0.1, verbose: 0
      }).then(function(hist){

        var best = Infinity, last = Infinity;
        var H  = hist && hist.history;
        var seq = (H && (H.val_loss || H.loss)) || [];
        for (var i0 = 0; i0 < seq.length; i0++){
          var v0 = seq[i0];
          if (isFinite(v0) && v0 < best) best = v0;
        }
        if (seq.length && isFinite(seq[seq.length-1])) last = seq[seq.length-1];

        // Secondary: estimate Top-K hit rate on a tail slice (Promise chain).
        var topK = 0, trials = 0, hitsSum = 0;

        var V = Math.max(20, Math.min(120, Math.floor(0.15 * n)));
        if (V < 5) V = 0;

        function finalizeScore(){
          var alpha = 0.50;
          var score = (isFinite(last) ? last : best) - alpha * topK;

          var mainAvg  = trials ? (hitsSum / trials) : 0;
          var bonusAvg = 0;
          var cases    = trials | 0;

          return {
            W: W,
            ok: true,
            loss: isFinite(best) ? best : Infinity,
            topK: trials ? topK : 0,
            score: isFinite(score) ? score : best,
            mainAvg: mainAvg,
            bonusAvg: bonusAvg,
            cases: cases
          };
        }

        if (!V){
          return finalizeScore();
        }

        var tailX = tfw.tensor2d(ds.xs.slice(n - V), [V, ds.inputDim], 'float32');
        var tailY = ds.ys.slice(n - V);
        var pred  = m.predict(tailX);

        return pred.array().then(function(p){

          try { tailX.dispose(); pred.dispose && pred.dispose(); } catch(_){}

          var K = 20;
          for (var r = 0; r < V; r++){
            var probs = p[r] || [];
            var pairs = [];
            for (var j0 = 0; j0 < probs.length; j0++) pairs.push([probs[j0], j0]);
            pairs.sort(function(a,b){ return b[0]-a[0]; });

            var idxs = [];
            for (var j1 = 0; j1 < Math.min(K, pairs.length); j1++) idxs.push(pairs[j1][1]);

            var y = tailY[r] || [];
            var hits = 0;
            for (var j2 = 0; j2 < idxs.length; j2++){
              var ii = idxs[j2];
              if (y[ii] > 0) hits++;
            }
            hitsSum += hits; topK += hits; trials++;
          }
          if (trials > 0) topK = topK / (K * trials);

          return finalizeScore();
        }).catch(function(){
          return finalizeScore();
        });

      }).catch(function(){
        return { W: W, ok: false, loss: Infinity };
      }).finally(function(){
        try { xsT.dispose(); ysT.dispose(); m.dispose && m.dispose(); } catch (__){}
      });
    }

    // CHG: ES5-safe runAutoTune (Promise-based).
    window.runAutoTune = function () {

      function ensureTfReadyOnce(){
        if (typeof window.ensureTF === 'function') {
          return window.ensureTF().then(function(){ return true; });
        }
        if (window.tf && window.tf.ready) {
          return window.tf.ready().then(function(){ return true; });
        }
        return Promise.resolve(false);
      }

      function sleep(ms){
        return new Promise(function(resolve){ setTimeout(resolve, ms); });
      }

      return ensureTfReadyOnce().catch(function(e){
        (window.SKAI_warn || console.warn)('[SKAI] TensorFlow init failed, retrying once...', e);
        return sleep(1200).then(ensureTfReadyOnce);
      }).then(function(tfReady){

        if (!tfReady) {
          try { window.__SKAI_RUNNING__ = false; } catch(_){}
          try { window.SKAI_emit && window.SKAI_emit('skai:analysis-stop', { detail:{ reason:'tf-init-failed' } }); } catch(_){}
          return null;
        }

        if (!window.tf || typeof window.tf.ready !== 'function') {
          throw new Error('TF not ready for Auto-Tune');
        }

        // Backend pref
        if (typeof window.SKAI_chooseBackend === 'function') {
          try { return window.SKAI_chooseBackend(); } catch(_){ return Promise.resolve(); }
        }
        return Promise.resolve();

      }).then(function(){

        // Source draws
        var raw = Array.isArray(window.draws)
          ? window.draws
          : (Array.isArray(window.__le_lastFiltered) ? window.__le_lastFiltered : []);
        if (!raw || raw.length < 20) throw new Error('Not enough draws for Auto-Tune');

        function gv(id, def) {
          var el = document.getElementById(id + '_ui')
                || document.querySelector('[id="' + id + '"]:not([type="hidden"])')
                || document.getElementById(id);
          var v  = (el && el.value != null) ? String(el.value).trim() : '';
          return v !== '' ? v : def;
        }

        var rawLen = raw.length | 0;

        var base = {
          epochs:       Math.max(1, parseInt(gv('epochs','16'),10) || 16),
          batchSize:    Math.max(1, parseInt(gv('batchSize','32'),10) || 32),
          dropoutRate:  Math.max(0, Math.min(0.95, parseFloat(gv('dropoutRate','0.2')) || 0.2)),
          learningRate: Math.max(0, parseFloat(gv('learningRate','0.001')) || 0.001),
          hiddenLayers: Math.max(1, parseInt(gv('hiddenLayers','2'),10) || 2),
          recencyDecay: Math.max(0, Math.min(1, parseFloat(gv('recencyDecay','0.9')) || 0.9)),
          blendRatio:   Math.max(0, Math.min(1, parseFloat(gv('blendRatio','0.60')) || 0.60)),
          gapScale:     Math.max(0, Math.min(1, parseFloat(gv('gapScale','0.20')) || 0.20)),
          windowSize:   Math.max(5, rawLen - 1)
        };

        var hist        = raw.length | 0;
        var maxFeasible = Math.max(5, hist - 5);
        var candidates  = [];
        for (var w = 8; w <= maxFeasible; w += (w < 20 ? 2 : 4)) candidates.push(w);
        if (!candidates.length) candidates.push(10);

        try { window.SKAI_emit && window.SKAI_emit('skai:autotune:start'); } catch(_){}
        try { window.SKAI_emit && window.SKAI_emit('skai:autotune:begin', { detail:{ total: candidates.length } }); } catch(_){}

        var results = [];

        // Sequential evaluation via recursion (ES5-safe).
        function evalAt(i){
          if (i >= candidates.length) return Promise.resolve();

          var W = candidates[i];
          return tuneOnce(W, raw, base).then(function(r){
            results.push(r);

            // live candidate event
            try {
              var pick   = (window.SKAI_META && Number(window.SKAI_META.pick)) || 5;
              var extras = (window.SKAI_META && window.SKAI_META.hasExtraBall) ? 1 : 0;
              var Wm = 5, We = 2;
              try {
                var sw = (window.SKAI_SCORE_WEIGHTS || {});
                if (isFinite(+sw.main))  Wm = +sw.main;
                if (isFinite(+sw.extra)) We = +sw.extra;
              } catch(_){}

              var nm = pick   > 0 ? (Number(r.mainAvg)  || 0) / pick   : 0;
              var ne = extras > 0 ? (Number(r.bonusAvg) || 0) / extras : 0;

              var scoreWL = (Wm * nm) + (We * ne);
              var avgScore = (isFinite(scoreWL) && scoreWL > 0)
                ? scoreWL
                : (isFinite(r.score)
                    ? (1 / (1 + Math.max(0, r.score)))
                    : (1 / (1 + Math.max(0, r.loss))));

              var payload = {
                window:   W,
                avgScore: avgScore,
                loss:     isFinite(r.loss) ? r.loss : Infinity,
                mainAvg:  Number(r.mainAvg)  || 0,
                bonusAvg: Number(r.bonusAvg) || 0,
                cases:    Number(r.cases)    || 0,
                pickMain: pick,
                pickBonus: extras,
                wtMain: Wm,
                wtBonus: We
              };

              window.SKAI_emit && window.SKAI_emit('skai:autotune:candidate', { detail: payload });
            } catch(__){}

            try {
              window.SKAI_emit && window.SKAI_emit('skai:autotune:progress', {
                detail: { index: i, total: candidates.length, W: W, loss: r.loss }
              });
            } catch(__){}

          }).catch(function(){
            results.push({ W: W, ok: false, loss: Infinity });
          }).then(function(){
            return evalAt(i + 1);
          });
        }

        return evalAt(0).then(function(){

          // Sort best first (ES5-safe comparator).
          results.sort(function(a,b){
            var as = isFinite(a.score) ? a.score : a.loss;
            var bs = isFinite(b.score) ? b.score : b.loss;
            return (as - bs) || (b.W - a.W);
          });

          var best = results[0] || { W: 30, loss: Infinity, score: Infinity };

          var top10 = results.slice(0,10).map(function(r, idx){
            return {
              rank: idx + 1,
              W: r.W | 0,
              loss: isFinite(r.loss) ? r.loss : Infinity,
              score: isFinite(r.score) ? r.score : (isFinite(r.loss) ? r.loss : Infinity),
              topK: isFinite(r.topK) ? r.topK : 0,
              mainAvg: Number(r.mainAvg) || 0,
              bonusAvg: Number(r.bonusAvg) || 0,
              cases: Number(r.cases) || 0
            };
          });

          window.SKAI_AUTOTUNE_TOP10 = top10;

          // CHG: ES5-safe shallow merge for SKAI_SERVER (no Object.assign).
          (function(){
            var cur   = window.SKAI_SERVER || {};
            var next  = {};
            var ck;
            for (ck in cur) {
              if (Object.prototype.hasOwnProperty.call(cur, ck)) {
                next[ck] = cur[ck];
              }
            }
            next.usedWindow  = best.W | 0;
            next.bestWindow  = best.W | 0;
            next.hasAutoTune = true;
            window.SKAI_SERVER = next;
          })();

          window.SKAI_TUNED_PARAMS       = { windowSize: best.W | 0 };
          window.__SKAI_AUTOTUNE_DONE__  = true;
          window.SKAI_AUTOTUNE_DONE      = true;
          window.__SKAI_TUNED_THIS_RUN__ = true;

          try {
            window.SKAI_emit && window.SKAI_emit('skai:server:ready', { detail:{ server: window.SKAI_SERVER } });
          } catch(_){}

          setValue('windowSize', best.W | 0);
          try { window.__SKAI_AT_SETTINGS_REQUIRED__ = true; } catch(_){}
          try { window.__SKAI_AT_SETTINGS_APPLIED__ = true; } catch(_){}

          try { window.SKAI_emit && window.SKAI_emit('skai:autotune:result', { detail:{ settings: window.SKAI_TUNED_PARAMS } }); } catch(_){}
          try { window.SKAI_emit && window.SKAI_emit('skai:autotune:ready-for-ml', { detail:{ windowSize: best.W | 0 } }); } catch(_){}
          try { window.SKAI_emit && window.SKAI_emit('skai:autotune:done', { detail:{ best: best, top10: top10 } }); } catch(_){}

          return { windowSize: best.W | 0 };
        });

      });
    };
  } // end singleton guard
})();
</script>

<script>
/* =========================
   Section 7: UI status chip & event wiring
   - progress labels for autotune/train/predict
   - retry hook
   - listeners (must be last)
   ========================= */
(function(){
  'use strict';

  // after Auto-Tune finishes, before training starts
  /* CHG: QUARANTINED duplicate autotune:done listener.
     Reason: setChip('tuned') already sets the same 60% label.
     Benefit: prevents double progress writes / flicker while preserving feature. */
  /*
  window.addEventListener('skai:autotune:done', function(e){
    var W = (e && e.detail && (e.detail.W || (e.detail.best && e.detail.best.W))) || 'N/A';
    try {
      ensureProgressAPI().set(60, 'Auto-Tune complete - W=' + W + ' - starting training...');
    } catch (_) {}
  });
  */

  // Status chip (minimal; reuses global @keyframes skaiSpin)
  // CHG: ES5-safe rewrite (no const/let/arrow). Feature parity preserved.
  (function statusChip() {
    if (window.SKAI_CHIP_WIRED) return;
    window.SKAI_CHIP_WIRED = true;

    function ensureChip() {
      var panel =
        document.getElementById('ai-status-area') ||
        document.getElementById('skai-ai-panel') ||
        document.getElementById('skai') ||
        document.body;
      if (!panel) return null;

      var chip = document.getElementById('skai-state-chip');
      if (!chip) {
        chip = document.createElement('div');
        chip.id = 'skai-state-chip';
        chip.style.cssText = [
          'display:flex','align-items:center','gap:6px','margin:6px 0','padding:6px 8px',
          'border:1px solid #e5e7eb','border-radius:8px','background:#f8fafc','font:600 12px system-ui'
        ].join(';');

        chip.innerHTML =
          '<span class="spin" data-chip-spin ' +
            'style="display:none;width:12px;height:12px;border:2px solid rgba(0,0,0,.15);' +
                   'border-top-color:#999;border-radius:50%;animation:skaiSpin 1s linear infinite"></span>' +
          '<span class="dot" data-chip-dot ' +
            'style="display:inline-block;width:8px;height:8px;border-radius:50%;background:#9CA3AF"></span>' +
          '<span class="msg" data-chip-msg style="font-weight:700"></span>' +
          '<span class="sub" data-chip-sub style="opacity:.8;margin-left:4px;"></span>' +
          '<button type="button" class="retry" data-chip-retry data-action="retry" ' +
            'style="display:none;margin-left:auto">Retry</button>';

        panel.insertBefore(chip, panel.firstChild || null);
      }
      return chip;
    }

      function showEl(el, on){
      if (el && el.style) el.style.display = on ? '' : 'none';
    }

    // NEW: Global SKAI status bar (fixed at top of viewport)
    // DISABLED: we no longer render a visible global status bar.
    function ensureGlobalStatusBar(){
      var bar = document.getElementById('skai-global-status');
      if (bar) {
        // Force it hidden in case it already exists in DOM
        bar.style.display = 'none';
        return bar;
      }

      try {
        // Create a hidden, non-intrusive container so writers can still log safely
        bar = document.createElement('div');
        bar.id = 'skai-global-status';
        bar.className = 'skai-global-status';
        bar.style.display = 'none';
        document.body.appendChild(bar);
      } catch (_){}

      return bar;
    }

    function updateGlobalStatus(state){
      var bar = ensureGlobalStatusBar();
      if (!bar) return;

      var kind = (state && state.kind) ? String(state.kind) : 'idle';
      var msgNode = bar.querySelector('[data-global-msg]');
      var text = 'SKAI is ready.';

      if (kind === 'tuning') {
        text = (state && state.text) ? String(state.text) : 'Auto-Tune is running-';
      } else if (kind === 'tuned') {
        text = (state && state.text) ? String(state.text) : 'Auto-Tune complete. SKAI is ready.';
      } else if (kind === 'training') {
        text = (state && state.text) ? String(state.text) : 'SKAI is training on your draw history-';
      } else if (kind === 'predicting') {
        text = (state && state.text) ? String(state.text) : 'SKAI is scoring and ranking numbers-';
      } else if (kind === 'rendering') {
        text = (state && state.text) ? String(state.text) : 'SKAI is preparing your picks-';
      } else if (kind === 'ready') {
        text = (state && state.text) ? String(state.text) : 'SKAI is finished. Your picks are ready below.';
      } else if (kind === 'stopped') {
        text = (state && state.text) ? String(state.text) : 'Analysis stopped. You can adjust settings and retry.';
      } else if (kind === 'error') {
        text = (state && state.text) ? String(state.text) : 'There was an error. Please review settings or try again.';
      }

      if (msgNode && msgNode.textContent !== text) {
        msgNode.textContent = text;
      }

      // Show the bar while SKAI is actively working; fade it away when idle/ready
      var busy = (kind === 'tuning' || kind === 'training' || kind === 'predicting' || kind === 'rendering');
      bar.className = busy ? 'skai-global-status is-active' : 'skai-global-status is-idle';
    }

    // CHG: canonical orb updater (truthful + blow-by-blow).
    // Supports {kind,text,detail,sub,pct,W,best}
    function setChip(state) {
      updateGlobalStatus(state);
      var chip = ensureChip();
      if (!chip) return;

      var spin  = chip.querySelector('[data-chip-spin]');
      var dot   = chip.querySelector('[data-chip-dot]');
      var retry = chip.querySelector('[data-chip-retry]');
      var msg   = chip.querySelector('[data-chip-msg]');
      var sub   = chip.querySelector('[data-chip-sub]');

      showEl(spin, false);
      showEl(dot, true);
      showEl(retry, false);

      var theme = { bg:'#F8FAFC', br:'#E5E7EB', dot:'#9CA3AF', text:'#111' };
      var text    = state && state.text ? String(state.text) : 'Idle';
      var subtext = state && (state.sub || state.detail) ? String(state.sub || state.detail) : 'Ready';

      var kind = String((state && state.kind) || 'idle');

      switch (kind) {
        case 'tuning':
          showEl(spin, true); showEl(dot, false);
          theme   = { bg:'#EFF6FF', br:'#BFDBFE', dot:'#60A5FA', text:'#111' };
          text    = state.text || 'Auto-Tune running-';
          subtext = subtext || 'Testing windows';
          break;

        case 'tuned':
          theme   = { bg:'#ECFDF5', br:'#D1FAE5', dot:'#10B981', text:'#064E3B' };
          text    = state.text || 'Auto-Tune complete';
          subtext = subtext || ('W=' + ((state.W != null) ? state.W : (state.best && state.best.W) ? state.best.W : '?'));
          break;

        // CHG: waiting-settings narrator (used by gatePollThrottled below).
        case 'waiting-settings':
          showEl(spin, true); showEl(dot, false);
          theme   = { bg:'#FFF7ED', br:'#FED7AA', dot:'#F59E0B', text:'#7C2D12' };
          text    = state.text || 'Waiting for settings-';
          subtext = subtext || 'Auto-Tune applying best window';
          break;

        case 'training':
          showEl(spin, true);
          theme   = { bg:'#FEF3C7', br:'#FDE68A', dot:'#F59E0B', text:'#7C2D12' };
          text    = state.text || SKAI_msg('trainingMain');
          subtext = subtext || 'Client-side ML';
          break;

        case 'predicting':
          showEl(spin, true);
          theme   = { bg:'#E0F2FE', br:'#BAE6FD', dot:'#38BDF8', text:'#0C4A6E' };
          text    = state.text || 'Predicting-';
          subtext = subtext || 'Scoring top numbers';
          break;

        case 'rendering':
          showEl(spin, true);
          theme   = { bg:'#F5F3FF', br:'#DDD6FE', dot:'#8B5CF6', text:'#3B0764' };
          text    = state.text || 'Rendering results-';
          subtext = subtext || 'Painting number pills';
          break;

        case 'saving':
          showEl(spin, true);
          theme   = { bg:'#FFF7ED', br:'#FED7AA', dot:'#F59E0B', text:'#7C2D12' };
          text    = state.text || 'Saving to dashboard-';
          subtext = subtext || 'Writing prediction record';
          break;

        case 'ready':
          theme   = { bg:'#E6F4EA', br:'#A7F3D0', dot:'#10B981', text:'#065F46' };
          text    = state.text || 'AI model ready';
          subtext = subtext || 'See picks below';
          break;

        case 'stopped':
          showEl(retry, true);
          theme   = { bg:'#FEF2F2', br:'#FECACA', dot:'#EF4444', text:'#7F1D1D' };
          text    = state.text || 'Analysis stopped';
          subtext = subtext || '';
          break;

        case 'error':
          showEl(retry, true);
          theme   = { bg:'#FEF2F2', br:'#FECACA', dot:'#EF4444', text:'#7F1D1D' };
          text    = state.text || 'Error';
          subtext = subtext || 'Check console';
          break;
      }

     // Also surface chip text in the floating global banner, so users
      // see the same narrative at the top of the page.
      if (typeof window.SKAI_setGlobalStatus === 'function') {
        window.SKAI_setGlobalStatus(text, subtext);
      }

      chip.style.background = theme.bg;
      chip.style.border = '1px solid ' + theme.br;

      if (dot && dot.style) dot.style.background = theme.dot;
      if (msg && msg.style) { msg.style.color = theme.text; msg.textContent = text; }
      if (sub && sub.style) { sub.style.color = theme.text; sub.textContent = subtext; }

      // CHG: also update progress bar text if pct provided
      try {
        if (state && state.pct != null && typeof ensureProgressAPI === 'function') {
          ensureProgressAPI().set(state.pct, text + (subtext ? ' - ' + subtext : ''));
        }
      } catch(_){}
      
      // Update progress indicator stages based on pct
      // NOTE: Support both tuning and ML training phases
      try {
        if (state && state.pct != null && window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.setStage === 'function') {
          var stage = 0;
          var pct = state.pct;
          
          // Auto-tune phase (kind='tuning' or 'tuned')
          if (kind === 'tuning' || kind === 'tuned') {
            stage = 0; // Auto Tune stage
            if (kind === 'tuned') {
              // Mark auto-tune as complete, ready for loading data
              stage = 1; // Move to Loading Data stage
            }
          }
          // ML training phases
          else {
            if (pct < 5) {
              stage = 1; // Loading Data (0-4%)
            } else if (pct >= 5 && pct < 72) {
              stage = 2; // Training Main AI (5-71%)
            } else if (pct >= 72 && pct < 95) {
              stage = 3; // Training Extra AI (72-94%)
            } else if (pct >= 95 && pct < 100) {
              stage = 4; // Generating Picks (95-99%)
            } else if (pct >= 100) {
              stage = 5; // Complete (100%)
            }
          }
          window.SKAI_ProgressIndicator.setStage(stage);
        }
      } catch(_){}
    }

    /* =========================
       CHG: EXPORT setChip() GLOBALLY
       Reason:
         - setChip was scoped inside statusChip() IIFE.
         - Blow-by-blow listeners + legacy emitters call setChip globally.
         - Without export ? ReferenceError: setChip is not defined ? analysis-stop.
       Benefit:
         - One canonical orb narrator shared across all SKAI events.
       ========================= */
    window.setChip = setChip;       // legacy compatibility
    window.SKAI_setChip = setChip;  // preferred alias

    // Retry handler (canonical)
    document.addEventListener('click', function (e) {

      // CHG: ES5-safe closest() fallback.
      function closestSafe(node, sel){
        var el = node;
        while (el && el.nodeType === 1){
          try {
            if (el.matches ? el.matches(sel) : (el.msMatchesSelector && el.msMatchesSelector(sel))) return el;
          } catch(_) {}
          el = el.parentElement;
        }
        return null;
      }

      var target = e && e.target;
      var btn = null;
      if (target && target.closest) {
        try { btn = target.closest('#skai-state-chip [data-chip-retry], #skai-state-chip [data-action="retry"]'); } catch(_){}
      }
      if (!btn) btn = closestSafe(target, '#skai-state-chip [data-chip-retry], #skai-state-chip [data-action="retry"]');
      if (!btn) return;

      e.preventDefault();

      if (btn.disabled || window.__SKAI_RUNNING__) return;

      var start = window.SKAI_startPredictionFlow || window.runSkaiML || null;
      if (typeof start === 'function') {
        try { start(); } catch (err) { console.warn('[SKAI] retry start error:', err); }
      } else {
        console.warn('[SKAI] retry: no runner available');
      }
    }, true);

     function __skaiEnableRetry__(){
      try {
        // CHG: ES5-safe: replace `const` with `var` to avoid ES6-only syntax.
        var btn = document.querySelector('#skai-state-chip [data-chip-retry], #skai-state-chip [data-action="retry"]');
        if (btn) { btn.disabled = false; }
      } catch (_) {}
    }

    window.addEventListener('skai:ml:start', function () {
      try {
        // CHG: ES5-safe: replace `const` with `var` here as well.
        var btn = document.querySelector('#skai-state-chip [data-chip-retry], #skai-state-chip [data-action="retry"]');
        if (btn) { btn.disabled = true; }
      } catch (_) {}
    });
    window.addEventListener('skai:ml:done', __skaiEnableRetry__);
    window.addEventListener('skai:analysis-stop', __skaiEnableRetry__);

    // Initial state
    setChip({ kind: 'idle', detail: SKAI_msg('ready') });

  })(); // CHG: close statusChip IIFE (fixes missing } after function body)

  // Event wiring (support both ?start? and ?begin?) - NOW WITH LIVE TOP-10 LEADERBOARD
  (function(){

    // --- Window slider dynamic max & sync -----------------------------------
    function getAvailableWindowMax(){
      try {
        // Prefer server-computed rowsUsed if present
        var meta = (window.SKAI_SERVER && window.SKAI_SERVER.FEATURES && window.SKAI_SERVER.FEATURES.meta) || null;
        var rowsUsed = meta && typeof meta.rowsUsed === 'number' ? meta.rowsUsed : null;
        if (rowsUsed && rowsUsed > 0) return rowsUsed;
      } catch(_){}
      // Fallback: count of client draws (ASC or current filter)
      try {
        var d = (typeof getDraws === 'function') ? getDraws() : (Array.isArray(window.draws) ? window.draws : []);
        if (Array.isArray(d) && d.length > 0) return d.length;
      } catch(_){}
      return 50; // safe fallback
    }

    function clamp(v, min, max){ v = +v||0; return Math.min(Math.max(v, min), max); }

    function setWindowControlsMax(){
      var r = document.getElementById('skaiadv_window');
      var n = document.getElementById('skaiadv_window_num');
      if (!r || !n) return;

      var maxAvail = Math.max(5, getAvailableWindowMax());
      // Override any hardcoded max=500 with real DB size
      r.max = String(maxAvail);
      n.max = String(maxAvail);
      r.min = r.min || '5';
      n.min = n.min || '5';
      r.step = r.step || '1';
      n.step = n.step || '1';

      // Clamp current values into the new range
      var min = +r.min || 5, max = +r.max || maxAvail;
      var current = clamp((n.value || r.value || 50), min, max);
      r.value = String(current);
      n.value = String(current);
    }

    // keep range <-> number in sync & clamped
    (function wireWindowSync(){
      var r = document.getElementById('skaiadv_window');
      var n = document.getElementById('skaiadv_window_num');
      if (!r || !n) return;
      var onInput = function(from, to){
        return function(){
          var min = +from.min || 5, max = +from.max || getAvailableWindowMax();
          var v = clamp(from.value, min, max);
          from.value = String(v);
          to.value = String(v);
          // bubble a change so any listeners (e.g., applyBestWindowToUI) can react
          try { to.dispatchEvent(new Event('change')); } catch(_){}
        };
      };
      r.addEventListener('input', onInput(r,n));
      n.addEventListener('input', onInput(n,r));
    })();

    // initialize soon after data is available
    setTimeout(setWindowControlsMax, 0);
    // also re-apply when autotune finishes or data changes
    window.addEventListener('skai:autotune:done', setWindowControlsMax);
    window.addEventListener('skai:data:ready', setWindowControlsMax);
    window.addEventListener('skai:draws:changed', setWindowControlsMax);
  // ---- tiny UI helpers -----------------------------------------------------
  function $(id){ return document.getElementById(id); }
  function ensureTuneUI(){
    // Put the panel under the AI card status area if present, else body
    var host = $('ai-status-area') || $('skai-ai-panel') || document.body;
    if (!host) return null;

    var box = $('skai-tune-leaderboard');
     if (!box) {
      box = document.createElement('div');
      box.id = 'skai-tune-leaderboard';
      // make it easy to find later from other modules
      box.setAttribute('data-skai-panel','leaderboard');
      box.style.margin = '8px 0 10px 0';
      box.style.border = '1px solid #e5e7eb';
      box.style.borderRadius = '6px';
      box.style.padding = '8px 10px';
      box.style.fontSize = '12px';
      box.innerHTML =
        '<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;">' +
          '<strong>Auto-Tune: Best Windows (Top 10)</strong>' + // leaderboard label
          '<span id="skai-tune-best-pill" style="opacity:.85;"></span>' +
        '</div>' +
        '<div id="skai-tune-live"></div>' +
        '<table id="skai-tune-table" style="width:100%;border-collapse:collapse;margin-top:6px;">' +
          '<thead><tr>' +
            '<th style="text-align:left;border-bottom:1px solid #eee;padding:4px 2px;">#</th>' +
            '<th style="text-align:left;border-bottom:1px solid #eee;padding:4px 2px;">Window W</th>' +
            // Loss column removed  not shown to users
            '<th style="text-align:left;border-bottom:1px solid #eee;padding:4px 2px;">Avg main hits</th>' +
            '<th style="text-align:left;border-bottom:1px solid #eee;padding:4px 2px;">Avg extra hits</th>' +
            '<th style="text-align:left;border-bottom:1px solid #eee;padding:4px 2px;">Weighted score</th>' +
          '</tr></thead><tbody id="skai-tune-tbody"></tbody>' +
        '</table>';
      host.appendChild(box);
    }
    return box;
  }

  // Legacy SKAI_TUNE_ROWS leaderboard removed.
  // New Top-10 leaderboard uses SKAI_AT_ROWS / SKAI_AT_TOP below.
  // ---- scoring logic (truthful; weights fall back to 5:2 if not provided) --
  function getPickSpec(){

    var pick = 5, extras = 1;
    try {
      var cfg = window.SKAI_CONFIG || window.__le_gameConfig || window.lottoConfig || {};
      if (cfg.pickSize) pick = +cfg.pickSize;
      if (cfg.hasExtraBall) extras = +cfg.extraCount || 1;
    } catch(_){}
    return { pick: pick, extras: extras };
  }
  function getWeights(){
    try {
      var w = (window.SKAI_SCORE_WEIGHTS || {});
      return { wm: +w.main || 5, we: +w.extra || 2 };
    } catch(_){ return { wm:5, we:2 }; }
  }
  function scoreOf(r){
    // prefer provided score; else compute from main/extra; else fallback to bounded loss quality
    // CHG: ES5-safe finite check.
    if (isFinite(+r.score)) return +r.score;
    var spec = getPickSpec(), W = getWeights();
    var main = Number(r.mainAvg)||0, extra = Number(r.extraAvg)||0;
    var nm = spec.pick   ? (main  / spec.pick)   : 0;
    var ne = spec.extras ? (extra / spec.extras) : 0;
    if (nm || ne) return (W.wm*nm + W.we*ne);       // weighted normalized hit-rate
    if (isFinite(+r.loss)) {
      var L = Math.max(0, +r.loss);
      return 1 / (1 + L); // smaller loss => score closer to 1 (never negative)
    }
    return -Infinity;
  }

  // ---- state for Top-10 ----------------------------------------------------
  // Map<W, row>, and an array cache for quick sort
  /* CHG: ES5-safe Map shim if Map is missing.
     Reason: Joomla module may run in older engines without Map.
     Benefit: preserves leaderboard feature instead of crashing. */
  if (typeof window.Map !== 'function') {
    window.Map = function MapShim(){
      this.__s = {};
      this.__k = [];
    };
    window.Map.prototype.get = function(k){ return this.__s[String(k)]; };
    window.Map.prototype.set = function(k,v){
      var key = String(k);
      if (!this.__s.hasOwnProperty(key)) this.__k.push(key);
      this.__s[key] = v; return this;
    };
    window.Map.prototype.values = function(){
      var out = [], i;
      for (i=0;i<this.__k.length;i++){
        out.push(this.__s[this.__k[i]]);
      }
      return out;
    };
  }

  window.SKAI_AT_ROWS = new Map();
  window.SKAI_AT_TOP  = [];       // array of rows
  window.SKAI_AT_BEST = null;     // best row

  function upsertRow(d){
    // Accept flexible payload names from both 'progress' and 'candidate' events
    var W = isFinite(+d.W) ? (+d.W|0) : (isFinite(+d.window) ? (+d.window|0) : 0);
    var row = window.SKAI_AT_ROWS.get(W) || { W: W };

    if (isFinite(+d.loss))       row.loss     = +d.loss;
    if (isFinite(+d.mainAvg))    row.mainAvg  = +d.mainAvg;

    // Map either 'extraAvg' or 'bonusAvg' into the same field the UI renders
    if (isFinite(+d.extraAvg))   row.extraAvg = +d.extraAvg;
    if (isFinite(+d.bonusAvg))   row.extraAvg = +d.bonusAvg;

    if (isFinite(+d.score))      row.score    = +d.score;

    window.SKAI_AT_ROWS.set(W, row);
  }

  function recomputeTop(){
    // FNR-FIX: Map.values() returns an iterator in modern browsers.
    // We must normalize to a real array or Top-10 will always be empty.
    var vals = (window.SKAI_AT_ROWS && typeof window.SKAI_AT_ROWS.values === 'function')
      ? window.SKAI_AT_ROWS.values()
      : [];

    var arr = [];

    // If it's already an array (MapShim), use it directly
    if (Array.isArray(vals)) {
      arr = vals.slice();
    } else {
      // Real Map iterator ? convert to array safely
      try {
        if (typeof Array.from === 'function') {
          arr = Array.from(vals);
        } else if (vals && typeof vals.next === 'function') {
          var step;
          while (!(step = vals.next()).done) {
            arr.push(step.value);
          }
        }
      } catch(_){
        arr = [];
      }
    }

    window.SKAI_AT_TOP = arr;
    window.SKAI_AT_TOP.sort(function(a,b){ return scoreOf(b) - scoreOf(a); });

    // Keep only the Top 10 rows for display
    if (window.SKAI_AT_TOP.length > 10) window.SKAI_AT_TOP.length = 10;
    window.SKAI_AT_BEST = window.SKAI_AT_TOP[0] || null;
  }

  function renderTop(){
    ensureTuneUI();
    var tbody = $('skai-tune-tbody');
    var pill  = $('skai-tune-best-pill');
    if (!tbody) return;

    var rows = window.SKAI_AT_TOP;
    var html = '';
    for (var i=0;i<rows.length;i++){
      var r = rows[i];
      // Loss is no longer displayed; focus on main / extra averages and score
      var main  = isFinite(+r.mainAvg)  ? (+r.mainAvg).toFixed(2)  : 'N/A';
      var extra = isFinite(+r.extraAvg) ? (+r.extraAvg).toFixed(2) : 'N/A';
      var s     = scoreOf(r);
      var scoreTxt = (isFinite(+s) && +s >= 0 && +s <= 1)
        ? ((+s * 100).toFixed(1) + '%')
        : (isFinite(+s) ? (+s).toFixed(5) : 'N/A');
      html += '<tr>' +
        '<td style="padding:4px 2px;' + (i ? '' : 'font-weight:600;') + '">' + (i + 1) + '</td>' +
        '<td style="padding:4px 2px;' + (i ? '' : 'font-weight:600;') + '">W=' + r.W + '</td>' +
        '<td style="padding:4px 2px;">' + main  + '</td>' +
        '<td style="padding:4px 2px;">' + extra + '</td>' +
        '<td style="padding:4px 2px;' + (i ? '' : 'font-weight:600;') + '">' + scoreTxt + '</td>' +
      '</tr>';
    }
    // 5 columns now: #, W, Main avg, Extra avg, Score
    tbody.innerHTML = html || '<tr><td colspan="5" style="padding:6px 2px;color:#6b7280;">Tuning...</td></tr>';

    if (pill && window.SKAI_AT_BEST){
      pill.textContent = 'Best so far: W=' + window.SKAI_AT_BEST.W;
    }
  }


  // reset state on (re)start
  function resetTop(){
    window.SKAI_AT_ROWS = new Map();
    window.SKAI_AT_TOP  = [];
    window.SKAI_AT_BEST = null;
    var live = $('skai-tune-tbody'); if (live) live.innerHTML = '';
    var pill = $('skai-tune-best-pill'); if (pill) pill.textContent = '';
  }

  // ---- event wiring (blow-by-blow orb narrator) ----------------------------
  window.addEventListener('skai:autotune:start', function(){
    setChip({ kind: 'tuning', text: 'Auto-Tune started', detail: 'Building candidate windows', pct: 5 });
    ensureTuneUI(); resetTop();
  });

  window.addEventListener('skai:autotune:begin', function(e){
    var total = e && e.detail && e.detail.total ? (e.detail.total|0) : 0;
    setChip({ kind: 'tuning', text: 'Auto-Tune running-', detail: (total? ('Total windows: ' + total) : 'Testing windows'), pct: 8 });
    ensureTuneUI(); resetTop();
  });

  window.addEventListener('skai:autotune:progress', function (e) {
    var d = e && e.detail; if (!d) return;

    // leaderboard ingest
    upsertRow(d);
    recomputeTop();
    renderTop();

    var idx = (d.index != null) ? (d.index|0) : 0;
    var total = (d.total != null) ? (d.total|0) : 0;
    var Wval = (isFinite(+d.W) ? d.W : (isFinite(+d.window) ? d.window : 'n/a'));

    var pct = total ? Math.min(55, 10 + Math.round((idx/total)*45)) : 20;

    setChip({
      kind: 'tuning',
      text: 'Auto-Tune window search',
      detail: 'Testing W=' + Wval + (total ? (' - step ' + (idx+1) + ' of ' + total) : ''),
      pct: pct
    });
  });

  window.addEventListener('skai:autotune:candidate', function (e) {
    var d = e && e.detail; if (!d) return;
    upsertRow({
      W:        d.window,
      loss:     d.loss,
      mainAvg:  d.mainAvg,
      bonusAvg: d.bonusAvg,
      score:    d.avgScore
    });
    recomputeTop();
    renderTop();

    setChip({
      kind: 'tuning',
      text: 'Evaluated window W=' + d.window,
      detail: 'Score updated in Top-10 list',
      pct: 55
    });
  });

  window.addEventListener('skai:autotune:done', function(e){
    recomputeTop(); renderTop();
    var bestW = (e && e.detail && e.detail.best && e.detail.best.W) ? e.detail.best.W : (window.SKAI_AT_BEST ? window.SKAI_AT_BEST.W : '?');

    setChip({
      kind: 'tuned',
      text: 'Auto-Tune complete',
      detail: 'Best window locked: W=' + bestW,
      pct: 60,
      W: bestW
    });
  });

  // Training narrator (epochs / metrics)
  window.addEventListener('skai:ml:start', function () {
    setChip({ kind: 'training', text: 'Training started', detail: 'Preparing tensors + model', pct: 62 });
  });

  window.addEventListener('skai:ml:epoch', function(e){
    var d = e && e.detail || {};
    var ep = d.epoch != null ? (d.epoch+1) : '?';
    var total = d.total != null ? d.total : '?';
    var pct = (d.total != null && d.epoch != null) ? Math.min(85, 62 + Math.round((d.epoch/d.total)*23)) : 70;

    setChip({
      kind: 'training',
      text: 'Training epoch ' + ep + '/' + total,
      detail: (d.loss != null ? ('loss ' + (+d.loss).toFixed(4)) : 'Optimizing weights'),
      pct: pct
    });
  });

  window.addEventListener('skai:ml:metrics', function(e){
    var d = e && e.detail || {};
    if (d.logs && d.logs.val_loss != null) {
      setChip({
        kind: 'training',
        text: 'Validation check',
        detail: 'val_loss ' + (+d.logs.val_loss).toFixed(4),
        pct: 85
      });
    }
  });

  // Prediction + render narrator
  window.addEventListener('skai:ml:predict', function(){
    setChip({ kind: 'predicting', text: 'Predicting numbers-', detail: 'Ranking top probabilities', pct: 90 });
  });

  window.addEventListener('skai:render:done', function(){
    // Treat render completion as a final, READY state so the spinner stops
    setChip({ kind: 'ready', text: 'Rendering complete', detail: 'Numbers painted', pct: 100 });

    // Safety: make sure any SKAI spinners / busy states are cleared
    try {
      if (typeof window.SKAI_spinnerHide === 'function') {
        window.SKAI_spinnerHide();
      }
    } catch (_){}

    try {
      if (typeof window.SKAI_setBusy === 'function') {
        window.SKAI_setBusy(false);
      }
    } catch (_){}
  });

  // If ML emits a proper done signal, also show a READY state
  window.addEventListener('skai:ml:done', function () {
    setChip({ kind: 'ready', text: 'Analysis complete', detail: SKAI_msg('picksComputed'), pct: 100 });
  });

  window.addEventListener('skai:analysis-stop', function (e) {
    var r = (e && e.detail && e.detail.reason) ? String(e.detail.reason) : 'unknown';
    setChip({ kind: 'stopped', text: 'Analysis stopped', detail: r.replace(/[-]/g, ' '), pct: 100 });
  });

  window.addEventListener('skai:ml:error', function (e) {
    var msg = (e && e.detail && e.detail.message) ? e.detail.message : 'ML error';
    setChip({ kind: 'error', text: 'Error', detail: msg, pct: 100 });
  });


    /* =========================
       CHG: QUARANTINED DUPLICATE ORB LISTENERS
       Reason:
         - The blow-by-blow narrator above already handles:
           skai:ml:start, skai:ml:error, skai:ml:done, skai:done, skai:analysis-stop.
         - These duplicates were firing second and overwriting messages,
           causing confusing / stale orb text.
       Benefit:
         - Single source of truth for orb narration.
         - No flicker, no message collisions.
       ========================= */
    /*
    window.addEventListener('skai:ml:start', function () {
      setChip({ kind: 'training' });
      try {
        var c = document.getElementById('aiPredictedNumbers');
        if (c) {
          var help = c.querySelector('.help');
          if (help) help.remove();
          if (!c.querySelector('.nball')) c.innerHTML = '';
        }
      } catch (_){}
    });

    window.addEventListener('skai:ml:error', function (e) {
      const msg = (e && e.detail && e.detail.message) ? e.detail.message : 'ML error';
      setChip({ kind: 'error', detail: msg });
    });

    window.addEventListener('skai:ml:done', function () {
      setChip({ kind: 'ready', detail: SKAI_msg('picksComputed') });
    });

    window.addEventListener('skai:done', function () {
      setChip({ kind: 'ready', detail: 'All steps finished' });
    });

    window.addEventListener('skai:analysis-stop', function (e) {
      const r = (e && e.detail && e.detail.reason) ? String(e.detail.reason) : 'unknown';
      setChip({ kind: 'stopped', detail: r.replace(/[-]/g, ' ') });
      try { window.SKAI_Progress && SKAI_Progress.set && SKAI_Progress.set(100, 'Stopped'); } catch (_){}
    });
    */

    // --- Confidence pill (real-time from skai:ml:metrics) -------------------
    (function confidencePill(){
      function host(){
        return document.getElementById('ai-status-area')
            || document.getElementById('skai-ai-panel')
            || document.body;
      }
      function ensure(){
        var h = host(); if (!h) return null;
        var p = document.getElementById('skai-confidence-pill');
        if (!p){
          p = document.createElement('span');
          p.id = 'skai-confidence-pill';
          p.style.cssText = 'display:inline-block;margin:4px 0 0 0;padding:3px 6px;border:1px solid #e5e7eb;border-radius:6px;background:#f9fafb;font:600 12px system-ui';
          p.textContent = 'Confidence: N/A';
          try { h.appendChild(p); } catch(_){}
        }
        return p;
      }
      function clamp01(x){ if (!(x>0)) return 0; if (x>1) return 1; return x; }
      function computeConfidenceFromLogs(logs){
        logs = logs || {};
        var hasVal = (typeof logs.val_loss === 'number') || (typeof logs.val_accuracy === 'number');
        if (typeof logs.val_loss === 'number' && isFinite(logs.val_loss)){
          // invert loss ? higher is better; rough heuristic
          var c = 1 - Math.max(0, Math.min(1, logs.val_loss));
          return Math.round(clamp01(c) * 100);
        }
        if (typeof logs.val_accuracy === 'number' && isFinite(logs.val_accuracy)){
          return Math.round(clamp01(logs.val_accuracy) * 100);
        }
        if (typeof logs.accuracy === 'number' && isFinite(logs.accuracy)){
          return Math.round(clamp01(logs.accuracy) * 100);
        }
        // Fallback
        return hasVal ? 50 : 0;
      }

      window.addEventListener('skai:ml:metrics', function(e){
        try{
          var d = e && e.detail || {};
          var pct = computeConfidenceFromLogs(d.logs || {});
          var pill = ensure(); if (pill) pill.textContent = 'Confidence: ' + pct + '%';
        }catch(_){}
      });

      window.addEventListener('skai:ml:done', function(e){
        try{
          var pill = ensure(); if (!pill) return;
          // If we didn't get metrics, leave last value; otherwise keep final.
          if (!(/\d+%$/.test(pill.textContent || ''))) pill.textContent = 'Confidence: 100%';
        }catch(_){}
      });
    })();

    // Reflect ?waiting for settings? while gated (throttled)
    (function gatePollThrottled(){
      var ticking = false;
      function tick(){
        ticking = false;
        // CHG: ES5-safe vars (const is ES6).
        var need    = (window.__SKAI_AT_SETTINGS_REQUIRED__ === true);
        var have    = (window.__SKAI_AT_SETTINGS_APPLIED__  === true);
        var running = (window.__SKAI_RUNNING__              === true);
        if (need && !have && running) {
          setChip({ kind: 'waiting-settings' });
        try { if (typeof setLive === 'function') setLive('Waiting for settings...'); } catch(_){}
        }
      }
      setInterval(function(){
        if (ticking) return;
        ticking = true;
        try { tick(); } finally { ticking = false; }
      }, 250);
    })();
  })();
})();
</script>

<script>
/* =========================
   Section A: Calibration & stacking helpers (no deps)
   - SKAI_fitPlatt
   - SKAI_applyPlatt (guarded; avoids double-def)
   - SKAI_trainGate
   ========================= */
(function(){
  'use strict';

  // Safe logit with clamps for local use
  function __toLogit(p){
    var x = Math.min(1-1e-6, Math.max(1e-6, Number(p)||0));
    return Math.log(x/(1-x));
  }

  // Simple Platt-like calibration: fit A,B by least-squares on logits
  if (typeof window.SKAI_fitPlatt !== 'function') {
    window.SKAI_fitPlatt = function(probs, targets){
      var n = Math.min(probs.length|0, targets.length|0);
      if (n < 20) return {A:1, B:0}; // not enough data
      var xsum=0,x2=0,ysum=0,xysum=0;
      for (var i=0;i<n;i++){
        var li = __toLogit(probs[i]);
        var yi = Math.min(1-1e-6, Math.max(1e-6, Number(targets[i])||0));
        var ti = __toLogit(yi);
        xsum  += li;  ysum  += ti;
        x2    += li*li; xysum+= li*ti;
      }
      var denom = (n*x2 - xsum*xsum) || 1e-9;
      var A = (n*xysum - xsum*ysum)/denom;
      var B = (ysum - A*xsum)/n;
      // CHG: ES5-safe finite checks (Number.isFinite is ES6).
      if (!isFinite(A)) A = 1;
      if (!isFinite(B)) B = 0;
      return {A:A, B:B};
    };
  }

  // Platt scaling: maps raw probabilities to calibrated ones using A,B
  if (typeof window.SKAI_applyPlatt !== 'function') {
    window.SKAI_applyPlatt = function(probs, A, B){
      'use strict';
      var EPS = 1e-15;

      function clip(p){
        if (!(p > 0)) return EPS;        // handles NaN and <=0
        if (p >= 1)   return 1 - EPS;
        return p;
      }
      function safeLogit(p){
        p = clip(p);
        return Math.log(p / (1 - p));
      }
      function stableSigmoid(z){
        if (z >= 0){ var ez = Math.exp(-z); return 1 / (1 + ez); }
        var ez2 = Math.exp(z); return ez2 / (1 + ez2);
      }

      var a = (typeof A === 'number' && isFinite(A)) ? A : 1;
      var b = (typeof B === 'number' && isFinite(B)) ? B : 0;
      var arr = Array.isArray(probs) ? probs : [probs];
      var out = new Array(arr.length);

      for (var i = 0; i < arr.length; i++){
        var p = arr[i];
        if (!(typeof p === 'number') || !isFinite(p)){ out[i] = NaN; continue; }
        var z = safeLogit(p) * a + b;
        out[i] = stableSigmoid(z);
      }
      return out;
    };
  }

  // Tiny stacking gate: learns blend for [AI, SH, AI*SH, 1] -> y with 1 hidden layer
  if (typeof window.SKAI_trainGate !== 'function') {
    // CHG: ES5-safe Promise-based gate trainer (no async/await, no unqualified tf).
    window.SKAI_trainGate = function(design, targets, opts){
      try{
        var tfw = window.tf;
        if (!tfw || typeof tfw.sequential !== 'function') return Promise.resolve(null);

        var X = tfw.tensor2d(design,  [design.length, 4], 'float32');
        var Y = tfw.tensor2d(targets, [targets.length, 1], 'float32');
        var m = tfw.sequential();
        var hu = Math.max(4, Math.min(16, (opts && opts.units)|0 || 8));

        m.add(tfw.layers.dense({ units: hu, inputShape:[4], activation:'tanh' }));
        m.add(tfw.layers.dense({ units: 1, activation:'sigmoid' }));
        m.compile({ optimizer: tfw.train.adam((opts && opts.lr)||0.01), loss:'binaryCrossentropy' });

        return m.fit(X, Y, {
          epochs: (opts && opts.epochs)||12,
          batchSize: 256,
          shuffle:true,
          verbose:0,
          validationSplit: 0
        }).then(function(){
          try { X.dispose(); Y.dispose(); } catch(_){}
          return m; // caller disposes later
        }).catch(function(){
          try { X.dispose(); Y.dispose(); m.dispose && m.dispose(); } catch(_){}
          return null;
        });
      }catch(_){
        return Promise.resolve(null);
      }
    };
  }
})();
</script>

<script>
; (function ensureSkaiGlobals(){
  'use strict';

  // Global assert used across ML + scoring blocks
  if (typeof window.SKAI_assert !== 'function') {
    window.SKAI_assert = function(cond, code, msg){
      if (cond) return true;
      var text = (code ? '[' + code + '] ' : '') + (msg || 'SKAI assertion failed');
      try { (window.SKAI_warn || console.warn)('[SKAI] ' + text); } catch(_){}
      try { if (window.SKAI_Progress && typeof window.SKAI_Progress.done === 'function') { window.SKAI_Progress.done('Error: ' + text); } } catch(_){}
      try { if (typeof window.SKAI_emit === 'function') { window.SKAI_emit('skai:analysis-stop', { detail:{ reason: text } }); } } catch(_){}
      throw new Error(text);
    };
  }

  // Lightweight event emitter
  if (typeof window.SKAI_emit !== 'function') {
    window.SKAI_emit = function(name, payload){
      try{
        var hasDetail = payload && Object.prototype.hasOwnProperty.call(payload, 'detail');
        var detail = hasDetail ? payload.detail : payload;
        var ev;
        if (typeof window.CustomEvent === 'function') {
          ev = new CustomEvent(String(name || ''), { detail: detail, bubbles: true, composed: true });
        } else {
          ev = document.createEvent('CustomEvent');
          ev.initCustomEvent(String(name || ''), true, false, detail || null);
        }
        window.dispatchEvent(ev);
      } catch(_){}
    };
  }

  // Fallback progress provider ? drives #skai-progress .fill if site API missing
  if (typeof window.SKAI_getProgress !== 'function') {
    window.SKAI_getProgress = function(){
      try {
        var host = document.getElementById('skai-progress') || document.querySelector('[data-skai-progress]');
        if (!host) return null;
        var fill = host.querySelector('.fill') || host.querySelector('.bar > i') || host.querySelector('.meter > i');
        if (!fill) { fill = document.createElement('div'); fill.className = 'fill'; host.appendChild(fill); }
        var api = {
          value: 0,
          show: function(_lbl){ /* no-op */ },
          set: function(p, _lbl){
            p = Math.max(0, Math.min(100, +p || 0));
            this.value = p;
            try { fill.style.width = p + '%'; } catch(_){}
          },
          done: function(lbl){ this.set(100, lbl); }
        };
        return api;
      } catch(_){ return null; }
    };
  }

  // Non-regressing progress setter
  if (typeof window.SKAI_progressSetSafe !== 'function') {
    window.SKAI_progressSetSafe = function(pct, label){
      try {
        var P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress() : (window.SKAI_Progress || null);
        if (!P || typeof P.set !== 'function') return;
        var cur = (typeof P.value === 'number') ? P.value : 0;
        if (typeof pct === 'number' && pct > cur) {
          P.set(pct, label);
        } else if (cur === 0 && typeof pct === 'number') {
          P.set(pct, label);
        }
      } catch(_) {}
    };
  }
})();
</script>

<script>
/* =========================
   Section B: One-shot ML run (compact, de-duped)
   - window.runSkaiML
   ========================= */
if (typeof window.runSkaiML !== 'function') { // singleton guard to avoid redefinition

  // CHG: async parse-fence for ES5 runtimes.
  // Reason: some Joomla clients still choke on `async function` at parse time.
  // Benefit: modern browsers keep async/await; legacy browsers fail-soft.
  try {
    window.runSkaiML = (async function runSkaiML() {
  if (window.__SKAI_RUNNING__) { try { console.warn('[SKAI] run ignored: already running'); } catch (_) {} return; }
  window.__SKAI_RUNNING__ = true;

  // If any Auto-Tune (Skip & Hit or classic) is currently running, defer ML
  // until it has finished its best-window search. This prevents the model
  // from training on stale window settings while the tuner is still scanning.
  if (window.SKAI_FLAGS && window.SKAI_FLAGS.autotuneRunning) {
    try {
      if (window.SKAI_Progress) {
        window.SKAI_Progress.show('Waiting for Auto-Tune-');
        window.SKAI_Progress.set(5, 'Waiting for Auto-Tune-');
      }
      if (typeof setLive === 'function') {
        setLive('Waiting for Auto-Tune to finish-');
      }
    } catch (_) {}

    // Release the running lock so we can start cleanly once tuning completes
    window.__SKAI_RUNNING__ = false;

    try {
      var handler = function () {
        try { window.removeEventListener('skai:autotune:done', handler, false); } catch (_) {}
        try { window.runSkaiML(); } catch (_) {}
      };
      window.addEventListener('skai:autotune:done', handler, false);
    } catch (_) {}

    return;
  }

  /* CHG: ES5-safe declarations.
     Reason: `let` is ES6 and can throw syntax errors in older Joomla module contexts.
     Benefit: prevents -missing ) / unexpected token- parse crashes. */
  var xsT, ysT;

  // CHG: Clear any stale predictions from previous runs.
  // Reason: If user runs SKAI multiple times, old predictions could persist in memory.
  // Benefit: Ensures we never show cached/stale predictions as if they were new ML results.
  try {
    window.SKAI_TOP_MAIN = [];
    window.SKAI_TOP_EXTRA = [];
    window.__SKAI_LAST_PICKS__ = [];
    window.__SKAI_LEARNED_EXTRA__ = false;
  } catch (_) {}

  // Progress + live label
  try {
    if (window.SKAI_Progress) {
      window.SKAI_Progress.show('Starting AI...');
      window.SKAI_Progress.set(1, 'Starting...');
    }
  } catch (_) {}

// Ensure TF
  if (typeof window.ensureTF === 'function') { try { await window.ensureTF(); } catch (_) {} }
  if (!window.tf || typeof window.tf.ready !== 'function') { throw new Error('TF not ready'); }
  var tfw = window.tf; // CHG: alias for strict-safe access

  // Prefer WebGL; fall back to CPU
  if (typeof window.SKAI_chooseBackend === 'function') {
    try { await window.SKAI_chooseBackend(); } catch(_){}
  }

  // Auto-Tune gate (robust + debounced)
  if (typeof window.__SKAI_AT_SETTINGS_REQUIRED__ === 'undefined') { window.__SKAI_AT_SETTINGS_REQUIRED__ = true; }
  if (typeof window.__SKAI_AT_SETTINGS_APPLIED__  === 'undefined') { window.__SKAI_AT_SETTINGS_APPLIED__  = false; }

  if (window.__SKAI_AT_SETTINGS_REQUIRED__ && !window.__SKAI_AT_SETTINGS_APPLIED__) {
    // Ensure Auto-Tune exists
    if (typeof window.runAutoTune !== 'function') {
      throw new Error('Auto-Tune unavailable (runAutoTune is not defined)');
    }

    // Debounce concurrent calls: reuse a shared promise
    if (!window.__SKAI_AT_PROMISE__) {
      try {
        if (window.SKAI_Progress && typeof window.SKAI_Progress.set === 'function') {
          window.SKAI_Progress.set(3, 'Auto-tuning...');
        }
      } catch (_) {}
      window.__SKAI_AT_PROMISE__ = Promise.resolve().then(function(){ return window.runAutoTune(); });
    }

    // Wait for Auto-Tune to finish
    try {
      await window.__SKAI_AT_PROMISE__;
      window.__SKAI_TUNED_THIS_RUN__ = true;
    } catch (e) {
      // Surface the failure; training must not proceed with unknown window
      throw (e instanceof Error ? e : new Error(String(e)));
    }

    // Validate the tuned window and apply
    (function applyTunedFromServer(){
      var sv = window.SKAI_SERVER || {};
      /* CHG: ES5-safe finite checks.
         Reason: `Number.isFinite` is ES6 and can break parsing.
         Benefit: same validation, wider browser support. */
      var tunedW = isFinite(+sv.usedWindow) ? (+sv.usedWindow)
                : isFinite(+sv.bestWindow)  ? (+sv.bestWindow)  : NaN;

      if (!isFinite(tunedW) || tunedW < 2 || tunedW > 2000) {
        throw new Error('Auto-Tune did not produce a valid window');
      }
      // Defer exact application until settings object is built below; we also pre-apply here for safety.
      try { if (!window.__SKAI_TUNED_WINDOW__) { window.__SKAI_TUNED_WINDOW__ = tunedW|0; } } catch(_){}
      window.__SKAI_AT_SETTINGS_APPLIED__ = true;
    })();
  }

  // Settings (prefer visible control, fall back safely)
  function gv(id, def) {
    /* CHG: ES5-safe vars instead of const.
       Reason: const is ES6.
       Benefit: prevents parse-time SyntaxError. */
    var el =
      document.getElementById(id) ||
      document.getElementById(id + '_ui') ||
      document.querySelector('[id="' + id + '"]:not([type="hidden"])');
    var v = (el && el.value != null) ? String(el.value).trim() : '';
    return v !== '' ? v : def;
  }

  // Acquire draws BEFORE settings so we can size defaults to the database (no hidden caps)
  // Cache once globally to avoid const re-declarations across blocks.
  (function(){
    var _src = Array.isArray(window.draws)
      ? window.draws
      : (Array.isArray(window.__le_lastFiltered) ? window.__le_lastFiltered : []);
    if (!window.__SKAI_RAW_DRAWS__) window.__SKAI_RAW_DRAWS__ = _src;
  })();
  var rawDraws = window.__SKAI_RAW_DRAWS__;
  var __HIST__ = (Array.isArray(rawDraws) ? rawDraws.length : 0) | 0;
  var __DEFAULT_W__ = Math.max(5, (__HIST__ > 0 ? (__HIST__ - 1) : 50));

  /* CHG: ES5-safe settings declaration (var instead of const).
     Reason: const is ES6.
     Benefit: keeps same settings values without syntax risk. */
  var settings = {
    epochs:       Math.max(1, Math.min(500, parseInt(gv('epochs',       '90'), 10) || 90)),
    batchSize:    Math.max(1, Math.min(512, parseInt(gv('batchSize',    '32'),  10) || 32)),
    addSHFeature: true,
    distillEps:   0.05,
    dropout:      Math.max(0, Math.min(0.6,  parseFloat(gv('dropoutRate','0.25')) || 0.25)),
    lr:           Math.max(1e-6, Math.min(1e-1, parseFloat(gv('learningRate','0.0008')) || 0.0008)),
    layers:       Math.max(0, Math.min(8,    parseInt(gv('hiddenLayers','2'),   10) || 2)),
    recencyDecay: Math.max(0, Math.min(0.999, parseFloat(gv('recencyDecay','0.95')) || 0.95)),
    blend:        (function(){
                     var val;
                     
                     // FIX: ALWAYS prefer the visible slider (user's current choice) over hidden input
                     // The slider is the source of truth for user intent
                     var slider = document.getElementById('skai-blend-range');
                     if (slider && slider.value !== '') {
                       val = parseFloat(slider.value) / 100;
                     } else {
                       // Fallback: check hidden blendRatio input (only if slider doesn't exist)
                       var raw = gv('blendRatio','');
                       if (raw !== '') {
                         val = parseFloat(raw);
                       }
                     }

                     /* CHG: ES5 finite check */
                     if (!isFinite(val)) { val = 0.40; }  // Default to 40% (HTML default)
                     if (val < 0) { val = 0; }
                     if (val > 1) { val = 1; }

                     // DEBUG: Log the blend value being used
                     // TODO: Remove after verification
                     try { console.log('[SKAI] Settings.blend initialized to:', val, '(slider=' + (slider ? slider.value : 'null') + ')'); } catch(_){}

                     return val;
                   })(),
    gapScale:     Math.max(0, Math.min(1,     parseFloat(gv('gapScale','0.20'))   || 0.20)),
    gap:          Math.max(0, Math.min(1,     parseFloat(gv('gapScale','0.20'))   || 0.20)), // back-compat alias
    laplaceK:     (function(){
                     var k = parseInt(gv('laplaceK','1'),10);
                     if (!isFinite(k)) k = 1;
                     if (k < 0) k = 0;
                     if (k > 2) k = 2;
                     return k;
                   })(),
    skipGamma:    (function(){
                     var g = parseFloat(gv('skipGamma','0.20'));
                     if (!isFinite(g)) g = 0.20;
                     if (g < 0) g = 0;
                     if (g > 1) g = 1;
                     return g;
                   })(),
    // Default window = entire DB (hist-1), and clamp ONLY to the DB length (no arbitrary max caps)
    windowSize:   (function(){
                     var ui = parseInt(gv('windowSize', String(__DEFAULT_W__)), 10);
                     if (!isFinite(ui) || ui <= 0) ui = __DEFAULT_W__;
                     var hi = Math.max(5, (__HIST__ > 0 ? (__HIST__ - 1) : ui));
                     return Math.max(5, Math.min(hi, ui)) | 0;
                   })(),

    // === Advanced ensemble & calibration controls ===
    ensembleSeeds: (gv('ensembleSeeds','1337,2029,4093')||'')
                     .split(',')
                     .map(function(s){ return parseInt(s.trim(),10); })
                     .filter(function(x){ return isFinite(x); }),
    windowEnsemble: (gv('windowEnsemble','0.9,1,1.1')||'')
                      .split(',')
                      .map(function(s){ return parseFloat(s.trim()); })
                      .filter(function(x){ return isFinite(x); }),
    useGateMeta: true,
    calibrateTemp: true
  };

  // Enforce tuned window if present
  (function applyTuned() {
    /* CHG: Validate + clamp tuned window again at the final enforcement point.
       Reason: downstream settings must never accept invalid / out-of-range tuned values.
       Benefit: prevents bad server values from overriding DB-sized defaults. */
    var sv = window.SKAI_SERVER || {};
    var tunedW = (+sv.usedWindow) || (+sv.bestWindow) || settings.windowSize;

    if (isFinite(tunedW) && tunedW >= 2) {
      var hi = Math.max(5, (__HIST__ > 0 ? (__HIST__ - 1) : tunedW));
      settings.windowSize = Math.max(5, Math.min(hi, tunedW)) | 0;
    }
  })();

  // Data prep begin / done
  try { window.dispatchEvent(new Event('skai:dataprep:begin')); } catch(_){}
  /* CHG: var instead of const.
     Reason: ES5 compatibility.
     Benefit: prevents -unexpected token const- in older browsers. */
  var ds = window.buildSkaiDataset(rawDraws, settings);
  try { window.dispatchEvent(new Event('skai:dataprep:done')); } catch(_){}

  // Guard: dataset must be large enough (HARD ASSERT)
  window.SKAI_assert(
    !!ds && Array.isArray(ds.xs) && ds.xs.length >= 5,
    'DS_TOO_SMALL',
    'Dataset too small (have ' + ((ds && ds.xs) ? ds.xs.length : 0) + ', need = 5)'
  );
  // If the assert failed, it already threw and signaled stop; do not `return` here.

  /* CHG: var + isFinite.
     Reason/Benefit: ES5-safe sizing and validation while preserving logic. */
  var n = ds.xs.length | 0;
  var outDim = (ds.domain | 0) || (ds.ys && ds.ys[0] ? (ds.ys[0].length | 0) : 0);
  if (!isFinite(outDim) || outDim <= 0) {
    try { SKAI_emit('skai:analysis-stop', { detail:{ reason:'invalid-output-dim', have: outDim } }); } catch(_){}
    window.__SKAI_RUNNING__ = false;
    return;
  }

  // ====== Ensemble training (seeds) + window-ensemble inference + temperature calibration ======
  xsT = tfw.tensor2d(ds.xs, [n, ds.inputDim], 'float32');
  ysT = tfw.tensor2d(ds.ys, [n, outDim],      'float32');

  var seeds = (Array.isArray(settings.ensembleSeeds) && settings.ensembleSeeds.length)
    ? settings.ensembleSeeds : [1337];

  var winFactors = (Array.isArray(settings.windowEnsemble) && settings.windowEnsemble.length)
    ? settings.windowEnsemble : [1];

  // Distribute total epochs across seeds exactly (sum == chosen epochs)
  var totalEpochsChosen = Math.max(1, (+settings.epochs|0) || 50);
  var S = Math.max(1, seeds.length|0);
  var base = Math.floor(totalEpochsChosen / S);
  var rem  = totalEpochsChosen % S;
  var per  = new Array(S);
  for (var i=0;i<S;i++) per[i] = base + (i < rem ? 1 : 0);

  var models = [];

  try {
    if (typeof ensureProgressAPI === 'function') { ensureProgressAPI().set(62, SKAI_msg('trainingMain')); }
    else if (window.SKAI_Progress && typeof SKAI_Progress.set === 'function') { SKAI_Progress.set(62, SKAI_msg('trainingMain')); }
  } catch(_) {}

  // Unified emission path (shim guarantees CustomEvent + {detail})
  try { SKAI_emit('skai:ml:start', { detail: {} }); } catch(_) {}

  // CHG: ES5-safe Object.assign shim scoped to this block
    function __skaiAssign__(){
    var out = {};
    for (var i=0;i<arguments.length;i++){
      var src = arguments[i] || {};
      for (var k in src){
        if (Object.prototype.hasOwnProperty.call(src, k)) out[k] = src[k];
      }
    }
    return out;
  }

  // CHG: removed stray tau guard here.
  // Reason: tau is defined later inside the calibration block.
  // Benefit: prevents ReferenceError in strict ES5/module runtimes.

  var offsetSoFar = 0;
  for (var si=0; si<S; si++){
    var seed = seeds[si] | 0;
    var modelCfg = __skaiAssign__({}, settings, { SEED: seed, deterministic: true });
    var m = window.buildSkaiModel(modelCfg, ds.inputDim, outDim);
    var epochsThis = Math.max(1, per[si]|0);
    var fitCfg = __skaiAssign__({}, settings, {
      epochs: epochsThis,
      __phaseLabel: 'Main numbers \u2022 seed ' + seed,
      __epochOffset: offsetSoFar,        // NEW: tell the helper how many have been completed
      __totalEpochs: totalEpochsChosen,  // NEW: tell the helper the overall target
      deterministic: true
    });

    await window.fitWithValidation(
      m,
      { xsTensor: xsT, ysTensor: ysT },
      fitCfg
    );

    offsetSoFar += epochsThis;
    models.push(m);
  }

   // ? Publish to window (REQUIRED ? we use these in scoring)
  try {
    window.SKAI_MODELS      = models;
    window.SKAI_OUT_DIM     = outDim;
    window.SKAI_DS_N        = n;
    window.SKAI_DS          = ds;
    window.SKAI_WIN_FACTORS = winFactors;
    window.SKAI_SETTINGS    = settings;
    window.SKAI_RAW_DRAWS   = rawDraws;
  } catch(_){}

  // --- Helpers: clamp/logit/sigmoid ---
  function clamp01(p){
    p = +p;
    if (!isFinite(p)) return 0.5;
    if (p <= 1e-6) return 1e-6;
    if (p >= 1 - 1e-6) return 1 - 1e-6;
    return p;
  }
  function logit(p){
    p = clamp01(p);
    return Math.log(p / (1 - p));
  }
  function sigmoid(z){
    if (z >= 0){ var ez = Math.exp(-z); return 1 / (1 + ez); }
    var ez2 = Math.exp(z); return ez2 / (1 + ez2);
  }

  // CHG: Auto-tune Skip/Hit knobs BEFORE inference (no leakage; uses past->future splits).
  // Tunes only settings.skipGamma and settings.laplaceK, using buildSkaiCurrentVector() + recall@20 on recent draws.
  function __skaiRecallAtK__(ranked, winners, K){
    var set = {};
    var i;
    for (i=0;i<Math.min(K, ranked.length);i++){ set[ranked[i]] = 1; }
    var hit = 0;
    for (i=0;i<winners.length;i++){ if (set[winners[i]]) hit++; }
    return winners.length ? (hit / winners.length) : 0;
  }

  function __skaiRankBySkipPrior__(skipPrior){
    var idx = [];
    for (var i=0;i<skipPrior.length;i++){ idx.push(i); }
    idx.sort(function(a,b){
      var da = +skipPrior[a]; var db = +skipPrior[b];
      if (!isFinite(da)) da = -1e9;
      if (!isFinite(db)) db = -1e9;
      return db - da; // desc
    });
    return idx;
  }

  function __skaiAutoTuneSkipParams__(rawDraws, settings){
    try {
      rawDraws = Array.isArray(rawDraws) ? rawDraws : [];
      if (rawDraws.length < 60) return settings;

      var meta = window.SKAI_META || {};
      var pick = (+meta.pick > 0)
        ? (+meta.pick)
        : (Array.isArray(rawDraws[0] && rawDraws[0].numbers) ? rawDraws[0].numbers.length : 5);

      var K = 20;
      var horizon = Math.min(12, Math.max(6, Math.floor(rawDraws.length * 0.08))); // 6..12
      var trainEnd = rawDraws.length - horizon;
      if (trainEnd < 40) return settings;

      var gammaGrid = [0.10, 0.15, 0.20, 0.25, 0.30];
      var laplaceGrid = [0.5, 1.0, 1.5, 2.0];

      var best = null;

      for (var gi=0; gi<gammaGrid.length; gi++){
        for (var li=0; li<laplaceGrid.length; li++){

          var cfgBase = {};
          for (var k in settings){
            if (Object.prototype.hasOwnProperty.call(settings, k)) { cfgBase[k] = settings[k]; }
          }
          cfgBase.skipGamma = gammaGrid[gi];
          cfgBase.laplaceK  = laplaceGrid[li];

          var recallSum = 0, rounds = 0;

          // rolling: validate each of last 'horizon' draws using history before it
          for (var t=trainEnd; t<rawDraws.length; t++){
            var trainSlice = rawDraws.slice(0, t);
            var valDraw = rawDraws[t];

            var vec = window.buildSkaiCurrentVector(trainSlice, cfgBase);
            if (!vec || !vec.skipPrior || !vec.skipPrior.length) continue;

            // CHG: evaluate using FULL SKAI ranking (not skip-only)
var fullRank = (function(){
  var v = window.buildSkaiCurrentVector(trainSlice, cfgBase);
  if (!v || !v.x) return [];
  // Use the SAME downstream ranking logic SKAI uses later
  return (typeof window.__SKAI_RANK_FROM_VECTOR__ === 'function')
    ? window.__SKAI_RANK_FROM_VECTOR__(v, cfgBase)
    : __skaiRankBySkipPrior__(v.skipPrior);
})();
var rankedNums = fullRank;


            var winners = (typeof numsOf === 'function') ? (numsOf(valDraw) || []) : [];
            // Fallback: try common shapes
            if (!winners.length){
              var n = (valDraw && valDraw.numbers) ? valDraw.numbers : (valDraw && valDraw.main) ? valDraw.main : [];
              winners = Array.isArray(n) ? n.slice(0, pick) : [];
            }
            winners = Array.isArray(winners) ? winners.slice(0, pick) : [];
            if (!winners.length) continue;

            recallSum += __skaiRecallAtK__(rankedNums, winners, K);
            rounds++;
          }

          if (!rounds) continue;
          var recall = recallSum / rounds;

          if (!best || recall > best.recall){
            best = { recall: recall, skipGamma: cfgBase.skipGamma, laplaceK: cfgBase.laplaceK };
          }
        }
      }

      if (best){
        var tuned = {};
        for (var kk in settings){
          if (Object.prototype.hasOwnProperty.call(settings, kk)) { tuned[kk] = settings[kk]; }
        }
        tuned.skipGamma = best.skipGamma;
        tuned.laplaceK  = best.laplaceK;
        tuned.__tunedSkip = { recallAt20: best.recall, skipGamma: best.skipGamma, laplaceK: best.laplaceK };
        return tuned;
      }

      return settings;
    } catch(_){
      return settings;
    }
  }

  // NEW: Auto-tune AI-vs-Skip blend (settings.blend interpreted as AI share alpha)
  // Goal: maximize Recall@20 on recent rolling splits using the *same* model ensemble already trained.
  async function __skaiAutoTuneBlendAlpha__(rawDraws, settings, models, outDim, tfw){
    try {
      rawDraws = Array.isArray(rawDraws) ? rawDraws : [];
      settings = settings || {};
      models = Array.isArray(models) ? models : [];

      if (!rawDraws.length || rawDraws.length < 80) return settings;
      if (!models.length || !tfw || !tfw.tensor2d) return settings;
      if (!outDim || outDim < 5) return settings;

      var meta = window.SKAI_META || {};
      var pick = (+meta.pick > 0)
        ? (+meta.pick)
        : (Array.isArray(rawDraws[0] && rawDraws[0].numbers) ? rawDraws[0].numbers.length : 5);

      // NOTE: Regular lotteries show Top 20; tune specifically for Recall@20.
      var K = 20;

      // Horizon: last 8..14 draws (slightly larger than skip tuner; still fast)
      var horizon = Math.min(14, Math.max(8, Math.floor(rawDraws.length * 0.10)));
      var trainEnd = rawDraws.length - horizon;
      if (trainEnd < 60) return settings;

      // Alpha grid: AI share. (Skip share = 1 - alpha)
      var alphaGrid = [0.35, 0.45, 0.55, 0.65, 0.75, 0.85];

      // Helper: rank numbers by the same blend form used in your scorer:
      // score = (wAI * aiAdj) * exp(wSH * (prior - 0.5))   (bias form)
      function rankByAlpha(probsArr, priorArr, alpha, allowZero){
        var dom = Math.max(
          (probsArr && probsArr.length) ? probsArr.length : 0,
          (priorArr && priorArr.length) ? priorArr.length : 0
        );

        var list = [];
        for (var i=0; i<dom; i++){
          var num = allowZero ? i : (i + 1);
          var ai = (typeof probsArr[i] === 'number' && isFinite(probsArr[i])) ? probsArr[i] : 0;
          var pr = (typeof priorArr[i] === 'number' && isFinite(priorArr[i])) ? priorArr[i] : 0;

          // Mirror your blend idea: alpha controls AI share, (1-alpha) controls Skip bias
          var bias = Math.exp((1 - alpha) * (pr - 0.5));
          var sc = Math.max(0, (alpha * ai) * bias);

          list.push({ num: num, score: sc });
        }

        list.sort(function(a,b){
          if (b.score !== a.score) return b.score - a.score;
          return a.num - b.num;
        });

        var ranked = [];
        for (var r=0; r<list.length; r++){ ranked.push(list[r].num); }
        return ranked;
      }

      // Helper: predict ensemble probs for a single vector x (no training, uses trained models)
      async function predictEnsemble(xVec){
        var sum = new Array(outDim);
        for (var i0=0; i0<outDim; i0++) sum[i0] = 0;

        for (var mi=0; mi<models.length; mi++){
          var m = models[mi];
          var xNow = tfw.tensor2d([xVec], [1, xVec.length], 'float32');
          var y = m.predict(xNow);
          var p = await y.data();

          for (var j=0; j<outDim; j++){
            sum[j] += (p[j] || 0);
          }

          try { y.dispose && y.dispose(); } catch(_){}
          try { xNow.dispose && xNow.dispose(); } catch(_){}
        }

        var denom = models.length || 1;
        for (var k=0; k<outDim; k++){ sum[k] = sum[k] / denom; }
        return sum;
      }

      var best = null;

      for (var ai=0; ai<alphaGrid.length; ai++){
        var alpha = alphaGrid[ai];

        var recallSum = 0, rounds = 0;

        for (var t=trainEnd; t<rawDraws.length; t++){
          var trainSlice = rawDraws.slice(0, t);
          var valDraw = rawDraws[t];

          // Build prior + features from history only
          var vec = window.buildSkaiCurrentVector(trainSlice, settings);
          if (!vec || !vec.x || !vec.x.length) continue;

          var probs = await predictEnsemble(vec.x);

          // Winner extraction (same fallback logic you already use)
          var winners = (typeof numsOf === 'function') ? (numsOf(valDraw) || []) : [];
          if (!winners.length){
            var n = (valDraw && valDraw.numbers) ? valDraw.numbers : (valDraw && valDraw.main) ? valDraw.main : [];
            winners = Array.isArray(n) ? n.slice(0, pick) : [];
          }
          winners = Array.isArray(winners) ? winners.slice(0, pick) : [];
          if (!winners.length) continue;

          var allowZero = (typeof meta.allowZero === 'boolean')
            ? (meta.allowZero && !meta.hasExtraBall)
            : ((+meta.domain > 0 && +meta.domain <= 9) && !meta.hasExtraBall);

          var rankedNums = rankByAlpha(probs, vec.skipPrior || [], alpha, allowZero);

          recallSum += __skaiRecallAtK__(rankedNums, winners, K);
          rounds++;
        }

        if (!rounds) continue;
        var recall = recallSum / rounds;

        if (!best || recall > best.recall){
          best = { recall: recall, alpha: alpha };
        }
      }

      if (best){
        var tuned = {};
        for (var kk in settings){
          if (Object.prototype.hasOwnProperty.call(settings, kk)) { tuned[kk] = settings[kk]; }
        }

        // Store alpha as a 0..1 number. Your main blend code already normalizes 0..1 or 0..100.
        tuned.blend = best.alpha;

        tuned.__tunedBlend = {
          recallAt20: best.recall,
          alpha: best.alpha
        };

        return tuned;
      }

      return settings;
    } catch(_){
      return settings;
    }
  }




  var tunedSettings = __skaiAutoTuneSkipParams__(rawDraws, settings);

  // NEW: auto-tune AI-vs-Skip blend to improve Recall@20 (Top Picks coverage)
  tunedSettings = await __skaiAutoTuneBlendAlpha__(rawDraws, tunedSettings, models, outDim, tfw);

  // Flag used by your UI label ("• Auto-tuned")
  try { window.__SKAI_TUNED_THIS_RUN__ = true; } catch(_){}


  // --- Build current feature vectors for each window factor ---
  var nowVectors = (function(){
    var list = [];
    for (var fi = 0, F = winFactors.length; fi !== F; fi++){
      var f = winFactors[fi];
      var wAdj = Math.max(5, Math.min(2000, Math.round(tunedSettings.windowSize * f)));

      var cfg = {};
      for (var k in tunedSettings){
        if (Object.prototype.hasOwnProperty.call(tunedSettings, k)) { cfg[k] = tunedSettings[k]; }
      }
      cfg.windowSize = wAdj;

      var vec = window.buildSkaiCurrentVector(rawDraws, cfg);
      list.push({ f: f, wAdj: wAdj, x: vec.x });
    }
    return list;
  })();

  // --- Predict with ensemble (average over seeds and window factors) ---
  var probsArr = new Array(outDim);
  for (var i0 = 0, L0 = outDim; i0 !== L0; i0++){ probsArr[i0] = 0; }

  for (var mi = 0, M = models.length; mi !== M; mi++){
    var m = models[mi];
    for (var nvi = 0, NV = nowVectors.length; nvi !== NV; nvi++){
      var nv = nowVectors[nvi];
      var xNow = tfw.tensor2d([nv.x], [1, nv.x.length], "float32");
      var yPred = m.predict(xNow);
      var p = await yPred.data();
      for (var i1 = 0, L1 = outDim; i1 !== L1; i1++){ probsArr[i1] += (p[i1] || 0); }
      try { yPred.dispose && yPred.dispose(); } catch(_){}
      try { xNow.dispose && xNow.dispose(); } catch(_){}
    }
  }
  var denom = (models.length * nowVectors.length) || 1;
  for (var i2 = 0, L2 = outDim; i2 !== L2; i2++){ probsArr[i2] = probsArr[i2] / denom; }

  // --- Temperature calibration on a small validation tail (optional) ---
  if (settings.calibrateTemp){
    try {
      var V = Math.max(30, Math.min(200, Math.floor(0.15 * n)));
      if (V >= 5){
        var tailX = tfw.tensor2d(ds.xs.slice(n - V), [V, ds.inputDim], "float32");
        var tailY = ds.ys.slice(n - V);

        var pVal = new Array(V);
        for (var r0 = 0; r0 !== V; r0++){
          pVal[r0] = new Array(outDim);
          for (var c0 = 0; c0 !== outDim; c0++){ pVal[r0][c0] = 0; }
        }

        for (var mi2 = 0, M2 = models.length; mi2 !== M2; mi2++){
          var m2 = models[mi2];
          var pred = m2.predict(tailX);
          var arr = await pred.array();
          for (var r1 = 0; r1 !== V; r1++){
            for (var c1 = 0; c1 !== outDim; c1++){
              pVal[r1][c1] += (arr[r1][c1] || 0);
            }
          }
          try { pred.dispose && pred.dispose(); } catch(_){}
        }
        try { tailX.dispose && tailX.dispose(); } catch(_){}
        for (var r2 = 0; r2 !== V; r2++){
          for (var c2 = 0; c2 !== outDim; c2++){ pVal[r2][c2] /= models.length; }
        }

        function learnTempSigmoid(pMat, yMat){
          var tau = 1.0;
          var iters = 50, lr = 0.05;
          var clampTau = function(v){ return Math.max(0.25, Math.min(4.0, v)); }; // stability band
          for (var t = 0; t !== iters; t++){
            var dL = 0;
            for (var rr = 0, R = pMat.length; rr !== R; rr++){
              var pr = pMat[rr], yr = yMat[rr];
              for (var jj = 0, JJ = pr.length; jj !== JJ; jj++){
                var pv = clamp01(pr[jj]);
                var z  = logit(pv);
                var zt = z / tau;
                var q  = sigmoid(zt);
                // gradient wrt tau (bounded)
                var g = (q - (yr[jj] || 0)) * (q * (1 - q)) * (-z / (tau * tau));
                // cap contribution to prevent blow-ups on extreme logits
                if (g > 5) g = 5; else if (g < -5) g = -5;
                dL += g;
              }
            }
            var step = lr * dL;
            tau = clampTau(tau - step);
            /* CHG: ES5-safe finite check.
               Reason: Number.isFinite is ES6 and may be undefined in some runtimes.
               Benefit: same guard behavior with wider compatibility. */
            if (!isFinite(tau)) { tau = 1.0; break; }
            if (Math.abs(step) < 1e-4) break; // early convergence
          }
          return tau;
        }

        var tau = learnTempSigmoid(pVal, tailY);
        if (isFinite(tau) && tau > 0.1 && tau < 10){
          for (var i3 = 0, L3 = probsArr.length; i3 !== L3; i3++){
            var zAvg = logit(probsArr[i3]);
            if (!isFinite(zAvg)) continue;
            probsArr[i3] = sigmoid(zAvg / tau);
          }
        }
      }
    } catch (e) {}
  }

  // dispose models & tensors (main head)
  try { xsT && xsT.dispose && xsT.dispose(); } catch(_){}
  try { ysT && ysT.dispose && ysT.dispose(); } catch(_){}
  for (var mi3 = 0, M3 = models.length; mi3 !== M3; mi3++){
    try { models[mi3].dispose && models[mi3].dispose(); } catch(_){}
  }
  try { window.SKAI_MODELS = null; } catch(_){}

  // [CHANGED] REQUIRED: make probs available to the scoring section
  try { window.SKAI_lastProbs = Array.isArray(probsArr) ? probsArr.slice() : []; } catch(_){}

  // [ADDED] Signal that learning actually completed (used by scoring script guards)
  try { window.__SKAI_LEARNED__ = (Array.isArray(window.SKAI_lastProbs) && window.SKAI_lastProbs.length > 0); } catch(_){}
  try { window.dispatchEvent(new Event('skai:learned')); } catch(_){}

  // NEW: kick off extra-ball ML head (Powerball / EuroMillions, etc.)
  // This uses the same settings passed into runSkaiML so the extra head
  // stays in sync with the main head.
  try {
    if (typeof window.SKAI_runExtra === 'function') {
      window.SKAI_runExtra(settings || {});
    }
  } catch (_){}

    }); // end async runSkaiML IIFE assignment
  } catch (e) {
    // Legacy fallback: expose a no-op runner that surfaces a clear error.
    window.runSkaiML = function(){
      try { console.warn('[SKAI] async/await not supported in this browser.'); } catch(_){}
      try { if (typeof window.SKAI_emit === 'function') { window.SKAI_emit('skai:ml:error', { detail:{ message:'Browser does not support async ML runner.' } }); } } catch(_){}
    };
  }

} // end singleton guard
</script>

<script>
; (function(){
  // expose callable scorer so we can run it after ML completes
  if (typeof window.SKAI_scoreAndRender !== 'function') {
  window.SKAI_scoreAndRender = function SKAI_scoreAndRender(){
  // --- ES5 shims -------------------------------------------------
  function isFiniteNum(v){ return typeof v === 'number' && isFinite(v); }
  function emitEvt(name){
    try {
      if (typeof window.Event === 'function') {
        window.dispatchEvent(new Event(name));
      } else {
        var ev = document.createEvent('Event');
        ev.initEvent(name, true, true);
        window.dispatchEvent(ev);
      }
    } catch(_){}
  }

  // CHG: strict-safe emitter alias for this block
  var SKAI_emitSafe = (typeof window.SKAI_emit === 'function') ? window.SKAI_emit : function(){};


  // Hoisted so later blend loop cannot throw "L is not defined" if braces move.
  // Evidence: L used later in `for (var i0=0; i0<L; i0++)` outside the try.
  var settings = {};
  var ds = null;
  var probs = [];
  var rawDraws = [];
  var meta = {};
  var priorMain = [];
  var allowZero = false;
  var L = 0;

  try {
    // -------------------------------
    // Section 1: Enforce learning + score mains
    // -------------------------------
    settings = window.SKAI_SETTINGS || {};
    ds       = window.SKAI_DS || null;
    probs    = (window.SKAI_lastProbs && window.SKAI_lastProbs.slice) ? window.SKAI_lastProbs.slice() : [];
    rawDraws = Array.isArray(window.SKAI_RAW_DRAWS) ? window.SKAI_RAW_DRAWS
                  : (Array.isArray(window.draws) ? window.draws : []);
    meta     = window.SKAI_META || {};

    // Guards
    var dsOK = !!(ds && Array.isArray(ds.xs) && Array.isArray(ds.ys) && ds.xs.length >= 5 && ds.ys.length === ds.xs.length);
    var pOK  = Array.isArray(probs) && probs.length > 0;
    if (!(dsOK && pOK)) {
      try { (window.SKAI_warn || console.warn)('[SKAI] Scoring skipped: training not ready or dataset missing.'); } catch(_){}
      return;
    }

    // Progress signal
    emitEvt('skai:score:begin');

    // Basics
    var n      = (typeof window.SKAI_DS_N === 'number') ? window.SKAI_DS_N : (ds.xs.length | 0);
    var outDim = (typeof window.SKAI_OUT_DIM === 'number' && window.SKAI_OUT_DIM > 0) ? window.SKAI_OUT_DIM : (probs.length | 0);
    var W      = (settings && settings.windowSize) ? (settings.windowSize | 0) : 50;

// Prior
var nowVec  = window.buildSkaiCurrentVector(rawDraws, settings) || { skipPrior: [] };
priorMain   = Array.isArray(nowVec.skipPrior) ? nowVec.skipPrior : [];

/* ============================================================
   POSITION-SPECIFIC DIGIT PRIORS + BLEND (Pick 3 / Pick 4)
   - Activates only for digit games (domain<=9 and allowZero)
   - Produces:
       window.SKAI_POS_BLEND  : [pos][digit] probability
       window.SKAI_POS_TOPS   : [pos] -> [{num, p}, ...]
       window.SKAI_POS_COMBOS : [{main:[...], score, approxPct}, ...]
   ============================================================ */
try {
  // Detect digit game
  var domainMain = (meta && isFinite(+meta.domain) && +meta.domain > 0) ? (+meta.domain|0) : 0;
  var pickMain   = (meta && isFinite(+meta.pick)   && +meta.pick   > 0) ? (+meta.pick|0)   : 0;

  // allowZero already exists in this function later; we can infer digit game defensively:
  var isDigitGame = (domainMain > 0 && domainMain <= 9);

  if (isDigitGame && pickMain >= 2 && pickMain <= 6 && Array.isArray(rawDraws) && rawDraws.length >= 10) {

    // Config: use the same window + decay approach SKAI uses elsewhere
    var hist = rawDraws.length | 0;

    var Wpos = +settings.windowSize;
    if (!isFinite(Wpos) || Wpos <= 0) Wpos = Math.max(10, hist - 1);
    Wpos = Math.max(10, Math.min((Wpos|0), Math.max(10, hist)));

    var decayPos = +settings.recencyDecay;
    if (!isFinite(decayPos)) decayPos = 0.90;
    if (decayPos < 0) decayPos = 0;
    if (decayPos > 1) decayPos = 1;

    // Blend weight between ML and position prior
    // 0 = pure ML (no position effect), 1 = pure position prior
    var posBlendLambda = Number(settings.positionBlend);
    if (!isFinite(posBlendLambda)) posBlendLambda = 0.55;
    if (posBlendLambda < 0) posBlendLambda = 0;
    if (posBlendLambda > 1) posBlendLambda = 1;

    // Domain digits: 0..9
    var domDigits = 10;

    // Helpers (ES5-safe)
    function numsOf(d){
      if (Array.isArray(d)) return d;
      if (d && Array.isArray(d.numbers)) return d.numbers;
      if (d && Array.isArray(d.nums)) return d.nums;
      return [];
    }
    function clamp01(x){
      x = +x;
      if (!isFinite(x)) return 0;
      if (x < 0) return 0;
      if (x > 1) return 1;
      return x;
    }

    // Build weighted counts per position with Laplace smoothing
    var posCounts = [];
    for (var p = 0; p < pickMain; p++){
      var row = new Array(domDigits);
      for (var d0 = 0; d0 < domDigits; d0++) row[d0] = 1; // Laplace(1)
      posCounts.push(row);
    }

    var startPos = Math.max(0, hist - Wpos);
    var endPos   = hist;

    for (var iPos = startPos; iPos < endPos; iPos++){
      var draw = rawDraws[iPos];
      var arr  = numsOf(draw);
      if (!arr || !arr.length) continue;

      // Newest draw gets weight 1, older decays
      var age = (endPos - 1 - iPos) | 0;
      if (age < 0) age = 0;
      var wgt = (decayPos === 1) ? 1 : Math.pow(decayPos, age);

      for (var pp = 0; pp < pickMain; pp++){
        var v = arr[pp];
        if (!isFinite(v)) continue;
        v = (v|0);
        if (v < 0 || v > 9) continue;
        posCounts[pp][v] += wgt;
      }
    }

    // Normalize to priors
    var posPrior = [];
    for (var p2 = 0; p2 < pickMain; p2++){
      var sum = 0;
      for (var d1 = 0; d1 < domDigits; d1++) sum += posCounts[p2][d1];
      var pr = new Array(domDigits);
      if (sum > 0) {
        for (var d2 = 0; d2 < domDigits; d2++) pr[d2] = posCounts[p2][d2] / sum;
      } else {
        for (var d3 = 0; d3 < domDigits; d3++) pr[d3] = 1 / domDigits;
      }
      posPrior.push(pr);
    }

    // ------------------------------------------------------------
    // CHG: Support true per-position ML output (Pick×10)
    // If probs.length === pickMain*10, interpret it as concatenated heads:
    //   [pos0(10), pos1(10), ...]
    // Otherwise fall back to legacy single 10-way ML vector.
    // Blend becomes: pos-ML ⊕ pos-prior (multiplicative fusion) then renorm.
    // ------------------------------------------------------------

    var havePosML = (Array.isArray(probs) && probs.length === (pickMain * domDigits));
    var posML = null;

    if (havePosML) {
      posML = new Array(pickMain);
      for (var pML = 0; pML < pickMain; pML++){
        var row = new Array(domDigits);
        var sRow = 0;
        for (var dML = 0; dML < domDigits; dML++){
          var pv2 = +probs[(pML * domDigits) + dML];
          if (!isFinite(pv2) || pv2 < 0) pv2 = 0;
          row[dML] = pv2;
          sRow += pv2;
        }
        // normalize head defensively
        if (sRow > 0) {
          for (var dML2 = 0; dML2 < domDigits; dML2++) row[dML2] /= sRow;
        } else {
          for (var dML3 = 0; dML3 < domDigits; dML3++) row[dML3] = 1 / domDigits;
        }
        posML[pML] = row;
      }
    }

    // Legacy ML vector (single 10-way), used only if no posML
    var ml = null;
    if (!havePosML) {
      ml = new Array(domDigits);
      for (var d4 = 0; d4 < domDigits; d4++){
        var pv = (Array.isArray(probs) && isFinite(probs[d4])) ? +probs[d4] : (1 / domDigits);
        if (pv < 1e-9) pv = 1e-9;
        ml[d4] = pv;
      }
      var mlSum = 0;
      for (var d5 = 0; d5 < domDigits; d5++) mlSum += ml[d5];
      if (mlSum > 0) { for (var d6 = 0; d6 < domDigits; d6++) ml[d6] /= mlSum; }
    }

    // pos-ML ⊕ pos-prior (multiplicative fusion); use posBlendLambda as prior weight
    // posBlendLambda=0 => pure ML, posBlendLambda=1 => pure position prior
    var wPrior = posBlendLambda;
    var wML    = 1 - wPrior;

    var posBlend = [];
    for (var p3 = 0; p3 < pickMain; p3++){
      var vec = new Array(domDigits);
      var s2 = 0;

      for (var d7 = 0; d7 < domDigits; d7++){
        var pml = havePosML ? (posML[p3][d7]) : (ml[d7]);
        var ppr = posPrior[p3][d7];

        // clamp away from 0 (prevents collapse)
        if (!(pml > 0)) pml = 1e-12;
        if (!(ppr > 0)) ppr = 1e-12;

        // ⊕ implemented as product of powered terms, then renormalize
        var b = Math.pow(pml, wML) * Math.pow(ppr, wPrior);
        if (b < 1e-12) b = 1e-12;

        vec[d7] = b;
        s2 += b;
      }

      if (s2 > 0) { for (var d8 = 0; d8 < domDigits; d8++) vec[d8] /= s2; }
      posBlend.push(vec);
    }

    // Build tops per position (top 5)
    function topN(vec, N){
      var tmp = [];
      for (var dd = 0; dd < vec.length; dd++){
        tmp.push({ num: dd, p: +vec[dd] });
      }
      tmp.sort(function(a,b){ return (b.p - a.p); });
      return tmp.slice(0, N);
    }

    var tops = [];
    for (var p4 = 0; p4 < pickMain; p4++){
      tops.push(topN(posBlend[p4], 5));
    }

    // ------------------------------------------------------------
    // CHG: Dynamic per-position pool size for combo generation
    // - Legacy (global ML): 4 per position (unchanged)
    // - True pos-ML (Pick×10): 6 per position by default
    // - Safety cap: keep total expansions under a hard limit
    // ------------------------------------------------------------
    var _havePosML = (typeof havePosML !== 'undefined') ? !!havePosML : false;

    var poolK = _havePosML ? 6 : 4;       // default behavior
    var MAX_ENUM = 5000;                  // hard safety cap

    // shrink poolK if K^pickMain would exceed MAX_ENUM
    function powInt(a, b){
      var r = 1;
      for (var i0 = 0; i0 < b; i0++) r *= a;
      return r;
    }
    while (pickMain >= 2 && powInt(poolK, pickMain) > MAX_ENUM && poolK > 2) poolK--;

    // Generate top combos using dynamic poolK
    var perPosPool = [];
    for (var p5 = 0; p5 < pickMain; p5++){
      perPosPool.push(topN(posBlend[p5], poolK));
    }

    var combos = [];
    function pushCombo(mainArr, score){
      combos.push({ main: mainArr.slice(), score: +score });
    }

    if (pickMain === 2){
      for (var a2 = 0; a2 < perPosPool[0].length; a2++){
        for (var b2 = 0; b2 < perPosPool[1].length; b2++){
          var A2 = perPosPool[0][a2], B2 = perPosPool[1][b2];
          pushCombo([A2.num, B2.num], A2.p * B2.p);
        }
      }
    } else if (pickMain === 3){
      for (var a3 = 0; a3 < perPosPool[0].length; a3++){
        for (var b3 = 0; b3 < perPosPool[1].length; b3++){
          for (var c3 = 0; c3 < perPosPool[2].length; c3++){
            var A3 = perPosPool[0][a3], B3 = perPosPool[1][b3], C3 = perPosPool[2][c3];
            pushCombo([A3.num, B3.num, C3.num], A3.p * B3.p * C3.p);
          }
        }
      }
    } else if (pickMain === 4){
      for (var a4 = 0; a4 < perPosPool[0].length; a4++){
        for (var b4 = 0; b4 < perPosPool[1].length; b4++){
          for (var c4 = 0; c4 < perPosPool[2].length; c4++){
            for (var d4b = 0; d4b < perPosPool[3].length; d4b++){
              var A4 = perPosPool[0][a4], B4 = perPosPool[1][b4], C4 = perPosPool[2][c4], D4 = perPosPool[3][d4b];
              pushCombo([A4.num, B4.num, C4.num, D4.num], A4.p * B4.p * C4.p * D4.p);
            }
          }
        }
      }
    } else {
      // For pick sizes >4, compute only per-position tops (no combos)
    }


    combos.sort(function(a,b){ return (b.score - a.score); });
    if (combos.length > 12) combos = combos.slice(0, 12);

    // Approx percent display (not a promise; just scaled score)
    // Keep it purely comparative: normalize max to 100.
    var mx = 0;
    for (var ci = 0; ci < combos.length; ci++){
      if (combos[ci].score > mx) mx = combos[ci].score;
    }
    for (var ci2 = 0; ci2 < combos.length; ci2++){
      var pct = (mx > 0) ? (100 * combos[ci2].score / mx) : 0;
      combos[ci2].approxPct = Math.round(pct);
    }

    // Publish
    window.SKAI_POS_BLEND  = posBlend;
    window.SKAI_POS_TOPS   = tops;
    window.SKAI_POS_COMBOS = combos;
  } else {
    // Clear if not a digit game
    window.SKAI_POS_BLEND  = null;
    window.SKAI_POS_TOPS   = null;
    window.SKAI_POS_COMBOS = null;
  }
} catch(_posErr) {
  // fail silent - never block main rendering
}

    // CHG: Thompson Sampling posterior arrays (optional)
    var postA = (nowVec && Array.isArray(nowVec.postA)) ? nowVec.postA : null;
    var postB = (nowVec && Array.isArray(nowVec.postB)) ? nowVec.postB : null;

    // TS controls (defaults ON)
    var tsOn = (settings && settings.thompsonSampling != null) ? !!settings.thompsonSampling : true;

    // CHG: Stability (anti-churn) for UX: EMA blend with last scores
    // 0 = no smoothing; 1 = fully locked to previous (not recommended)
    var stability = (settings && settings.stability != null) ? Number(settings.stability) : NaN;
    if (!isFinite(stability)) stability = 0.35;
    if (stability < 0) stability = 0;
    if (stability > 0.95) stability = 0.95;

    // Persistent score cache (per session)
    window.SKAI_lastScoreByNum = window.SKAI_lastScoreByNum || {};
    var tsStrength = (settings && settings.tsStrength != null) ? Number(settings.tsStrength) : NaN;
    if (!isFinite(tsStrength)) tsStrength = 1.0;
    if (tsStrength < 0) tsStrength = 0;
    if (tsStrength > 3) tsStrength = 3;

    // CHG: Mode -> policy mapping (best-in-class UX)
    // If settings.tsStrength is explicitly set, it remains authoritative.
    // Otherwise, we auto-pick tsStrength based on mode.
    var modeKey = (settings && settings.mode != null) ? String(settings.mode) : "";
    var mk = modeKey.toLowerCase();

    if (!(settings && settings.tsStrength != null)) {
      // Conservative: reduce exploration (more stable ranking)
      if (mk.indexOf("conserv") >= 0) { tsStrength = 0.25; }

      // Balanced: default exploration
      else if (mk.indexOf("balanc") >= 0) { tsStrength = 1.00; }

      // Explorative: increased exploration (more variety)
      else if (mk.indexOf("explor") >= 0) { tsStrength = 1.75; }

      // AI-forward: moderate exploration, more stability
      else if (mk.indexOf("ai") >= 0) { tsStrength = 0.75; }

      // Skip-dominant: moderate exploration, allow more churn
      else if (mk.indexOf("skip") >= 0) { tsStrength = 1.25; }

      // Mixed: between balanced and explorative
      else if (mk.indexOf("mix") >= 0) { tsStrength = 1.20; }

      // Fallback
      else { tsStrength = 1.00; }
    }

    // CHG: Temperature policy for AI probabilities (ranking-safe monotone transform)
    // If settings.aiTemp is explicitly set, it remains authoritative.
    var aiTemp = (settings && settings.aiTemp != null) ? Number(settings.aiTemp) : NaN;
    if (!isFinite(aiTemp) || aiTemp <= 0) {
      // Mode defaults:
      if (mk.indexOf("conserv") >= 0)      { aiTemp = 0.70; }  // sharper
      else if (mk.indexOf("explor") >= 0)  { aiTemp = 1.40; }  // flatter
      else if (mk.indexOf("ai") >= 0)      { aiTemp = 0.85; }  // slightly sharper
      else if (mk.indexOf("skip") >= 0)    { aiTemp = 1.10; }  // slightly flatter
      else if (mk.indexOf("mix") >= 0)     { aiTemp = 1.15; }
      else                                 { aiTemp = 1.00; }  // balanced
    }
    if (aiTemp < 0.25) aiTemp = 0.25;
    if (aiTemp > 3.00) aiTemp = 3.00;

    allowZero   = !!meta.allowZero && !meta.hasExtraBall;
    L           = Math.max(probs.length, priorMain.length || 0);

    // Tail design for gate/ridge
    var V     = Math.max(30, Math.min(200, Math.floor(0.15 * n)));
    var Vsafe = Math.max(0, Math.min(V, n));
    var X = [], Y = [];

    if (Vsafe >= 5) {
      var yVal = ds.ys.slice(n - Vsafe);
      var pVal = new Array(Vsafe);
      for (var r = 0; r < Vsafe; r++) { pVal[r] = probs.slice(); }

      for (var r2 = 0; r2 < Vsafe; r2++) {
        var ai    = pVal[r2];
        var wEdge = Math.max(1, (W | 0) + r2);
        var drawsR = Array.isArray(rawDraws) ? rawDraws.slice(0, Math.min(rawDraws.length, wEdge)) : [];
        var nowR   = window.buildSkaiCurrentVector(drawsR, settings) || {};
        var shR    = Array.isArray(nowR.skipPrior) ? nowR.skipPrior : new Array(ai.length);
        if (!Array.isArray(nowR.skipPrior)) { for (var f0=0; f0<ai.length; f0++){ shR[f0]=0; } }
        var y = yVal[r2] || [];
        for (var j=0; j<ai.length; j++){
          var a  = (+ai[j]) || 0;
          var s  = (+shR[j]) || 0;
          var yj = (+y[j])  || 0;
          X.push([a, s, a*s, 1]);  // intercept
          Y.push(yj);
        }
      }
    }

    // Ridge (ES5)
    function ridgeSolve(Xm, Ym, lambda){
      if (!Xm.length) return [0.7, 0.3, 0.0, 0.0];
      var m = Xm.length, d = Xm[0].length, i, j;
      var XtX = []; for (i=0;i<d;i++){ XtX[i]=[]; for(j=0;j<d;j++){ XtX[i][j]=0; } }
      var XtY = []; for (i=0;i<d;i++){ XtY[i]=0; }
      for (var r3=0; r3<m; r3++){
        var xi = Xm[r3], yi = Ym[r3];
        for (var a=0;a<d;a++){
          XtY[a]+=xi[a]*yi;
          for (var b=0;b<d;b++){ XtX[a][b]+=xi[a]*xi[b]; }
        }
      }
      for (var a2=0;a2<d;a2++){ XtX[a2][a2] += (lambda || 0); }
      var A = [];
      for (i=0;i<d;i++){ A[i]=XtX[i].slice(0); A[i].push(XtY[i]); }
      var dim=d;
      for (var col=0; col<dim; col++){
        var piv=col;
        for (var rr=col+1; rr<dim; rr++){ if (Math.abs(A[rr][col])>Math.abs(A[piv][col])) piv=rr; }
        if (piv!==col){ var tmp=A[col]; A[col]=A[piv]; A[piv]=tmp; }
        var pv=A[col][col] || 1e-9;
        for (var c=col; c<=dim; c++){ A[col][c]/=pv; }
        for (var r4=0; r4<dim; r4++){
          if (r4===col) continue;
          var f=A[r4][col];
          for (var c2=col; c2<=dim; c2++){ A[r4][c2]-=f*A[col][c2]; }
        }
      }
      var w=new Array(dim); for (i=0;i<dim;i++){ w[i]=A[i][dim]; }
      return w;
    }

    // Gate (ES5)
    function gateLearn(Xm, Ym, iters, lr, l2){
      if (!Xm.length) return [0.7, 0.3, 0.0, 0.0];
      var d = Xm[0].length, w=[], t, k;
      for (k=0;k<d;k++){ w[k]=0; }
      function sig(z){ return 1/(1+Math.exp(-z)); }
      iters = iters || 300; lr = lr || 0.05; l2 = l2 || 1e-3;
      for (t=0; t<iters; t++){
        var g=[]; for (k=0;k<d;k++){ g[k]=0; }
        for (var i4=0; i4<Xm.length; i4++){
          var xi = Xm[i4], yi = Ym[i4], z=0;
          for (k=0;k<d;k++) z += w[k]*xi[k];
          var p = sig(z);
          for (k=0;k<d;k++) g[k] += (p-yi)*xi[k];
        }
        for (k=0;k<d;k++){ g[k] = g[k]/Xm.length + l2*w[k]; w[k] -= lr*g[k]; }
      }
      return w;
    }

    // Weights (start from sane defaults)
    var wAI = 0.7, wSH = 0.3, wINT = 0.0, wB = 0.0;
    if (settings.useGateMeta && X.length){
      var wg = gateLearn(X, Y, 300, 0.05, 1e-3);
      wAI = wg[0]; wSH = wg[1]; wINT = wg[2]; wB = wg[3];
    } else if (X.length){
      var wr = ridgeSolve(X, Y, 1e-2);
      wAI = wr[0]; wSH = wr[1]; wINT = wr[2]; wB = wr[3];
    }

    // Harden the weights: if they come out NaN, infinite, or strongly negative,
    // fall back to the safe defaults so the blend behaves sensibly.

    (function(){
      function sane(v, fallback){
        /* CHG: ES5 finite check.
           Reason: Number.isFinite is ES6.
           Benefit: avoids parse/runtime issues, same guard behavior. */
        if (!isFinite(v)) return fallback;
        // If the learner tries to push very negative or huge values, ignore it.
        if (v < -0.1 || v > 5) return fallback;
        return v;
      }
      var defAI  = 0.7, defSH  = 0.3, defINT = 0.0, defB = 0.0;

      wAI  = sane(wAI,  defAI);
      wSH  = sane(wSH,  defSH);
      wINT = sane(wINT, defINT);
      wB   = sane(wB,   defB);

      // Enforce non-negative blend for interpretability; if any are negative,
      // drop back to the defaults.
      if (wAI < 0 || wSH < 0 || wINT < 0 || wB < 0){
        wAI  = defAI;
        wSH  = defSH;
        wINT = defINT;
        wB   = defB;
      }

      // User-controlled AI vs Skip blend override (slider / settings).
      // settings.blend may be 0-1 or 0-100; normalize to 0-1 and
      // interpret it as the AI share for the main head.
      try {
        var alpha = null;

        // Primary source: settings.blend from the SKAI run settings
        if (typeof settings !== 'undefined' && settings && settings.blend !== undefined) {
          var rawBlend = Number(settings.blend);
          /* CHG: ES5 finite check.
             Reason: Number.isFinite is ES6 and may be undefined in module clients.
             Benefit: same -accept only real numbers- logic without runtime crashes. */
          if (isFinite(rawBlend)) {
            alpha = rawBlend;
          } else {
            // DEBUG: Log when blend value is invalid
            // TODO: Remove after verification
            try { console.warn('[SKAI] settings.blend is not finite:', settings.blend, 'rawBlend=' + rawBlend); } catch(_){}
          }
        } else {
          // DEBUG: Log when settings.blend is undefined
          // TODO: Remove after verification
          try { console.warn('[SKAI] settings.blend is undefined or settings object is invalid. settings:', settings); } catch(_){}
        }

        // Fallback source: global SKAI_BLEND_ALPHA (e.g. from blend engine)
        if (alpha === null && typeof window !== 'undefined' && typeof window.SKAI_BLEND_ALPHA === 'number') {
          alpha = window.SKAI_BLEND_ALPHA;
          // TODO: Remove after verification
          try { console.log('[SKAI] Using fallback SKAI_BLEND_ALPHA:', alpha); } catch(_){}
        }

        /* CHG: ES5 finite check for alpha.
           Reason/Benefit: prevents -Number.isFinite is not a function- errors while preserving normalization. */
        if (alpha !== null && isFinite(alpha)) {
          // Allow either 0-1 or 0-100; normalize to 0-1
          if (alpha > 1) { alpha = alpha / 100; }
          if (alpha < 0) { alpha = 0; }
          if (alpha > 1) { alpha = 1; }

          var shShare = 1 - alpha;
          wAI = alpha;
          wSH = shShare;

          // Expose the effective alpha back out for debugging / continuity
          try { window.SKAI_BLEND_ALPHA = alpha; } catch(_){}
        } else {
          // DEBUG: Log when user blend override is not applied
          // TODO: Remove after verification
          try { console.warn('[SKAI] User blend override NOT applied. alpha=' + alpha + ', using learned weights wAI=' + wAI + ', wSH=' + wSH); } catch(_){}
        }
      } catch (e){
        // DEBUG: Log any exceptions in blend override
        // TODO: Remove after verification
        try { console.error('[SKAI] Exception in blend override:', e); } catch(_){}
      }

      // Optionally renormalize main vs SH so they sum to 1 (if both > 0)
      var s = wAI + wSH;
      if (s > 0){
        wAI /= s;
        wSH /= s;
      }

      // DEBUG: Log the final blend weights being used for scoring
      // TODO: Remove after verification
      try { console.log('[SKAI] Final blend weights - wAI:', wAI.toFixed(3), 'wSH:', wSH.toFixed(3), '(from settings.blend=' + (settings && settings.blend) + ')'); } catch(_){}
     })();

  } catch (_){
    // FIX: close the outer try so we don't throw "missing catch or finally after try"
    try { (window.SKAI_warn || console.warn)('[SKAI] scoreAndRender failed:', _); } catch(__){}
  }

  // Mark learned before blending so downstream listeners can react.
  try { window.__SKAI_LEARNED__ = true; } catch(_){}

  // Blend mains  (FIX: this must be INSIDE SKAI_scoreAndRender so probs/priorMain/etc exist)
  var blended = [];
  var mainSkipMap = {};  // per-number Skip scores (prior)
  var mainMlMap   = {};  // per-number ML scores (probs)

  // FIX: L may be undefined if earlier guards returned before assigning it.
  // Evidence: loop uses `L` directly.
  var Lsafe = (typeof L === 'number' && isFinite(L) && L > 0)
    ? (L | 0)
    : Math.max((probs && probs.length) ? probs.length : 0,
               (priorMain && priorMain.length) ? priorMain.length : 0);

  for (var i0=0; i0<Lsafe; i0++){
    var num   = allowZero ? i0 : (i0 + 1);
    var ai    = isFiniteNum(probs[i0])      ? probs[i0]      : 0;
    var prior = isFiniteNum(priorMain[i0]) ? priorMain[i0]  : 0;

    // CHG: Temperature transform on AI probability for policy-driven modes (monotone; ranking-safe)
    var aiAdj = ai;
    if (isFiniteNum(aiTemp) && aiTemp > 0 && ai > 0) {
      aiAdj = Math.pow(ai, 1 / aiTemp);
    }

    // CHG: Thompson Sampling exploration factor from history posterior
    // We sample Beta(postA, postB) and scale score by sample/mean (tempered by tsStrength).
    var tsFactor = 1;
    if (tsOn && tsStrength > 0 && postA && postB && isFiniteNum(postA[i0]) && isFiniteNum(postB[i0])) {
      var aTS = postA[i0], bTS = postB[i0];
      if (aTS > 0 && bTS > 0) {
        var meanTS = aTS / (aTS + bTS);
        if (meanTS > 0) {
          var sampTS = window.skaiSampleBeta(aTS, bTS);
          if (isFiniteNum(sampTS) && sampTS > 0) {
            tsFactor = Math.pow((sampTS / meanTS), tsStrength);
          }
        }
      }
    }

    // CHG: Coherent blend: treat Skip/Hit prior as a bounded multiplicative bias on the learned AI probability.
    // This prevents scale-mismatch (adding heterogeneous scores) and stabilizes mode changes.
    var bias = Math.exp(wSH * (prior - 0.5));
    var baseScore = Math.max(0, (wAI * aiAdj) * bias + wB);
    var score = baseScore * tsFactor;

    // CHG: Stability smoothing (EMA vs last score)
    var prev = window.SKAI_lastScoreByNum ? window.SKAI_lastScoreByNum[String(num)] : null;
    if (stability > 0 && prev != null && isFinite(prev)) {
      score = (1 - stability) * score + stability * prev;
    }
    if (window.SKAI_lastScoreByNum) window.SKAI_lastScoreByNum[String(num)] = score;

    blended.push({
      num: num,
      score: score,
      explain: {
        ai: ai,
        aiAdj: (typeof aiAdj !== 'undefined') ? aiAdj : ai,
        prior: prior,
        bias: (typeof bias !== 'undefined') ? bias : 1,
        tsFactor: (typeof tsFactor !== 'undefined') ? tsFactor : 1,
        baseScore: (typeof baseScore !== 'undefined') ? baseScore : score,
        stability: (typeof stability !== 'undefined') ? stability : 0
      }
    });

    // FIX: these maps must be written per-iteration while `num/ai/prior` are in scope.
    mainMlMap[num]   = ai;
    mainSkipMap[num] = prior;
  }

   // Sort by score desc, then by number asc (no bitwise tricks)
  blended.sort(function(a,b){
    if (b.score !== a.score) { return b.score - a.score; }
    return a.num - b.num;
  });

  // CHG: expose latest ranking for explainability/debug
  window.SKAI_lastBlended = blended;

  var top = blended.slice(0, 20);

  // Keep SKAI_BLEND_RESULTS in sync using the shared blend engine (if present)
  try {
    if (window.SKAI_blendEngine && typeof window.SKAI_blendEngine.run === 'function') {
      var blendInput = {
        mainSkip:  mainSkipMap,
        mainMl:    mainMlMap,
        extraSkip: (window.SKAI_EXTRA_SKIP_MAP || {}),
        extraMl:   (window.SKAI_EXTRA_ML_MAP   || {}),
        options:   {
          alpha:      (typeof settings !== 'undefined' && settings && typeof settings.blend !== 'undefined')
                        ? settings.blend
                        : undefined,
          mainLimit:  20,
          extraLimit: 5
        }
      };
      window.SKAI_BLEND_RESULTS = window.SKAI_blendEngine.run(blendInput);
    }
  } catch(_){}

  try {
    window.SKAI_TOP_MAIN = top.slice();
    window.SKAI_DEBUG_MAIN = {
      weights: { wAI: wAI, wSH: wSH, wINT: wINT, wB: wB },
      probs:   (probs && probs.slice) ? probs.slice() : [],
      prior:   (priorMain && priorMain.slice) ? priorMain.slice() : [],
      top:     top.slice()
    };

    // keep: expose last picks so other listeners can see them
    try {
      var lastPicks = [];
      for (var t = 0; t < top.length; t++) {
        // each item in `top` is { num: N, score: S }
        lastPicks.push(top[t].num);
      }
      window.__SKAI_LAST_PICKS__ = lastPicks;
      
      // FIX: Set skaiSaveMainOrdered for database save in probability order
      // This ensures predictions are saved highest-to-lowest confidence, not sorted numerically
      window.skaiSaveMainOrdered = lastPicks.slice();

      // NEW: Build canonical final ticket combos (ensures full pickSize is represented)
      // Note: combo builder is optional and only runs when called.
      try {
        if (typeof window.SKAI_buildFinalCombos === 'function') {
          var _metaFC = window.SKAI_META || {};
          var _pickFC = parseInt(_metaFC.pick, 10);
          if (!_pickFC || _pickFC < 1) { _pickFC = (lastPicks && lastPicks.length) ? lastPicks.length : 5; }

          var _extraCountFC = (_metaFC && _metaFC.hasExtraBall) ? 1 : 0;

          // Build and expose ranked combos (also writes window.SKAI_FINAL_COMBOS)
          window.SKAI_buildFinalCombos({
            pickSize: _pickFC,
            extraCount: _extraCountFC,
            topK: 12,
            limit: 25
          });

// NEW: Optional combo build (do NOT change displayed Top Picks)
try {
  if (window.SKAI_FINAL_COMBOS && window.SKAI_FINAL_COMBOS.length) {
    // Expose for debugging/insights only; UI Top Picks remains SKAI_TOP_MAIN (top 20)
    window.SKAI_BEST_COMBO = window.SKAI_FINAL_COMBOS[0] || null;
  }
} catch(_){}
        }
      } catch(_){}
    } catch (_){}
  } catch(_){}

  // NEW: use the main SKAI Top Picks renderer so:
  //  - Top 10/15/20 chips work
  //  - extra balls are .xball (red) instead of plain .nb
  //  - it emits `skai:render:done` so the progress bar reaches 100%
  try {
    if (typeof window.SKAI_renderTopPicks === 'function') {
      window.SKAI_renderTopPicks();
    } else if (typeof window.SKAI_renderPredictions === 'function') {
      // legacy fallback: still support the simple renderer
      var src = (window.__SKAI_LAST_PICKS__ && window.__SKAI_LAST_PICKS__.slice)
        ? window.__SKAI_LAST_PICKS__.slice()
        : (window.__SKAI_LAST_PICKS__ || []);
      window.SKAI_renderPredictions(src);
    }
  } catch (_){}

  emitEvt('skai:score:done');

    }; // end window.SKAI_scoreAndRender
  } // end singleton guard


    // -------------------------------
    // Section 2: Extra ball (Promise chain, ES5)
    // -------------------------------
    // EXPOSED as window.SKAI_runExtra so it can be called after main ML completes
	
	
window.SKAI_runExtra = function runExtraBallML(settings) {
  // Extra-ball ML head (Powerball, EuroMillions, etc.)
  // - Uses extraDraws + buildSkaiExtraDataset/buildSkaiExtraCurrentVector
  // - Trims features to the model's expected input shape (fixes 26 vs 130 mismatch)
  // - Never leaves UI stuck at 99%; always emits skai:extra:done

  settings = settings || {};

  var meta       = window.SKAI_META || {};
  var extraDraws = Array.isArray(window.extraDraws) ? window.extraDraws : [];
  var hasExtra   = !!(meta && meta.hasExtraBall);
  var cleaned    = false;
  var xsTX = null;
  var ysTX = null;
  var mX   = null;
  var tfw  = window.tf || null;

  // Local safe emitter alias (don’t assume SKAI_emit exists)
  var SKAI_emitSafe = (typeof window.SKAI_emit === 'function')
    ? window.SKAI_emit
    : function () {};

  // Small ES5-safe finite check (Number.isFinite is ES6)
  function isFiniteNum(v) {
    return typeof v === 'number' && isFinite(v);
  }

  // Helper: best-effort progress updates that never throw
  function SKAI_progressExtraSafe(pct, msg) {
    try {
      if (typeof window.SKAI_progressSetSafe === 'function') {
        window.SKAI_progressSetSafe(pct, msg || '');
        return;
      }
      if (typeof window.SKAI_requireProgress === 'function') {
        var P = window.SKAI_requireProgress();
        if (P && typeof P.set === 'function') {
          P.set(pct, msg || '');
        }
      }
    } catch (_){}
  }

  // Local assert helper which delegates to global SKAI_assert if present
  function SKAI_assert(cond, code, msg) {
    if (typeof window.SKAI_assert === 'function') {
      return window.SKAI_assert(cond, code, msg);
    }
    if (cond) {
      return true;
    }
    var text = (code ? '[' + code + '] ' : '') + (msg || 'SKAI assertion failed');
    try {
      (window.SKAI_warn || console.warn)('[SKAI] ' + text);
      try {
        SKAI_emitSafe('skai:analysis-stop', { detail: { reason: text } });
      } catch (_){}
    } catch (_){}
    return false;
  }

  // Central cleanup + signalling helper
  function SKAI_cleanupExtra(err, outcome) {
    if (cleaned) {
      return;
    }
    cleaned = true;

    // Dispose TF tensors/models (best-effort)
    try { if (xsTX && xsTX.dispose) xsTX.dispose(); } catch (_){}
    try { if (ysTX && ysTX.dispose) ysTX.dispose(); } catch (_){}
    try { if (mX   && mX.dispose)   mX.dispose();   } catch (_){}

    // Unlock UI overlay / busy state (best-effort)
    try {
      if (typeof window.SKAI_setBusy === 'function') {
        window.SKAI_setBusy(false);
      }
      var overlay = document.getElementById('skaiOverlay');
      if (overlay) {
        overlay.style.display = 'none';
      }
      if (document && document.body && document.body.classList) {
        document.body.classList.remove('skai-busy');
      }
    } catch (_){}

    // Error logging (if any)
    if (err) {
      try { SKAI_emitSafe('skai:extra:error', err); } catch (_){}
      try {
        if (window.console && console.error) {
          console.error('SKAI extra head failed:', err);
        }
      } catch (_){}
      try { window.SKAI_TOP_EXTRA = []; } catch (_){}
    }

    // Always notify listeners that extra head reached a terminal state
    try {
      var top = (window.SKAI_TOP_EXTRA && window.SKAI_TOP_EXTRA.slice)
        ? window.SKAI_TOP_EXTRA.slice()
        : [];
      SKAI_emitSafe('skai:extra:done', {
        detail: {
          outcome: outcome || (err ? 'error' : 'ok'),
          error:   err || null,
          top:     top
        }
      });
    } catch (_){}

    // Final 100% completion for the progress bar (best-effort)
    try {
      if (typeof window.SKAI_progressSetSafe === 'function') {
        window.SKAI_progressSetSafe(
          100,
          (typeof window.SKAI_msg === 'function'
            ? window.SKAI_msg('readyPicks')
            : 'Completed.')
        );
      } else if (typeof window.SKAI_requireProgress === 'function') {
        var __P = window.SKAI_requireProgress();
        if (__P && typeof __P.set === 'function') {
          __P.set(100, 'Extra head complete.');
        }
        if (__P && typeof __P.done === 'function') {
          __P.done('Extra head complete.');
        }
      }
    } catch (_){}
  }

  var usedDimX = 0;

  try {
    // 1) If game does not have an extra ball, skip cleanly
    if (!hasExtra) {
      try {
        window.SKAI_TOP_EXTRA = [];
        window.__SKAI_LEARNED_EXTRA__ = false;
      } catch (_){}
      SKAI_progressExtraSafe(100, 'No extra ball for this game (skip).');
      SKAI_cleanupExtra(null, 'skip');
      return;
    }

    // 2) TensorFlow not ready for extra head
    if (!tfw || !tfw.tensor2d) {
      try {
        (window.SKAI_warn || console.warn)('[SKAI] Extra head skipped: TensorFlow not ready.');
      } catch (_){}
      try {
        window.SKAI_TOP_EXTRA = [];
        window.__SKAI_LEARNED_EXTRA__ = false;
      } catch (_){}
      SKAI_progressExtraSafe(100, 'Extra head skipped (TF not ready).');
      SKAI_cleanupExtra(null, 'skip');
      return;
    }

    // 3) Dataset builders must exist
    if (typeof window.buildSkaiExtraDataset !== 'function' ||
        typeof window.buildSkaiExtraCurrentVector !== 'function') {
      SKAI_progressExtraSafe(100, 'Extra head skipped (no dataset builder).');
      SKAI_cleanupExtra(
        new Error('Extra head: dataset or current-vector builder missing.'),
        'error'
      );
      return;
    }

        // 4) Build dataset using same path as known-good version
    var dsX = window.buildSkaiExtraDataset(extraDraws, settings) || {};
    var rowsX   = (dsX.xs && dsX.xs.length) ? dsX.xs.length : 0;
    var inDimX  = dsX.inputDim  ? (dsX.inputDim  | 0) : 0;

    // IMPORTANT:
    // For the extra-ball head we want the *extra* domain, e.g. 26 for Powerball,
    // NOT the main-ball domain (69). The dataset builder currently reports
    // dsX.domain = 69, while dsX.ys rows have length 26. That mismatch caused:
    //   "target expected shape [69] but received [26]"
    // So we prefer meta.extraDomain when available, and only fall back to
    // dsX.domain otherwise.
    var domainX = 0;
    if (meta && typeof meta.extraDomain !== 'undefined' && Number(meta.extraDomain) > 0) {
      domainX = Number(meta.extraDomain) | 0;   // e.g. 26 for Powerball
    } else if (dsX.domain) {
      domainX = dsX.domain | 0;
    }

    usedDimX = inDimX;

    if (!rowsX || !inDimX || !domainX) {
      try {
        (window.SKAI_warn || console.warn)('[SKAI] Extra head skipped: empty extra dataset.');
      } catch (_){}
      try {
        window.SKAI_TOP_EXTRA = [];
        window.__SKAI_LEARNED_EXTRA__ = false;
      } catch (_){}
      SKAI_progressExtraSafe(100, 'Extra head skipped (no extra samples).');
      SKAI_cleanupExtra(null, 'skip');
      return;
    }

    // 5) Build model for extra head
    try {
      /* CHG: call buildSkaiModel with the SAME signature as main head.
         Reason: main uses (cfg, inDim, outDim); extra was using a different overload.
         Benefit: removes overload mismatch without guessing new APIs. */
      var cfgX = {};
      for (var kX in settings){
        if (Object.prototype.hasOwnProperty.call(settings, kX)) cfgX[kX] = settings[kX];
      }
      cfgX.head = 'extra';

      mX = window.buildSkaiModel
        ? window.buildSkaiModel(cfgX, inDimX, domainX)
        : null;
    } catch (eModel) {
      mX = null;
      throw eModel;
    }

    if (!mX || !mX.predict) {
      throw new Error('Extra head: model not built or invalid.');
    }

    // Detect model's expected input dimension (e.g. 26) from the first input tensor
    try {
      var inpShape = (mX.inputs && mX.inputs[0] && mX.inputs[0].shape)
        ? mX.inputs[0].shape
        : null;
      if (inpShape && typeof inpShape[1] === 'number' && inpShape[1] > 0) {
        usedDimX = inpShape[1] | 0;
      }
    } catch (_){}

    if (!usedDimX) {
      usedDimX = inDimX;
    }

    // If dataset rows are wider than model expects, trim each row (features)
    var featMat = dsX.xs || [];
    if (usedDimX > 0 && usedDimX !== inDimX && Array.isArray(featMat)) {
      var trimmed = new Array(rowsX);
      for (var rr = 0; rr < rowsX; rr++) {
        var rowF = featMat[rr] || [];
        trimmed[rr] = rowF.slice(0, usedDimX);
      }
      featMat = trimmed;
    }

    // NEW: detect model's output dimension and adapt labels (targets) to it.
    var outDimX = domainX;
    try {
      var outShape = (mX.outputs && mX.outputs[0] && mX.outputs[0].shape)
        ? mX.outputs[0].shape
        : null;
      if (outShape && typeof outShape[1] === 'number' && outShape[1] > 0) {
        outDimX = outShape[1] | 0;  // e.g. 69, 26, etc.
      }
    } catch (_){}

    if (!outDimX) {
      outDimX = domainX;
    }

    // Adapt dsX.ys rows to match outDimX (pad with zeros or trim)
    var labelMat = dsX.ys || [];
    if (outDimX > 0 && Array.isArray(labelMat) && labelMat.length) {
      var labTrimmed = new Array(rowsX);
      for (var rr2 = 0; rr2 < rowsX; rr2++) {
        var rowY = labelMat[rr2] || [];
        if (rowY.length > outDimX) {
          labTrimmed[rr2] = rowY.slice(0, outDimX);
        } else if (rowY.length < outDimX) {
          var padded = rowY.slice(0);
          while (padded.length < outDimX) {
            padded.push(0);
          }
          labTrimmed[rr2] = padded;
        } else {
          labTrimmed[rr2] = rowY;
        }
      }
      labelMat = labTrimmed;
    }

    // Use the actual output dimension as our domain for the rest of the function
    domainX = outDimX;

    xsTX = tfw.tensor2d(featMat,  [rowsX, usedDimX], 'float32');
    ysTX = tfw.tensor2d(labelMat, [rowsX, domainX], 'float32');

    // Emit "start" so any listeners or logs can react
    try {
      SKAI_emitSafe('skai:extra:start', {
        detail: {
          rows:   rowsX,
          domain: domainX
        }
      });
    } catch (_){}


    // 6) Train extra head, then predict in a single Promise chain
    Promise
      .resolve(
        window.fitWithValidation(
          mX,
          { xsTensor: xsTX, ysTensor: ysTX },
          (function () {
            // ES5-safe shallow merge of settings + extra-head telemetry flags
            var cfg = {};
            var s   = settings || {};
            for (var k in s) {
              if (Object.prototype.hasOwnProperty.call(s, k)) {
                cfg[k] = s[k];
              }
            }
            cfg.__phaseLabel = 'Extra ball - SKAI run';
            cfg.__eventName  = 'skai:extra:epoch';
            return cfg;
          }())
        )
      )
      .then(function () {
        // Build current vector and run prediction AFTER training completes
        var nowX = window.buildSkaiExtraCurrentVector(extraDraws, settings);

        var curVec = (nowX && Array.isArray(nowX.x)) ? nowX.x.slice() : [];
        if (usedDimX > 0 && curVec.length > usedDimX) {
          curVec = curVec.slice(0, usedDimX);
        }

        SKAI_assert(
          curVec.length === usedDimX,
          'XTRA_CURR_VEC',
          'Extra head: current vector invalid (dim mismatch)'
        );

        var xX = tfw.tensor2d([curVec], [1, usedDimX], 'float32');
        var yX = mX.predict(xX);

        return Promise
          .resolve(yX.data())
          .then(function (pX) {
            try { if (yX && yX.dispose) yX.dispose(); } catch (_){}

            var tag = Object.prototype.toString.call(pX);
            var isArr = tag === '[object Float32Array]' || Array.isArray(pX);
            SKAI_assert(isArr, 'XTRA_PROBS_TYPE', 'Extra head: probs not an array');
            SKAI_assert(
              (pX.length | 0) === domainX,
              'XTRA_PROBS_LEN',
              'Extra head: invalid prediction length'
            );

             var priX        = Array.isArray(nowX.skipPrior) ? nowX.skipPrior : [];

            /* CHG: normalize blend for extra head.
               Reason: settings.blend may be 0–1 OR 0–100 (slider). Without normalization,
               values like 50 clamp to 1 and overweight Skip for extras.
               Benefit: extra-ball blend matches main-head behavior deterministically. */
            var lamRawX = Number(settings.blend);
            if (!isFiniteNum(lamRawX)) { lamRawX = 0; }
            if (lamRawX > 1) { lamRawX = lamRawX / 100; }
            if (lamRawX < 0) { lamRawX = 0; }
            if (lamRawX > 1) { lamRawX = 1; }
            var lamX = lamRawX;

            var domX        = Math.max(pX.length, priX.length || 0);
            var extraDomain = (meta && Number(meta.extraDomain) > 0)
              ? Number(meta.extraDomain)
              : domainX;
            var allowZeroX  = (meta && meta.forceOneBasedExtra)
              ? false
              : (extraDomain <= 9);

            var tempX = Number(settings.temperature || settings.temp || 1.0);
            if (!isFiniteNum(tempX) || tempX <= 0) tempX = 1.0;
            if (tempX < 0.25) tempX = 0.25;
            if (tempX > 4.0)  tempX = 4.0;

            var diversityX = Number(settings.diversityPenalty || settings.diversity || 0);
            if (!isFiniteNum(diversityX) || diversityX < 0) diversityX = 0;
            if (diversityX > 0.5) diversityX = 0.5;

            function adjustProbExtra(p) {
              var x = +p;
              if (!isFinite(x) || x <= 0) x = 1e-6;
              if (x >= 1) x = 1 - 1e-6;

              var z = Math.log(x / (1 - x));
              z = z / tempX;

              var y = 1 / (1 + Math.exp(-z));

              if (diversityX > 0) {
                var noise = (Math.random() - 0.5) * 2 * diversityX;
                y += noise;
              }

              if (y < 0) y = 0;
              if (y > 1) y = 1;
              return y;
            }

            var blendedX = [];
            var ii;
            for (ii = 0; ii < domX; ii++) {
              var ai2 = isFiniteNum(pX[ii])   ? pX[ii]   : 0;
              var sh2 = isFiniteNum(priX[ii]) ? priX[ii] : 0;

              ai2 = adjustProbExtra(ai2);

              blendedX.push({
                num:   (allowZeroX ? ii : (ii + 1)),
                // Blend: AI vs Skip for extra ball
                score: (1 - lamX) * ai2 + lamX * sh2
              });
            }

            blendedX.sort(function (a, b) {
              return (b.score - a.score) || (a.num - b.num);
            });

            var maxExtra = 5;
            var topX = blendedX.slice(0, Math.min(blendedX.length, maxExtra));

            SKAI_assert(
              topX.length > 0,
              'XTRA_TOP_EMPTY',
              'Extra head: no top predictions were produced'
            );

            try {
              window.SKAI_TOP_EXTRA = topX.slice();
              window.__SKAI_LEARNED_EXTRA__ = true;
              
              // FIX: Set skaiSaveExtraOrdered for database save in probability order
              // Extract just the numbers from topX array (which contains {num, score} objects)
              var extraPicks = [];
              for (var i = 0; i < topX.length; i++) {
                if (topX[i] && topX[i].num != null) {
                  extraPicks.push(topX[i].num);
                }
              }
              window.skaiSaveExtraOrdered = extraPicks;
            } catch (_){}

            try {
              var x1 = (topX[0] && topX[0].num != null) ? String(topX[0].num) : 'N/A';
              var lamTxt = (Number(settings.blend) || 0);
              try { lamTxt = lamTxt.toFixed(2); } catch (_){}
              SKAI_progressExtraSafe(
                98,
                'Extra ready: lambda=' + lamTxt + ' \u2022 top1=' + x1
              );
            } catch (_){}

            SKAI_cleanupExtra(null, 'ok');
            return topX;
          })
          .catch(function (err) {
            SKAI_progressExtraSafe(100, 'Extra head failed (main picks ready).');
            SKAI_cleanupExtra(err, 'error');
            return null;
          });
      })
      .catch(function (err) {
        SKAI_progressExtraSafe(100, 'Extra head failed (main picks ready).');
        SKAI_cleanupExtra(err, 'error');
      });

  } catch (errOuter) {
    SKAI_progressExtraSafe(100, 'Extra head failed (main picks ready).');
    SKAI_cleanupExtra(errOuter, 'error');
  }
}; // end window.SKAI_runExtra

    
    // Also expose as runExtraBallML for backward compatibility
    window.runExtraBallML = window.SKAI_runExtra;

    // ------------------------------------------------------------
    // FNR-FIX: Page-load failsafe unlock
    // Reason:
    //  - Some blocks mark busy/overlay during bootstrap.
    //  - If ML is not running yet, we must NOT stay gray.
    // Benefit:
    //  - Ensures UI is visible on first paint.
    //  - Busy state still works during real predictions (skai:ml:start).
    // ------------------------------------------------------------
    (function skaiFailsafeUnlockOnLoad(){
      function unlockIfIdle(){
        try {
          // If a real run is active, do not interfere.
          if (window.__SKAI_RUNNING__ || window.__SKAI_RUN_ACTIVE__) return;

          if (typeof window.SKAI_setBusy === 'function') {
            window.SKAI_setBusy(false);
          }

          var overlay = document.getElementById('skaiOverlay');
          if (overlay) overlay.style.display = 'none';

          try { document.body.classList.remove('skai-busy'); } catch(_){}
          try {
            var root = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
            if (root) root.classList.remove('is-busy');
          } catch(_){}
        } catch(_){}
      }

      if (document.readyState !== 'loading') {
        unlockIfIdle();
      } else {
        document.addEventListener('DOMContentLoaded', unlockIfIdle, false);
      }

      // Also unlock on first tick in case some CSS/overlay lands after DOM ready
      setTimeout(unlockIfIdle, 0);
    })();

    // -------------------------------
    // Section 3: Render
    // -------------------------------
    (function(){
      // Render the latest SKAI_TOP_MAIN / SKAI_TOP_EXTRA into the UI hosts.
      // Exposed as window.SKAI_renderTopPicks so other code (e.g. score-done)
      // can repaint whenever fresh predictions are ready.

      // Display lens: remember how many top numbers the user prefers to see.
      var TOP_LIMITS    = [10, 15, 20];
      var TOP_LIMIT_KEY = 'skai_top_limit';

      function getTopLimit(){
        var v = 0;
        try {
          v = parseInt((window.localStorage && window.localStorage.getItem(TOP_LIMIT_KEY)) || '', 10);
        } catch(_){}
        if (TOP_LIMITS.indexOf(v) === -1) v = 20;
        return v;
      }

      function syncTopLimitControls(v){
        try {
          var buttons = document.querySelectorAll('[data-skai-top-limit]');
          for (var i = 0; i < buttons.length; i++){
            var b   = buttons[i];
            var val = parseInt(b.getAttribute('data-skai-top-limit') || '', 10);
            var on  = (val === v);
            b.setAttribute('aria-pressed', on ? 'true' : 'false');
            if (on) { b.classList.add('btn-chip--active'); }
            else    { b.classList.remove('btn-chip--active'); }
          }
        } catch(_){}
      }

      function setTopLimit(v){
        if (TOP_LIMITS.indexOf(v) === -1) return;
        try {
          if (window.localStorage) {
            window.localStorage.setItem(TOP_LIMIT_KEY, String(v));
          }
        } catch(_){}
        try {
          if (typeof window.SKAI_renderTopPicks === 'function') {
            window.SKAI_renderTopPicks();
          }
        } catch(_){}
        syncTopLimitControls(v);
      }

      // Export helpers so other code (or future modules) can reuse them.
      try {
        if (typeof window.SKAI_getTopLimit !== 'function')       { window.SKAI_getTopLimit       = getTopLimit; }
        if (typeof window.SKAI_setTopLimit !== 'function')       { window.SKAI_setTopLimit       = setTopLimit; }
        if (typeof window.SKAI_syncTopLimitControls !== 'function') { window.SKAI_syncTopLimitControls = syncTopLimitControls; }
      } catch(_){}

      function bindTopLimitControls(){
        try {
          var buttons = document.querySelectorAll('[data-skai-top-limit]');
          if (!buttons.length) return;

          var handler = function(evt){
            var btn = evt.currentTarget;
            var val = parseInt(btn.getAttribute('data-skai-top-limit') || '', 10);
            if (!val) return;
            setTopLimit(val);
          };

          for (var i = 0; i < buttons.length; i++){
            var b = buttons[i];
            if (b.__skaiTopBound__) continue;
            b.__skaiTopBound__ = true;
            b.addEventListener('click', handler, false);
          }

          // Initial sync from stored preference
          syncTopLimitControls(getTopLimit());
        } catch(_){}
      }

      if (document.readyState !== 'loading') {
        bindTopLimitControls();
      } else {
        var __skaiDomOnce = function(){
          try { document.removeEventListener('DOMContentLoaded', __skaiDomOnce, false); } catch(_){}
          bindTopLimitControls();
        };
        document.addEventListener('DOMContentLoaded', __skaiDomOnce, false);
      }

      // CHG: strict-safe emitter alias for this render block
      var SKAI_emitSafe = (typeof window.SKAI_emit === 'function') ? window.SKAI_emit : function(){};

       function SKAI_renderTopPicks(){
        try { SKAI_emitSafe('skai:render:begin'); } catch(_){}

        var topAll  = Array.isArray(window.SKAI_TOP_MAIN)  ? window.SKAI_TOP_MAIN  : [];
        var topXAll = Array.isArray(window.SKAI_TOP_EXTRA) ? window.SKAI_TOP_EXTRA : [];

var meta = window.SKAI_META || {};
var pickMain = parseInt(meta.pick, 10);

// Safety fallback (only if meta.pick is missing)
if (!pickMain || pickMain < 1) { pickMain = 5; }

// Keep top-limit controls available for other modules
var limit = (typeof window.SKAI_getTopLimit === 'function') ? window.SKAI_getTopLimit() : 20;
if (!limit || limit < 1) { limit = 20; }

// Use JSON config to determine game type: daily digit games vs regular lotteries
// Daily games (from JSON config with is_daily/isDaily flag): render exact pick size
// Regular lotteries: render top 20 results
var isDailyGame = !!(meta && meta.isDaily);
var top = isDailyGame ? topAll.slice(0, pickMain) : topAll.slice(0, limit);

// Extra balls: only render if the game actually has an extra ball
var hasExtra = !!meta.hasExtraBall;
var topX = (hasExtra ? topXAll.slice(0, 5) : []);


syncTopLimitControls(limit);

        // unify pad2 as a global to avoid duplicates
        if (typeof window.SKAI_pad2 !== 'function') {
          window.SKAI_pad2 = function(n){
            var v = Number(n) || 0; var s = String(v);
            return s.length < 2 ? ('0' + s) : s;
          };
        }
        var pad2 = window.SKAI_pad2;

        // include modern and legacy hosts
        // Priority:
        //   1) Modern SKAI containers (.skai-ai-main, [data-skai-results])
        //   2) ONLY if none exist, fall back to legacy IDs (#aiPredictedNumbers, #prediction)
        // This prevents "double rows" when both modern + legacy markup are
        // present on the same page (your current SKAI layout).
        var hosts = (function(){
          var list = [];
          var i;

          // Prefer modern SKAI hosts
          var primary = document.querySelectorAll('.skai-ai-main, [data-skai-results]');
          if (primary && primary.length){
            for (i = 0; i < primary.length; i++){
              list.push(primary[i]);
            }
          } else {
            // Legacy fallback: only used on older pages that don't have the
            // modern SKAI containers.
            var c2 = document.getElementById('aiPredictedNumbers');
            if (c2) list.push(c2);
            var c3 = document.getElementById('prediction');
            if (c3) list.push(c3);
          }

          // de-dupe without template literals (ES5)
          var out = [];
          for (var k = 0; k < list.length; k++){
            var el = list[k];
            var exists = false;
            for (var z = 0; z < out.length; z++){
              if (out[z] === el) { exists = true; break; }
            }
            if (!exists) out.push(el);
          }
          return out;
        })();

        // Save card progressive disclosure (safe, tolerant selectors)
        function toggleSaveActive(isReady){
          try {
            var root = document.querySelector('.skai-results-card') || document.body;
            if (!root) return;

            root.classList.remove('skai-save--active');
            root.classList.remove('skai-save--inactive');
            root.classList.add(isReady ? 'skai-save--active' : 'skai-save--inactive');

            var saveEl =
              document.querySelector('.skai-save-card') ||
              document.getElementById('skai-save-card') ||
              document.getElementById('saveAIPredictionCard') ||
              document.querySelector('[data-skai-save-card]');

            if (saveEl) {
              saveEl.setAttribute('aria-hidden', isReady ? 'false' : 'true');
            }
          } catch(_){}
        }

        // 1) If no main picks yet, show calm loading placeholder
        var isReadyMain = top && top.length > 0;

        for (var h=0; h<hosts.length; h++){
          var container = hosts[h];
          if (!container) continue;

          container.innerHTML = '';

          if (!isReadyMain){
            container.classList.add('skai-results--loading');

            var shell = document.createElement('div');
            shell.className = 'skai-loading-shell';

            var t1 = document.createElement('div');
            t1.className = 'skai-loading-title';
            // CHG: replace mojibake - with a proper ellipsis (Unicode-safe)
            t1.textContent = 'Running analysis\u2026';

            var t2 = document.createElement('div');
            t2.className = 'skai-loading-sub';
            t2.textContent = 'Your picks will appear here when ready.';

            shell.appendChild(t1);
            shell.appendChild(t2);
            container.appendChild(shell);

            try { container.style.display = ''; } catch(_){}
            continue;
          }

          container.classList.remove('skai-results--loading');

          var hh = document.createElement('h4');
          hh.setAttribute('data-skai', 'top');
          var tunedNow = !!window.__SKAI_TUNED_THIS_RUN__;
          var tunedSrv = !!(window.SKAI_SERVER && (window.SKAI_SERVER.hasAutoTune || window.SKAI_SERVER.usedWindow));
          // CHG: replace mojibake - with a proper bullet separator for brand-consistent typography
          hh.textContent = 'SKAI Top Picks (most likely first)' +
            ((tunedNow || tunedSrv) ? ' \u2022 Auto-tuned' : '');
          container.appendChild(hh);

          var frag = document.createDocumentFragment();
          for (var t=0; t<top.length; t++){
            var item = top[t];
            var num  = item.num;
            var s    = document.createElement('span');
            s.className   = 'nball';
            s.textContent = pad2(num);
            s.title = 'Number ' + num;
            frag.appendChild(s);
          }

          try { container.style.display = ''; } catch(_){}
container.appendChild(frag);

/* ------------------------------------------------------------
   NEW: Position guidance for Pick-3 / Pick-4 digit games
   Uses window.SKAI_POS_TOPS and window.SKAI_POS_COMBOS
------------------------------------------------------------ */
try {
  var meta = window.SKAI_META || {};
  var domainMain = (meta && isFinite(+meta.domain) && +meta.domain > 0) ? (+meta.domain|0) : 0;
  var pickMain   = (meta && isFinite(+meta.pick)   && +meta.pick   > 0) ? (+meta.pick|0)   : 0;

  var isDigitGame = (domainMain > 0 && domainMain <= 9);
  var tops = window.SKAI_POS_TOPS;
  var combos = window.SKAI_POS_COMBOS;

  if (isDigitGame && pickMain >= 2 && pickMain <= 4 && Array.isArray(tops) && tops.length === pickMain) {

    var panel = document.createElement('div');
    panel.className = 'skai-pos-panel';
    panel.style.marginTop = '12px';
    panel.style.padding = '12px';
    panel.style.borderRadius = '12px';
    panel.style.background = 'linear-gradient(180deg, #EFEFF5 0%, #FFFFFF 100%)';
    panel.style.border = '1px solid rgba(10,26,51,0.08)';

    var title = document.createElement('div');
    title.style.fontWeight = '700';
    title.style.color = '#0A1A33';
    title.style.marginBottom = '8px';
    title.textContent = 'Digit guidance by position';
    panel.appendChild(title);

    var grid = document.createElement('div');
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(' + pickMain + ', minmax(0, 1fr))';
    grid.style.gap = '10px';

    function fmtPct(p){
      var x = Math.round(1000 * (+p || 0)) / 10; // one decimal
      return String(x) + '%';
    }

    for (var p = 0; p < pickMain; p++){
      var col = document.createElement('div');
      col.style.padding = '10px';
      col.style.borderRadius = '10px';
      col.style.background = '#FFFFFF';
      col.style.border = '1px solid rgba(10,26,51,0.06)';

      var h = document.createElement('div');
      h.style.fontWeight = '700';
      h.style.color = '#0A1A33';
      h.style.marginBottom = '6px';
      h.textContent = 'Position ' + (p + 1);
      col.appendChild(h);

      var list = document.createElement('div');
      for (var i = 0; i < Math.min(3, tops[p].length); i++){
        var row = tops[p][i];
        var line = document.createElement('div');
        line.style.display = 'flex';
        line.style.alignItems = 'center';
        line.style.justifyContent = 'space-between';
        line.style.padding = '6px 0';

        var left = document.createElement('span');
        left.style.fontWeight = '700';
        left.style.color = '#1C66FF';
        left.textContent = String(row.num);

        var right = document.createElement('span');
        right.style.color = '#7F8DAA';
        right.style.fontSize = '12px';
        right.textContent = fmtPct(row.p);

        line.appendChild(left);
        line.appendChild(right);
        list.appendChild(line);
      }

      col.appendChild(list);
      grid.appendChild(col);
    }

    panel.appendChild(grid);

    // Combos (ranked)
    if (Array.isArray(combos) && combos.length) {
      var sub = document.createElement('div');
      sub.style.marginTop = '10px';
      sub.style.color = '#0A1A33';
      sub.style.fontWeight = '700';
      sub.textContent = 'High-probability combinations (relative rank)';
      panel.appendChild(sub);

      var ul = document.createElement('div');
      ul.style.marginTop = '6px';

      for (var c = 0; c < Math.min(6, combos.length); c++){
        var it = combos[c];
        var line2 = document.createElement('div');
        line2.style.display = 'flex';
        line2.style.justifyContent = 'space-between';
        line2.style.padding = '6px 0';
        line2.style.borderBottom = '1px solid rgba(10,26,51,0.06)';

        var a = document.createElement('span');
        a.style.fontWeight = '700';
        a.style.color = '#0A1A33';
        a.textContent = it.main.join('');

        var b = document.createElement('span');
        b.style.color = '#7F8DAA';
        b.style.fontSize = '12px';
        b.textContent = (it.approxPct != null ? String(it.approxPct) : '') + '%';

        line2.appendChild(a);
        line2.appendChild(b);
        ul.appendChild(line2);
      }

      panel.appendChild(ul);

      var note = document.createElement('div');
      note.style.marginTop = '8px';
      note.style.color = '#7F8DAA';
      note.style.fontSize = '12px';
      note.textContent = 'These are ranked by SKAI’s blended position probabilities (history + model). They are comparative signals—not guarantees.';
      panel.appendChild(note);
    }

    container.appendChild(panel);
  }
} catch(_posUIErr){}

        }

// 2) Extra-ball render (with fallbacks)
        var aiX = document.getElementById('aiExtraPredictionContainer');
        if (aiX) {
          aiX.innerHTML = '';

          // Prefer local topX, then global SKAI_TOP_EXTRA, then saved ordered array
          var topXr =
            (typeof topX !== 'undefined' && topX && topX.length) ? topX :
            (window.SKAI_TOP_EXTRA && window.SKAI_TOP_EXTRA.length) ? window.SKAI_TOP_EXTRA :
            (window.skaiSaveExtraOrdered && window.skaiSaveExtraOrdered.length) ? window.skaiSaveExtraOrdered :
            [];

          if (topXr && topXr.length) {
            // Optional label (only when we actually have extra picks)
            var lab = document.createElement('div');
            lab.className = 'help';
            lab.style.marginTop = '4px';
            lab.style.width = '100%';
            lab.textContent = 'Extra ball pick(s)';
            aiX.appendChild(lab);

            var frag2 = document.createDocumentFragment();
            for (var tx=0; tx<topXr.length; tx++){
              var itemX = topXr[tx];

              // Accept either {num, score} objects or raw numbers
              var numX = (itemX && itemX.num != null) ? itemX.num : itemX;

              if (numX == null) continue;

              var sx = document.createElement('span');
              sx.className   = 'xball';
              sx.textContent = pad2(numX);
              sx.title = 'Extra ' + numX;
              frag2.appendChild(sx);
            }

            aiX.appendChild(frag2);
            aiX.setAttribute('data-ai-ready', '1');
            aiX.style.display = '';
          } else {
            aiX.removeAttribute('data-ai-ready');
          }
        }

        // 3) Save block only becomes -active- once main picks exist
        toggleSaveActive(isReadyMain);

        // 4) Summary line when ready (unchanged message, brand punctuation)
        if (isReadyMain) {
          var sum = document.getElementById('aiPredictionSummary');
          if (sum){
            sum.textContent = 'Source: SKAI client ML - Main and extra numbers ready.';
          }
        }

        try { SKAI_emitSafe('skai:render:done'); } catch(_){}
      }
      // Expose the renderer but DO NOT call it on initial page load.
      // Reason: SKAI_TOP_MAIN is empty until ML completes. Rendering before ML
      //         could show stale/cached data or create confusion.
      // Benefit: Render only happens after ML produces real predictions.
      try { window.SKAI_renderTopPicks = SKAI_renderTopPicks; } catch(_){}
      // CHG: REMOVED initial SKAI_renderTopPicks() call - now only triggered after ML completes

      // Legacy compatibility:
      // Older scripts may still call window.SKAI_renderPredictions, which
      // draws a second row of main balls. Now that SKAI_renderTopPicks
      // owns the UI (mains + extras), we neutralize the legacy renderer
      // on this page to prevent duplicate output while keeping calls safe.
      try {
        window.SKAI_renderPredictions = function(){
          // no-op: superseded by SKAI_renderTopPicks
        };
      } catch(_){}

      // ------------------------------------------------------------
      // SKAI Blend Accuracy - Part C (Missing Combo Builder Added)
      // ------------------------------------------------------------
      // What it is:
      //   A deterministic final-ticket builder that turns Top-N evidence
      //   into ranked combinations.
      //
      // Why it matters:
      //   Your system had Top-20 numbers but no canonical way to build
      //   ranked final tickets. This module supplies that bridge.
      //
      // What to do with it:
      //   Call window.SKAI_buildFinalCombos({ pickSize, extraCount, topK, limit })
      //   whenever you want final ranked ticket sets.
      //
      // Notes:
      //   - Fully optional: never runs unless called.
      //   - Uses blended evidence when present.
      //   - ES5 / Sorcerer safe. No template literals.
      // ------------------------------------------------------------
      (function initFinalComboBuilder(){
        if (window.SKAI_buildFinalCombos) return; // don't double-define

        function uniqSorted(arr){
          var seen = {};
          var out = [];
          for (var i=0;i<arr.length;i++){
            var n = arr[i];
            if (seen[n]) continue;
            seen[n] = true;
            out.push(n);
          }
          out.sort(function(a,b){ return a-b; });
          return out;
        }

        function getMainPool(topK){
          var br = window.SKAI_BLEND_RESULTS || null;
          var pool = [];

          // Prefer blend engine top list if available
          if (br && Array.isArray(br.topMain) && br.topMain.length){
            for (var i=0;i<br.topMain.length && pool.length<topK;i++){
              pool.push(br.topMain[i].number);
            }
          } else if (Array.isArray(window.SKAI_TOP_MAIN) && window.SKAI_TOP_MAIN.length){
            for (var j=0;j<window.SKAI_TOP_MAIN.length && pool.length<topK;j++){
              pool.push(window.SKAI_TOP_MAIN[j].num);
            }
          }

          return uniqSorted(pool);
        }

        function getExtraPool(topK){
          var br = window.SKAI_BLEND_RESULTS || null;
          var pool = [];

          if (br && Array.isArray(br.topExtra) && br.topExtra.length){
            for (var i=0;i<br.topExtra.length && pool.length<topK;i++){
              pool.push(br.topExtra[i].number);
            }
          } else if (Array.isArray(window.SKAI_TOP_EXTRA) && window.SKAI_TOP_EXTRA.length){
            for (var j=0;j<window.SKAI_TOP_EXTRA.length && pool.length<topK;j++){
              pool.push(window.SKAI_TOP_EXTRA[j].num);
            }
          }

          return uniqSorted(pool);
        }

        // Lexicographic k-combination generator (ES5)
        function kCombinations(arr, k){
          var results = [];
          var n = arr.length;
          if (k <= 0 || k > n) return results;

          var idx = [];
          for (var i=0;i<k;i++) idx[i]=i;

          while (true){
            var combo = [];
            for (var j=0;j<k;j++) combo.push(arr[idx[j]]);
            results.push(combo);

            var m = k - 1;
            while (m >= 0 && idx[m] === n - k + m) m--;
            if (m < 0) break;

            idx[m]++;
            for (var t=m+1;t<k;t++){
              idx[t] = idx[t-1] + 1;
            }
          }
          return results;
        }

        // Score a combo using blended evidence if available
        function scoreCombo(combo){
          var base = 0;
          for (var i=0;i<combo.length;i++){
            base += combo[i]; // neutral base tie-breaker (stable ordering)
          }

          try {
            var br = window.SKAI_BLEND_RESULTS || null;
            var map = br && br.mainMap ? br.mainMap : null;
            if (!map) return base;

            var lift = 0;
            for (var j=0;j<combo.length;j++){
              var n = combo[j];
              if (map[n] && typeof map[n].score === 'number'){
                lift += map[n].score;
              }
            }
            lift = lift / combo.length;

            // light influence to preserve your existing behavior shape
            return base + (lift * 0.15);
          } catch(_){
            return base;
          }
        }

        /**
         * window.SKAI_buildFinalCombos(opts)
         *
         * opts:
         *  {
         *    pickSize:   Number (required),
         *    extraCount:Number (default 0),
         *    topK:       Number (default 12),
         *    limit:      Number (default 25)
         *  }
         *
         * returns:
         *  [
         *    { main:[..], extra:[..], score:Number },
         *    ...
         *  ]
         */
        window.SKAI_buildFinalCombos = function(opts){
          opts = opts || {};
          var pickSize   = Number(opts.pickSize)   || 5;
          var extraCount = Number(opts.extraCount) || 0;
          var topK       = Number(opts.topK)       || 12;
          var limit      = Number(opts.limit)      || 25;

          if (topK < pickSize) topK = pickSize;
          if (limit < 1) limit = 25;

          var mainPool  = getMainPool(topK);
          var extraPool = (extraCount > 0) ? getExtraPool(Math.max(5, extraCount * 5)) : [];

          var mainCombos = kCombinations(mainPool, pickSize);
          var results = [];

          for (var i=0;i<mainCombos.length;i++){
            var main = mainCombos[i];
            var sc   = scoreCombo(main);

            var entry = { main: main.slice(), extra: [], score: sc };
            results.push(entry);
          }

          // rank main combos
          /* CHG: stable tie-breaker returns 0 on equality.
             Reason: comparator must be antisymmetric; equality should return 0.
             Benefit: prevents UI/save jitter when scores tie; no logic change otherwise. */
          results.sort(function(a,b){
            if (b.score !== a.score) return b.score - a.score;
            var am = a.main.join(','), bm = b.main.join(',');
            if (am === bm) return 0;
            return am < bm ? -1 : 1;
          });

          // attach extras by top evidence (simple, stable)
          if (extraCount > 0 && extraPool.length){
            for (var r=0;r<results.length;r++){
              results[r].extra = extraPool.slice(0, extraCount);
            }
          }

          if (results.length > limit){
            results = results.slice(0, limit);
          }

          // expose for UI or save handlers
          try { window.SKAI_FINAL_COMBOS = results.slice(); } catch(_){}

          return results;
        };
      })();
 

      // NEW: standalone extra renderer so we can repaint when extra head finishes
    if (typeof window.SKAI_renderExtras !== 'function') {
      window.SKAI_renderExtras = function(){
        try {
          var topX = Array.isArray(window.SKAI_TOP_EXTRA) ? window.SKAI_TOP_EXTRA : [];
          var aiX  = document.getElementById('aiExtraPredictionContainer');
          if (!aiX) return;
          // reuse global pad2 (defined in render)
          if (typeof window.SKAI_pad2 !== 'function') {
            window.SKAI_pad2 = function(n){
              var v = Number(n) || 0;
              var s = String(v);
              return s.length < 2 ? ('0' + s) : s;
            };
          }
          var pad2 = window.SKAI_pad2;

          aiX.innerHTML = '';
          if (!topX.length){
            aiX.removeAttribute('data-ai-ready');
            return;
          }

          var frag2 = document.createDocumentFragment();
          for (var tx = 0; tx < topX.length; tx++){
            var itemX = topX[tx];
            var numX  = itemX && itemX.num;
            var sx    = document.createElement('span');
            sx.className   = 'xball';
            sx.textContent = pad2(numX);
            sx.title       = 'Extra ' + numX;
            frag2.appendChild(sx);
          }
          aiX.appendChild(frag2);
          aiX.setAttribute('data-ai-ready', '1');
          aiX.style.display = '';
          var sum = document.getElementById('aiPredictionSummary');
          if (sum){
            // UX: same polished summary for the standalone extra renderer
            sum.textContent = 'Source: SKAI client ML \u2022 Main and extra numbers ready.';
          }
        } catch(_){}
      };
    } // close singleton guard for SKAI_renderExtras
    // Wire: whenever the extra head signals ready, repaint extras
    try {
      if (!window.__skaiExtraRenderBound__) {
        window.__skaiExtraRenderBound__ = true;
        window.addEventListener('skai:extra:done', function(){
          try {
            if (typeof window.SKAI_renderExtras === 'function') {
              window.SKAI_renderExtras();
            }
          } catch(_){}
        });
      }
    } catch(_){}

    // Hot path: if extras are already computed (e.g., quick reruns), render now
    try {
      if (Array.isArray(window.SKAI_TOP_EXTRA) && window.SKAI_TOP_EXTRA.length) {
        window.SKAI_renderExtras();
      }
    } catch(_){}

	// -------------------------------
    // Section 5: Finalize progress
    // -------------------------------
 
    try {
      var __P = (typeof window.SKAI_getProgress === 'function')
                  ? window.SKAI_getProgress()
                  : (window.SKAI_Progress || null);

      // CHG: strict-safe message alias for finalize block
      var SKAI_msgSafe = (typeof window.SKAI_msg === 'function')
        ? window.SKAI_msg
        : function(k){ return String(k || ''); };

      // 1) Flip any "Epoch x / y" labels to "Completed."
      var epochLabels = document.querySelectorAll('.skai-epoch, .skai-epoch-label, .ai-row-epoch, .ai-epoch');
      for (var i = 0; i < epochLabels.length; i++) {
        var txt = (epochLabels[i].textContent || '').trim();
        if (/^Epoch\s+\d+\s*\/\s*\d+/.test(txt)) {
          epochLabels[i].textContent = 'Completed.';
          epochLabels[i].setAttribute('data-skai-main-done', '1');
        }
      }

      // 2) Ensure the Main row meter hits 100% (avoid Extra row)
      var barCandidates = document.querySelectorAll(
        '.skai-progress-main .bar > i, .skai-progress-main .meter > i, ' +
        '.ai-row-main .bar > i, .ai-row-main .meter > i, ' +
        '.skai-progress .bar > i, .skai-progress .meter > i'
      );
      for (var j = 0; j < barCandidates.length; j++) {
        var el = barCandidates[j];
        var host = (el.closest && el.closest('.skai-progress, .ai-row')) ? el.closest('.skai-progress, .ai-row') : null;
        var hostText = (host && host.textContent) ? host.textContent : '';
        if (/Extra\s+Numbers/i.test(hostText)) continue; // don't touch Extra row
        el.style.width = '100%';
        // keep attribute in sync for downstream consumers (no ARIA added)
        var prog = document.getElementById('skai-progress') || document.querySelector('[data-skai-progress]');
        if (prog && prog.setAttribute) {
          prog.setAttribute('data-valuenow', '100');
        }
      }

      // 3) Non-regressing progress ? 100% and mark done
      if (typeof window.SKAI_progressSetSafe === 'function') {
        window.SKAI_progressSetSafe(100, SKAI_msgSafe('readyPicks'));
      } else if (__P && typeof __P.set === 'function') {
        __P.set(100, SKAI_msgSafe('readyPicks'));
      }

      if (__P && typeof __P.done === 'function') {
        __P.done(SKAI_msgSafe('readyPicks'));
      }

      if (typeof setLive === 'function') {
        setLive(SKAI_msgSafe('readyPicks'));
      }

      // 4) If extras already landed, ensure they-re painted (non-fatal)
      if (typeof window.SKAI_renderExtras === 'function') {
        try {
          window.SKAI_renderExtras();
        } catch (eRender) {
          try {
            (window.SKAI_warn || console.warn)('[SKAI] Extra rendering failed, skipping extras:', eRender);
          } catch(_){}
        }
      }

    } catch (e) {
      try {
        (window.SKAI_warn || console.warn)('[SKAI] ML finalize error:', e);
        var __P2 = (typeof window.SKAI_getProgress === 'function')
                    ? window.SKAI_getProgress()
                    : (window.SKAI_Progress || null);
        if (__P2 && typeof __P2.done === 'function') {
          __P2.done(SKAI_msgSafe('error'));
        }
      } catch (_) {}
      try {
        var __err = String((e && e.message) || e);
        if (typeof setLive === 'function') {
          setLive('Error: ' + __err, 'error');
        }
      } catch (_) {}
      try {
        var SKAI_emitSafe = (typeof window.SKAI_emit === 'function') ? window.SKAI_emit : function(){};
        SKAI_emitSafe('skai:analysis-stop', { detail: { reason: String((e && e.message) || e) } });
      } catch (_) {}
    } finally {
      try {
        window.__SKAI_RUNNING__ = false;
      } catch (_) {}
    }

    // -------------------------------------------------
    // Outer safety net NOTE:
    // The outer catch/finally was removed here because the
    // matching top-level `try {` is not open at this point,
    // which caused a SyntaxError (floating catch).
    // If you want an outer safety net, ensure a real
    // `try { ... } catch(eOuter) { ... } finally { ... }`
    // wraps the entire function body from the top.
    // -------------------------------------------------
 
  // Wire: run after ML has actually produced probs
  try {
    if (!window.__skaiScoreAfterLearnedBound__) {
      window.__skaiScoreAfterLearnedBound__ = true;
      window.addEventListener('skai:learned', function(){
        try {
          if (typeof window.SKAI_scoreAndRender === 'function') {
            window.SKAI_scoreAndRender();
          }
        } catch (e) {
          console.error('[SKAI] score/render after learned failed:', e);
        }
      });
    }
  } catch (_) {}

  // Safety: if probs already exist (hot path), render now
  try {
    if (Array.isArray(window.SKAI_lastProbs) && window.SKAI_lastProbs.length > 0) {
      window.SKAI_scoreAndRender();
    }
  } catch (_) {}
})();
})();

/* -------------------------------------------------------------
   Developer telemetry logger (Step 4.12) ? wire once, outside fn
   ------------------------------------------------------------- */
; (function(){
  if (window.__SKAI_TELEM_WIRED__) return;
  window.__SKAI_TELEM_WIRED__ = true;

  window.addEventListener('skai:telemetry', function(e){
    try {
      var d = e && e.detail;
      if (!d) return;
      var ts = d.timestamp || new Date().toISOString();
      var stamp = '[' + ts.substring(11,19) + ']';
      var headFmt  = '%cSKAI telemetry%c';
      var headSty1 = 'background:#222;color:#0ff;padding:2px 4px;border-radius:3px;';
      var headSty2 = 'color:#999;';
      var tail =
        '\nOutcome: ' + (d.outcome || '?') +
        (d.reason      ? '\nReason: ' + d.reason : '') +
        (d.tunedWindow ? '\nTuned W=' + d.tunedWindow : '') +
        (d.draws       ? '\nDraws=' + d.draws : '') +
        (d.durationMs  ? '\nDuration=' + d.durationMs + ' ms' : '') +
        '\nExtra ball: ' + (d.hasExtra ? 'Yes' : 'No') +
        '\nTime: ' + stamp;

      console.log(headFmt + tail, headSty1, headSty2);
    } catch (_){}
  });
})(); 
</script>

<script>
/* One-shot confidence wiring ? live % and optional chart feed */
;(function(){
  if (window.__SKAI_CONF_WIRED__) return;
  window.__SKAI_CONF_WIRED__ = true;

  function clamp01(x){ x = Number(x)||0; return x < 0 ? 0 : (x > 1 ? 1 : x); }
  function fmtPct(x){ try { return Math.round(clamp01(x)*100); } catch(_){ return 0; } }

  function setConfPct(p){
    var sel = document.querySelector('#ai-confidence, .skai-conf-pct, [data-skai-conf]');
    if (!sel) return;
    try {
      var v = fmtPct(p);
      sel.textContent = v + '%';
      sel.setAttribute('data-skai-conf', String(v));
    } catch(_){}
  }

  function pushConfChart(x, y){
    try{
      var ch = window.SKAI_CONF_CHART;
      if (!ch || !ch.data || !ch.data.datasets || !ch.data.datasets.length) return;
      var ds = ch.data.datasets[0];
      if (!Array.isArray(ch.data.labels)) ch.data.labels = [];
      ch.data.labels.push(x);
      if (!Array.isArray(ds.data)) ds.data = [];
      ds.data.push(y);
      if (typeof ch.update === 'function') ch.update();
    } catch(_){}
  }

  // Update on epoch AND metrics; keep confidence non-decreasing within a run
  (function(){
    var lastPct = 0;
    function updateFromLogs(logs, epoch){
      var conf =
        (typeof logs.val_accuracy === 'number' ? logs.val_accuracy :
        (typeof logs.accuracy     === 'number' ? logs.accuracy     :
        (typeof logs.val_loss     === 'number' ? (1 - logs.val_loss) : NaN)));
      /* CHG: ES5-safe finite guard.
         Reason: Number.isFinite is ES6 and may be undefined in older clients.
         Benefit: confidence updates won-t crash or silently stop. */
      if (!isFinite(conf)) return;
      var pct = clamp01(conf);
      if (pct < lastPct) pct = lastPct; // monotonic during run
      lastPct = pct;
      setConfPct(pct);
      if (typeof epoch === 'number') pushConfChart((epoch|0)+1, Math.round(pct*100));
    }
    window.addEventListener('skai:ml:epoch', function(e){
      try { var d = e && e.detail || {}; updateFromLogs(d.logs||{}, d.epoch); } catch(_){}
    });
    window.addEventListener('skai:ml:metrics', function(e){
      try { var d = e && e.detail || {}; updateFromLogs(d.logs||{}, d.epoch); } catch(_){}
    });
    // reset guard when a run starts
    /* CHG: ES5-safe listener signature.
       Reason: third-arg options objects can throw in older browsers.
       Benefit: prevents tail-script failure; behavior unchanged. */
    window.addEventListener('skai:ml:start', function(){ lastPct = 0; }, false);
  })();

  // Final paint after scoring (ensure top picks reflect the latest predictions)
  window.addEventListener('skai:score:done', function(){
    try {
      // Repaint top picks whenever scoring finishes so the balls always
      // show the most recent, "ready" predictions from SKAI_TOP_MAIN/EXTRA.
      if (typeof window.SKAI_renderTopPicks === 'function') {
        window.SKAI_renderTopPicks();
      }
    } catch(_){}
  });
})();
</script>

<script>
/* SKAI Insights wiring - uses existing #skai-insights styles (no ARIA, no new globals)
   CHG: replaced garbled -?- with an em dash for clean typography and to prevent mojibake. */
;(function(){
  if (window.__SKAI_INSIGHTS_WIRED__) return;
  window.__SKAI_INSIGHTS_WIRED__ = true;

  function ensureInsightsBox(){
    var box = document.getElementById('skai-insights');
    if (!box) return null;
    // minimal skeleton if empty
    if (!box.querySelector('.skai-insights__hdr')){
      box.innerHTML =
        '<div class="skai-insights__hdr">AI Confidence & Picks</div>' +
        '<div class="skai-insights__bar"><i id="skai-insights-fill" style="width:0%"></i></div>' +
        '<div class="skai-insights__body">' +
          '<div class="skai-insights__conf">Confidence: <strong class="skai-conf-pct">0%</strong></div>' +
          '<div class="skai-insights__picks" id="skai-insights-picks"></div>' +
          '<div class="skai-insights__why"><em class="skai-unc">Live during training; stabilizes after completion.</em></div>' +
          '<div class="skai-insights__chips" id="skai-insights-chips"></div>' +
        '</div>';
    }
    return box;
  }

  function clamp01(x){ x = Number(x)||0; return x<0?0:(x>1?1:x); }
  function setInsightsConfidence(p){
    var box = ensureInsightsBox(); if (!box) return;
    var pct = Math.round(clamp01(p)*100);
    var f = document.getElementById('skai-insights-fill'); if (f) f.style.width = pct + '%';
    var t = box.querySelector('.skai-conf-pct'); if (t){ t.textContent = pct + '%'; t.setAttribute('data-skai-conf', String(pct)); }
  }

  function pad2(n){ var s=String(n|0); return s.length<2?('0'+s):s; }

  function renderInsightsRecommendations(){
    var box = ensureInsightsBox(); if (!box) return;
    var chips = document.getElementById('skai-insights-chips'); if (!chips) return;
    var picks = document.getElementById('skai-insights-picks'); // optional summary

    var top  = Array.isArray(window.SKAI_TOP_MAIN)  ? window.SKAI_TOP_MAIN  : [];
    var topX = Array.isArray(window.SKAI_TOP_EXTRA) ? window.SKAI_TOP_EXTRA : [];
    var confEl = document.querySelector('.skai-conf-pct');
    /* CHG: ES5-safe finite guard.
       Reason: Number.isFinite is ES6; older clients may not support it.
       Benefit: insights chips won-t fail silently. */
    var confPct = 0;
    if (confEl){
      var v = parseInt((confEl.textContent||'0').replace(/\D+/g,''),10);
      if (isFinite(v)) confPct = v;
    }

    // simple, explainable heuristics for chips (presentational only)
    var chipsOut = [];
    if (confPct >= 75)      chipsOut.push('High confidence');
    else if (confPct >= 55) chipsOut.push('Moderate confidence');
    else                    chipsOut.push('Exploratory run');

    if (top && top.length >= 5) chipsOut.push('Top 5 stabilized');
    if (topX && topX.length)    chipsOut.push('Extra-ball ready');

    // Fill chips
    chips.innerHTML = '';
    for (var i=0;i<chipsOut.length;i++){
      var s = document.createElement('span');
      s.className = 'skai-chip';
      s.textContent = chipsOut[i];
      chips.appendChild(s);
    }

    // Optional short picks summary (first 10 only, no new UI widgets)
    if (picks){
      /* CHG: Support both shapes for SKAI_TOP_MAIN / SKAI_TOP_EXTRA.
         Reason: some paths emit plain numbers, others emit {num,score}.
         Benefit: Insights never renders blank chips due to shape mismatch. */
      var nums = top.slice(0,10).map(function(x){
        var v = (x && typeof x === 'object' && x.num != null) ? x.num : x;
        return pad2(v);
      }).filter(Boolean).join(' ');

      var xFirst = (topX && topX.length) ? topX[0] : null;
      var xVal = (xFirst && typeof xFirst === 'object' && xFirst.num != null) ? xFirst.num : xFirst;
      var x1 = (xVal != null && isFinite(+xVal))
        ? (' - Extra ' + pad2(xVal))
        : '';

      picks.textContent = nums ? ('Top: ' + nums + x1) : '';
    }
  }

  // live confidence from epoch/metrics logs (monotonic within run)
  (function(){
    var last = 0;
    function toConf(logs){
      var c =
        (typeof logs.val_accuracy === 'number' ? logs.val_accuracy :
        (typeof logs.accuracy     === 'number' ? logs.accuracy     :
        (typeof logs.val_loss     === 'number' ? (1 - logs.val_loss) : NaN)));
      /* CHG: ES5-safe finite check.
         Reason: avoids Number.isFinite (ES6).
         Benefit: live confidence keeps working everywhere. */
      return isFinite(c) ? c : null;
    }
    function bump(c){
      if (c == null) return;
      if (c < last) c = last;
      last = c;
      setInsightsConfidence(c);
    }
    window.addEventListener('skai:ml:epoch',   function(e){ try{ bump(toConf((e&&e.detail&&e.detail.logs)||{})); }catch(_){} });
    window.addEventListener('skai:ml:metrics', function(e){ try{ bump(toConf((e&&e.detail&&e.detail.logs)||{})); }catch(_){} });
    /* CHG: ES5-safe addEventListener signature.
       Reason: options objects can throw in older browsers.
       Benefit: prevents tail-script abort; behavior unchanged. */
    window.addEventListener('skai:ml:start', function(){ last = 0; }, false);
  })();

  // render recommendations after picks are computed
  window.addEventListener('skai:render:done', function(){ renderInsightsRecommendations(); });

  // Hot path: if something is already there, render now
  try { renderInsightsRecommendations(); } catch(_){}
})();
</script>

<script>
// Safe debug shim — always defined, even if a real logger isn't loaded yet
// CHG: fixed garbled chars ("?" / "isn't") to proper punctuation.
;window.SKAI_debug = (typeof window.SKAI_debug === 'function')
  ? window.SKAI_debug
  : function(){ try{ console.debug && console.debug.apply(console, arguments); }catch(_){} };
</script>



<script>
// Alias exports (safer, fully idempotent; won't clobber real orchestrators)
// CHG: fixed garbled "won't" apostrophe to clean ASCII (no behavior change).
(function(){
  'use strict';

  function tryWireAliases(attempt){
    var runRef = (typeof window.runSkaiML === 'function') ? window.runSkaiML : null;
    if (!runRef) {
      // CHG: ES5-safe deferred wiring so aliases appear if runner loads later.
      if ((attempt|0) < 10) {
        setTimeout(function(){ tryWireAliases((attempt|0) + 1); }, 200);
      }
      return;
    }

    if (typeof window.startSkaiML !== 'function')              window.startSkaiML = runRef;
    if (typeof window.SKAI_run !== 'function')                  window.SKAI_run = runRef;
    if (typeof window.runSkaiClientOnce !== 'function')         window.runSkaiClientOnce = runRef;
    if (typeof window.SKAI_startPredictionFlow !== 'function')  window.SKAI_startPredictionFlow = runRef;
  }

  tryWireAliases(0);
})();
</script>

<script>
/* ==========================================================
   SKAI JS Block B: Copy / Export Utilities + AI Save Wiring
   Purpose:
     - Copy predicted mains/extras to clipboard
     - Prepare hidden save fields for MyLottoExpert dashboard
   Depends on:
     - DOM elements for prediction outputs, save form
     - setLive() available (Block A provides fallback)
   Exposes (globals):
     - window.skaiPrepareAiSave()  (defined in Block A / earlier IIFE)
   Notes:
     - Must run after prediction UI exists, but safe if loaded early.
   ========================================================== */

// Copy buttons (global helpers + all handlers in one scope)
;(function () {
  'use strict';

  function pad2(n) {
    var v = parseInt(String(n).replace(/\D/g, ''), 10);
    // ES5 finite guard
    if (!isFinite(v)) {
      return '';
    }
    return (v < 10 ? '0' : '') + v;
  }

  // Collect pure numeric tokens from multiple selectors
  function getNumbers() {
    var out = [];
    for (var a = 0; a < arguments.length; a++) {
      var sel = arguments[a];
      if (!sel) {
        continue;
      }
      var nodes = document.querySelectorAll(sel);
      for (var i = 0; i < nodes.length; i++) {
        var t = (nodes[i].textContent || '')
          .replace(/[\u00A0\u200B-\u200D\uFEFF]/g, '') // strip NBSP & ZW*
          .trim();
        if (/^\d+$/.test(t)) {
          out.push(t);
        }
      }
    }
    return out;
  }

  function copyText(t) {
    function legacyCopy(txt) {
      var ta = document.createElement('textarea');
      ta.value = txt;
      ta.setAttribute('readonly', '');
      ta.style.position = 'fixed';
      ta.style.opacity = '0';
      document.body.appendChild(ta);
      ta.select();
      try {
        document.execCommand('copy');
      } finally {
        document.body.removeChild(ta);
      }
      return Promise.resolve();
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
      return navigator.clipboard.writeText(t).catch(function () {
        return legacyCopy(t);
      });
    }

    return legacyCopy(t);
  }

  function normalizeNumericArray(arr) {
    if (!arr || !arr.length) {
      return [];
    }
    var out = [];
    for (var i = 0; i < arr.length; i++) {
      var v = parseInt(arr[i], 10);
      if (!isNaN(v)) {
        out.push(v);
      }
    }
    return out;
  }

  function wireOnce(id, handler) {
    var el = document.getElementById(id);
    if (!el) {
      return;
    }

    // ES5-safe wired flag (dataset fallback)
    var wired = (el.dataset && el.dataset.wired) ? el.dataset.wired : el.getAttribute('data-wired');
    if (wired === '1') {
      return;
    }

    if (el.dataset) {
      el.dataset.wired = '1';
    } else {
      el.setAttribute('data-wired', '1');
    }

    el.addEventListener('click', handler);
  }

  // AI save wiring helper – prepares hidden fields for MyLottoExpert.
  // Uses the same pattern as the "Copy SKAI picks" button: top 20 mains, top 5 extras.
  //
  // NOTE:
  //   The canonical implementation of window.skaiPrepareAiSave is defined earlier
  //   in this file (inside another IIFE). Here we only:
  //     1) Harvest numbers from the DOM on submit.
  //     2) Pass numbers + SKAI parameters (if available) into that helper.
  //
  //   To provide SKAI parameters, set window.skaiConfig in your SKAI engine:
  //
  //     window.skaiConfig = {
  //       epochs: 10,
  //       batchSize: 2,
  //       dropoutRate: 0.2,
  //       learningRate: 0.0002,
  //       activationFunction: 'tanh',
  //       hiddenLayers: 2,
  //       recencyDecay: 0,
  //       drawsAnalyzed: 1200
  //     };
  //
  //   The helper will then populate the matching hidden inputs so they can be
  //   saved with the prediction.
  // ---------------------------------------------------------------------------

  // Before the AI save form submits, harvest top 20 mains and top 5 extras from the AI display
  if (!window.__SKAI_AI_SAVE_SUBMIT_WIRED__) {
    window.__SKAI_AI_SAVE_SUBMIT_WIRED__ = true;

    document.addEventListener('submit', function (ev) {
      var form = ev.target;
      if (!form || form.id !== 'skai-ai-save-form') {
        return;
      }

      if (typeof window.skaiPrepareAiSave !== 'function') {
        return;
      }

      // Use the same extraction as the Copy SKAI picks button (DOM fallback)
      var mainsAI = getNumbers(
        '#aiPredictedNumbers .nball',
        '#skai-ai-panel .nball',
        '.skai-ai-main .nball'
      ).slice(0, 20);
      var extraAI = getNumbers(
        '#aiExtraPredictionContainer .xball'
      ).slice(0, 5);

      // Default order from DOM
      var mainsArrDom = normalizeNumericArray(mainsAI);
      var extraArrDom = normalizeNumericArray(extraAI);

      // Preferred order: arrays provided by the SKAI engine, already ordered
      // from most likely to least likely. If not provided, fall back to DOM order.
      var mainsArr = (window.skaiSaveMainOrdered && window.skaiSaveMainOrdered.length)
        ? normalizeNumericArray(window.skaiSaveMainOrdered)
        : mainsArrDom;

      var extraArr = (window.skaiSaveExtraOrdered && window.skaiSaveExtraOrdered.length)
        ? normalizeNumericArray(window.skaiSaveExtraOrdered)
        : extraArrDom;

      if (!mainsArr.length && !extraArr.length) {
        // Block submission if there is nothing to save
        ev.preventDefault();
        var live = document.getElementById('ai-live-status');
        if (live && !live.textContent) {
          live.textContent = 'Nothing to save yet. Run SKAI AI analysis first.';
        }
        return;
      }

      // Optional SKAI parameter source – your SKAI engine can set this object
      var cfg = window.skaiConfig || {};

      // Call the canonical helper to populate all hidden fields (numbers + params)
      window.skaiPrepareAiSave({
        mainNumbers: mainsArr,
        extraNumbers: extraArr,
        numbersJson: {
          main_numbers: mainsArr,
          extra_numbers: extraArr
        },
        topCombosJson: null,
        drawsAnalyzed: (typeof cfg.drawsAnalyzed === 'number') ? cfg.drawsAnalyzed : 0,

        // SKAI / NN hyperparameters – only applied if defined
        epochs: cfg.epochs,
        batchSize: cfg.batchSize,
        dropoutRate: cfg.dropoutRate,
        learningRate: cfg.learningRate,
        activationFunction: cfg.activationFunction,
        hiddenLayers: cfg.hiddenLayers,
        recencyDecay: cfg.recencyDecay
      });
    });
  }

  // AI (main + extra) button in the AI card (canonical copy format)
  wireOnce('btnCopyAiBoth', function () {
    var mainsAI = getNumbers(
      '#aiPredictedNumbers .nball',
      '#skai-ai-panel .nball',
      '.skai-ai-main .nball'
    ).slice(0, 20);

    var extraAI = getNumbers(
      '#aiExtraPredictionContainer .xball'
    ).slice(0, 5);

    if (!mainsAI.length && !extraAI.length) {
      var live0 = document.getElementById('ai-live-status');
      if (live0) {
        // UX: softer, branded message when there is nothing to copy yet
        live0.textContent = 'Nothing to copy yet. Run SKAI first to generate AI picks.';
      }
      return;
    }

    mainsAI = mainsAI.map(pad2).filter(Boolean);
    extraAI = extraAI.map(pad2).filter(Boolean);

    var parts = [];
    if (mainsAI.length) {
      parts.push('Main: ' + mainsAI.join(' '));
    }
    if (extraAI.length) {
      parts.push('Extra: ' + extraAI.join(' '));
    }

    // Canonical SKAI prefix
    var txt = 'SKAI picks \u2022 ' + parts.join('  |  ');

    copyText(txt).then(function () {
      try {
        if (console && console.debug) {
          console.debug('[SKAI] Copied picks to clipboard.');
        }
      } catch (e) {}

      var live = document.getElementById('ai-live-status');
      if (live) {
        live.textContent = 'Copied picks to clipboard.';
      }
    }).catch(function () {
      // Graceful fallback prompt (mirrors earlier handler behavior)
      try {
        window.prompt('Copy picks:', txt);
      } catch (e) {}
    });
  });

})();
</script>

<script>
/* ==========================================================
   SKAI JS Block A: Core Shims, Debug Flags, & Event Bridge
   Purpose:
     - Provide safe fallbacks for setLive(), live(), SKAI_emit()
     - Define debug toggles and helpers (SKAI_DEBUG, SKAI_log, SKAI_warn)
   Depends on:
     - None (must run very early)
   Exposes (globals):
     - window.setLive (fallback)
     - window.live (legacy shim)
     - window.SKAI_emit (polyfilled emitter)
     - window.SKAI_DEBUG / SKAI_log / SKAI_warn
   Notes:
     - Behavior-preserving; required before any other SKAI block uses these.
   ========================================================== */
/* SKAI Core Shims & Debug */
(function () { 'use strict';

  // fallback if setLive is not yet defined
  if (typeof window.setLive !== 'function') {
    window.setLive = function setLive(message, kind){
      try {
        var text = (message && typeof message === 'object') ? (message.text || message.message || '') : String(message || '');
        if (kind === 'error' || (message && message.kind === 'error')) text = 'Error: ' + text;
        if (text) { try { console.debug('[SKAI]', text); } catch(_){} }
      } catch(_){}
    };
  }

  // shim: redirect legacy live() calls to setLive()
  if (typeof window.live !== 'function') {
    window.live = function(){
      return {
        set textContent(v){ try { if (typeof window.setLive === 'function') window.setLive(v); } catch(_){ } },
        get textContent(){ return ''; }
      };
    };
  }

  // debug helpers (silent by default; set window.SKAI_DEBUG = true to enable)
  if (typeof window.SKAI_DEBUG === 'undefined') window.SKAI_DEBUG = false;
  if (typeof window.SKAI_log  !== 'function') window.SKAI_log  = function(){ try{ if (window.SKAI_DEBUG) console.log.apply(console, arguments); }catch(_){ } };
  if (typeof window.SKAI_warn !== 'function') window.SKAI_warn = function(){ try{ if (window.SKAI_DEBUG) console.warn.apply(console, arguments); }catch(_){ } };

  // Event shim - emits CustomEvent safely (idempotent, payload-normalizing)
  /* CHG: add ES5/legacy CustomEvent fallback.
     Reason: `new CustomEvent` can be undefined in older clients.
     Benefit: all SKAI_* listeners (progress, learned, save-enablers) still fire reliably. */
  if (typeof window.SKAI_emit !== 'function') {
    window.SKAI_emit = function(name, payload){
      try {
        // Accept either a plain payload or an object that already has {detail:?}
        var d = (payload && typeof payload === 'object' && Object.prototype.hasOwnProperty.call(payload, 'detail'))
          ? payload.detail
          : (payload || {});

        var ev;
        if (typeof window.CustomEvent === 'function') {
          ev = new CustomEvent(String(name || ''), { detail: d });
        } else {
          ev = document.createEvent('CustomEvent');
          ev.initCustomEvent(String(name || ''), true, true, d);
        }
        window.dispatchEvent(ev);
      } catch(_){}
    };
  }

  // announce shim (routes to setLive politely)
  if (typeof window.SKAI_announce !== 'function') {
    window.SKAI_announce = function(msg){ try{ if (typeof window.setLive === 'function') window.setLive(String(msg||'')); }catch(_){} };
  }

  // debug-only telemetry summary
  window.addEventListener('skai:telemetry', function(e){
    try {
      if (!window.SKAI_DEBUG) return;
      var d = e && e.detail || {};
      var parts = ['[SKAI] telemetry:', d.outcome || '?'];
      if (d.reason) parts.push('reason=' + d.reason);
      if (typeof d.durationMs === 'number') parts.push('duration=' + d.durationMs + 'ms');
      if (d.startedAt)  parts.push('startedAt='  + d.startedAt);
      if (d.finishedAt) parts.push('finishedAt=' + d.finishedAt);
      // CHG: replace mojibake - with a proper separator bullet in debug log
      (window.SKAI_log || console.log)(parts.join(' \u2022 '));
    } catch(_){}
  });


  // public, read-only metrics accessor
  if (typeof window.SKAI_getMetrics !== 'function') {
    window.SKAI_getMetrics = function(){
      try {
        var m = window.SKAI_METRICS || {};
        var snap = {
          lastOutcome:     m.lastOutcome || null,
          lastReason:      m.lastReason  || null,
          lastDurationMs:  (m.lastDurationMs|0) || 0,
          lastStartedAt:   m.lastStartedAt || null,
          lastFinishedAt:  m.lastFinishedAt || null,
          totalStarts:     (m.totalStarts|0) || 0,
          totalDone:       (m.totalDone|0)   || 0,
          totalStopped:    (m.totalStopped|0)|| 0
        };
        snap.isRunning   = (window.__SKAI_RUNNING__ === true);
        snap.startedAgoMs = (window.__SKAI_T0__) ? (((typeof performance!=='undefined'&&performance.now)?performance.now():Date.now()) - window.__SKAI_T0__) : null;
        return snap;
      } catch(_){
        return { lastOutcome:null, totalStarts:0, totalDone:0, totalStopped:0, isRunning:(window.__SKAI_RUNNING__===true) };
      }
    };
  }

  // QA helper: reset metrics (no-op while running)
  if (typeof window.SKAI_resetMetrics !== 'function') {
    window.SKAI_resetMetrics = function(){
      try {
        if (window.__SKAI_RUNNING__ === true) return false;
        window.SKAI_METRICS = {
          lastOutcome: null,
          lastReason:  null,
          lastDurationMs: 0,
          lastStartedAt:  null,
          lastFinishedAt: null,
          totalStarts: 0,
          totalDone:   0,
          totalStopped:0
        };
        window.__SKAI_T0__ = null;
        window.__SKAI_T0_ISO__ = null;
        if (window.SKAI_log) window.SKAI_log('[SKAI] metrics reset');
        return true;
      } catch(_){ return false; }
    };
  }

  /* Shims: Clipboard & Export Summary (idempotent) */
  if (typeof window.SKAI_copy !== 'function') {
    window.SKAI_copy = function(text){
      text = String(text || '');
      function legacyCopy(txt){
        var ta = document.createElement('textarea'); ta.value = txt;
        ta.setAttribute('readonly',''); ta.style.position='fixed'; ta.style.opacity='0';
        document.body.appendChild(ta); ta.select();
        try { document.execCommand('copy'); } finally { document.body.removeChild(ta); }
        return Promise.resolve();
      }
      if (navigator.clipboard && navigator.clipboard.writeText){
        return navigator.clipboard.writeText(text).catch(function(){ return legacyCopy(text); });
      }
      return legacyCopy(text);
    };
  }

  if (typeof window.SKAI_buildExportSummary !== 'function') {
    window.SKAI_buildExportSummary = function(){
      try {
        var meta = (window.__SKAI_INSIGHTS_META__ && window.__SKAI_INSIGHTS_META__.last) || {};
        var parts = [];
        if (meta.export) parts.push(String(meta.export));

        if (!parts.length) {
          // CHG: Use explicit prediction data sources ONLY - never scrape DOM.
          // Reason: DOM .nball elements can include draw history pills from other page sections.
          // Benefit: Export summary always shows actual AI predictions, not recent draws.
          var nums = [];
          
          // Priority 1: Use the captured last picks from scoring
          if (window.__SKAI_LAST_PICKS__ && window.__SKAI_LAST_PICKS__.length) {
            for (var i=0; i<window.__SKAI_LAST_PICKS__.length; i++){
              nums.push(String(window.__SKAI_LAST_PICKS__[i]));
            }
          } else if (Array.isArray(window.SKAI_TOP_MAIN) && window.SKAI_TOP_MAIN.length) {
            // Priority 2: Use SKAI_TOP_MAIN if available
            for (var j=0; j<window.SKAI_TOP_MAIN.length; j++){
              var item = window.SKAI_TOP_MAIN[j];
              nums.push(String(item.num || item));
            }
          }
          // Priority 3 REMOVED: Never scrape .nball from DOM - those could be draw history
          
          if (nums.length) parts.push('Picks: ' + nums.join(', '));
        }

        return parts.join(' | ');
      } catch(_){ return ''; }
    };
  }

  // Global fail-safe traps
  window.addEventListener('unhandledrejection', function(ev){
    try {
      var msg = (ev && ev.reason && (ev.reason.message || String(ev.reason))) || 'Unhandled promise rejection';
      (window.SKAI_warn || console.warn)('[SKAI] unhandledrejection:', msg);
      if (typeof setLive === 'function') setLive('Error: ' + msg, 'error');
      try {
        if (typeof window.SKAI_emit === 'function') {
          // CHG: normalize payload to detail.
          window.SKAI_emit('skai:analysis-stop', { detail: { reason: 'unhandledrejection:' + msg } });
        }
      } catch(_){}
    } catch(_){}
  });

  window.addEventListener('error', function(ev){
    try {
      var msg = (ev && ev.message) ? ev.message : 'Script error';
      (window.SKAI_warn || console.warn)('[SKAI] window.error:', msg);
      if (typeof setLive === 'function') setLive('Error: ' + msg, 'error');
       try {
        if (typeof window.SKAI_emit === 'function') {
          // CHG: normalize payload to detail.
          window.SKAI_emit('skai:analysis-stop', { detail: { reason: 'window.error:' + msg } });
        }
      } catch(_){}
    } catch(_) {}
  });
})(); 
</script>

<script>
/* SKAI Watchdog, Runner, Data/Progress Accessors */
(function(){ 'use strict';
  // Heartbeat + watchdog (auto-recovery; configurable via window.SKAI_LIMITS)
  (function(){
    try {
      var beat = function(){ try { window.__SKAI_HB__ = Date.now(); } catch(_){ } };
      window.addEventListener('skai:autotune:progress', beat);
      window.addEventListener('skai:ml:epoch', beat);
      window.addEventListener('skai:extra:epoch', beat);

      // NEW: mark T0 at training start for accurate MAX_RUN timing (for every run)
      window.addEventListener('skai:ml:start', function(){
        try { window.__SKAI_T0__ = Date.now(); } catch(_){}
      }, false); // CHG: ES5-safe signature; behavior unchanged.

      var clearBeat = function(){
        try { window.__SKAI_HB__ = null; window.__SKAI_T0__ = null; } catch(_){ }
      };
      /* CHG: ES5-safe signature (no options object).
         Reason: old browsers/webviews can throw on {once:true}.
         Benefit: watchdog teardown still works; duplicate clears are harmless. */
      window.addEventListener('skai:ml:done',       clearBeat, false);
      window.addEventListener('skai:analysis-stop', clearBeat, false);

      var LIM       = (window.SKAI_LIMITS || {});
      // Default heartbeat timeout: 2 minutes (120000 ms) instead of 30s.
      /* CHG: ES5-safe finite guard.
         Reason: Number.isFinite is ES6.
         Benefit: watchdog won-t crash on older clients. */
      var LIMIT_MS  = isFinite(+LIM.noHeartbeatMs) ? +LIM.noHeartbeatMs : 120000;

      // Compute MAX_RUN. If LIM.maxRunMs is not provided, we default to Infinity (no max-run cutoff),
      // and rely on the heartbeat timeout as the primary safety mechanism.
      (function(){
        var rawMax;
        /* CHG: ES5-safe finite guard for maxRunMs. */
        if (isFinite(+LIM.maxRunMs)) {
          rawMax = +LIM.maxRunMs;
          if (rawMax < 60000) {                     // floor: at least 60 seconds
            rawMax = 60000;
          }
        } else {
          rawMax = Infinity;                        // default: no explicit max-run limit
        }
        window.__SKAI_MAX_RUN__ = rawMax;           // expose for debugging
      })();
      var MAX_RUN   = window.__SKAI_MAX_RUN__;

      /* CHG: ES5-safe finite guard for watchdogTickMs. */
      var TICK_MS   = isFinite(+LIM.watchdogTickMs) ? +LIM.watchdogTickMs : 10000;
      var INT_MSG   = (typeof LIM.interruptMessage === 'string' && LIM.interruptMessage)
        ? LIM.interruptMessage
        : 'AI process interrupted?';

      if (!window.__SKAI_WATCHDOG_TIMER__) {
        window.__SKAI_WATCHDOG_TIMER__ = setInterval(function(){
          try {
            if (window.__SKAI_RUNNING__ !== true) return;
            var t0   = window.__SKAI_T0__ || Date.now();
            var now  = Date.now();
            var age  = now - t0;
            var hb   = window.__SKAI_HB__;
            var sinceBeat = (hb ? (now - hb) : Infinity);

            if (age > MAX_RUN || sinceBeat > LIMIT_MS){
              var _reason = (age > MAX_RUN) ? 'watchdog:max-run' : 'watchdog:no-heartbeat';

              // CHG: richer debug output so we can see *why* it tripped
              try {
                (window.SKAI_warn || console.warn)(
                  '[SKAI] watchdog interrupt',
                  {
                    reason: _reason,
                    age_ms: age,
                    max_run_ms: MAX_RUN,
                    sinceBeat_ms: sinceBeat,
                    limit_noHeartbeat_ms: LIMIT_MS,
                    tick_ms: TICK_MS,
                    SKAI_LIMITS: (window.SKAI_LIMITS || {}),
                    t0: t0,
                    lastHeartbeat: hb
                  }
                );
              } catch(_){}

              try { if (typeof setLive === 'function') setLive(INT_MSG, 'error'); } catch(_){}
              try {
                 if (typeof window.SKAI_emit === 'function') {
                  // CHG: normalize to {detail:{...}} so listeners always read e.detail.reason.
                  window.SKAI_emit('skai:analysis-stop', { detail: { reason: _reason } });
                }
             } catch(_){}
              try { window.__SKAI_RUNNING__ = false; window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
            }
          } catch(_){}
        }, TICK_MS);
      }

      try {
        window.__SKAI_TEARDOWNS__ = window.__SKAI_TEARDOWNS__ || [];
        window.__SKAI_TEARDOWNS__.push(function(){
          try { if (window.__SKAI_WATCHDOG_TIMER__) { clearInterval(window.__SKAI_WATCHDOG_TIMER__); window.__SKAI_WATCHDOG_TIMER__ = null; } } catch(_){}
        });
      } catch(_){}
    } catch(_){}
  })();

  // canonical runner resolver (safe + idempotent)
  if (typeof window.SKAI_getRunner !== 'function') {
    window.SKAI_getRunner = function(){
      try {
        return window.runSkaiML || window.SKAI_run || window.runSkaiClientOnce || window.startSkaiML || null;
      } catch(_){ return null; }
    };
  }

  // canonical data readiness check
  if (typeof window.SKAI_hasMinimumData !== 'function') {
    window.SKAI_hasMinimumData = function(min){
      try {
        var lim = (window.SKAI_LIMITS || {});
        /* CHG: ES5-safe finite guards.
           Reason: Number.isFinite is ES6.
           Benefit: min-data gate won-t crash; prevents false -no data- stops. */
        var need = isFinite(+min) ? +min : (isFinite(+lim.minDraws) ? +lim.minDraws : 10);
        var d = window.draws || window.__le_lastFiltered || [];
        return Array.isArray(d) && d.length >= need;
      } catch(_){ return false; }
    };
  }

  // Progress accessor:
  // - If SKAI_getProgress already exists, DECORATE it once to add width-stamping (no replacement).
  // - Else define it with ensureProgressAPI/SKAI_Progress fallback + stamping.
  (function(){
    function decorateProgress(P, host){
      function clampPct(n){ n = +n; if (!isFinite(n)) return 0; return n < 0 ? 0 : (n > 100 ? 100 : Math.round(n)); }
      function stamp(n){
        try {
          if (!host) return;
          var pct = clampPct(n);
          host.setAttribute('data-valuenow', String(pct));
          var fill = host.querySelector('.fill') || host.querySelector('.bar > i') || host.querySelector('.meter > i');
          if (fill && fill.style) fill.style.width = String(pct) + '%';
        } catch(_){}
      }
      var _show = (typeof P.show  === 'function') ? P.show  : function(){};
      var _set  = (typeof P.set   === 'function') ? P.set   : function(){};
      var _done = (typeof P.done  === 'function') ? P.done  : function(){};
      var _reset= (typeof P.reset === 'function') ? P.reset : function(){};
      P.show  = function(x){ try{ _show.call(P, x); }catch(_){ } };
      P.set   = function(n,l){ try{ _set.call(P, n, l); }catch(_){ } stamp(n); };
      P.done  = function(l){ try{ _done.call(P, l); }catch(_){ } stamp(100); };
      P.reset = function(){ try{ _reset.call(P); }catch(_){ } };
      return P;
    }

    var host = document.getElementById('skai-progress') || document.querySelector('[data-skai-progress]');

    if (typeof window.SKAI_getProgress === 'function') {
      if (!window.__SKAI_P_DECOR__) {
        window.__SKAI_P_DECOR__ = true;
        var orig = window.SKAI_getProgress;
        window.SKAI_getProgress = function(){
          var P = orig();
          return decorateProgress(P || { show:function(){}, set:function(){}, done:function(){}, reset:function(){} }, host);
        };
      }
    } else {
      window.SKAI_getProgress = function(){
        try {
          var P = (typeof window.ensureProgressAPI === 'function') ? window.ensureProgressAPI() : (window.SKAI_Progress || null);
          if (!P) {
            // Minimal no-op with stamping
            return decorateProgress({
              show:function(){}, set:function(){}, done:function(){}, reset:function(){}
            }, host);
          }
          return decorateProgress(P, host);
        } catch(_){
          return decorateProgress({ show:function(){}, set:function(){}, done:function(){}, reset:function(){} }, host);
        }
      };
    }
  })();
})();
</script>

<script>
/* SKAI Strings, Messages, Config Validator & Preset Sanitizer */
(function(){ 'use strict';
  // Unified stage update bridge (kept for reuse)
  function SKAI_stageSync(phase, msg){
    try {
      var P = (typeof window.ensureProgressAPI==='function') ? window.ensureProgressAPI() : window.SKAI_Progress;
      if (P && typeof P.show === 'function') P.show(phase);
      else if (P && typeof P.set === 'function') P.set(0, phase);
      if (typeof setLive === 'function') setLive(phase);
      if (typeof window.stage === 'function') window.stage(phase, msg || phase);
    } catch(_){}
  }
  window.SKAI_stageSync = window.SKAI_stageSync || SKAI_stageSync;

// canonical status strings + tiny formatter
if (typeof window.SKAI_STR !== 'object') {
  window.SKAI_STR = {
    valueClamped:       'Adjusted {field} to {value}',
    configInvalid:      'Configuration invalid.',
    configMissing:      'Configuration missing.',
    configDetailPrefix: 'Config error: ',
    tfReady:            'TensorFlow ready.',
    preparing:          'Preparing...',
    startingAI:         'Starting AI...',
    trainingMain:       'Training (main numbers)...',
    trainingExtra:      'Training (extra)...',
    mlMainDone:         'Main training complete',
    mlExtraDone:        'Extra training complete',
    allFinished:        'All steps finished.',
    autoTuneStart:      'Auto-Tune starting...',
    // CHG: replace mojibake - separators with bullet characters for clean typography.
    autoTuneDone:       'Auto-Tune complete \u2022 W={W} \u2022 starting training...',
    finalizing:         'Finalizing predictions...',
    generating:         'Generating predictions...',
    picksComputed:      'Picks computed',
    completed:          'Completed.',
    waitingDefault:     'Waiting for ML predictions...',
    runnerNotReady:     'Runner not ready yet.',
    alreadyRunning:     'Already running...',
    aiPausedNeedDraws:  'AI paused: need {need} draws.',
    autoTuneBusy:       'Auto-Tuning best window...',
    autoTuneNotApplied: 'Auto-Tune finished but settings not applied.',
    moduleMissing:      'AI module not loaded on this page.',
    interrupted:        'AI process interrupted...',
    ready:              'Ready',
    // CHG: replace mojibake - with a bullet separator for consistency.
    readyPicks:         'Ready \u2022 Picks computed',
    // CHG: same typography fix for scoring status.
    scoringPredictions: 'Scoring \u2022 Generating predictions...',
    error:              'Error'
  };
}
  if (typeof window.SKAI_msg !== 'function') {
    window.SKAI_msg = function(key, params){
      try {
        var s = (window.SKAI_STR && window.SKAI_STR[key]) || '';
        if (!params) return s;
        return s.replace(/\{(\w+)\}/g, function(_, k){ return (k in params) ? String(params[k]) : _; });
      } catch(_){ return ''; }
    };
  }

  // JSON config validator (hardened)
  if (typeof window.SKAI_validateConfig !== 'function') {
    window.SKAI_validateConfig = function(cfg){
      try {
        var errors = [], warnings = [];
        var OtoS = Object.prototype.toString;
        function isPlainObject(x){ return !!x && OtoS.call(x) === '[object Object]' && Object.getPrototypeOf(x) === Object.prototype; }
        function hasOwn(o,k){ return Object.prototype.hasOwnProperty.call(o,k); }
        function isSafeString(s, min, max, rx){ if (typeof s !== 'string') return false; var len = s.length; if (!(len >= (min||0) && len <= (max||1e5))) return false; return rx ? rx.test(s) : true; }
        function isFiniteInt(n){ return typeof n === 'number' && isFinite(n) && Math.floor(n) === n; }
        function inRange(n, a, b){ return isFiniteInt(n) && n >= a && n <= b; }
        function pushErr(code){ errors.push(code); try{ console.warn && console.warn('[SKAI] cfg:', code); }catch(_){} }
        function pushWarn(code){ warnings.push(code); }

        if (!isPlainObject(cfg)) return { ok:false, reason:'missing-or-not-object', errors:['cfg.notObject'] };

        var bannedTop = ['__proto__','prototype','constructor'];
        for (var i=0;i<bannedTop.length;i++){ if (hasOwn(cfg, bannedTop[i])) pushErr('cfg.pollutionKey.'+bannedTop[i]); }

        try { var keyCount = Object.keys(cfg).length; if (keyCount > 200) pushWarn('cfg.manyKeys'); } catch(_){}

        var required = ['gameId','rules','features'];
        for (var r=0;r<required.length;r++){ if (!hasOwn(cfg, required[r])) pushErr('cfg.missing.'+required[r]); }
        if (errors.length) return { ok:false, reason:errors[0], errors:errors, warnings:warnings };

        if (!isSafeString(cfg.gameId, 1, 32, /^[A-Za-z0-9._-]+$/)) pushErr('cfg.gameId.invalid');

        if (!isPlainObject(cfg.rules)) { pushErr('cfg.rules.notObject'); }
        else {
          for (var j=0;j<bannedTop.length;j++){ if (hasOwn(cfg.rules, bannedTop[j])) pushErr('cfg.rules.pollutionKey.'+bannedTop[j]); }
          var BOUNDS = { window:[2,50], pickSize:[1,20], mainNumbersMax:[1,99], extraNumbersMax:[1,99] };
          function checkBound(key){
            if (!hasOwn(cfg.rules, key)) return;
            var v = Number(cfg.rules[key]);
            if (!isFiniteInt(v)) { pushErr('cfg.rules.'+key+'.notInt'); return; }
            var b = BOUNDS[key];
            if (b && !inRange(v, b[0], b[1])) pushErr('cfg.rules.'+key+'.outOfRange');
          }
          checkBound('window'); checkBound('pickSize'); checkBound('mainNumbersMax'); checkBound('extraNumbersMax');
          if (hasOwn(cfg.rules,'hasExtraBall') && typeof cfg.rules.hasExtraBall !== 'boolean') pushErr('cfg.rules.hasExtraBall.notBool');
        }

        if (!Array.isArray(cfg.features)) { pushErr('cfg.features.notArray'); }
        else {
          if (cfg.features.length === 0) pushErr('cfg.features.empty');
          if (cfg.features.length > 200) pushWarn('cfg.features.tooMany');
          for (var f=0; f<cfg.features.length; f++){
            var item = cfg.features[f];
            if (typeof item !== 'string') { pushErr('cfg.features.item.notString['+f+']'); continue; }
            if (!isSafeString(item, 1, 64, /^[A-Za-z0-9 .:_-]+$/)) pushErr('cfg.features.item.invalid['+f+']');
          }
        }

        var knownTop = Object.create(null); knownTop.gameId=1; knownTop.rules=1; knownTop.features=1; knownTop.meta=1;
        try { Object.keys(cfg).forEach(function(k){ if (!hasOwn(knownTop, k)) pushWarn('cfg.unknown.'+k); }); } catch(_){}

        if (errors.length) return { ok:false, reason:errors[0], errors:errors, warnings:warnings };
        return { ok:true, warnings:warnings.length ? warnings : undefined };
      } catch(e){
        try { console.error && console.error('[SKAI] validateConfig error:', e); } catch(_){}
        return { ok:false, reason:String((e && e.message) || e), errors:['cfg.exception'] };
      }
    };
  }

  // preset sanitizer: enforces types and bounds
  if (typeof window.SKAI_sanitizePreset !== 'function') {
    window.SKAI_sanitizePreset = function(preset){
      try {
        var L   = (window.SKAI_LIMITS || {});
        var minW = isFinite(+L.minWindow) ? +L.minWindow : 5;
        var maxW = isFinite(+L.maxWindow) ? +L.maxWindow : 2000;
        var minB = 0, maxB = 1;

        var p = {};
        var src = preset || {};
        // CHG: block prototype pollution keys while copying preset.
        var bannedTop = { '__proto__':1, 'prototype':1, 'constructor':1 };
        for (var k in src){
          if (!Object.prototype.hasOwnProperty.call(src, k)) continue;
          if (bannedTop[k] === 1) continue;
          p[k] = src[k];
        }

        // CHG: ES5-safe finite guards (replace Number.isFinite).
        if ('window' in p) {
          var w = +p.window;
          if (!isFinite(w)) delete p.window;
          else p.window = Math.max(minW, Math.min(maxW, Math.round(w)));
        }
        if ('windowSize' in p) {
          var ws = +p.windowSize;
          if (!isFinite(ws)) delete p.windowSize;
          else p.windowSize = Math.max(minW, Math.min(maxW, Math.round(ws)));
        }
        if ('blendRatio' in p) {
          var br = +p.blendRatio;
          if (!isFinite(br)) delete p.blendRatio;
          else p.blendRatio = Math.max(minB, Math.min(maxB, br));
        }

        var maxEpochs = isFinite(+L.maxEpochs) ? +L.maxEpochs : 200;

        ['epochsMain','epochsExtra'].forEach(function(k){
          if (k in p) {
            var v = +p[k];
            if (!isFinite(v)) delete p[k];
            else p[k] = Math.max(1, Math.min(maxEpochs, Math.round(v)));
          }
        });
        return p;
      } catch(_){ return preset || {}; }
    };
  }
})();
</script>

<script>
/* SKAI Insights removed by request (no-op shim to avoid caller errors) */
(function(){ 'use strict';
  if (typeof window.SKAI_generateRationale !== 'function')  window.SKAI_generateRationale = function(){ return null; };
  if (typeof window.SKAI_estimateUncertainty !== 'function') window.SKAI_estimateUncertainty = function(){ return null; };
  if (typeof window.SKAI_renderInsights !== 'function')      window.SKAI_renderInsights = function(){};
  if (typeof window.SKAI_ensureInsightsHost !== 'function')  window.SKAI_ensureInsightsHost = function(){ return null; };
})();
</script>

<script>
/* SKAI Orchestrator & Helpers */
(function(){ 'use strict';
  // waitFor utility (ES5-safe Promise version)
  if (typeof window.SKAI_waitFor !== 'function') {
    window.SKAI_waitFor = function waitFor(fn, label, opts){
      opts = opts || {};
      var timeout  = (opts && isFinite(+opts.timeout))  ? +opts.timeout  : 15000;
      var interval = (opts && isFinite(+opts.interval)) ? +opts.interval : 100;
      var jitter   = (opts && opts.jitter === false) ? false : true;

      var t0 = Date.now();

      function tick(){
        if ((Date.now() - t0) >= timeout){
          try { (window.SKAI_warn || console.warn)('[SKAI] waitFor timeout:', label || ''); } catch(_){}
          return Promise.resolve(false);
        }

        var v = null;
        try { v = fn(); } catch (_){ v = null; }

        // If fn returns a Promise, wait on it; else treat as boolean
        if (v && typeof v.then === 'function'){
          return Promise.resolve(v).then(function(ok){
            if (ok) return true;
            return waitThenNext();
          }).catch(function(){
            return waitThenNext();
          });
        }

        if (v) return Promise.resolve(true);
        return waitThenNext();
      }

      function waitThenNext(){
        var waitMs = jitter
          ? interval + Math.floor(Math.random() * Math.min(60, interval))
          : interval;

        return new Promise(function(res){
          setTimeout(res, waitMs);
        }).then(function(){
          if (interval < 500) interval += 20;
          return tick();
        });
      }

      return tick();
    };
  }

  // Orchestrator (ES5-safe Promise-based)
  window.SKAI_startPredictionFlow = function SKAI_startPredictionFlow(){
    if (window.__SKAI_RUNNING__){
      try { if (typeof setLive === 'function') setLive(SKAI_msg('alreadyRunning')); } catch(_){}
      return Promise.resolve(false);
    }

    window.__SKAI_RUNNING__    = true;
    window.__SKAI_RUN_ACTIVE__ = true;
    try { if (typeof window.SKAI_emit === 'function') window.SKAI_emit('skai:ml:start'); } catch(_){}

    // FIX: watchdog - if no terminal event arrives, force-unlock UI.
    // Keeps UX safe even if a promise chain silently aborts.
    try {
      var WD_MS = (window.SKAI_LIMITS && isFinite(+window.SKAI_LIMITS.watchdogMs))
        ? +window.SKAI_LIMITS.watchdogMs
        : 60000; // 60s default

      setTimeout(function(){
        try {
          if (window.__SKAI_RUN_ACTIVE__ || window.__SKAI_RUNNING__) {
            // no done/stop received -> unlock
            if (typeof SKAI_unlockUI === 'function') SKAI_unlockUI('watchdog');
          }
        } catch(_){ }
      }, WD_MS);
    } catch(_){}

    try {
      window.__SKAI_T0__ = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      window.__SKAI_T0_ISO__ = new Date().toISOString();
      window.SKAI_METRICS = window.SKAI_METRICS || {};
      window.SKAI_METRICS.totalStarts = (window.SKAI_METRICS.totalStarts|0) + 1;
    } catch(_){}

    function release(){
      try { window.__SKAI_RUNNING__ = false; } catch(_){}
      try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
    }

    function onDone(e){
      try {
        var t1  = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        var dur = (t1 - (window.__SKAI_T0__ || t1)) | 0;
        window.SKAI_METRICS = window.SKAI_METRICS || {};
        window.SKAI_METRICS.lastOutcome     = 'done';
        window.SKAI_METRICS.lastDurationMs  = dur;
        window.SKAI_METRICS.lastStartedAt   = window.__SKAI_T0_ISO__ || null;
        window.SKAI_METRICS.lastFinishedAt  = new Date().toISOString();
        window.SKAI_METRICS.totalDone       = (window.SKAI_METRICS.totalDone|0) + 1;
        if (window.SKAI_log) window.SKAI_log('[SKAI] run done in ' + dur + 'ms');
        try {
          if (typeof window.SKAI_emit === 'function') window.SKAI_emit('skai:telemetry', {
            outcome: 'done',
            durationMs: dur,
            startedAt: window.SKAI_METRICS.lastStartedAt,
            finishedAt: window.SKAI_METRICS.lastFinishedAt
          });
        } catch(_){}
      } catch(_){}
      try { release(); } catch(_){}
      try { window.removeEventListener('skai:ml:done', onDone); } catch(_){}
    }

    function onStop(e){
      try {
        var t1  = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
        var dur = (t1 - (window.__SKAI_T0__ || t1)) | 0;
        var r   = (e && e.detail && e.detail.reason) ? String(e.detail.reason) : 'stopped';
        window.SKAI_METRICS = window.SKAI_METRICS || {};
        window.SKAI_METRICS.lastOutcome     = 'stopped';
        window.SKAI_METRICS.lastReason      = r;
        window.SKAI_METRICS.lastDurationMs  = dur;
        window.SKAI_METRICS.lastStartedAt   = window.__SKAI_T0_ISO__ || null;
        window.SKAI_METRICS.lastFinishedAt  = new Date().toISOString();
        window.SKAI_METRICS.totalStopped    = (window.SKAI_METRICS.totalStopped|0) + 1;
        if (window.SKAI_log) {
          window.SKAI_log('[SKAI] run stopped after ' + dur + 'ms - reason: ' + r);
        }
        try {
          if (typeof window.SKAI_emit === 'function') window.SKAI_emit('skai:telemetry', {
            outcome: 'stopped',
            reason: r,
            have: (e && e.detail && typeof e.detail.have !== 'undefined') ? e.detail.have : undefined,
            need: (e && e.detail && typeof e.detail.need !== 'undefined') ? e.detail.need : undefined,
            durationMs: dur,
            startedAt: window.SKAI_METRICS.lastStartedAt,
            finishedAt: window.SKAI_METRICS.lastFinishedAt
          });
        } catch(_){}
      } catch(_){}
      try { release(); } catch(_){}
      try { window.removeEventListener('skai:analysis-stop', onStop); } catch(_){}
    }

    // One-time done/stop listeners (ES5 - no {once:true} objects)
    if (typeof window.SKAI_once === 'function') {
      SKAI_once('skai:ml:done', onDone);
      SKAI_once('skai:analysis-stop', onStop);
    } else {
      var doneWrap = function(ev){ try { onDone(ev); } finally { window.removeEventListener('skai:ml:done', doneWrap); } };
      var stopWrap = function(ev){ try { onStop(ev); } finally { window.removeEventListener('skai:analysis-stop', stopWrap); } };
      window.addEventListener('skai:ml:done', doneWrap);
      window.addEventListener('skai:analysis-stop', stopWrap);
    }

    // Friendly cancel UX
    var stopUiWrap = function(){
      try {
        if (typeof window.setLive === 'function') {
          try { window.setLive({ text: 'Analysis cancelled.', busy: false, force: true }); }
          catch(_) { window.setLive('Analysis cancelled.'); }
        }
      } catch(_){}
      try { window.SKAI_setBusy(false); } catch(_){}
      try { window.removeEventListener('skai:analysis-stop', stopUiWrap); } catch(_){}
    };
    window.addEventListener('skai:analysis-stop', stopUiWrap);

    // ============================================================
    // FIX: Global UI unlock safety
    // If any branch forgets to clear busy/overlay, this guarantees release.
    // ============================================================
    function SKAI_unlockUI(reason){
      try {
        if (typeof window.SKAI_setBusy === 'function') {
          window.SKAI_setBusy(false);
        }
      } catch(_){}

      try {
        var overlay = document.getElementById('skaiOverlay');
        if (overlay) { overlay.style.display = 'none'; }
      } catch(_){}

      try { document.body.classList.remove('skai-busy'); } catch(_){}
      try { window.__SKAI_RUNNING__ = false; } catch(_){}
      try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}

      // Optional debug breadcrumb
      try {
        if (reason && window.console && console.log) {
          console.log('[SKAI] UI unlocked:', reason);
        }
      } catch(_){}
    }

    // Unlock on ALL terminal events (idempotent)
    // CHG: guard so we don't stack listeners on every run.
    // Reason: these listeners were added inside SKAI_startPredictionFlow with anonymous fns,
    // so each new run accumulated more handlers.
    // Benefit: prevents memory leaks and duplicate unlock work; behavior unchanged.
    try {
      if (!window.__SKAI_UNLOCK_WIRED__) {
        window.__SKAI_UNLOCK_WIRED__ = true;

        window.addEventListener('skai:ml:done',        function(){ SKAI_unlockUI('ml:done'); }, false);
        window.addEventListener('skai:done',           function(){ SKAI_unlockUI('done'); }, false);
        window.addEventListener('skai:analysis-stop',  function(){ SKAI_unlockUI('analysis-stop'); }, false);
        window.addEventListener('skai:extra:done',     function(){ SKAI_unlockUI('extra:done'); }, false);
        window.addEventListener('skai:extra:error',    function(){ SKAI_unlockUI('extra:error'); }, false);
      }
    } catch(_){}

   // Completion listener (ES5)
  if (typeof window.__skaiRenderInsightsNow__ !== 'function') {
    window.__skaiRenderInsightsNow__ = function(){
      try {
        if (typeof window.SKAI_buildExportSummary === 'function') {
          window.SKAI_buildExportSummary(); // legacy summary builder
          return;
        }
        if (typeof window.SKAI_renderInsights === 'function') {
          window.SKAI_renderInsights(); // newer insights hook
          return;
        }
        if (window.SKAI_insight && typeof window.SKAI_insight.render === 'function') {
          window.SKAI_insight.render(); // store-backed renderer
          return;
        }
      } catch(_){}
    };
  }
  var __skaiRenderInsightsNow__ = window.__skaiRenderInsightsNow__;

     var doneUiWrap = function(){
       try {
         var P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress() : (window.SKAI_Progress || null);
         if (P && typeof P.set === 'function') {
           P.set(100, SKAI_msg('completed'));
         } else {
          var bar = document.getElementById('skai-progress') || document.querySelector('[data-skai-progress]');
          if (bar) {
            bar.setAttribute('data-valuenow','100');
            var fill = bar.querySelector('.fill') || bar.querySelector('.bar > i') || bar.querySelector('.meter > i');
            if (fill && fill.style) fill.style.width = '100%';
          }
        }
      } catch(_){}
      try {
        if (typeof window.setLive === 'function') {
          try { window.setLive({ text: 'Analysis complete.', busy: false, force: true }); }
          catch(_) { window.setLive('Analysis complete.'); }
        }
      } catch(_){}
      try { window.SKAI_setBusy(false); } catch(_){}
      try { window.SKAI_buildExportSummary(); } catch(_){}
      try { window.__skaiRenderInsightsNow__(); } catch(_){}
      try { window.removeEventListener('skai:ml:done', doneUiWrap); } catch(_){}
    };
    window.addEventListener('skai:ml:done', doneUiWrap);

     // Legacy completion alias
    var doneAliasWrap = function(){ try { window.__skaiRenderInsightsNow__(); } catch(_){} try{ window.removeEventListener('skai:done', doneAliasWrap); }catch(_){} };
     window.addEventListener('skai:done', doneAliasWrap);

    return Promise.resolve(true);
  };


  // ============================================================
  // PREDICTION RENDERER (idempotent, defensive)
  // ============================================================
  if (typeof window.SKAI_renderPredictions !== 'function') {
    window.SKAI_renderPredictions = function(data){
      try {
        // Accept shapes: {picks:[...]} OR [...]
        var picks = Array.isArray(data) ? data
                  : (data && Array.isArray(data.picks)) ? data.picks
                  : null;

        // HARDENED: if we don’t have an explicit picks array, do nothing.
        // We no longer scrape .numbers/.combo or any other pills from the page.
        if (!picks || !picks.length) {
          return false;
        }

        // Target host - prefer the dedicated SKAI results row,
        // then fall back to older IDs or <body> as a last resort.
        var host = document.querySelector('[data-skai-results]') ||
                   document.getElementById('aiPredictedNumbers') ||
                   document.getElementById('prediction') ||
                   document.getElementById('skai-results') ||
                   document.body;

        // Ensure a line to place pills
        var line = host.querySelector('[data-skai-set], .prediction-set, .numbers, .combo');
        if (!line) {
          line = document.createElement('div');
          line.setAttribute('data-skai-set','');
          line.className = 'numbers';
          host.appendChild(line);
        }

        // Clear previous, then paint pills
        while (line.firstChild) line.removeChild(line.firstChild);
        for (var i = 0; i < picks.length; i++) {
          var s = document.createElement('span');
          s.className = 'nball';
          s.textContent = String(picks[i]);
          line.appendChild(s);
        }

        // mark matches/summary if helper exists
        try {
          if (typeof window.SKAI_markNumbers === 'function') {
            window.SKAI_markNumbers(host);
          }
        } catch(_){}

        // Signal render complete for any waiting orchestrator
        try {
          if (typeof window.SKAI_emit === 'function') {
            window.SKAI_emit('skai:render:done');
          }
        } catch(_){}

        return true;
      } catch(_){
        return false;
      }
    };
  }

  // Try to render predictions on completion using best-effort sources
  (function(){
    function tryRender(){
      // Priority 1 ONLY: explicit last picks produced by SKAI ML.
      if (window.__SKAI_LAST_PICKS__ && window.__SKAI_LAST_PICKS__.length) {
        if (window.SKAI_renderPredictions(window.__SKAI_LAST_PICKS__)) return;
      }
      // If we don't have ML picks, we do not render anything else.
      return;
      // Priority 2 REMOVED:
      // This fallback scraped live DOM .nball pills which can be recent draw history.
      // We only render from explicit model outputs (window.__SKAI_LAST_PICKS__).
      // Priority 3: do nothing (safe no-op)
    } // CHG: close tryRender() so listeners are top-level in this IIFE

    // CHG: ES5-safe one-time listeners (no options object).
    var __skaiTryRenderDone__ = function(ev){
      try { tryRender(ev); } finally { try { window.removeEventListener('skai:ml:done', __skaiTryRenderDone__); } catch(_){} }
    };
    var __skaiTryRenderAlias__ = function(ev){
      try { tryRender(ev); } finally { try { window.removeEventListener('skai:done', __skaiTryRenderAlias__); } catch(_){} }
    };
    window.addEventListener('skai:ml:done', __skaiTryRenderDone__);
    window.addEventListener('skai:done',    __skaiTryRenderAlias__);
  })();

// Render completion is NOT ML completion.
// Keep this event for UI hooks only; do not emit skai:ml:done from it.
window.addEventListener('skai:render:done', function(){
  try { window.__SKAI_RENDER_DONE__ = true; } catch(_){}

  // ------------------------------------------------------------
  // SKAI Daily Decision Panel (Pick 3 / Pick 4)
  // - Activates ONLY when mainMax <= 9 (daily digit-domain games)
  // - Uses SKAI_TOP_MAIN [{num, score}] which is already ranked
  // ------------------------------------------------------------
  try {
    var meta = window.SKAI_META || {};
    var mainMax = (meta && meta.mainMax != null) ? +meta.mainMax : null;

    // If meta is missing, infer from common daily rule: presence of digits 0-9 in top list
    var top = (window.SKAI_TOP_MAIN && window.SKAI_TOP_MAIN.length) ? window.SKAI_TOP_MAIN : [];

    // Gate: daily only - use meta.isDaily flag from config (consistent with rendering logic)
    var isDaily = !!(meta && meta.isDaily);

    var panel = document.getElementById('skai-daily-panel');
    if (!panel) return;

    if (!isDaily) {
      panel.style.display = 'none';
      return;
    }

    // Determine pick size (Pick 3 / Pick 4) from meta if available, else infer by rendered pills count
    var pickSize = (meta && meta.pickSize != null) ? (+meta.pickSize|0) : 0;
    if (!(pickSize > 0)) {
      var pills = document.querySelectorAll('.skai-ai-main .nball, #aiPredictedNumbers .nball');
      pickSize = (pills && pills.length) ? pills.length : 3;
    }
    if (pickSize < 3) pickSize = 3;
    if (pickSize > 4) pickSize = 4; // daily intent scope

    // Build ladder from SKAI_TOP_MAIN in ranked order
    function normTopScores(arr){
      var out = [];
      var sum = 0;
      for (var i=0; i<arr.length; i++){
        var it = arr[i] || {};
        var num = (it.num != null) ? +it.num : +it;
        var sc  = (it.score != null) ? +it.score : 0;
        if (!isFinite(num) || num < 0 || num > 9) continue;
        if (!isFinite(sc) || sc < 0) sc = 0;
        out.push({ num:num, score:sc });
        sum += sc;
      }
      // if all scores are zero/missing, fall back to equal weights
      if (!(sum > 0)) {
        sum = out.length || 1;
        for (var j=0; j<out.length; j++) out[j].score = 1;
      }
      // attach share
      for (var k=0; k<out.length; k++){
        out[k].share = out[k].score / sum;
      }
      return out;
    }

    var ranked = normTopScores(top);

    // Render digit ladder (0..9 in ranked order we received)
    var ladderHost = document.getElementById('skai-daily-digit-ladder');
    if (ladderHost) {
      ladderHost.innerHTML = '';
      var maxShare = 0;
      for (var ms=0; ms<ranked.length; ms++){
        if (ranked[ms].share > maxShare) maxShare = ranked[ms].share;
      }
      if (!(maxShare > 0)) maxShare = 1;

      for (var r=0; r<ranked.length; r++){
        var row = document.createElement('div');
        row.className = 'skai-daily-ladder-row';

        var d = document.createElement('div');
        d.className = 'skai-daily-digit';
        d.textContent = String(ranked[r].num);

        var bar = document.createElement('div');
        bar.className = 'skai-daily-bar';
        var fill = document.createElement('span');
        var w = Math.round((ranked[r].share / maxShare) * 100);
        if (w < 2) w = 2;
        if (w > 100) w = 100;
        fill.style.width = String(w) + '%';
        bar.appendChild(fill);

        var pct = document.createElement('div');
        pct.className = 'skai-daily-pct';
        pct.textContent = String(Math.round(ranked[r].share * 100)) + '%';

        row.appendChild(d);
        row.appendChild(bar);
        row.appendChild(pct);
        ladderHost.appendChild(row);
      }
    }

    // Build top straight combos using independence approximation (product of digit shares)
    // Keep it small and fast: take topK digits only
    function topKDigits(arr, K){
      var out = [];
      for (var i=0; i<arr.length && out.length < K; i++) out.push(arr[i]);
      return out;
    }

    function scoreCombo(combo, arrMap){
      var s = 1;
      for (var i=0; i<combo.length; i++){
        var key = String(combo[i]);
        var sh = arrMap[key];
        if (!(sh > 0)) sh = 0.000001;
        s *= sh;
      }
      return s;
    }

    function toBoxKey(combo){
      var c = combo.slice(0);
      c.sort(function(a,b){ return a-b; });
      return c.join('');
    }

    var mapShare = {};
    for (var m=0; m<ranked.length; m++){
      mapShare[String(ranked[m].num)] = ranked[m].share;
    }

    var K = (pickSize === 3) ? 6 : 7;         // limit explosion
    var want = (pickSize === 3) ? 8 : 10;     // visible items

    var pool = topKDigits(ranked, K);

    // Generate combos by nested loops (ES5, no recursion)
    var combos = [];
    if (pickSize === 3) {
      for (var a=0; a<pool.length; a++){
        for (var b=0; b<pool.length; b++){
          for (var c=0; c<pool.length; c++){
            var combo3 = [pool[a].num, pool[b].num, pool[c].num];
            combos.push({ combo: combo3, score: scoreCombo(combo3, mapShare) });
          }
        }
      }
    } else {
      for (var a4=0; a4<pool.length; a4++){
        for (var b4=0; b4<pool.length; b4++){
          for (var c4=0; c4<pool.length; c4++){
            for (var d4=0; d4<pool.length; d4++){
              var combo4 = [pool[a4].num, pool[b4].num, pool[c4].num, pool[d4].num];
              combos.push({ combo: combo4, score: scoreCombo(combo4, mapShare) });
            }
          }
        }
      }
    }

    combos.sort(function(x,y){ return (y.score - x.score); });

    // De-dupe by BOX key so we don’t show 12 permutations of the same digits
    var seenBox = {};
    var chosen = [];
    for (var cc=0; cc<combos.length && chosen.length < want; cc++){
      var bx = toBoxKey(combos[cc].combo);
      if (seenBox[bx]) continue;
      seenBox[bx] = 1;
      chosen.push(combos[cc]);
    }

    var comboHost = document.getElementById('skai-daily-combos');
    if (comboHost) {
      comboHost.innerHTML = '';
      for (var z=0; z<chosen.length; z++){
        var row2 = document.createElement('div');
        row2.className = 'skai-daily-combo';

        var left = document.createElement('div');
        left.className = 'skai-daily-combo-left';

        var tag = document.createElement('span');
        tag.className = 'skai-daily-tag';
        tag.textContent = (pickSize === 3 ? 'Pick 3' : 'Pick 4') + ' • Straight';

        var digits = document.createElement('span');
        digits.className = 'skai-daily-combo-digits';
        digits.textContent = chosen[z].combo.join('');

        left.appendChild(tag);
        left.appendChild(digits);

        var right = document.createElement('div');
        right.className = 'skai-daily-combo-score';
        // Scale to readable “relative score”
        var rel = chosen[0].score > 0 ? (chosen[z].score / chosen[0].score) : 0;
        right.textContent = 'Relative: ' + String(Math.round(rel * 100)) + '%';

        row2.appendChild(left);
        row2.appendChild(right);
        comboHost.appendChild(row2);
      }
    }

    // Truthful rationale bullets (no hype). Use what we actually know exists in your system.
    var why = document.getElementById('skai-daily-why');
    if (why) {
      why.innerHTML = '';

      function li(txt){
        var x = document.createElement('li');
        x.appendChild(document.createTextNode(txt));
        return x;
      }

      // This is grounded in your implementation: top list is ranked + saved in probability order.
      why.appendChild(li('Digits are ranked by SKAI score (highest to lowest), then used to form combinations.'));

      // Mention blend only as conditional; your code supports a blend engine + blend ratio.
      var blendRatio = null;
      try {
        if (window.SKAI_SERVER && isFinite(+window.SKAI_SERVER.blendRatio)) blendRatio = +window.SKAI_SERVER.blendRatio;
      } catch(_){}

      if (blendRatio != null && blendRatio > 0) {
        why.appendChild(li('Blend is enabled: ML ranking is combined with Skip & Hit signals (' + String(Math.round(blendRatio)) + '% weighting).'));
      } else {
        why.appendChild(li('Ranking reflects the model’s learned distribution and run settings (no blend weighting applied).'));
      }

      // Auto-tune (you already expose hasAutoTune/usedWindow + badge wiring)
      var tuned = false;
      try { tuned = !!(window.__SKAI_AUTOTUNE_DONE__ || (window.SKAI_SERVER && (window.SKAI_SERVER.hasAutoTune || window.SKAI_SERVER.usedWindow))); } catch(_){}
      if (tuned) {
        why.appendChild(li('Auto-Tune is active: the lookback window was optimized for this game before scoring.'));
      } else {
        why.appendChild(li('Window selection follows your configured run settings for this game.'));
      }

      why.appendChild(li('Top combinations are an “independence approximation” from the ranked digit shares (useful for prioritization, not certainty).'));
    }

    // Finally show panel
    panel.style.display = '';
  } catch(_){}
});

    (function(){
      if (window.__SKAI_INSIGHTS_META__) return;
      window.__SKAI_INSIGHTS_META__ = { last:{}, prev:{} };
      try {
        var _P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress() : (window.SKAI_Progress || null);
        if (_P && typeof _P.show === 'function' && !_P.__skai_meta_wrapped__) {
          var _o = _P.show.bind(_P);
          _P.__skai_meta_wrapped__ = true;
          _P.show = function(txt){
            try { if (!window.__SKAI_INSIGHTS_META__.last.startedAt) window.__SKAI_INSIGHTS_META__.last.startedAt = Date.now(); } catch(_){}
            try { return _o(txt); } catch(e){ return e; }
          };
        }
      } catch(_){}

     function readConfidence(){
        try {
          var bar = document.getElementById('skai-progress') || document.querySelector('[data-skai-progress]');
          if (!bar) return null;
          var v = bar.getAttribute('data-valuenow');
          if (v == null) return null;
          var n = Math.max(0, Math.min(100, Math.round(+v)));
          return isFinite(n) ? n : null; // ES5-safe finite check
        } catch(_){ return null; }
      }      function firstSummary(){ try { var s = document.querySelector('.skai-inline-summary'); return (s && s.textContent.trim()) || ''; } catch(_){ return ''; } }

      window.addEventListener('skai:ml:done', function(){
        try {
          var meta = window.__SKAI_INSIGHTS_META__;
          meta.prev = meta.last;
          meta.last = { startedAt: meta.prev.startedAt || Date.now() };
          meta.last.endedAt = Date.now();
          var durMs = (meta.last.endedAt - (meta.prev.startedAt || meta.last.endedAt));
          var secs = Math.max(0, Math.round(durMs/1000));
          var conf = readConfidence();
          var sum  = firstSummary();

          if (window.SKAI_insight) {
            window.SKAI_insight.clear();
            if (conf != null) window.SKAI_insight.push({ category: 'confidence', title: 'Confidence Snapshot', body: 'Top-line confidence: ' + conf + '%', value: conf });
            if (secs) window.SKAI_insight.push({ category: 'duration', title: 'Run Duration', body: 'Completed in ~' + secs + ' seconds.', value: secs });
            if (sum) {
              var mainMatch = (function(){ var m = String(sum).match(/Matched\s+(\d+)\s*\/\s*(\d+)/i); return m ? +m[1] : 0; })();
              window.SKAI_insight.push({ category: 'matches', title: 'Matching Overview', body: sum, value: mainMatch, extra: { mainMatched: mainMatch } });
            }
          }
          meta.last.export = (function(){
            var lines = [];
            if (conf != null) lines.push('Confidence: ' + conf + '%');
            if (secs)         lines.push('Duration: ~' + secs + 's');
            if (sum)          lines.push('Matches: ' + sum);
            return lines.join(' | ');
          })();
          meta.last.startedAt = Date.now();
        } catch(_){}
      });
    })();

    // Global keyboard & minimal label helper (non-invasive)
    (function () {
      if (window.SKAI_label) return;
      window.SKAI_label = function (el, opts) {
        if (!el) return;
        opts = opts || {};
        var label = (opts.label != null) ? String(opts.label).trim() : '';
        var title = el.getAttribute('title') || '';
        var tip = el.getAttribute('data-skai-tip') || '';
        var descSel = opts.descSelector || null;
        if (!label && title) label = title;
        if (title && !tip) el.setAttribute('data-skai-tip', title);
        if (title) el.removeAttribute('title');
        if (descSel) { var _ = el.closest(descSel) || document.querySelector(descSel); void _; }
      };
    })();

    (function () {
      var b = document.getElementById('bestBanner');
      if (!b) return;
      var cs = window.getComputedStyle(b);
      if (b.hasAttribute('hidden')) b.removeAttribute('hidden');
      if (cs.display === 'none') b.style.display = 'flex';
    })();


})();

</script>

<script>
(function(){
  'use strict';

  /* ================= 7.10: Accessibility Auditor (idempotent) ================ */
    if (window.SKAI_a11y) return; // CHG: guard the actual exported stub
    // a11y: replace full auditor with a tiny no-op stub
    window.SKAI_a11y = function(){ return { fixes:0, notes:0 }; };
    window.SKAI_QA = function(){ return 'SKAI a11y audit disabled'; };
})();

  /* ================= 7.9: Idle polyfill + queue ================= */
  (function(){
    if (!('requestIdleCallback' in window)) {
      window.requestIdleCallback = function(cb, opts){
        var start = Date.now();
        return setTimeout(function(){
          cb({ didTimeout:false, timeRemaining:function(){ return Math.max(0, 50 - (Date.now()-start)); } });
        }, (opts && opts.timeout) || 1);
      };
      window.cancelIdleCallback = function(id){ clearTimeout(id); };
    }
    if (!window.SKAI_queueIdle) {
      window.SKAI_queueIdle = function(fn, timeout){
        try { return requestIdleCallback(fn, { timeout: timeout || 1200 }); } catch(_){ return setTimeout(fn, 50); }
      };
    }
  })();

  /* ================= 7.6: Busy/Idle manager ================= */
  (function(){
    if (window.SKAI_setBusy) return;
    var root = document.getElementById('skai-root') ||
               document.querySelector('[data-skai-root]') ||
               document.body;

    window.SKAI_setBusy = function(isBusy){
      try {
        if (!root) return;
        if (isBusy) {
          root.classList.add('is-busy');
          // ARIA removed: no aria-busy attribute
          if (!document.getElementById('skai-busy-style')) {
            var css = [
              '.is-busy [data-skai-dim]{opacity:.6; pointer-events:none;}',
              '.is-busy #bestBanner{opacity:1; pointer-events:auto;}'
            ].join('\n');
            var s = document.createElement('style');
            s.id = 'skai-busy-style';
            s.appendChild(document.createTextNode(css));
            document.head.appendChild(s);
          }
        } else {
          root.classList.remove('is-busy');
          // ARIA removed: no aria-busy attribute
        }
      } catch(_){}
    };


// Mark NOT-busy on load. Busy should start only when ML starts.
try { window.SKAI_setBusy(false); } catch(_){}

try {
  window.addEventListener('skai:ml:start', function(){
    try{ window.SKAI_setBusy(true); }catch(_){}
  });

  var __skaiBusyDone__ = function(){
    // CHG (gray-fix): never self-remove; must clear busy on EVERY run
    try{ window.SKAI_setBusy(false); }catch(_){}
  };
  window.addEventListener('skai:ml:done', __skaiBusyDone__);

  // CHG (gray-fix): also clear busy on stop/error aliases so UI can't stay gray
  window.addEventListener('skai:analysis-stop', __skaiBusyDone__);
  window.addEventListener('skai:ml:error',      __skaiBusyDone__);
  window.addEventListener('skai:done',          __skaiBusyDone__);
} catch(_){}

  })();

  /* ================= 7.3: Motion-safe scrolling helper ================= */
  (function(){
    var __hasScrollTo__ = (typeof window.SKAI_scrollTo === 'function');

// FNR-36: MutationObserver - single instance, throttled, and torn down on done/stop
(function(){
  var host = document.getElementById('prediction') ||
             document.querySelector('[data-skai-results]') ||
             document.getElementById('skai-results') ||
             document.body;
  if (!('MutationObserver' in window) || !host) return;

  // Prevent duplicate observers if this block is evaluated multiple times
  try { if (window.__SKAI_NUMUTIL_MO__) { window.__SKAI_NUMUTIL_MO__.disconnect(); } } catch(_){}

   function applyAll(ctx){
    if (!window.SKAI_markNumbers) return;
    var root = ctx || host;
    var sets = root.querySelectorAll('[data-skai-set], .prediction-set, .combo-set, .result-line');
    if (!sets.length) sets = root.querySelectorAll('.numbers, .combo, .result');
    for (var si = 0; si < sets.length; si++){
      try { window.SKAI_markNumbers(sets[si]); } catch(_){ }
    }
  }

  // Initial pass after idle
  try { (window.SKAI_queueIdle || function(f){ setTimeout(f,0); })(function(){ applyAll(host); }); } catch(_){}

  // Throttle with requestAnimationFrame + micro-timeout
  var pending = false, lastCtx = null, tId = 0, rafId = 0;
  function schedule(ctx){
    lastCtx = ctx || host;
    if (pending) return;
    pending = true;

    // CHG: ES5/legacy-safe rAF guards with setTimeout fallback.
    var raf = (typeof window.requestAnimationFrame === 'function') ? window.requestAnimationFrame : null;
    var caf = (typeof window.cancelAnimationFrame  === 'function') ? window.cancelAnimationFrame  : null;

    if (rafId && caf) caf(rafId);
    if (tId) clearTimeout(tId);

    if (raf) {
      rafId = raf(function(){
        tId = setTimeout(function(){
          pending = false;
          try { applyAll(lastCtx); } catch(_){}
        }, 90);
      });
    } else {
      // fallback: micro-timeout only
      tId = setTimeout(function(){
        pending = false;
        try { applyAll(lastCtx); } catch(_){}
      }, 90);
    }
  }

  var mo = new MutationObserver(function(muts){
    var ctx = null;
    for (var i=0;i<muts.length;i++){
      var m = muts[i];
      if (m.addedNodes && m.addedNodes.length){
        for (var j=0;j<m.addedNodes.length;j++){
          var n = m.addedNodes[j];
          if (n && n.nodeType === 1){ ctx = n; break; }
        }
      }
      if (ctx) break;
    }
    schedule(ctx || host);
  });

  // Observe and store handle for teardown
  try { mo.observe(host, { childList:true, subtree:true }); } catch(_){}
  window.__SKAI_NUMUTIL_MO__ = mo;

  // Teardown on completion or cancellation
  function teardown(){
    try { if (window.__SKAI_NUMUTIL_MO__) window.__SKAI_NUMUTIL_MO__.disconnect(); } catch(_){}
    window.__SKAI_NUMUTIL_MO__ = null;
    if (rafId) cancelAnimationFrame(rafId);
    if (tId) clearTimeout(tId);
    pending = false; lastCtx = null; rafId = 0; tId = 0;
  }
  var __skaiMoDone__ = function(){
    teardown();
    try{ window.removeEventListener('skai:ml:done', __skaiMoDone__); }catch(_){}
  };
  window.addEventListener('skai:ml:done', __skaiMoDone__);

  var __skaiMoStop__ = function(){
    teardown();
    try{ window.removeEventListener('skai:analysis-stop', __skaiMoStop__); }catch(_){}
  };
  window.addEventListener('skai:analysis-stop', __skaiMoStop__);
})();

    // 7.4: Map common button classes to high-contrast tokens
    (function(){
      if (document.getElementById('skai-btnmap-style')) return;
    var css = [
      '.btn, .button, .rl-btn, [data-skai-btn]{',
      '  background: var(--skai-accent); color: var(--skai-accent-contrast);',
      '  border: 1px solid var(--skai-accent);',
      '}'
      // focus-visible outline rule removed (pure a11y cosmetic)
      ].join('\n');
      var s = document.createElement('style');
      s.id = 'skai-btnmap-style';
      s.appendChild(document.createTextNode(css));
      document.head.appendChild(s);
    })();

    var prefersReduced = false;
    try { prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; } catch(_){}
    if (!__hasScrollTo__) {
      window.SKAI_scrollTo = function(el, opts){
        // Auto-scroll disabled by design; keep this stub so any callers
        // do not throw errors, but do not move the viewport.
        return;
      };
    }
  })();

/* ================= 7.1: Label the progress container + helpers ================ */
  (function(){
    var pc = document.getElementById('skai-progress') ||
             document.querySelector('[data-skai-progress]') ||
             null;

    // NEW: idempotent epoch progress sync (only if events carry a pct)
    (function(){
      if (!pc) return;
      if (window.__SKAI_EPOCH_SYNC_WIRED__) return;
      window.__SKAI_EPOCH_SYNC_WIRED__ = true;
      function progressEpochSync(e){
        try{
          var d = e && e.detail;
          if (!d || typeof d.pct === 'undefined') return;
          var P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress() : null;
          if (P && typeof P.set === 'function') {
            // Keep existing canonical progress behaviour
            P.set(d.pct, d.label || '');

            // NEW: mirror epoch label into the SKAI bubble / orb if available
            try{
              if (window.skaiProgress && typeof window.skaiProgress.setStatus === 'function'){
                window.skaiProgress.setStatus(d.label || '');
              }
            }catch(_){}
          } else {
            var pct = Math.max(0, Math.min(100, (+d.pct)||0));
            pc.setAttribute('data-valuenow', String(pct));
            var fill = pc.querySelector('.fill') || pc.querySelector('.bar > i') || pc.querySelector('.meter > i');
            if (fill && fill.style) fill.style.width = String(pct) + '%';

            // NEW: fallback - also show the label in the inline status text if present
            try{
              var live = document.getElementById('ai-live-status');
              if (live && (d.label || d.pct != null)) {
                live.textContent = d.label || (String(Math.round(pct)) + '% complete');
              }
            }catch(_){}
          }
        } catch(_){}
      }
      window.addEventListener('skai:ml:epoch', progressEpochSync);
      window.addEventListener('skai:extra:epoch', progressEpochSync);
    })();

    // 7.8: Helper to stamp drawn numbers (optional)
    (function(){
      if (window.SKAI_setDrawn) return;
      window.SKAI_setDrawn = function(mainArr, bonusArr){
        try {          var host = document.querySelector('[data-skai-results]') ||
                     document.getElementById('prediction') ||
                     document.getElementById('skai-results') ||
                     document.body;
          if (!host) return;
          if (Array.isArray(mainArr))  host.setAttribute('data-drawn-main',  mainArr.join(','));
          if (Array.isArray(bonusArr)) host.setAttribute('data-drawn-bonus', bonusArr.join(','));
        } catch(_){}
      };
    })();
  })(); // end 7.1: Label the progress container + helpers

  /* ================= FNR-4: Reset one-shot flags ================= */
  (function(){
    if (window.__SKAI_FNR4_WIRED__) return;
    window.__SKAI_FNR4_WIRED__ = true;
    function __skaiResetOneShots__(){
      try{ window.__SKAI_ANALYSIS_STARTED__    = false; }catch(_){}
      try{ window.__SKAI_AT_SETTINGS_APPLIED__ = false; }catch(_){}
      try{ window.__SKAI_RUN_ACTIVE__          = false; }catch(_){}
      try{ window.__SKAI_TUNED_THIS_RUN__      = false; }catch(_){}
      try{ window.__SKAI_RUNNING__             = false; }catch(_){}
    }
    window.addEventListener('skai:ml:done',       __skaiResetOneShots__);
    window.addEventListener('skai:analysis-stop', __skaiResetOneShots__);
    window.addEventListener('skai:ml:error',      __skaiResetOneShots__);
    window.addEventListener('skai:done',          __skaiResetOneShots__);
  })();

  /* ================= 7.5: Labeled ranges & live valuetext ================= */
  (function(){

    function ensureOut(el){
      // Ensure the slider has a stable id 
      if (!el.id) el.id = 'skai-' + Math.random().toString(36).slice(2);

      var outId = el.id + '-out';
      var out = document.getElementById(outId);
      if (!out) {
        out = document.createElement('output');
        out.id = outId;
        out.setAttribute('for', el.id);
        out.className = 'skai-range-out';
        // a11y live/status attributes removed

        // Prefer placing right after the control; fallback to parent
        if (el.parentElement && el.parentElement.insertBefore) {
          if (el.nextSibling) el.parentElement.insertBefore(out, el.nextSibling);
          else el.parentElement.appendChild(out);
        } else if (el.insertAdjacentElement) {
          el.insertAdjacentElement('afterend', out);
        } else {
          (document.body || document.documentElement).appendChild(out);
        }
      }
      return out;
    }

    function labelRange(el){
      var min = (el.min !== undefined && el.min !== '') ? +el.min : NaN;
      var max = (el.max !== undefined && el.max !== '') ? +el.max : NaN;
      var val = (el.value !== undefined && el.value !== '') ? +el.value : NaN;

      // a11y associations removed (label/desc/aria-valu* attributes)

      var out = ensureOut(el);
      if (out) out.textContent = (isFinite(val) ? String(val) : (el.value || ''));
    }

    // --- NEW: simple, defensive gauge updater ------------------------------
    // Looks for #skai-gauge or [data-skai-gauge], sets ONLY its `.fill` width (never container),
    // and updates a numeric label if present ([data-skai-gauge-pct] or .pct).
    // Accepts blendRatio sliders that emit 0-1 (fraction) OR 0-100 (percent).
    function updateSkaiGauge(){
      try {
        var g = document.getElementById('skai-gauge') || document.querySelector('[data-skai-gauge]');
        if (!g) return;

        function clamp01p(n){ n = +n; if (!isFinite(n)) return 0; return n<0?0:n>100?100:n; }
        function valOf(id){
          var el = document.getElementById(id + '_ui') || document.getElementById(id);
          return el ? el.value : null;
        }

        var pct = 0;

        // 1) Prefer blendRatio (either 0?1 or 0?100)
        var blend = parseFloat(valOf('blendRatio'));
        if (isFinite(blend)) {
          pct = (blend > 1) ? clamp01p(blend) : clamp01p(Math.round(blend * 100));
        } else {
          // 2) Otherwise derive from windowSize (vs maxWindow) or epochs (vs 2000)
          var w = parseFloat(valOf('windowSize'));
          var e = parseFloat(valOf('epochs'));
          if (isFinite(w)) {
            var limits = (window.SKAI_LIMITS || {});
            var maxW = isFinite(+limits.maxWindow) ? +limits.maxWindow : 4000;
            pct = clamp01p(Math.round((w / Math.max(1, maxW)) * 100));
          } else if (isFinite(e)) {
            var maxE = 2000;
            pct = clamp01p(Math.round((e / maxE) * 100));
          }
        }

        // B-02 (quarantined): ARIA progressbar re-add.
        // Reason: earlier module policy strips ARIA to avoid conflicts with template/a11y tooling.
        // Leaving commented preserves feature option for future re-enable without behavior change.
        /*
        try {
          g.setAttribute('role', 'progressbar');
          g.setAttribute('aria-valuemin', '0');
          g.setAttribute('aria-valuemax', '100');
          g.setAttribute('aria-valuenow', String(pct));
        } catch(_) {}
        */

        // Only move the FILL ? never the container (prevents the chart from shrinking)
        var fill = g.querySelector('.fill');
        if (fill && fill.style) {
          fill.style.width = String(pct) + '%';
        }

        // Update numeric % if present
        var pctEl = g.querySelector('[data-skai-gauge-pct], .pct');
        if (pctEl) {
          // Keep as integer percent for readability
          pctEl.textContent = String(pct) + '%';
        }
      } catch(_){}
    }

    function wire(el){
      if (el.__skaiRangeWired__) return; // idempotent
      el.__skaiRangeWired__ = true;

      // ES5-safe emit helper (uses SKAI_emit if present, else CustomEvent w/ legacy fallback)
      function emitParamsChanged(){
        try {
          if (typeof window.SKAI_emit === 'function') {
            window.SKAI_emit('skai:params:changed', {});
            return;
          }
        } catch(_){}
        try {
          var ev;
          try { ev = new CustomEvent('skai:params:changed'); }
          catch(e1){
            ev = document.createEvent('Event');
            ev.initEvent('skai:params:changed', true, true);
          }
          window.dispatchEvent(ev);
        } catch(_){}
      }

      try { labelRange(el); } catch(_){}

      el.addEventListener('input', function(){
        try { labelRange(el); } catch(_){}
        try { updateSkaiGauge(); } catch(_){}
        emitParamsChanged();
      }, false);

      el.addEventListener('change', function(){
        try { labelRange(el); } catch(_){}
        try { updateSkaiGauge(); } catch(_){}
        emitParamsChanged();
      }, false);

      // Light-touch commit hooks (no passive-options object for ES5)
      el.addEventListener('pointerup', function(){
        try { updateSkaiGauge(); } catch(_){}
        emitParamsChanged();
      }, false);

      el.addEventListener('keyup', function(){
        try { updateSkaiGauge(); } catch(_){}
        emitParamsChanged();
      }, false);
    }

    try {
      var sliders = document.querySelectorAll('input[type="range"], input[data-skai-range]');
      for (var si = 0; si < sliders.length; si++){
        wire(sliders[si]);
      }

      // Initial gauge paint (in case inputs already have values)
      try { updateSkaiGauge(); } catch(_){}

      // Extra safety: if DOM wasn't fully laid out, repaint once after a microtask
      try { setTimeout(function(){ try { updateSkaiGauge(); } catch(_){ } }, 0); } catch(_){}
    } catch(_){}
  })();



// FNR-54: Image stability – delegate + WeakSet de-dupe + observer for cached inserts + teardown
(function(){
  if (window.__SKAI_IMG_STAB_INIT__) return;
  window.__SKAI_IMG_STAB_INIT__ = true;

  // ES5-safe seen-tracking: WeakSet when available, else fallback array
  var seen = (typeof WeakSet === 'function') ? new WeakSet() : null;
  var seenArr = !seen ? [] : null;

  function isSeen(img){
    try { return seen ? seen.has(img) : (seenArr.indexOf(img) !== -1); } catch(_){ return false; }
  }
     function markSeen(img){
     try {
      // FNR-54-FIX-01:
      // Reason/benefit: original line `if markSeen(img);` was a broken recursive call
      // causing "missing ( before condition" parse failure. We instead mark into
      // WeakSet when available, else into the fallback array.
      if (seen) {
        seen.add(img);
      } else if (seenArr.indexOf(img) === -1) {
        seenArr.push(img);
      }
     } catch(_){}
   }


  function solidify(img){
    if (!img || img.tagName !== 'IMG' || isSeen(img)) return;
    try {
      if (!img.getAttribute('decoding')) img.setAttribute('decoding','async');
      if (!img.getAttribute('loading'))  img.setAttribute('loading','lazy');

      if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) {
        var nw = img.naturalWidth, nh = img.naturalHeight;

        if (!img.getAttribute('width'))  img.setAttribute('width',  String(nw));
        if (!img.getAttribute('height')) img.setAttribute('height', String(nh));

        // Stabilize layout even when CSS resizes images
        var ratio = (nw > 0 && nh > 0) ? (nw + ' / ' + nh) : '';
        if (ratio && (!img.style.aspectRatio || img.style.aspectRatio === '')) {
          img.style.aspectRatio = ratio;
        }

        // FNR-54-FIX-02:
        // Reason/benefit: seen may be null on older engines; use markSeen() for both paths.
        markSeen(img);
      }
    } catch(_) {}
  }

  // Prime existing images (single pass) - ES5-safe loop
  try {
    var __imgs0__ = document.querySelectorAll('img');
    for (var ii0 = 0; ii0 < __imgs0__.length; ii0++){ solidify(__imgs0__[ii0]); }
  } catch(_) {}

  // One delegated load handler covers all future images
  function onLoad(e){ try { solidify(e.target); } catch(_) {} }
  document.addEventListener('load', onLoad, true);

  // Observe DOM inserts to catch already-complete cached images (hardened)
  var mo = null;
  try {
    // Preconditions: feature & handler must exist
    if (typeof MutationObserver === 'function' && typeof solidify === 'function') {
      var root = document.documentElement || document.body || document;
      var observing = false;

      function safeScan(node){
        try {
          if (!node || node.nodeType !== 1) return; // element-only
          var tag = (node.tagName || '').toUpperCase();
          if (tag === 'IMG') { solidify(node); return; }
          if (node.querySelectorAll) {
            // Limit query to imgs only; avoid NodeList.forEach for wider compat
            var list = node.querySelectorAll('img');
            for (var k = 0; k < list.length; k++) { solidify(list[k]); }
          }
        } catch(_) {}
      }

      function startObserve(){
        if (observing) return;
        observing = true;
        mo = new MutationObserver(function(list){
          // Only consider added nodes to reduce churn
          for (var i = 0; i < list.length; i++){
            var m = list[i];
            var nodes = (m && m.addedNodes) ? m.addedNodes : null;
            if (!nodes || !nodes.length) continue;
            for (var j = 0; j < nodes.length; j++){ safeScan(nodes[j]); }
          }
        });
        mo.observe(root, { childList: true, subtree: true });
      }

      if (document.readyState === 'loading') {
        var __skaiImgDomReady__ = function(){
          try { startObserve(); } catch(_){}
          try { document.removeEventListener('DOMContentLoaded', __skaiImgDomReady__); } catch(_){}
        };
        document.addEventListener('DOMContentLoaded', __skaiImgDomReady__);
      } else {
        startObserve();
      }
    }
  } catch(_) {}

  // Optional public hook (hardened)
  window.SKAI_solidifyImages = function(scope){
    try {
      if (typeof solidify !== 'function') return;
      var s = (scope && (scope.nodeType === 1 || scope.nodeType === 9)) ? scope : document;
      var list = s.querySelectorAll ? s.querySelectorAll('img') : [];
      for (var i = 0; i < list.length; i++) { solidify(list[i]); }
    } catch(_) {}
  };

  // Register teardown
  try {
    window.__SKAI_TEARDOWNS__ = window.__SKAI_TEARDOWNS__ || [];
    window.__SKAI_TEARDOWNS__ = window.__SKAI_TEARDOWNS__ || [];
    window.__SKAI_TEARDOWNS__.push(function(){
      /* CHG: Guard onLoad by scope-safe typeof check.
         Reason: onLoad may be defined in a different closure or not at all.
         Benefit: teardown reliably detaches the listener when present, and stays silent otherwise. */
      try {
        var _onLoad = (typeof onLoad !== 'undefined') ? onLoad : null;
        if (typeof _onLoad === 'function') {
          document.removeEventListener('load', _onLoad, true);
        }
      } catch(_) {}
      try { mo && mo.disconnect(); } catch(_) {}
      try { window.__SKAI_IMG_STAB_INIT__ = false; } catch(_) {}
    });
  } catch(_) {}
})();
 
;(function(){ // progress prep shim (balances trailing IIFE close)
  try {
    // Avoid ReferenceError if P is not in scope; fall back to SKAI_getProgress
    var __P = (typeof P !== 'undefined' && P) ||
              (typeof window.SKAI_getProgress === 'function' ? window.SKAI_getProgress() : (window.SKAI_Progress || null));

    // CHG: qualify SKAI_msg via window to prevent ReferenceError in strict/isolated scopes.
    var __msg = (typeof window.SKAI_msg === 'function') ? window.SKAI_msg('preparing') : 'Preparing...';

    if (__P && typeof __P.show === 'function') { __P.show(__msg); }
  } catch(_){}
  try {
    var __msg2 = (typeof window.SKAI_msg === 'function') ? window.SKAI_msg('preparing') : 'Preparing...';
    if (typeof setLive === 'function') setLive(__msg2);
  } catch(_){}
})(); // end progress prep shim

// --- SKAI CONFIG BOOTSTRAP (required fields: gameId, rules, features) ---
(function(){
  'use strict';

  if (typeof window.assembleSkaiConfig !== 'function') {
    function fromUrl(param){
      try {
        var m = (location.search || '').match(new RegExp('[?&]'+param+'=([^&]+)'));
        return m ? decodeURIComponent(m[1]) : null;
      } catch(_){ return null; }
    }
    function firstNonEmpty(){
      for (var i=0;i<arguments.length;i++){
        var v = arguments[i];
        if (v != null && String(v).trim() !== '') return v;
      }
      return null;
    }
    function requireConfigFields(cfg){
      var missing = [];
      if (!cfg || typeof cfg !== 'object') return ['config-object'];
      if (!cfg.gameId)    missing.push('gameId');
      if (!cfg.rules)     missing.push('rules');
      if (!cfg.features)  missing.push('features');
      return missing;
    }
    window.assembleSkaiConfig = function(){
      var S  = window.SKAI_SERVER || {};
      var LC = window.lottoConfig || window.LOTTO_CONFIG || {};
      var GI = firstNonEmpty(fromUrl('game_id'), (S.gameId||S.game_id), (LC.gameId||LC.game_id));

      var rules    = S.rules    || LC.rules    || null;
      var features = S.features || LC.features || null;

      var detailPrefix = (S.detailPrefix || LC.detailPrefix || 'cfg');

      var cfg = {
        gameId: GI,
        rules: rules,
        features: features,
        detailPrefix: detailPrefix
      };
      cfg.missing = requireConfigFields(cfg);
      return cfg;
    };
    window.__SKAI_requireConfigFields = requireConfigFields;
  }
})();
</script>

<script>
// 7.3: Reserve and stabilize chart heights to eliminate CLS
(function () {
  'use strict';
  var ro;

  // 7.4 + 7.9: If Chart.js global defaults exist, sync to CSS tokens (idle)
  (function initChartDefaults(){
    var idle = window.SKAI_queueIdle || function(f){ setTimeout(f, 0); };
    idle(function(){
      try {
        var root = document.documentElement;
        var fg = (window.getComputedStyle && root) ? getComputedStyle(root).getPropertyValue('--skai-fg').trim() : '';
        if (!fg) fg = '#0b0b0c';
        // CHG: use window.Chart consistently to avoid relying on a bare global.
        if (!window.Chart || !window.Chart.defaults) return;

        window.Chart.defaults.color = fg;
        if (window.Chart.defaults) {
          window.Chart.defaults.borderColor = 'rgba(127,127,127,0.35)';
          // Apply grid color to common axes safely (v3+ uses `scales`)
          window.Chart.defaults.scales = window.Chart.defaults.scales || {};
          ['x','y','r'].forEach(function(ax){
            var s = (window.Chart.defaults.scales[ax] = window.Chart.defaults.scales[ax] || {});
            s.grid = s.grid || {};
            s.grid.color = 'rgba(127,127,127,0.25)';
          });
        }
      } catch(_) {}
    });
  })();

  function reserve(el) {
    try {
      if (!el) return;
      var cs = window.getComputedStyle ? getComputedStyle(el) : null;
      var hasFixedH = cs ? (parseFloat(cs.height) > 0) : false;
      if (!hasFixedH) {
        var r = el.getBoundingClientRect ? el.getBoundingClientRect() : { width: 320 };
        var bw = r.width || 320;
        var mh = Math.round(bw * 9 / 16);
        if (!el.style.minHeight) el.style.minHeight = mh + 'px';
      }
    } catch(_) {}
  }

  function scan() {
    try {
      var charts = document.querySelectorAll ? document.querySelectorAll('canvas.skai-chart, [data-skai-chart]') : [];
      for (var i = 0; i < charts.length; i++) { reserve(charts[i]); }
    } catch(_) {}
  }

  try {
    scan();
    if ('ResizeObserver' in window) {
      ro = new ResizeObserver(function () { scan(); });
      ro.observe(document.documentElement);
    } else {
      window.addEventListener('resize', scan, false);
    }
  } catch (_) {}
})(); // single outer IIFE close
</script>

<script>
;(function(){
  'use strict';

  // --- Canonical confidence resolver (idempotent define) ---------------------
  if (typeof window.SKAI_resolveConfidence !== 'function') {
    window.SKAI_resolveConfidence = function(){
      // Priority order: SKAI_META -> SKAI_SERVER -> insights export -> DOM attribute
      try {
        var meta = window.SKAI_META || {};
        if (isFinite(+meta.confidence)) return +meta.confidence;
      } catch(_){}
      try {
        var sv = window.SKAI_SERVER || {};
        if (isFinite(+sv.confidence)) return +sv.confidence;
      } catch(_){}
      try {
        var im = window.__SKAI_INSIGHTS_META__ || {};
        var last = im.last || {};
        if (last.export){
          var m = String(last.export).match(/(\d+)\s*%/);
          if (m) return +m[1];
        }
      } catch(_){}
      try {
        var host = document.getElementById('aiPredictedNumbers') || document.getElementById('skai-ai-results');
        if (host && host.getAttribute){
          var dc = host.getAttribute('data-confidence');
          if (isFinite(+dc)) return +dc;
        }
      } catch(_){}
      return null;
    };
  }

  // Resolve the gauge canvas and the number label (support multiple ids/classes)
  var gaugeEl = document.getElementById('skaiConfGauge')
            || document.getElementById('skai-confidence-gauge')
            || (function(){ var c=document.querySelector('[data-skai-gauge] canvas'); return c||null; })();

  var valueEl = document.getElementById('skaiConfValue')
            || document.getElementById('skai-confidence-value')
            || document.querySelector('.skai-conf-value')
            || null;

  // Reuse a single exported handle so others can reference the chart safely
  var chart = (window.SKAI_CONF_CHART && typeof window.SKAI_CONF_CHART === 'object') ? window.SKAI_CONF_CHART : null;

  function ensureChart(){
    if (!gaugeEl || !window.Chart) return null;
    if (chart && typeof chart.update === 'function') return chart;
    try {
      /* CHG (L-90): Use window.Chart to avoid accidental shadowing or missing global binding.
         Earlier code already guards `if (!window.Chart) return null;` so this is safe and consistent. */
      chart = new window.Chart(gaugeEl.getContext('2d'), {
        type: 'doughnut',
        data: { datasets: [{ data: [0, 100], borderWidth: 0 }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          rotation: -90,
          circumference: 180,
          cutout: '75%',
          plugins: { legend: { display:false }, tooltip: { enabled:false } },
          animation: false
        }
      });
      // Export for downstream readers (idempotent)
      try { window.SKAI_CONF_CHART = chart; } catch(_){}
    } catch(_) {}
    return chart;
  }

  function setConfidence(pct){
    var v = Math.round(Number(pct));
    if (!isFinite(v)) v = 0;
    v = Math.max(0, Math.min(100, v));

    var c = ensureChart();
    if (c){
      try { c.data.datasets[0].data = [v, 100 - v]; c.update('none'); } catch(_) {}
    }
    if (valueEl){
      try { valueEl.textContent = v + '%'; } catch(_) {}
    }
  }
  window.SKAI_setConfidence = setConfidence; // expose

  function resolveConfidence(){
    try { return window.SKAI_resolveConfidence(); } catch(_) { return null; }
  }

  // Update when flows finish
  window.addEventListener('skai:autotune:done', function(){
    var v = resolveConfidence();
    if (v != null) setConfidence(v);
  });
  window.addEventListener('skai:ml:done', function(){
    var v = resolveConfidence();
    if (v == null) v = 0;
    setConfidence(v);
  });

  // Optional programmatic update
  window.addEventListener('skai:confidence', function(e){
    try { var v = e && e.detail && e.detail.value; if (v != null) setConfidence(v); } catch(_){}
  });

  // --- Verification: ensure doughnut & linear bar stay in sync (diagnostic) ---
  (function(){
    function readLinearPct(){
      var label = document.getElementById('skai-conf-label')
               || document.querySelector('[data-skai-conf-label]')
               || document.querySelector('#confidenceBar .pct');
      if (!label) return null;
      var m = String(label.textContent||'').match(/(\d+)\s*%/);
      return m ? (+m[1]) : null;
    }
    function readDoughnutPct(){
      try {
        var c = (window.SKAI_CONF_CHART && window.SKAI_CONF_CHART.data && window.SKAI_CONF_CHART.data.datasets)
                ? window.SKAI_CONF_CHART.data.datasets[0].data : null;
        if (!c || !c.length) return null;
        return Number(c[0]); // first slice = filled percent
      } catch(_){ return null; }
    }
    function verify(){
      var a = readLinearPct();
      var b = readDoughnutPct();
      if (a == null || b == null) return;
      if (Math.abs(a - b) >= 2) {
        try { console.warn('[SKAI] Confidence sync check: linear=', a, ' doughnut=', b); } catch(_){}
      }
    }
    ['skai:autotune:done','skai:ml:done','skai:confidence'].forEach(function(ev){
      window.addEventListener(ev, function(){ try { verify(); } catch(_){} }, false);
    });
  })();

  // Initialize on DOM ready
  function init(){
    // Avoid calling resolveConfidence() twice; preserve behavior
    var v = resolveConfidence();
    setConfidence(v == null ? 0 : v);
  }
  if (document.readyState === 'loading') {
    var __skaiGaugeDomReady__ = function(){
      try { init(); } catch(_){}
      try { document.removeEventListener('DOMContentLoaded', __skaiGaugeDomReady__); } catch(_){}
    };
    document.addEventListener('DOMContentLoaded', __skaiGaugeDomReady__);
  } else {
    init();
  }
})();
</script>

<script>
;(function(){
  'use strict';

  // --- Recommendation helper (uses metrics when available; same copy otherwise)
  if (typeof window.SKAI_pickRecommendation !== 'function') {
    window.SKAI_pickRecommendation = function(pct, metrics){
      var v = Math.max(0, Math.min(100, Math.round(Number(pct)||0)));

      // If no metrics, keep existing tiers
      if (!metrics || typeof metrics !== 'object') {
        return (v < 40) ? 'Cautious - weak signal; use conservatively or re-run with tweaks.'
             : (v < 70) ? 'Balanced - reasonable signal; consider selective use.'
             :            'Strong - high signal; suitable for confident picks.';
      }

      // Extract common optional metrics safely (fallbacks keep behavior stable)
      var hr   = Number(metrics.hit_rate);            // 0..1
      var wr   = Number(metrics.winrate || metrics.backtest_winrate); // 0..1
      var lift = Number(metrics.lift);                // relative >0
      var stab = Number(metrics.stability || metrics.recent_stability); // 0..1
      var unc  = Number(metrics.uncertainty || metrics.std || metrics.variance); // lower is better
      var ks   = Number(metrics.ks_score);            // 0..1

      // Normalize to [0..1] where possible
      function clamp01(x){ return isFinite(x) ? Math.max(0, Math.min(1, x)) : null; }
      var n_hr   = clamp01(hr);
      var n_wr   = clamp01(wr);
      var n_stab = clamp01(stab);
      var n_ks   = clamp01(ks);

      // Build a lightweight composite score to refine the tier (all optional)
      var pos = 0, cnt = 0;
      if (n_hr   != null) { pos += n_hr;   cnt++; }
      if (n_wr   != null) { pos += n_wr;   cnt++; }
      if (n_stab != null) { pos += n_stab; cnt++; }
      if (n_ks   != null) { pos += n_ks;   cnt++; }

      // Lift helps; uncertainty hurts (heuristics, only if present)
      if (isFinite(lift)) pos += Math.max(0, Math.min(1, (lift - 1))); // lift=1?0, 1.2?0.2
      if (isFinite(unc))  pos -= Math.max(0, Math.min(1, unc));        // higher unc reduces score

     var comp = (cnt > 0)
        ? (pos / (cnt + (isFinite(lift)?1:0) + (isFinite(unc)?1:0)))
        : null;
      // Blend composite (if we have it) with raw confidence v
      var conf01 = v / 100;
      var blend  = (comp == null) ? conf01 : (0.6 * conf01 + 0.4 * comp);

      // Decide final tier using blended signal
      if (blend < 0.40) return 'Cautious - weak signal; use conservatively or re-run with tweaks.';
      if (blend < 0.70) return 'Balanced - reasonable signal; consider selective use.';
      return 'Strong - high signal; suitable for confident picks.';
    };
  }

})(); // ? close the IIFE
</script>

<script>
;(function(){
  'use strict';

  // --- Local helper: recompute recommendation from metrics (idempotent) -------
  function SKAI_updateRecommendationFromMetrics(metrics){
    try {
      // Resolve the current confidence once
      var pct = 0;
      if (typeof window.SKAI_resolveConfidence === 'function') {
        var __rc0__ = window.SKAI_resolveConfidence();
        pct = (__rc0__ == null) ? 0 : __rc0__;
      }
      var recEl = document.getElementById('skai-conf-reco')
               || document.querySelector('[data-skai-conf-reco]')
               || document.querySelector('#confidenceRecommendation')
               || null;
      if (!recEl) return;
      var v = Math.max(0, Math.min(100, Math.round(Number(pct)||0)));
      var recMsg = window.SKAI_pickRecommendation ? window.SKAI_pickRecommendation(v, metrics) : '';
      // Remove garbled characters; use plain ASCII hyphen
      recEl.textContent = 'Confidence: ' + v + '% - Recommendation: ' + recMsg;
    } catch(_){}
  }

  // React whenever fresh metrics/score arrive (no UX changes if absent)
  window.addEventListener('skai:metrics', function(e){
    try { SKAI_updateRecommendationFromMetrics(e && e.detail ? e.detail : null); } catch(_){}
  }, false);
  window.addEventListener('skai:score', function(e){
    try { SKAI_updateRecommendationFromMetrics(e && e.detail ? e.detail : null); } catch(_){}
  }, false);

  // --- (A) Minimal gauge setter (only if you don't already have one) ----------
  if (typeof window.SKAI_setConfidence !== 'function') {
    window.SKAI_setConfidence = function(pct){
      var v = Math.max(0, Math.min(100, Math.round(Number(pct)||0)));

      // Common radial gauge hosts (use whatever exists)
      var g  = document.querySelector('[data-skai-gauge]') ||
               document.getElementById('skai-gauge') ||
               document.querySelector('.skai-gauge');

      // Numeric label for radial gauge (optional)
      var gl = document.getElementById('skai-gauge-pct') ||
               document.querySelector('[data-skai-gauge-label]');

      // If your gauge uses a CSS conic-gradient track
      if (g && g.style) {
        try {
          // These CSS vars are typical; harmless if absent
          g.style.setProperty('--skai-gauge-pct', String(v));
          // Fallback: set inline background if your gauge expects it
          // g.style.background = 'conic-gradient(var(--skai-accent) ' + v + '%, var(--skai-gauge-track) 0)';
        } catch(_){}
      }
      if (gl) { try { gl.textContent = v + '%'; } catch(_){} }
    };
  }

  // --- (B) Linear confidence label updater removed (unused) -------------------

  // --- (C) Resolve confidence (delegate to canonical resolver) ----------------
  function resolveConfidence(){
    try {
      if (typeof window.SKAI_resolveConfidence === 'function') {
        return window.SKAI_resolveConfidence();
      }
    } catch(_){}
    return null; // defer to canonical pipeline; avoids duplicate logic paths
  }

  // --- (D) Update both UIs from one place ------------------------------------
  function updateConfidenceAll(pct){
    var v = Math.max(0, Math.min(100, Math.round(Number(pct)||0)));
    try { if (typeof window.SKAI_setConfidence === 'function') window.SKAI_setConfidence(v); } catch(_){}

    // Inline linear bar + label + recommendation (was setConfRecommendation)
    try {
      var bar = document.getElementById('skai-conf-bar')
             || document.querySelector('[data-skai-conf-bar]')
             || document.querySelector('#confidenceBar .fill')
             || null;
      if (bar && bar.style) { bar.style.width = v + '%'; }

      var label = document.getElementById('skai-conf-label')
               || document.querySelector('[data-skai-conf-label]')
               || document.querySelector('#confidenceBar .pct')
               || null;
      if (label) { label.textContent = v + '%'; }

      var recEl = document.getElementById('skai-conf-reco')
               || document.querySelector('[data-skai-conf-reco]')
               || document.querySelector('#confidenceRecommendation')
               || null;
      if (recEl) {
        var recMsg = (typeof window.SKAI_pickRecommendation === 'function')
          ? window.SKAI_pickRecommendation(v, (window.SKAI_METRICS||null))
          : ((v < 40) ? 'Cautious - weak signal; use conservatively or re-run with tweaks.'
             : (v < 70) ? 'Balanced - reasonable signal; consider selective use.'
             :            'Strong - high signal; suitable for confident picks.');
        recEl.textContent = 'Confidence: ' + v + '% - Recommendation: ' + recMsg;
      }
    } catch(_){}
  }

  function applyResolved(){
    var v = resolveConfidence();
    if (v == null) v = 0;
    updateConfidenceAll(v);
  }

  // On key lifecycle events
  window.addEventListener('skai:autotune:done', applyResolved);
  window.addEventListener('skai:ml:done',       applyResolved);
  window.addEventListener('skai:done',          applyResolved);

  // Optional: external setter
  window.addEventListener('skai:confidence', function(e){
    try {
      var v = e && e.detail && e.detail.value;
      if (v != null) updateConfidenceAll(v);
    } catch(_){}
  });

  // First paint
  if (document.readyState === 'loading'){
    var __skaiConfDomReady__ = function(){
      try {
        var __rc1__ = resolveConfidence();
        updateConfidenceAll((__rc1__ == null) ? 0 : __rc1__);
      } catch(_){}
      try { document.removeEventListener('DOMContentLoaded', __skaiConfDomReady__); } catch(_){}
    };
    document.addEventListener('DOMContentLoaded', __skaiConfDomReady__);
  } else {
    var __rc2__ = resolveConfidence();
    updateConfidenceAll((__rc2__ == null) ? 0 : __rc2__);
  }
})();
</script>

<script>
  // 7.7: Migrate any lingering title attributes to data-skai-tip (skip ARIA label)
  (function(){
    try {
      var __ttlEls__ = document.querySelectorAll('[title]');
      for (var ti = 0; ti < __ttlEls__.length; ti++){
        var el = __ttlEls__[ti];
        // Skip if title is empty
        var t = (el.getAttribute('title') || '').trim();
        if (!t) { el.removeAttribute('title'); continue; }
        if (!el.hasAttribute('data-skai-tip')) el.setAttribute('data-skai-tip', t);
        // a11y label removed
        el.removeAttribute('title');
      }
    } catch(_){}
  })();

</script>

<script>
;(function(){
  'use strict';

  // --- Safe helpers / fallbacks (don-t conflict if you already defined them) ---
  var _rd = (typeof window.rafDebounce === 'function')
    ? window.rafDebounce
    : function(fn){ return function(){ try{ fn.apply(this, arguments);}catch(_){}}; };

  // capture any existing setLive BEFORE we wrap it
  var _origSetLive = (typeof window.setLive === 'function')
    ? window.setLive
    : function(s){
        var liveEl = document.getElementById('skai-live')
                  || document.getElementById('live-status')
                  || document.querySelector('[data-skai-live]')
                  || null;
        if (liveEl) liveEl.textContent = (s == null ? '' : String(s));
      };

  // Ensure a fallback live region so liveElFallback is always defined
  var liveElFallback = (function(){
    var el = document.getElementById('skai-live')
          || document.getElementById('live-status')
          || document.querySelector('[data-skai-live]')
          || null;
    // a11y live region creation removed (no ARIA attributes)
    return el;
  })();

  // Public helper for one-off announcements
  window.SKAI_announce = function(text){
    try { window.setLive({ text: text, busy: false, force: true }); } catch(_){}
  };

  // FNR-49: Single-source setLive shim - prevent later redefinitions and duplicate wrappers
  if (!window.__SKAI_SETLIVE_SHIM__) {
    window.__SKAI_SETLIVE_SHIM__ = true;

    window.setLive = _rd(function(msg){
      var text  = (msg && typeof msg === 'object' && 'text' in msg) ? msg.text  : msg;
      var busy  = !!(msg && typeof msg === 'object' && msg.busy);
      var force = !!(msg && typeof msg === 'object' && msg.force);

      var st   = window.__SKAI_LIVE_STATE__ || (window.__SKAI_LIVE_STATE__ = { lastText:'', lastAt:0 });
      var now  = Date.now();
      var sTxt = (text == null ? '' : String(text)).trim();
      var MIN  = 350;

      if (!force && sTxt && sTxt === st.lastText && (now - st.lastAt) < MIN) {
        // a11y aria-busy update removed
        return;
      }

      st.lastText = sTxt;
      st.lastAt   = now;

       try { _origSetLive(sTxt); } catch(_){ try { liveElFallback && (liveElFallback.textContent = sTxt); } catch(_) {} }

      // a11y aria-busy update removed

    }, 80);
  }


  // Progress wrapper: gently debounce frequent updates (if P exists)
  (function wrapProgress(){
    // Local, low-risk debounce fallback in case earlier _rd/rafDebounce aren't defined yet
    var _rd = (typeof window.rafDebounce === 'function')
      ? window.rafDebounce
      : function(fn, wait){
          var rafId = 0, tId = 0, lastArgs = null;
          wait = isFinite(+wait) ? +wait : 60;
          function later(){
            tId = 0;
            var _raf = window.requestAnimationFrame || function(cb){ return setTimeout(cb, 16); };
            rafId = _raf(function(){ try{ fn.apply(null, lastArgs || []); } catch(_){}}); 
          }

          return function(){
            lastArgs = arguments;
            if (tId) clearTimeout(tId);

            // CHG: guard cancelAnimationFrame for older engines
            if (rafId) {
              var _caf = window.cancelAnimationFrame || function(id){ clearTimeout(id); };
              _caf(rafId);
            }

            tId = setTimeout(later, wait);
          };
        };

    var P = (typeof window.SKAI_getProgress === 'function')
              ? window.SKAI_getProgress()
              : (window.SKAI_Progress || null);
    if (P && typeof P.show === 'function') {
      var _origShow = P.show.bind(P);
      P.show = _rd(function(txt){
        try { _origShow(txt); } catch(_){}
        try { window.setLive({ text: txt, busy: true }); } catch(_){}
        try { window.SKAI_setBusy && window.SKAI_setBusy(true); } catch(_){}
      }, 80);
    }
  })();

})(); 
</script>

<script>
;(function(){
  'use strict';

  // Robust, idempotent param line builder
  window.__SKAI_SHOW_PARAMS__ = function showParams(s){
    try{
      s = s || {};
      // Prefer tuned window if present
      var sv = window.SKAI_SERVER || {};
      var tunedW = (+sv.usedWindow || +sv.bestWindow) || s.windowSize || 0;

      function fmtNum(n, d){
        var v = Number(n);
        return isFinite(v) ? v.toFixed(d) : 'n/a';
      }
      function fmtInt(n){
        var v = Number(n) | 0;
        return v > 0 ? String(v) : 'n/a';
      }
      function fmtLR(v){
        var x = Number(v);
        if (!isFinite(x)) return String(v || 'n/a');
        // readable scientific if tiny
        return (x < 0.0001 || x >= 1) ? x.toExponential(1) : String(x);
      }

      var blendVal = (s.blend != null) ? s.blend : s.blendRatio;
      var gapVal   = (s.gap   != null) ? s.gap   : s.gapScale;

      var line = [
        'Window='   + fmtInt(tunedW),
        'epochs='   + fmtInt(s.epochs),
        'batch='    + fmtInt(s.batchSize),
        'layers='   + fmtInt(s.layers),
        'dropout='  + fmtNum(s.dropout, 2),
        'lr='       + fmtLR(s.lr || s.learningRate),
        'decay='    + fmtNum(s.recencyDecay, 2),
        'blend='    + fmtNum(blendVal, 2),
        'gap='      + fmtNum(gapVal, 2)
      ].join('  '); // two spaces; removes any visible '?' separators

      var bottom = document.getElementById('skai-param-status-body');
      if (bottom) bottom.textContent = line;

      // Hide/silence the tiny inline -Parameters:- line under the main numbers
      var inline = document.getElementById('ai-param-readout');
      if (inline) { inline.textContent = ''; inline.style.display = 'none'; }
    }catch(_){}
  };
})();
</script>

<script>
;(function(){
  'use strict';
  function readUI(id){ 
    var el = document.getElementById(id+'_ui')
          || document.querySelector('[id="'+id+'"]:not([type="hidden"])')
          || document.getElementById(id);
    return el && el.value != null ? el.value : '';
  }
  function snapshot(){
    function numOrNull(v){
      var n = parseFloat(v);
      return isFinite(n) ? n : null;
    }
    return {
      windowSize:   numOrNull(readUI('windowSize')),
      epochs:       numOrNull(readUI('epochs')),
      batchSize:    numOrNull(readUI('batchSize')),
      layers:       numOrNull(readUI('hiddenLayers')),
      dropout:      numOrNull(readUI('dropoutRate')),
      lr:           numOrNull(readUI('learningRate')),
      recencyDecay: numOrNull(readUI('recencyDecay')),
      blend:        numOrNull(readUI('blendRatio')),
      gap:          numOrNull(readUI('gapScale'))
    };
  }

  // NEW: confidence gauge updater (idempotent, selector-flexible)
  if (typeof window.updateSkaiGauge !== 'function') {
    window.updateSkaiGauge = function(){
      try {
        // Confidence sources in priority order
        var conf = null;
        var META = window.SKAI_META || {};
        if (isFinite(+META.confidence)) conf = +META.confidence;
        else if (window.SKAI_SERVER && isFinite(+window.SKAI_SERVER.confidence)) conf = +window.SKAI_SERVER.confidence;

        // If still unknown, fall back to a harmless dash and skip number update
        var textNode =
              document.getElementById('skai-confidence')
           || document.getElementById('ai-confidence')
           || document.querySelector('[data-skai-confidence] .value')
           || document.querySelector('[data-skai-confidence-value]')
           || null;

        if (textNode) {
          if (isFinite(conf)) {
            var pct = Math.max(0, Math.min(100, Math.round(conf)));
            textNode.textContent = String(pct) + '%';
            // Optional: store as attribute for CSS-driven needles/bars
            var host = (textNode.closest && textNode.closest('[data-skai-confidence]')) || textNode.parentElement;
            if (host) { host.setAttribute('data-conf', String(pct)); }
          } else {
            // Neutral marker when confidence is unknown
            textNode.textContent = '-';
          }
        }

        // Optional fill bar if present
        var bar = document.getElementById('skaiConfidenceBar');
        if (bar && isFinite(conf)) {
          bar.style.width = Math.max(0, Math.min(100, Math.round(conf))) + '%';
        }
      } catch(_) {}
    };
  }

  // Update on Auto-Tune result and when ML completes
  window.addEventListener('skai:autotune:result', function(){
    try {
      // Refresh params line
      window.__SKAI_SHOW_PARAMS__ && window.__SKAI_SHOW_PARAMS__(snapshot());

      // If a header/badge exists, reflect tuned state (no ARIA, safe)
      var hdr = document.querySelector('[data-skai="top"]') || document.querySelector('#skai-top-header');
      if (hdr && hdr.textContent && !/\(Auto-tuned\)/.test(hdr.textContent)) {
        hdr.textContent = hdr.textContent.trim() + ' (Auto-tuned)';
      }
      var badge = document.getElementById('bestBanner') || document.querySelector('[data-skai-best]');
      if (badge) { badge.style.display = 'flex'; badge.removeAttribute('hidden'); }

      // repaint gauge and notify listeners
      try { window.updateSkaiGauge && window.updateSkaiGauge(); } catch(_){}
      try { window.dispatchEvent(new CustomEvent('skai:params:changed')); } catch(_){}
    } catch(_) {}
  });

  // Also repaint when ML completes (confidence may be set there)
  window.addEventListener('skai:ml:done', function(){
    try { window.__SKAI_SHOW_PARAMS__ && window.__SKAI_SHOW_PARAMS__(snapshot()); } catch(_){}
    try { window.updateSkaiGauge && window.updateSkaiGauge(); } catch(_){}
  });

  // And repaint when user changes sliders (keeps number in sync even pre-run)
  document.addEventListener('input', function(e){
    if (!e || !e.target) return;
    if (e.target.matches('#windowSize_ui,#epochs_ui,#batchSize_ui,#dropout_ui,#learningRate_ui,#recencyDecay_ui,#blendRatio_ui,#gapScale_ui')) {
      try { window.updateSkaiGauge && window.updateSkaiGauge(); } catch(_){}
    }
  }, true);

})();
</script>

<script>
// Smooth focus to results after submit (optional)
;(function(){
function SKAI_focusResults(targetId){
  // FIX: Auto-scroll disabled per user request
  // Keep function for compatibility but do not scroll
  return;
}

  function focusNow(){
    // Auto-scroll on initial load disabled; scrolling now happens only
    // when the full SKAI process finishes (skai:ml:done handler).
    return;
  }

if (document.readyState !== 'loading') { focusNow(); }
else { document.addEventListener('DOMContentLoaded', focusNow); }

// FIX: Auto-scroll disabled per user request
// window.addEventListener('skai:ml:done', function () {
//   try { SKAI_focusResults('skai-ai-results'); } catch (_) {
//     // Fallback scroll if helper not available
//     var t = document.getElementById('skai-ai-results');
// if (t && t.scrollIntoView) {
//   var prefersReduced = false;
//   try { prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; } catch(_){}
//   try { t.scrollIntoView({ behavior: prefersReduced ? 'auto' : 'smooth', block: 'start' }); } catch (e) { t.scrollIntoView(true); }
// }
//   }
// });
})();
</script>

<script>
(function(){
  'use strict';

  // Progress shim: guarantee SKAI_getProgress exists (proxy to SKAI_Progress)
  if (typeof window.SKAI_getProgress !== 'function' && window.SKAI_Progress) {
    window.SKAI_getProgress = function(){ return window.SKAI_Progress; };
  }

  // Self-check: confirm single doughnut instance is exported (diagnostic only)
  try {
    if (window.SKAI_CONF_CHART && typeof window.SKAI_CONF_CHART === 'object') {
      // no-op; presence confirms export is working
    }
  } catch(_){}

  // Score Normalizer + Trace (diagnostic only; does NOT alter model math)
  (function(){
    var MAX_TRACE = 30;

    function extend(base, extra){
      var out = {};
      try {
        base  = base  || {};
        extra = extra || {};
        for (var k in base){ if (Object.prototype.hasOwnProperty.call(base,k)) out[k] = base[k]; }
        for (var j in extra){ if (Object.prototype.hasOwnProperty.call(extra,j)) out[j] = extra[j]; }
      } catch(_){}
      return out;
    }

    function pushTrace(entry){
      try {
        var buf = (window.__SKAI_SCORE_TRACE__ = window.__SKAI_SCORE_TRACE__ || []);
        buf.push(extend({ at: Date.now() }, entry || {}));
        while (buf.length > MAX_TRACE) buf.shift();
      } catch(_){}
    }

    function toNum(x){
      var v = Number(x);
      return isFinite(v) ? v : null;
    }

    window.addEventListener('skai:score', function(e){
      try {
        var d   = (e && e.detail) || {};
        var raw = (typeof d.score !== 'undefined') ? Number(d.score) : null;

        // Keep a compact trace of inputs if provided by the emitter
        pushTrace({
          score: raw,
          hit_rate: d.hit_rate, winrate: d.winrate || d.backtest_winrate,
          lift: d.lift, stability: d.stability || d.recent_stability,
          uncertainty: d.uncertainty || d.std || d.variance,
          ks_score: d.ks_score,
          meta: d.meta || null
        });

        // If negative, tag <html> and emit a normalized ?safe? event for UI consumers
        if (raw != null && raw < 0) {
          try { document.documentElement.setAttribute('data-skai-negscore','1'); } catch(_){}
          try { console.info('[SKAI] Negative score observed:', raw, d); } catch(_){}
        }

        // Always compute a non-negative safeScore for UI layers that prefer clamped values
        var safe = (raw == null) ? null : Math.max(0, raw);

        // Re-emit a derived event with safeScore, preserving original fields
  try {
          // CHG: ES5-safe shallow merge (no Object.assign)
          var detail = {};
          for (var k1 in d){ if (Object.prototype.hasOwnProperty.call(d, k1)) detail[k1] = d[k1]; }
          detail.safeScore = safe;

          // CHG: CustomEvent fallback for older engines
          var CE1 = (typeof window.CustomEvent === 'function')
            ? window.CustomEvent
            : function(type, params){
                var e = document.createEvent('CustomEvent');
                params = params || { bubbles:false, cancelable:false, detail:null };
                e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
                return e;
              };
          window.dispatchEvent(new CE1('skai:score:safe', { detail: detail }));
        } catch(_){}
      } catch(_){}
    }, false);
  })();

  // One-time bootstrap: prefill defaults so Run works on first click
  window.addEventListener('DOMContentLoaded', function(){
    // Log resolved window (helps verify AUTO?FULL resolution across variants)
    try {
      var a = document.documentElement.getAttribute('data-skai-window');
      if (a) console.info('[SKAI] Window in use:', a);
    } catch(_){}

    // If the new preset runner is available, use it; else do a minimal prefill
    if (typeof window.SKAI_applyPresetAndMaybeRun === 'function') {
      try { window.SKAI_applyPresetAndMaybeRun('balanced', false); } catch(e){}
      return;
    }
    try {
var defaults = {epochs:120,batchSize:32,dropoutRate:0.2,learningRate:0.001,hiddenLayers:2,recencyDecay:0.9,windowSize:50,blendRatio:0.60,gapScale:0.20};
      Object.keys(defaults).forEach(function(k){
        var el = document.getElementById(k + '_ui') || document.getElementById(k);
        if (el) el.value = String(defaults[k]);
      });
    } catch(e){}
  });
})();
</script>

<script>
(function(){
  'use strict';

  // ============================================================
  // FIX: Startup auto-unlock.
  // Page should never load in a "busy/gray" state unless a run is active.
  // ============================================================
  function SKAI_unlockOnBoot(){
    try {
      // If a run is NOT active, force-clear any stale busy UI.
      if (!window.__SKAI_RUN_ACTIVE__ && !window.__SKAI_RUNNING__) {

        // Clear stale flags (prevents re-gray on later handlers)
        try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
        try { window.__SKAI_RUNNING__ = false; } catch(_){}
        try { window.__SKAI_START_COOLDOWN__ = false; } catch(_){}

        // Canonical busy helper
        try {
          if (typeof window.SKAI_setBusy === 'function') {
            window.SKAI_setBusy(false);
          }
        } catch(_){}

        // Hide any known overlays
        try {
          var overlay = document.getElementById('skaiOverlay')
                     || document.getElementById('skai-overlay')
                     || document.querySelector('.skai-overlay,[data-skai-overlay]');
          if (overlay) { overlay.style.display = 'none'; }
        } catch(_){}

        // Remove all busy classes
        try { document.body.classList.remove('skai-busy'); } catch(_){}
        try {
          var root = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
          if (root) root.classList.remove('is-busy');
        } catch(_){}
        try { document.documentElement.classList.remove('__skai-running'); } catch(_){}
      }
    } catch(_){}
  }

  // Run ASAP + on DOM ready + on full load (covers all boot orders)
  try { SKAI_unlockOnBoot(); } catch(_){}
  try {
    document.addEventListener('DOMContentLoaded', SKAI_unlockOnBoot);
    window.addEventListener('load', SKAI_unlockOnBoot);
    window.addEventListener('pageshow', SKAI_unlockOnBoot); // BFCache restore fix
  } catch(_){}

  // --- resolve the ML runner (startSkaiPrediction / runSkaiML / etc.) ---

// FNR-39: whenRunnerReady resolves as soon as a runner exists; do not gate on __SKAI_RUNNING__
function whenRunnerReady(timeoutMs){
  var t0 = Date.now(), limit = timeoutMs || 15000;

  // Promise-safe wrapper (older engines won-t crash diagnostics)
  var makePromise = (typeof Promise === 'function')
    ? function(executor){ return new Promise(executor); }
    : function(executor){
        // minimal thenable
        var resolved = false, value;
        executor(function(v){ resolved = true; value = v; });
        return { then:function(cb){ try{ cb(resolved ? value : null); }catch(_){} } };
      };

  return makePromise(function(resolve){
    (function loop(){
      var fn = (typeof window.SKAI_getRunner === 'function')
        ? window.SKAI_getRunner()
        : (window.runSkaiML || window.SKAI_run || window.runSkaiClientOnce || window.startSkaiML || null);

      // Resolve immediately when a callable runner is available
      if (typeof fn === 'function') return resolve(fn);

      // Timeout: log + live hint, with SKAI_msg guard
      if (Date.now() - t0 >= limit) {
        try { (window.SKAI_warn || console.warn)('[SKAI] whenRunnerReady: timeout after ' + limit + 'ms'); } catch(_){}
        try {
          if (typeof window.setLive === 'function') {
            var hint = (typeof window.SKAI_msg === 'function')
              ? window.SKAI_msg('runnerNotReady')
              : 'Runner not ready';
            window.setLive(hint);
          }
        } catch(_){}
        return resolve(null);
      }

      // Configurable poll cadence
      var lim = (window.SKAI_LIMITS || {});
      var poll = isFinite(+lim.runnerPollMs) ? +lim.runnerPollMs : 100;
      setTimeout(loop, poll);
    })();
  });
}
  // --- input helpers (prefer visible UI control; fall back to legacy/hidden) ---
  function q(id){
    return document.getElementById(id + '_ui')
        || document.querySelector('[id="'+id+'"]:not([type="hidden"])')
        || document.getElementById(id)
        || null;
  }
  function setValue(id, val){
    var el = q(id);
    if (!el) return false;
    el.value = String(val);

    // FIX: single well-formed try/catch (prevents -missing catch or finally after try-)
    try {
      var ev1, ev2;
      try {
        ev1 = new Event('input',  { bubbles:true });
        ev2 = new Event('change', { bubbles:true });
      } catch(e1){
        ev1 = document.createEvent('Event'); ev1.initEvent('input',  true, true);
        ev2 = document.createEvent('Event'); ev2.initEvent('change', true, true);
      }
      el.dispatchEvent(ev1);
      el.dispatchEvent(ev2);
    } catch(e) {}

    return true;
  }

  // --- presets (reuse single source of truth from Block A) ---
  // CHG: Fix object-literal closure (prevents "missing } after property list")
  var PRESETS = (window.SKAI_PRESETS || {
    balanced:     { epochs:90, batchSize:32, dropoutRate:0.25, learningRate:0.0008, hiddenLayers:2, recencyDecay:0.95, windowSize:'auto', blendRatio:0.55, gapScale:0.12 },
    explorative:  { epochs:80, batchSize:32, dropoutRate:0.30, learningRate:0.0008, hiddenLayers:3, recencyDecay:0.93, windowSize:'auto', blendRatio:0.60, gapScale:0.18 },
    conservative: { epochs:70, batchSize:32, dropoutRate:0.30, learningRate:0.0007, hiddenLayers:2, recencyDecay:0.97, windowSize:'auto', blendRatio:0.45, gapScale:0.08 }
  });

  // Optional hardening (safe): prevent accidental mutation during runtime
  try { if (Object.freeze) { Object.freeze(PRESETS); } } catch(_){}

function markActiveUI(presetName, blendValue) {
  // Normalize inputs
  var p = String(presetName || '').trim().toLowerCase();
  var lam = Number(blendValue);
  if (!isFinite(lam)) lam = 0.5;           // sensible default
  lam = Math.max(0, Math.min(1, lam));     // clamp to [0,1]

  // Derive mode from blend ratio
  var mode = (lam >= 0.5) ? 'skipml' : (lam <= 0.11 ? 'ai' : 'hybrid');

  // Helper: apply visual state
  function setActiveState(el, isOn) {
    if (!el || !el.classList) return;
    el.classList.toggle('is-active', !!isOn);
    // a11y: aria-pressed removed
  }

  // Profile / preset buttons (ES5 loop; no NodeList.forEach)
  var profBtns = document.querySelectorAll('[data-skai-profile],[data-profile],[data-preset]');
  for (var i = 0; i < profBtns.length; i++) {
    var b = profBtns[i];
    var name = (b.getAttribute('data-skai-profile')
             || b.getAttribute('data-profile')
             || b.getAttribute('data-preset')
             || '').toLowerCase();
    setActiveState(b, name === p);
  }


  // Blend-mode buttons (ES5 loop)
  var blendBtns = document.querySelectorAll('[data-skai-blend]');
  for (var j = 0; j < blendBtns.length; j++) {
    var bb = blendBtns[j];
    var want = String(bb.getAttribute('data-skai-blend') || '').toLowerCase();
    var on = (want === mode) || (want === 'skip' && mode === 'skipml');
    setActiveState(bb, on);
  }

  // Explicit mode toggles by id
  [['mode_skipml','skipml'], ['mode_hybrid','hybrid'], ['mode_ai','ai']].forEach(function (pair) {
    var el = document.getElementById(pair[0]);
    if (el) setActiveState(el, pair[1] === mode);
  });

  // Optional: return current selection snapshot
  return { preset: p, blend: lam, mode: mode };
}

  function inferPresetNameFromNode(node){
    if (!node) return '';
    var name = (node.getAttribute && (node.getAttribute('data-skai-profile')
                                   || node.getAttribute('data-profile')
                                   || node.getAttribute('data-preset'))) || '';
    if (name) return String(name).toLowerCase();
    var t = (node.innerText || node.value || '').toLowerCase();
    if (/balanced/.test(t)) return 'balanced';
    if (/explor/i.test(t))  return 'explorative';
    if (/conserv/.test(t))  return 'conservative';
    return '';
  }

  // Export the active-state helper so later shims can reuse it for presets/blend buttons
  try {
    if (typeof window.SKAI_markActiveUI !== 'function') {
      window.SKAI_markActiveUI = markActiveUI;
    }
  } catch (_) {}

})(); // close outer IIFE
</script>

<script>
// --- Safety shims so this block works even if prior exports didn't run yet ---
;window.SKAI_PRESETS = window.SKAI_PRESETS || {
  balanced:     { epochs:90,  batchSize:32, dropoutRate:0.25, learningRate:0.0008, hiddenLayers:2, recencyDecay:0.95, windowSize:'auto', blendRatio:0.55, gapScale:0.12 },
  explorative:  { epochs:80,  batchSize:32, dropoutRate:0.30, learningRate:0.0008, hiddenLayers:3, recencyDecay:0.93, windowSize:'auto', blendRatio:0.60, gapScale:0.18 },
  conservative: { epochs:70,  batchSize:32, dropoutRate:0.30, learningRate:0.0007, hiddenLayers:2, recencyDecay:0.96, windowSize:'auto', blendRatio:0.50, gapScale:0.08 }
};

var q = (typeof window.SKAI_q === 'function') ? window.SKAI_q : function(id){
  return document.getElementById(id + '_ui')
      || document.querySelector('[id="'+id+'"]:not([type="hidden"])')
      || document.getElementById(id)
      || null;
};
var setValue = (typeof window.SKAI_setValue === 'function') ? window.SKAI_setValue : function(id,val){
  var el = q(id);
  if (!el) return false;
  el.value = String(val);
 try {
    var ev3, ev4;
    try {
      ev3 = new Event('input',  { bubbles:true });
      ev4 = new Event('change', { bubbles:true });
    } catch(e2){
      ev3 = document.createEvent('Event'); ev3.initEvent('input',  true, true);
      ev4 = document.createEvent('Event'); ev4.initEvent('change', true, true);
    }
    el.dispatchEvent(ev3);
    el.dispatchEvent(ev4);
  } catch(_){}
  return true;
};
var markActiveUI = (typeof window.SKAI_markActiveUI === 'function') ? window.SKAI_markActiveUI : function(){};

function applyPresetAndMaybeRun(presetName, autoRun){
    var p = String(presetName||'').toLowerCase();
    // Read from the single global source to avoid duplicate PRESETS bindings
    var presetSpec = (window.SKAI_PRESETS || {})[p];
    if (!presetSpec) return;

    // NEW: shallow-clone to avoid mutating global preset templates
    var spec = {};
    for (var k0 in presetSpec){
      if (Object.prototype.hasOwnProperty.call(presetSpec, k0)) {
        spec[k0] = presetSpec[k0];
      }
    }

    // wait for inputs to exist (Promise-chain, no async/await)
    var waitInputs = (typeof Promise === 'function')
      ? new Promise(function(res){
          if (q('epochs')) return res();
          var tries = 40, iv = setInterval(function(){
            if (q('epochs') || --tries <= 0){ clearInterval(iv); res(); }
          }, 100);
        })
      : { then:function(cb){ cb(); } };

    return waitInputs.then(function(){

      // sanitize (if available) - operates on local clone
      if (typeof window.SKAI_sanitizePreset === 'function') {
        spec = window.SKAI_sanitizePreset(spec);
      }

      // --- resolve windowSize 'auto' => full DB length (entire dataset) ---
      try {
        var fullLen = 1;
        if (Array.isArray && Array.isArray(window.__le_lastFiltered)) {
          fullLen = Math.max(fullLen, window.__le_lastFiltered.length|0);
        } else if (Array.isArray && Array.isArray(window.draws)) {
          fullLen = Math.max(fullLen, window.draws.length|0);
        }
        // Accept also string 'MAX' as alias for full history
        if (String(spec.windowSize).toLowerCase() === 'auto' || String(spec.windowSize).toUpperCase() === 'MAX') {
          spec.windowSize = fullLen;
          try { console.info('[SKAI] Preset window auto->full:', fullLen); } catch(_){}
        }
        // Mirror to SKAI_SERVER for downstream readers (no Object.assign)
        try {
          var prevS = window.SKAI_SERVER || {};
          var S = window.SKAI_SERVER = {};
          for (var kk in prevS){ if (Object.prototype.hasOwnProperty.call(prevS,kk)) S[kk] = prevS[kk]; }
          S.usedWindow = S.bestWindow = S.tunedWindow = S.windowSize = spec.windowSize;
          document.documentElement.setAttribute('data-skai-window', String(spec.windowSize));
        } catch(_){}
      } catch(_){}

      Object.keys(spec).forEach(function(k){ setValue(k, spec[k]); });
      markActiveUI(p, spec.blendRatio);

      // Emit a dedicated preset snapshot event so dashboards/insights can react
      try {
        var presetSnap = {
          preset: p,
          windowSize: spec.windowSize,
          epochs: spec.epochs,
          batchSize: spec.batchSize,
          hiddenLayers: spec.hiddenLayers,
          dropoutRate: spec.dropoutRate,
          learningRate: spec.learningRate,
          recencyDecay: spec.recencyDecay,
          blendRatio: spec.blendRatio,
          gapScale: spec.gapScale,
          at: Date.now()
        };
        var CE = (typeof window.CustomEvent === 'function')
          ? window.CustomEvent
          : function(type, params){
              var e = document.createEvent('CustomEvent');
              params = params || { bubbles:false, cancelable:false, detail:null };
              e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
              return e;
            };
        window.dispatchEvent(new CE('skai:preset:applied', { detail: presetSnap }));
      } catch(_){}

      try { if (typeof setLive === 'function') setLive(p.charAt(0).toUpperCase() + p.slice(1) + ' preset applied.'); } catch(_){}

      if (autoRun === false) return;

      // Data readiness guard
      var readyOK = false;
      try {
        readyOK = (typeof window.SKAI_hasMinimumData === 'function')
          ? window.SKAI_hasMinimumData()
          : ((window.draws && window.draws.length >= 10) || false);

        if (!readyOK) {
          (window.SKAI_warn || console.warn)('[SKAI] retry: draws not ready, attempting recovery once.');
          try { if (typeof setLive === 'function') setLive('Retrying: preparing draws...'); } catch(_){}
        }
      } catch(_){}

      var afterWait = (typeof Promise === 'function')
        ? new Promise(function(r){ setTimeout(r, 1500); })
        : { then:function(cb){ cb(); } };

      return afterWait.then(function(){
        try {
          readyOK = (typeof window.SKAI_hasMinimumData === 'function')
            ? window.SKAI_hasMinimumData()
            : ((window.draws && window.draws.length >= 10) || false);
        } catch(_){}

        if (!readyOK) {
          (window.SKAI_warn || console.warn)('[SKAI] recovery failed - insufficient data.');
          try { if (typeof setLive === 'function') setLive('Error: Not enough data to start AI.', 'error'); } catch(_){}
          if (window.SKAI_Progress && typeof window.SKAI_Progress.done === 'function') {
            try { window.SKAI_Progress.done('Error'); } catch(_) {}
          }
          try { if (typeof SKAI_emit === 'function') SKAI_emit('skai:analysis-stop', { reason: 'insufficient-data' }); } catch(_){}
          try { if (typeof window.SKAI_setBusy === 'function') window.SKAI_setBusy(false); } catch(_){}
          try { if (typeof window.SKAI_spinnerHide === 'function') window.SKAI_spinnerHide(); } catch(_){}
          try { window.__SKAI_RUNNING__ = false; } catch(_){}
          try { window.__SKAI_RUN_ACTIVE__ = false; } catch(_){}
          return;
        }

        // FNR-31: resolve runner before using `fn` (no const/let)
        var fn = (typeof window.SKAI_getRunner === 'function')
          ? window.SKAI_getRunner()
          : (window.SKAI_startPredictionFlow
             || window.runSkaiML
             || window.SKAI_run
             || window.runSkaiClientOnce
             || window.startSkaiML
             || null);

        // Validate config, then run exactly once
        if (typeof fn === 'function' && !window.__SKAI_RUNNING__) {
          try {
            var cfg = window.SKAI_CONFIG || window.__le_gameConfig || null;
            var v = (typeof window.SKAI_validateConfig === 'function')
                      ? window.SKAI_validateConfig(cfg)
                      : { ok: true };

            if (!v.ok) {
              var msg;
              try {
                msg = (v.reason === 'missing')
                  ? ((typeof SKAI_msg === 'function') ? SKAI_msg('configMissing') : 'Configuration missing')
                  : (((typeof SKAI_msg === 'function') ? SKAI_msg('configDetailPrefix') : 'Config: ') + v.reason);
              } catch(_) {
                msg = 'Configuration error: ' + (v.reason || 'unknown');
              }
              try { if (typeof setLive === 'function') setLive(msg, 'error'); } catch(_){}
              try {
                (typeof window.SKAI_getProgress === 'function'
                  ? SKAI_getProgress()
                  : (window.SKAI_Progress || { done: function(){} })
                ).done((typeof SKAI_msg === 'function') ? SKAI_msg('error') : 'Error');
              } catch(_){}
              try { (typeof SKAI_emit === 'function') && SKAI_emit('skai:analysis-stop', { reason: 'config:' + v.reason }); } catch(_){}
            } else {
              fn(); // run
            }
          } catch(e) {
            (window.SKAI_warn || console.warn)('[SKAI] preset-run validation error:', e);
          }
        } else {
          try { if (typeof setLive === 'function') setLive((typeof SKAI_msg === 'function') ? SKAI_msg('runnerNotReady') : 'Runner not ready'); } catch(_){}
        }
      });
    });
  }

  window.SKAI_applyPresetAndMaybeRun = applyPresetAndMaybeRun;

  // (delegation & bootstrap below unchanged)

</script>

<script>
  // --- Hard reset: never get stuck in "running" state across navigations ---
  try { window.__SKAI_RUNNING__ = false; } catch(e) {}
  // Compatibility shim (keep legacy name in sync if present)
  try {
    if (typeof window.__SKAI_RUNNING === 'boolean') window.__SKAI_RUNNING__ = window.__SKAI_RUNNING;
    Object.defineProperty(window, '__SKAI_RUNNING', {
      get: function(){ return window.__SKAI_RUNNING__; },
      set: function(v){ window.__SKAI_RUNNING__ = !!v; }
    });
  } catch(_){}


// --- Ensure a visible status line and a progress host near the run button ---
// Thin proxy to the canonical helpers to avoid duplicate logic.
function ensureStatusAndProgress(){
  try { if (typeof window.ensureStatusNode   === 'function') window.ensureStatusNode(); } catch(_){}
  try { if (typeof window.ensureProgressHost === 'function') window.ensureProgressHost(); } catch(_){}
}

// FNR-37: remove magic %; let real training drive progress
if (!window.__SKAI_WIRED_PROGRESS__) {
  window.__SKAI_WIRED_PROGRESS__ = true;

  (function () {
    var P = (typeof window.SKAI_getProgress === 'function')
      ? window.SKAI_getProgress()
      : ((typeof ensureProgressAPI === 'function')
          ? ensureProgressAPI()
          : (window.SKAI_Progress || { set: function(){}, show: function(){}, done: function(){} }));

// Start of ML run – do not set arbitrary % here; let the training loop drive progress updates
// FNR-44: no fixed % at start; let the training loop drive progress updates
window.addEventListener('skai:ml:start', function () {
  try {
    var msg = (typeof SKAI_msg === 'function') ? SKAI_msg('trainingMain') : 'Training model...';
    if (P && typeof P.show === 'function') P.show(msg);
    // Do not call P.set(...) here; avoid competing with real epoch updates
  } catch (_) {}

  try { window.__SKAI_LAST_EPOCH__ = -1; } catch (_) {}

  var live = document.getElementById('ai-live-status');
  if (live) live.textContent = 'Training...';
});

    // Drive progress bar from real epoch callbacks (single source of truth)
    (function(){
      // guard to ignore late events after ML is done
      var __done = false;

      // NEW: flip done on completion/cancel so late epochs can't overwrite 100%
      try {
        window.addEventListener('skai:ml:done', function(){ __done = true; }, false);
        window.addEventListener('skai:analysis-stop', function(){ __done = true; }, false);
      } catch(_){}

      function getEpochTotal(){
        // prefer event-provided total; else UI; else SKAI_SERVER; else 100
        try {
          var el = document.getElementById('epochs') || document.getElementById('epochs_ui');
          if (el && el.value) return Math.max(1, parseInt(el.value, 10) || 0);
        } catch(_){}
        try {
          if (window.SKAI_SERVER && +window.SKAI_SERVER.epochs > 0) return +window.SKAI_SERVER.epochs;
        } catch(_){}
        return 100;
      }


      window.addEventListener('skai:ml:epoch', function(e){
        if (__done) return;
        var cur   = (e && e.detail && +e.detail.epoch) || 0;     // 0-based from fit()
        var total = (e && e.detail && +e.detail.totalEpochs) || getEpochTotal();
        // convert to 1-based for display and percent
        var shown = Math.min(cur + 1, total);
        var pct   = Math.max(0, Math.min(100, Math.round((shown / total) * 100)));

        try {
          var P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress()
                : ((typeof ensureProgressAPI === 'function') ? ensureProgressAPI()
                   : (window.SKAI_Progress || null));
          if (P && P.set) P.set(pct, 'Epoch ' + shown + ' / ' + total);
        } catch(_){}
      }, false);
    })();


    // Optional progress (0–100) from tuner

    window.addEventListener('skai:autotune:progress', function (e) {
      try {
        var v = e && e.detail && Number(e.detail.percent);
        var P2 = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress()
                : P;

        // Ensure ETA has a fixed start time for Auto-Tune:
        // first progress event calls show(), which sets the internal t0.
        if (P2 && typeof P2.show === 'function' && !window.__SKAI_AUTOTUNE_PROGRESS_STARTED__) {
          window.__SKAI_AUTOTUNE_PROGRESS_STARTED__ = true;
          P2.show('Auto-Tune');
        }

        // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
        if (isFinite(v) && P2 && typeof P2.set === 'function') {
          P2.set(Math.max(5, Math.min(95, v)), 'Auto-Tune');
        }
      } catch(_){}
    });

    // Auto-Tune done – ML will take over progress
    window.addEventListener('skai:autotune:done', function () {
      try {
        var P2 = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress() : P;
        if (P2 && typeof P2.show === 'function') P2.show('Preparing training...');
      } catch(_){}
    });


    // Training finished; finalize progress at 100% and label N/N
    window.addEventListener('skai:ml:done', function () {
      try {
        // Prefer unified accessor
        var P = (typeof window.SKAI_getProgress === 'function')
              ? window.SKAI_getProgress()
              : (window.SKAI_Progress || { set:function(){}, show:function(){} });

        // Compute total epochs from current UI/server snapshot (exact, no off-by-one)
        var total = (function(){
          try {
            var el = document.getElementById('epochs') || document.getElementById('epochs_ui');
            var v = el && el.value ? parseInt(el.value, 10) : NaN;
            if (isFinite(v) && v > 0) return v; // CHG: ES5 finite guard
          } catch(_){}
          try {
            var sv = window.SKAI_SERVER && +window.SKAI_SERVER.epochs;
            if (isFinite(sv) && sv > 0) return +sv; // CHG: ES5 finite guard
          } catch(_){}
          return 100;
        })();

        // 100% and explicit label N/N
        P.set(100, 'Epoch ' + total + ' / ' + total);
        P.show('Picks ready');

        var live = document.getElementById('ai-live-status');
        if (live) live.textContent = 'Picks ready';
      } catch(_){}
    }, false);



// Legacy finalization still supported
window.addEventListener('skai:done', function () {
  try { if (P && P.set) P.set(100, 'Done.'); if (P && P.done) P.done('Done.'); } catch (e) {}
});

    // Fail-closed: stop bar and mark error
    window.addEventListener('skai:analysis-stop', function (e) {
      try {
        var reason = (e && e.detail && e.detail.reason) ? String(e.detail.reason) : 'error';
        var live = document.getElementById('ai-live-status');
        if (live) live.textContent = 'Analysis stopped (' + reason + ').';
        P.set && P.set(100, 'Error');
        P.done && P.done('Error');
      } catch (err) {}
    });
  })();
}

// Minimal shim so older pages that expected status/progress boot still get it.
(function(){ try{ if (typeof ensureStatusAndProgress === 'function') ensureStatusAndProgress(); }catch(_){}})();

// Guard manual edits to blendRatio & laplaceK fields
(function(){
  // --- blendRatio guard (fraction 0..1 or percent 0..100 based on max attr)
  var br = document.getElementById('blendRatio_ui') || document.getElementById('blendRatio');
  if (br) {
    br.addEventListener('change', function(){
      var maxAttr = parseFloat(br.max);
      // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
      var isFraction = isFinite(maxAttr) ? (maxAttr <= 1.5) : false;
      var raw = parseFloat(br.value);
      if (!isFinite(raw)) return;

      var clamped = isFraction ? Math.max(0, Math.min(1, raw))
                               : Math.max(0, Math.min(100, Math.round(raw)));
      if (clamped !== raw) {
        br.value = String(clamped);
        try {
          if (typeof setLive === 'function') {
            var msg = (typeof SKAI_msg === 'function')
              ? SKAI_msg('valueClamped', { field: 'blendRatio', value: clamped })
              : ('blendRatio clamped to ' + clamped);
            setLive(msg);
          }
        } catch(_){}
      }

      // ES5-safe merge into SKAI_SERVER (no Object.assign)
      try {
        var prevS = window.SKAI_SERVER || {};
        var S = window.SKAI_SERVER = {};
        for (var kk in prevS){ if (Object.prototype.hasOwnProperty.call(prevS, kk)) S[kk] = prevS[kk]; }
        S.blendRatio = clamped;
      } catch(_){}
    });
  }

  // --- laplaceK guard (integer in {0,1,2})
  var lk = document.getElementById('laplaceK_ui') || document.getElementById('laplaceK');
  if (lk) {
    lk.addEventListener('change', function(){
      var raw = parseFloat(lk.value);
      // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
      if (!isFinite(raw)) return;
      var k = Math.round(raw);
      if (k < 0) k = 0; if (k > 2) k = 2;

      if (String(k) !== String(lk.value)) {
        lk.value = String(k);
        try { if (typeof setLive === 'function') setLive('Laplace K set to ' + k); } catch(_){}
      }

      // ES5-safe merge into SKAI_SERVER (no Object.assign)
      try {
        var prevS2 = window.SKAI_SERVER || {};
        var S2 = window.SKAI_SERVER = {};
        for (var kk2 in prevS2){ if (Object.prototype.hasOwnProperty.call(prevS2, kk2)) S2[kk2] = prevS2[kk2]; }
        S2.laplaceK = k;
      } catch(_){}

      // Notify listeners that tuning-affecting param changed (ES5 CustomEvent fallback)
      try {
        var CE = (typeof window.CustomEvent === 'function')
          ? window.CustomEvent
          : function(type, params){
              var e = document.createEvent('CustomEvent');
              params = params || { bubbles:false, cancelable:false, detail:null };
              e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
              return e;
            };
        window.dispatchEvent(new CE('skai:params:changed', { detail:{ laplaceK: k } }));
      } catch(_){}
    });
  }
})();
</script>

<script>
// Centralize status/progress into the AI card (no globals leaked)
// Safe: no free "host" refs, resilient to late DOM changes.
;(function(){
  'use strict';

  function ensureArea(){
    var panel = document.getElementById('skai-ai-panel') ||
                document.getElementById('skai') ||
                document.body;
    if (!panel) return null;

    var area = document.getElementById('ai-status-area');
    if (!area) {
      area = document.createElement('div');
      area.id = 'ai-status-area';
      panel.appendChild(area);
    }

    // Live status line (ABOVE the bar)
    var live = document.getElementById('ai-live-status');
    if (!live) {
      live = document.createElement('span');
      live.id = 'ai-live-status';
      // ARIA removed (role/aria-live/aria-atomic)
      live.style.display = 'block';
      live.style.margin = '0 0 6px 0';
      live.textContent = 'Ready.';
area.insertBefore(live, area.firstChild || null);
try { live.style.opacity = '0'; live.style.transition = 'opacity .25s ease'; requestAnimationFrame(function(){ live.style.opacity = '1'; }); } catch(_){}
    }

    // Progress host (BELOW the status line) ? unify on #skai-progress, accept legacy id if present
    var prog = document.getElementById('skai-progress') || document.getElementById('skaiProgressHost');
    if (!prog) {
      prog = document.createElement('div');
      prog.id = 'skai-progress'; // primary id
      // ARIA removed (role/progressbar and aria-valu*)
      prog.setAttribute('data-skai-progress','1'); // readers query by attribute as well
      prog.style.height = '24px';
      prog.style.margin = '6px 0 10px 0';

      // optional visual fill (safe if unused)
      if (!prog.querySelector('.fill')) {
        var fill = document.createElement('div');
        fill.className = 'fill';
        fill.style.width = '0%'; // ensure a visible starting state
        prog.appendChild(fill);
      }

      // insert *after* the status line
      if (live && live.nextSibling) area.insertBefore(prog, live.nextSibling);
      else area.appendChild(prog);
    } else {
      // Legacy host exists (#skaiProgressHost): normalize attributes/children safely
      try { prog.setAttribute('data-skai-progress','1'); } catch(_){}
      if (!prog.querySelector('.fill')) {
        try {
          var f2 = document.createElement('div');
          f2.className = 'fill';
          f2.style.width = '0%';
          prog.appendChild(f2);
        } catch(_) {}
      }
    }
    return area;
  }

  function relocate(){
    var area = ensureArea();
    if (!area) return;

    // Ensure nodes live under #ai-status-area
    var prog = document.getElementById('skai-progress') || document.getElementById('skaiProgressHost');
    if (prog) {
      try { prog.setAttribute('data-skai-progress','1'); } catch(_){}
      if (prog.parentNode !== area) {
        var live = document.getElementById('ai-live-status');
        if (live && live.nextSibling) area.insertBefore(prog, live.nextSibling);
        else area.appendChild(prog);
      }
    }

    var live = document.getElementById('ai-live-status');
    if (live && live.parentNode !== area) area.appendChild(live);

    // If a screen-reader line exists, keep it here too
    var sr = document.getElementById('ai-live-status-sr');
    if (sr && sr.parentNode !== area) area.appendChild(sr);
  }

  // Export ?where to put status/progress? helpers so other code can call us (guard redefs)
  if (typeof window.ensureStatusNode !== 'function') {
    window.ensureStatusNode = function(){ relocate(); return document.getElementById('ai-live-status'); };
  }
  if (typeof window.ensureProgressHost !== 'function') {
    window.ensureProgressHost = function(){
      relocate();
      return document.getElementById('skai-progress') || document.getElementById('skaiProgressHost');
    };
  }

  function showIdleOrComplete(){
    try {
      // Prefer local ensureProgressAPI, else fall back to SKAI_getProgress() or SKAI_Progress
      var p = (typeof ensureProgressAPI === 'function')
        ? ensureProgressAPI()
        : (typeof window.SKAI_getProgress === 'function' ? window.SKAI_getProgress()
           : (window.SKAI_Progress || { show:function(){}, set:function(){}, done:function(){} }));

      // Detect results ONLY from ML globals, never from DOM pills.
      var hasMain  = Array.isArray(window.__SKAI_LAST_PICKS__) && window.__SKAI_LAST_PICKS__.length > 0;
      var hasExtra = Array.isArray(window.__SKAI_LAST_EXTRA__) && window.__SKAI_LAST_EXTRA__.length > 0;

      if (hasMain || hasExtra) {
        var label = hasMain && hasExtra ? 'Main + Extra complete'
                  : hasMain ? 'Main complete'
                  : 'Extra complete';
        p.show('Results ready');
        p.set(100, label);       // finished state
      } else {
        p.show('Idle');
        p.set(0, 'Idle');        // start at 0%
      }
    } catch(_) {}
  }

  // Run now, on DOM ready, and track dynamic DOM changes
  if (document.readyState === 'loading') {
    // Fix: ES5-safe "once" via self-removing listener. Risk: Very low; preserves one-time execution.
    var __skaiOnReady__ = function(){
      try { document.removeEventListener('DOMContentLoaded', __skaiOnReady__); } catch(_){}
      relocate();
      showIdleOrComplete(); // ALWAYS visible, 0% (or 100% if results already exist)
    };
    document.addEventListener('DOMContentLoaded', __skaiOnReady__, false);
  } else {
    relocate();
    showIdleOrComplete();   // ALWAYS visible, 0% (or 100% if results already exist)

 
    // If results already on the page (cached render), build & show insights immediately
    try {
      var preHasMain  = document.querySelectorAll('.skai-ai-main .nball').length > 0;
      var preHasExtra = document.querySelectorAll('#aiExtraPredictionContainer .xball').length > 0;
      if ((preHasMain || preHasExtra) && typeof window.SKAI_renderInsights === 'function') {
        // CHG: Use explicit prediction data sources ONLY - never scrape DOM.
        // Reason: DOM .nball elements can include draw history pills from other page sections.
        // Benefit: Insights always show actual AI predictions, not recent draws.
        var picksNow = [];
        
        // Priority 1: Use the captured last picks from scoring
        if (window.__SKAI_LAST_PICKS__ && window.__SKAI_LAST_PICKS__.length) {
          for (var pi=0; pi<window.__SKAI_LAST_PICKS__.length; pi++){
            picksNow.push(String(window.__SKAI_LAST_PICKS__[pi]));
          }
        } else if (Array.isArray(window.SKAI_TOP_MAIN) && window.SKAI_TOP_MAIN.length) {
          // Priority 2: Use SKAI_TOP_MAIN if available
          for (var pj=0; pj<window.SKAI_TOP_MAIN.length; pj++){
            var item = window.SKAI_TOP_MAIN[pj];
            picksNow.push(String(item.num || item));
          }
        }
        // Priority 3 REMOVED: Never scrape .nball from DOM - those could be draw history
        
        var autoNow = (typeof window.SKAI_generateRationale === 'function')
          ? (window.SKAI_generateRationale({ lookback: 50 }) || {})
          : {};
        // CHG: ES5-safe merge instead of Object.assign
        var __ins__ = {};
        for (var k2 in autoNow){ if (Object.prototype.hasOwnProperty.call(autoNow, k2)) __ins__[k2] = autoNow[k2]; }
        __ins__.picks = picksNow;
        window.SKAI_renderInsights(__ins__);      }
    } catch(_){}
  }

// FNR-43: MutationObserver teardown for status/progress relocator (prevent leaks across navs)
try {
  if (!window.__SKAI_OBS_STATUS__) {
    window.__SKAI_OBS_STATUS__ = new MutationObserver(relocate);
    window.__SKAI_OBS_STATUS__.observe(document.documentElement, { childList: true, subtree: true });

    // Teardown on tab hide or page unload
    function __skaiDisconnectStatusObs__(){
      try {
        if (window.__SKAI_OBS_STATUS__) {
          window.__SKAI_OBS_STATUS__.disconnect();
          window.__SKAI_OBS_STATUS__ = null;
        }
      } catch(_) {}
      try { document.removeEventListener('visibilitychange', __skaiDisconnectStatusObs__, true); } catch(_) {}
      try { window.removeEventListener('beforeunload', __skaiDisconnectStatusObs__, true); } catch(_) {}
    }
    document.addEventListener('visibilitychange', function(){
      if (document.visibilityState === 'hidden') __skaiDisconnectStatusObs__();
    }, true);
    window.addEventListener('beforeunload', __skaiDisconnectStatusObs__, true);
  }
} catch(e) { /* no-op */ }

})();

</script>

<script>
;(function(){
  // never get stuck between navigations
  window.__SKAI_RUN_ACTIVE__ = false;

  // Helper: start/stop the spinner on the approved buttons
function setBtnLoading(on){
['startPrediction'].forEach(function(id){
      var b = document.getElementById(id);
      if (!b) return;
      b.classList.toggle('skai-btn-busy', !!on);
      if ('disabled' in b) b.disabled = !!on;
      // ARIA removed: aria-busy / aria-disabled not set
      if (on) { b.setAttribute('data-skai-busy','1'); } else { b.removeAttribute('data-skai-busy'); }
    });

  // Keep global busy signals consistent with leave-prompt policy
  try {
    var root = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
    if (root) root.classList.toggle('is-busy', !!on);
    document.documentElement.classList.toggle('__skai-running', !!on);
    if (typeof window.SKAI_setBusy === 'function') window.SKAI_setBusy(!!on);
  } catch(_) {}
}

  // Public API used by runners (no-ops if buttons absent)
window.SKAI_spinnerShow = function(){
  setBtnLoading(true);
  try { document.documentElement.classList.add('__skai-running'); } catch(_){}
};
window.SKAI_spinnerHide = function(){
  setBtnLoading(false);
  try { document.documentElement.classList.remove('__skai-running'); } catch(_){}
};

  // Unified spinner policy: lock on start of Auto-Tune or ML; unlock only on done/abort
  window.addEventListener('skai:autotune:start', function(){ setBtnLoading(true); }, false);
  window.addEventListener('skai:ml:start',       function(){ setBtnLoading(true); }, false);

  window.addEventListener('skai:done',           function(){ setBtnLoading(false); }, false);
  window.addEventListener('skai:ml:done',        function(){ setBtnLoading(false); }, false);
  window.addEventListener('skai:analysis-stop',  function(){ setBtnLoading(false); }, false);
})();
</script>

<script>
;(function(){
  'use strict';

  // ---------- 1) Make "apply autotune" robust & update telemetry ----------
  function __skaiApplyATSettingsSafe(s){
    if (!s || typeof s !== 'object') return false;

    // Normalize alt ids used in your UI (maps ? canonical keys in `s`)
    var alias = {
      layers: 'hiddenLayers',
      lr: 'learningRate',
      blend: 'blendRatio',
      gap: 'gapScale'
    };
    Object.keys(alias).forEach(function(k){
      if (s[k] != null && s[alias[k]] == null) s[alias[k]] = s[k];
    });

    // Inputs that might exist on this page
    var ids = [
      'windowSize','epochs','batchSize','dropoutRate','learningRate',
      'activationFunction','hiddenLayers','recencyDecay',
      'temperature','diversityPenalty','blendRatio','gapScale'
    ];

    var applied = 0, missing = [];

    // Set BOTH raw id and _ui mirror when present; count each successful write
    function setVal(id, val){
      var wrote = 0;

      var el1 = document.getElementById(id);
      var el2 = document.getElementById(id + '_ui');

      if (!el1 && !el2) { missing.push(id); return; }

      [el1, el2].forEach(function(el){
        if (!el) return;
        try {
          el.value = String(val);
          el.dispatchEvent(new Event('input',  {bubbles:true}));
          el.dispatchEvent(new Event('change', {bubbles:true}));
          wrote++;
        } catch(_){}
      });

      applied += wrote;

      // Broadcast a lightweight -params changed- signal
      try {
        var CE = (typeof window.CustomEvent === 'function')
          ? window.CustomEvent
          : function(type, params){
              var e = document.createEvent('CustomEvent');
              params = params || { bubbles:false, cancelable:false, detail:null };
              e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
              return e;
            };
        window.dispatchEvent(new CE('skai:params:changed'));
      } catch(_){}
    }

    // Special handling for window size + full telemetry + broadcast
    if (s.windowSize != null){
      var max = 1;
      try{
        if (Array.isArray(window.__le_lastFiltered)) max = Math.max(max, window.__le_lastFiltered.length|0);
        else if (Array.isArray(window.draws))       max = Math.max(max, window.draws.length|0);
      }catch(_){}
      var tag = String(s.windowSize).trim().toUpperCase();
      var w = (tag === 'MAX' || tag === 'AUTO' || tag === 'FULL' || tag === 'ALL')
        ? max
        : Math.max(1, Math.min(parseInt(s.windowSize, 10) || 1, max));

      // Write BOTH controls when present
      setVal('windowSize', w);

      // Keep slider bounds aligned with data size (if those inputs exist)
      try {
        ['windowSize','windowSize_ui'].forEach(function(id){
          var el = document.getElementById(id);
          if (el && el.max != null) el.max = String(max);
        });
      } catch(_){}

      // Update the inline pill if present
      try{ var pill = document.getElementById('windowSizeVal'); if (pill) pill.textContent = String(w); }catch(_){}

      // Mirror tuned W into all common keys (ES5-safe merge)
      try {
        var prevS = window.SKAI_SERVER || {};
        var S = window.SKAI_SERVER = {};
        for (var kk in prevS){ if (Object.prototype.hasOwnProperty.call(prevS, kk)) S[kk] = prevS[kk]; }

        S.usedWindow    = w;
        S.bestWindow    = w;
        S.tunedWindow   = w;
        S.windowSize    = w;          // some readers check this legacy key
        S.tuneSucceeded = 1;
        S.tuneRequested = 1;
        S.tuneRan       = 1;
        S.hasAutoTune   = true;

        document.documentElement.setAttribute('data-skai-window', String(w));
      } catch(_){}

      // Expose on <html> as a stable data-hook (already set above)
      // try { document.documentElement.setAttribute('data-skai-window', String(w)); } catch(_){}

      // Tell listeners explicitly which window was chosen
      try {
        var CE2 = (typeof window.CustomEvent === 'function')
          ? window.CustomEvent
          : function(type, params){
              var e = document.createEvent('CustomEvent');
              params = params || { bubbles:false, cancelable:false, detail:null };
              e.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
              return e;
            };
        window.dispatchEvent(new CE2('skai:settings:window', { detail:{ value:w } }));
      } catch(_){}
    }

    // Scalars
    ids.forEach(function(id){
      if (id === 'windowSize') return;
      if (s[id] == null) return;
      setVal(id, s[id]);

      // Also mirror a few key scalars to SKAI_SERVER for downstream UI
      try {
        if (!window.SKAI_SERVER) window.SKAI_SERVER = {};
        if (id === 'blendRatio')   window.SKAI_SERVER.blendRatio   = s[id];
        if (id === 'recencyDecay') window.SKAI_SERVER.recencyDecay = s[id];
        if (id === 'epochs')       window.SKAI_SERVER.epochs       = s[id];
      } catch(_){}
    });

    // Mark -applied- if anything was written OR there are no matching inputs (dashboard variant)
    if (typeof window.__SKAI_AT_SETTINGS_APPLIED__ === 'undefined') window.__SKAI_AT_SETTINGS_APPLIED__ = false;
    if (applied > 0 || missing.length === ids.length){
      window.__SKAI_AT_SETTINGS_APPLIED__ = true;
    }

    // Do not auto-start; just clear defer flag if it was set
    if (window.__SKAI_DEFER_START__) { window.__SKAI_DEFER_START__ = false; }

    // One concise diagnostic
    try{
      console.log('[SKAI] Auto-Tune apply:',
        'applied=', applied,
        missing.length ? ('missing='+missing.join(',')) : 'missing=none'
      );
    }catch(_){}

    return true;
  }

// ---------- 2) Hook the bridge; pass tuned W and AUTO-START ML (one-shot, no double runs) ----------
(function(){
  // one-shot guard for this page lifetime
  function canAutoStart(){
    // Do not start if another run is already active or a cooldown says ?wait?
    if (window.__SKAI_RUNNING__ === true) return false;
    if (window.__SKAI_START_COOLDOWN__ === true) return false;
    if (window.__SKAI_AUTOSTART_LOCK__ === true) return false;
    return true;
  }

  function __skaiStartMLOnce(){
    if (!canAutoStart()) return;
    window.__SKAI_AUTOSTART_LOCK__ = true; // prevent any subsequent auto-starts

    // wait a micro-tick so inputs/DOM settle after we applied settings
    setTimeout(function(){
      // re-check after microtask
      if (window.__SKAI_RUNNING__ === true || window.__SKAI_START_COOLDOWN__ === true) return;

      var invoke = function(fn){
        if (typeof fn !== 'function') throw new Error('Runner not ready');

        // Publish normalized cfg (includes tuned window already mirrored)
        try {
          var cfg = (typeof window.assembleSkaiConfig === 'function') ? window.assembleSkaiConfig() : null;
          if (cfg){
            var prevS = window.SKAI_SERVER || {};
            var S = window.SKAI_SERVER = {};
            for (var kk in prevS){ if (Object.prototype.hasOwnProperty.call(prevS, kk)) S[kk] = prevS[kk]; }
            for (var ck in cfg){ if (Object.prototype.hasOwnProperty.call(cfg, ck)) S[ck] = cfg[ck]; }
          }
        } catch(_){}

        // Let the runner set __SKAI_RUNNING__ itself to avoid -already running?-
        try { document.documentElement.classList.add('__skai-running'); } catch(_){}
        fn();
      };

      var fail = function(err){
        try { console.warn('[SKAI] auto-start failed:', err); } catch(_){}
        try { document.documentElement.classList.remove('__skai-running'); } catch(_){}
        // allow manual Run button if auto-start fails
        window.__SKAI_AUTOSTART_LOCK__ = false;
      };

      if (typeof window.whenRunnerReady === 'function') {
        window.whenRunnerReady(15000).then(invoke).catch(fail);
      } else {
        var fn = (typeof window.SKAI_getRunner === 'function')
          ? (function(){ try { return window.SKAI_getRunner(); } catch(_) { return null; } })()
          : (window.SKAI_startPredictionFlow || window.runSkaiML || window.SKAI_run || window.runSkaiClientOnce || window.startSkaiML || null);
        try { invoke(fn); } catch(e){ fail(e); }
      }
    }, 60);
  }

  // clear the one-shot lock after a full cycle (done or stop), just in case user re-tunes
  ['skai:ml:done','skai:analysis-stop'].forEach(function(ev){
    window.addEventListener(ev, function(){ try { window.__SKAI_AUTOSTART_LOCK__ = false; } catch(_){ } }, false);
  });

  window.addEventListener('skai:autotune:result', function(ev){
    try{
      var payload = (ev && ev.detail && ev.detail.settings) ? ev.detail.settings :
                    (ev && ev.detail) ? ev.detail : null;

      var ok = false;
      if (payload) ok = __skaiApplyATSettingsSafe(payload);
      else if (window.SKAI_TUNED_PARAMS) ok = __skaiApplyATSettingsSafe(window.SKAI_TUNED_PARAMS);

      // Resolve tuned window for UI badge & logs
      var W = (window.SKAI_SERVER && (+window.SKAI_SERVER.usedWindow || +window.SKAI_SERVER.bestWindow)) || 0; // fixed corrupted property chain

      // Announce and show W in the green pill; also better status copy
      try {
        var msg = W > 0 ? ('Auto-Tune complete (W=' + W + ') - starting training...')
                        : 'Auto-Tune complete - starting training...';
        if (typeof window.setLive === 'function') setLive(msg);
        var pill = document.querySelector('[data-skai-tune-pill], #skai-tune-pill');
        if (pill && W > 0) pill.textContent = 'Auto-Tune complete  W=' + W;
      } catch(_){}

      try { (typeof window.SKAI_emit === 'function') && SKAI_emit('skai:settings:applied'); } catch(_){}

      // Progress line: show handoff -> ML (no undefined vars; let training drive %)
      try {
        var P = (typeof window.SKAI_getProgress === 'function') ? window.SKAI_getProgress() : null;
        if (P && typeof P.show === 'function') P.show('Preparing training...');
      } catch(_){}

      __skaiStartMLOnce();
    }catch(_){}
  });
})(); // end inner IIFE

})(); // end outer IIFE that began with `;(function(){` at the top
</script>

<script>
;(function(){
  'use strict';

// --- helpers ---------------------------------------------------------------
// ---- Run button discovery ---------------------------------------------------
function findRunButtons(){
  var a = [];
  var b1 = document.getElementById('btnRunAI');
  if (b1) a.push(b1);

  // #startPrediction is handled by the canonical gate script; do not wire it here to avoid double-start
  try {
    var nodes = document.querySelectorAll('[data-skai-run]');
    for (var i = 0; i < nodes.length; i++){
      a.push(nodes[i]);
    }
  } catch(_){}

  // ES5 de-dupe
  var out = [];
  for (var j = 0; j < a.length; j++){
    if (out.indexOf(a[j]) === -1) out.push(a[j]);
  }
  return out;
}


function setBtnState(btn, ready){
  btn.disabled = !ready;
  btn.classList.toggle('skai-btn--ready', !!ready);
  // ARIA removed: no aria-disabled
}

// [LEDGER-FIX L-001] Helper shims (defined only if missing)
if (typeof window.pressedLabel !== 'function'){
  window.pressedLabel = function(on){ return on ? 'On' : 'Off'; };
}
if (typeof window.computeLabel !== 'function'){
  window.computeLabel = function(v, unit){
    try {
      if (v == null || v === '') return '';
      return String(v) + (unit ? (' ' + unit) : '');
    } catch(_){ return ''; }
  };
}
if (typeof window.applyPreset !== 'function'){
  // Safe no-op preset applier; real preset function (if added later) will override this.
  window.applyPreset = function(){ return false; };
}

// ---- Run-state controller (no checkbox gating) ------------------------------
(function(){
  'use strict';

  // Light raf debounce (idempotent if one already exists globally)
  var _rafDebounce = (typeof window.rafDebounce === 'function')
    ? window.rafDebounce
    : function(fn, waitMs){
        var rafId = 0, tId = 0, lastArgs;
        // ES5-safe RAF fallbacks
        var _raf  = window.requestAnimationFrame || function(cb){ return setTimeout(cb, 16); };
        var _craf = window.cancelAnimationFrame  || function(id){ clearTimeout(id); };

        var later = function(){
          tId = 0;
          rafId = _raf(function(){ try { fn.apply(null, lastArgs||[]); } catch(_){} });
        };
        return function(){
          lastArgs = arguments;
          if (tId) clearTimeout(tId);
          if (rafId) _craf(rafId);
          tId = setTimeout(later, waitMs || 60);
        };
      };

// Predicate for overall readiness: block when running or in cooldown window
function canRun(){
  try {
    return (window.__SKAI_RUNNING__ !== true) && (window.__SKAI_START_COOLDOWN__ !== true);
  } catch(_) { return true; }
}

  // Debounced updater
  function _update(){
    var ready = canRun();
    try {
      var buttons;
      if (typeof findRunButtons === 'function') {
        buttons = findRunButtons();
      } else {
        buttons = [];
        try {
          var nodes = document.querySelectorAll('#startPrediction, #btnRunAI, [data-skai-run]');
          for (var i = 0; i < nodes.length; i++) buttons.push(nodes[i]);
        } catch(_){}
      }

      for (var j = 0; j < buttons.length; j++) {
        var btn = buttons[j];
        if (!btn) continue;

        if (typeof setBtnState === 'function') {
          setBtnState(btn, ready);
        } else {
          // fallback
          try { btn.disabled = !ready; } catch(_){}
          try { btn.classList && btn.classList.toggle('skai-btn--ready', !!ready); } catch(_){}
          // ARIA removed: no aria-disabled
        }
      }
    } catch(_) {}

    try {
      if (typeof window.setLive === 'function') {
        window.setLive('Ready to run');
      }
    } catch(_){}
  }

  var updateRunState = _rafDebounce(_update, 80);

  // Expose for other modules that already call it
  try { window.updateRunState = updateRunState; } catch(_) {}

  // Initial pass
  try { updateRunState(); } catch(_) {}

  // Keep buttons in sync with lifecycle / settings changes
  ['skai:data:ready','skai:data:insufficient','skai:autotune:result','skai:ml:start','skai:ml:done','skai:analysis-stop']
    .forEach(function(ev){
      window.addEventListener(ev, function(){ try { updateRunState(); } catch(_){} }, false);
    });


  // Also react to settings inputs changing
  document.addEventListener('input', function(e){
    if (!e || !e.target) return;
    if (e.target.matches('#windowSize_ui,#epochs_ui,#batchSize_ui,#dropout_ui,#learningRate_ui,#recencyDecay_ui,#blendRatio_ui,#gapScale_ui')) {
      try { updateRunState(); } catch(_) {}
    }
  }, true);
})();

function handleClick(e){
  var btn = e.currentTarget;
  if (!btn || btn.disabled) return;

  // If this is a submit button inside a form, let the form submit render results
  var isSubmit = (btn.matches('button:not([type]),button[type="submit"],input[type="submit"]') && btn.form);
  if (isSubmit) return;

  // Single-flight guard: lock immediately to prevent double firing before ml:start
  if (window.__SKAI_RUNNING__ || window.__SKAI_START_COOLDOWN__) return;
  try { window.__SKAI_RUNNING__ = true; } catch(_) {}
  try {
    document.documentElement.classList.add('__skai-running');
    var root = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
    if (root) root.classList.add('is-busy');
  } catch(_) {}
  try { window.SKAI_setBusy && window.SKAI_setBusy(true); } catch(_){}
  // Clean status copy (no mojibake)
  try { typeof window.setLive === 'function' && window.setLive('Starting AI...'); } catch(_){}

  // === CONFIG GUARD: assemble & validate BEFORE resolving the runner ===
  try {
    var cfg = (typeof window.assembleSkaiConfig === 'function') ? window.assembleSkaiConfig() : null;
    var miss = (typeof window.__SKAI_requireConfigFields === 'function') ? window.__SKAI_requireConfigFields(cfg) : ['config-object'];
    if (miss && miss.length) {
      try { console.warn('[SKAI] cfg: cfg.missing.' + miss.join(', ')); } catch(_){}
      try { window.SKAI_reportConfigMissing && window.SKAI_reportConfigMissing(miss); } catch(_){}
      // Unlock & exit cleanly
      try { window.__SKAI_RUNNING__ = false; } catch(_){}

      // CHG: also remove the global running class so any gray overlay clears
      try {
        document.documentElement.classList.remove('__skai-running');
      } catch(_){}

      try {
        var r = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
        if (r) r.classList.remove('is-busy');
      } catch(_){}
      try { window.SKAI_setBusy && window.SKAI_setBusy(false); } catch(_){}
      return;
    }

    // ---- Ensure tuned Window (W) is injected into what the runner reads ----
    // Prefer explicit UI values; else fall back to SKAI_SERVER; else data attribute.
    var wUI  = (function(){
      var el = document.getElementById('windowSize_ui') || document.getElementById('windowSize');
      var v  = el ? parseInt(el.value, 10) : NaN;
      // CHG: ES5-safe finite guard
      return isFinite(v) && v > 0 ? v : NaN;
    })();
    var wBadge = (function(){
      var a = document.documentElement.getAttribute('data-skai-window');
      var v = a ? parseInt(a,10) : NaN;
      // CHG: ES5-safe finite guard
      return isFinite(v) && v > 0 ? v : NaN;
    })();
    var tunedW = isFinite(wUI) ? wUI
               : (isFinite(+((window.SKAI_SERVER||{}).tunedWindow))  ? +window.SKAI_SERVER.tunedWindow
               :  isFinite(+((window.SKAI_SERVER||{}).bestWindow))   ? +window.SKAI_SERVER.bestWindow
               :  isFinite(+((window.SKAI_SERVER||{}).usedWindow))   ? +window.SKAI_SERVER.usedWindow
               :  isFinite(wBadge) ? wBadge : NaN);

    // Synchronize all common places if we have a window value
    // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
    if (isFinite(tunedW) && tunedW > 0){
      try {
        window.SKAI_SERVER.usedWindow  = tunedW;
        window.SKAI_SERVER.bestWindow  = tunedW;
        window.SKAI_SERVER.tunedWindow = tunedW;
        document.documentElement.setAttribute('data-skai-window', String(tunedW));
      } catch(_){}
    }
  } catch(_){ /* fail-safe */ }

  // Resolve runner when ready (prefers whenRunnerReady)
  var useWhen = (typeof window.whenRunnerReady === 'function');

  var runOnce = function(fn){
    if (typeof fn !== 'function') throw new Error('Runner not ready');
    fn();
  };

  var onFail = function(err){
    try { console.warn('[SKAI] start failed:', err); } catch(_){}
    try { typeof window.setLive === 'function' && window.setLive('Runner not ready'); } catch(_){}
    // unlock safely
    try { window.__SKAI_RUNNING__ = false; } catch(_) {}
    try {
      document.documentElement.classList.remove('__skai-running');
      var root = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
      if (root) root.classList.remove('is-busy');
    } catch(_) {}
    try { window.SKAI_setBusy && window.SKAI_setBusy(false); } catch(_){}
  };

  if (useWhen) {
    window.whenRunnerReady(15000).then(function(fn){ runOnce(fn); }).catch(onFail);
  } else {
    var fn = (typeof window.SKAI_getRunner === 'function')
      ? (function(){ try { return window.SKAI_getRunner(); } catch(_) { return null; } })()
      : (window.SKAI_startPredictionFlow || window.runSkaiML || window.SKAI_run || window.runSkaiClientOnce || window.startSkaiML || null);
    try { runOnce(fn); } catch (err) { onFail(err); }
  }
}

  // --- wire once -------------------------------------------------------------
function wireOnce(){
  if (window.__SKAI_RUN_WIRED__) return;
  window.__SKAI_RUN_WIRED__ = true;

  // Ensure all run buttons are enabled and wired to start immediately
  findRunButtons().forEach(function(b){
      if (b.dataset.skaiRunWired === '1') return;
      b.dataset.skaiRunWired = '1';
      // enable without ARIA side effects (no setBtnState call here)
      b.disabled = false;
      try { b.classList.add('skai-btn--ready'); } catch(_){}
      b.addEventListener('click', handleClick);
    });

    // Announce ready state once wired
    try { if (typeof window.setLive === 'function') window.setLive('Ready to run'); } catch(_){}
  }

  // Keep buttons enabled across lifecycle events (no checkbox gate)
  function ensureButtonsEnabled(){
    try {
      findRunButtons().forEach(function(b){
        // enable without ARIA side effects (no setBtnState call here)
        b.disabled = false;
        try { b.classList.add('skai-btn--ready'); } catch(_){}
      });
      if (typeof window.setLive === 'function') window.setLive('Ready to run');
    } catch(_){}
  }

  window.addEventListener('skai:data:ready',        ensureButtonsEnabled);
  window.addEventListener('skai:data:insufficient', ensureButtonsEnabled);
  window.addEventListener('skai:autotune:result',   ensureButtonsEnabled);
  // removed: 'skai:ml:start' to avoid fighting spinner/busy disable policy
  window.addEventListener('skai:ml:done',           ensureButtonsEnabled);
  window.addEventListener('skai:analysis-stop',     ensureButtonsEnabled);

  // If settings inputs change, keep the buttons enabled (no gating)
  document.addEventListener('input', function(e){
    if (!e || !e.target) return;
    if (e.target.matches('#windowSize_ui,#epochs_ui,#batchSize_ui,#dropout_ui,#learningRate_ui,#recencyDecay_ui,#blendRatio_ui,#gapScale_ui')) {
      ensureButtonsEnabled();
    }
  }, true);

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', function(){ setTimeout(wireOnce,120); }, { once:true });
  } else {
    setTimeout(wireOnce,120);
  }
})();
</script>

<script>
;(function(){
  'use strict';
  var btn = document.getElementById('btnOptimize') || document.querySelector('[data-skai-optimize]');
  if (!btn) return;
  if (btn.dataset.skaiOptWired === '1') return;
  btn.dataset.skaiOptWired = '1';

  btn.addEventListener('click', function(){
    try { (window.setLive || function(){})(); } catch(_){}
 try { (window.setLive || function(){})('Optimizing (Skip & Hit)-'); } catch(_){}
    // Safe CustomEvent dispatch (works even on older engines)
    try {
      var CE = (typeof window.CustomEvent === 'function')
        ? window.CustomEvent
        : function(type, params){
            params = params || { bubbles:false, cancelable:false, detail:null };
            var ev = document.createEvent('CustomEvent');
            ev.initCustomEvent(type, !!params.bubbles, !!params.cancelable, params.detail);
            return ev;
          };
      window.dispatchEvent(new CE('skai:autotune:start', { detail: { source:'optimize-button' } }));
    } catch(_){}

    // Read Laplace K from UI (supports #laplaceK_ui or #laplaceK); clamp to {0,1,2}; default=1
    var kEl = document.getElementById('laplaceK_ui') || document.getElementById('laplaceK');
    var k   = (kEl && isFinite(+kEl.value)) ? (+kEl.value|0) : 1;
    if (k < 0) k = 0;
    if (k > 2) k = 2;
try {
      var prevS = window.SKAI_SERVER || {};
      var S = window.SKAI_SERVER = {};
      for (var kk in prevS){ if (Object.prototype.hasOwnProperty.call(prevS, kk)) S[kk] = prevS[kk]; }
      S.laplaceK = k;
    } catch(_){}
    // Canonical path: use ensureAutoTune -> window.runAutoTune (scoreWindow(W))
    if (typeof window.ensureAutoTune === 'function') {
      // Force a fresh auto-tune whenever the user clicks "Optimize"
      window.ensureAutoTune(true).catch(function(){
        // Errors are surfaced via existing HUD / status handlers
      });
    } else if (typeof window.runAutoTune === 'function') {
      // Fallback: call runAutoTune directly if ensureAutoTune is not available
      try {
        var p = window.runAutoTune();
        if (p && typeof p.then === 'function') {
          p.catch(function(){
            // Errors are surfaced via existing HUD / status handlers
          });
        }
      } catch (_){}
    }
  });
})();
</script>

<script>
/* ==========================================================
   SKAI Runner/Optimizer Block 7: Auto-Tune / Grid Optimizer Engine
   Purpose:
     - Runs grid/auto-tune search across parameter combos
     - Scores combos via backtest weights (main*5 + bonus*2 or spec)
     - Publishes best combo + progress state
   Depends on:
     - window.SKAI_SERVER / SKAI_CONFIG (rules, weights)
     - window.__le_lastFiltered or draw history globals
     - Current UI inputs (windowSize, burnIn, K, decay, etc.)
   Exposes (globals):
     - window.SKAI_FLAGS.autotuneRunning / autotuneDone / autotunePct
     - window.__SKAI_AUTOTUNE_DONE__ (gatekeeper reads this)
     - window.skaiApplyBestCombo() (if defined inside)
   Notes:
     - This is the Pick-5 -hang hotspot- zone.
     - Leave order and loop timing unchanged.
   ========================================================== */
   
   /* === EXTRA BALL ENGINE (NOTE: Actual runner is now exposed as window.SKAI_runExtra, defined earlier) === */
   /* Event listeners for extra ball progress are set up in the progress bar section */
   
;(function(){
  'use strict';

  // ====== CONFIG ======
  // Use existing SKAI_LIMITS.maxTuneWindows if set; else default to 50
  var LIM = (window.SKAI_LIMITS = window.SKAI_LIMITS || {});

  // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
  if (!isFinite(+LIM.maxTuneWindows)) LIM.maxTuneWindows = 50;

  // Re-entrancy + progress state for autotune
  var FLAGS = (window.SKAI_FLAGS = window.SKAI_FLAGS || {});
  if (typeof FLAGS.autotuneRunning !== 'boolean') FLAGS.autotuneRunning = false;
  if (typeof FLAGS.autotuneDone !== 'boolean') FLAGS.autotuneDone = false;
  // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
  if (!isFinite(+FLAGS.autotunePct)) FLAGS.autotunePct = 0;

  // Weighting from your Skip & Hit spec (prefer SKAI_CONFIG.scoring; fallback to .weights; else defaults)
  function readWeights(){
    try {
      var cfg = window.SKAI_CONFIG || window.__le_gameConfig || {};
      // Preferred: cfg.scoring.{main,bonus}
      // CHG: ES5-safe finite guard (Number.isFinite -> isFinite)
      if (cfg && cfg.scoring && isFinite(+cfg.scoring.main) && isFinite(+cfg.scoring.bonus)) {
        return { main: +cfg.scoring.main, bonus: +cfg.scoring.bonus };
      }
      // Fallback (legacy): cfg.weights.{main,bonus}
      if (cfg && cfg.weights && isFinite(+cfg.weights.main) && isFinite(+cfg.weights.bonus)) {
        return { main: +cfg.weights.main, bonus: +cfg.weights.bonus };
      }
    } catch(_){}
    return { main: 5, bonus: 2 };
  }

  // ====== DATA ACCESS ======
  function getDraws(){
    var d = Array.isArray(window.__le_lastFiltered) ? window.__le_lastFiltered
          : (Array.isArray(window.draws) ? window.draws : []);
    return Array.isArray(d) ? d : [];
  }

  // Read canonical spec from SKAI_SERVER.CONFIG.lotteryConfig (PHP-normalized), fall back to SKAI_CONFIG
  function getSkaiSpec(){
    var S = (window.SKAI_SERVER && window.SKAI_SERVER.CONFIG && window.SKAI_SERVER.CONFIG.lotteryConfig)
            ? window.SKAI_SERVER.CONFIG.lotteryConfig
            : (window.SKAI_CONFIG && window.SKAI_CONFIG.lotteryConfig)
              ? window.SKAI_CONFIG.lotteryConfig
              : (window.SKAI_CONFIG || {});
    // Normalize keys we care about (the PHP already tried to do this server-side)
    var pickSize = (isFinite(+S.pick_size) && +S.pick_size > 0) ? (+S.pick_size|0)
                 : (isFinite(+S.num_main_balls_drawn) && +S.num_main_balls_drawn > 0) ? (+S.num_main_balls_drawn|0)
                 : 0;

    var extraCount = (isFinite(+S.extra_ball_count) && +S.extra_ball_count >= 0) ? (+S.extra_ball_count|0)
                   : (isFinite(+S.num_extra_balls_drawn) && +S.num_extra_balls_drawn >= 0) ? (+S.num_extra_balls_drawn|0)
                   : 0;

    var mainMax = (isFinite(+S.main_ball_max) && +S.main_ball_max > 0) ? (+S.main_ball_max|0)
                : (isFinite(+S.max_main_ball_number) && +S.max_main_ball_number > 0) ? (+S.max_main_ball_number|0)
                : 0;

var extraMax = (isFinite(+S.extra_ball_max) && +S.extra_ball_max > 0) ? (+S.extra_ball_max|0)
             : (isFinite(+S.max_extra_ball_number) && +S.max_extra_ball_number > 0) ? (+S.max_extra_ball_number|0)
             : 0;

// Explicit flag wins. Only fall back to extraMax>0 when no flag is present.
var hasExtraFlag = null;
if (Object.prototype.hasOwnProperty.call(S, 'has_extra_ball')) {
  hasExtraFlag = !!S.has_extra_ball;
} else if (Object.prototype.hasOwnProperty.call(S, 'hasExtraBall')) {
  hasExtraFlag = !!S.hasExtraBall;
}
var hasExtra = (hasExtraFlag !== null) ? hasExtraFlag : (extraMax > 0);

return {
  main_ball_columns:  Array.isArray(S.main_ball_columns) ? S.main_ball_columns.slice() : [],
  extra_ball_columns: Array.isArray(S.extra_ball_columns) ? S.extra_ball_columns.slice() : [],
  pick_size:          pickSize,
  extra_ball_count:   extraCount,
  main_ball_max:      mainMax,
  extra_ball_max:     extraMax,
  has_extra_ball:     hasExtra,
  // LottoExpert rule: exclude 0 except for daily games (domain = 9)
  allowZeroMain:      (+(mainMax || 0) <= 9),
  allowZeroExtra:     (+(extraMax || 0) <= 9)
};
  }

  // Normalize a draw record ? { main:[...], bonus:[...] } using canonical DB column lists
  function splitBalls(row){
    if (!row) return { main:[], bonus:[] };

    var spec = getSkaiSpec();
    var allowZeroMain  = !!spec.allowZeroMain;
    var allowZeroExtra = !!spec.allowZeroExtra;

    // 1) MAIN from structured "numbers" arrays (SKAI ML history) or configured main_ball_columns
    var outM = [];

    // 1a) SKAI ML format: row = { numbers:[...], date:"..." }
    if (Array.isArray(row.numbers) && row.numbers.length) {
      for (var n = 0; n < row.numbers.length; n++) {
        var mv = row.numbers[n];
        var v  = isFinite(+mv) ? (+mv | 0) : NaN;
        if (!isFinite(v)) continue;
        if (!allowZeroMain && v === 0) continue;   // project rule
        if (v < 0) continue;
        outM.push(v);
      }
    }

    // 1b) MAIN from configured main_ball_columns (DB-style rows)
    if (Array.isArray(spec.main_ball_columns) && spec.main_ball_columns.length){
      for (var i=0;i<spec.main_ball_columns.length;i++){
        var col = spec.main_ball_columns[i];
        if (!col || !Object.prototype.hasOwnProperty.call(row, col)) continue;
        var raw = (row[col] != null) ? String(row[col]).trim() : '';
        if (raw === '') continue;
        var m = raw.match(/\d+/);
        var v2 = m ? parseInt(m[0], 10) : NaN;
        if (!isFinite(v2)) continue;
        if (!allowZeroMain && v2 === 0) continue;
        if (v2 < 0) continue;
        outM.push(v2);
      }
    }

    // 2) BONUS from configured extra_ball_columns
    var outB = [];
    if (spec.has_extra_ball && Array.isArray(spec.extra_ball_columns) && spec.extra_ball_columns.length){
      for (var j=0;j<spec.extra_ball_columns.length;j++){
        var bcol = spec.extra_ball_columns[j];
        if (!bcol || !Object.prototype.hasOwnProperty.call(row, bcol)) continue;
        var braw = (row[bcol] != null) ? String(row[bcol]).trim() : '';
        if (braw === '') continue;
        var bm = braw.match(/\d+/);
        var bv = bm ? parseInt(bm[0], 10) : NaN;
        if (!isFinite(bv)) continue;
        if (!allowZeroExtra && bv === 0) continue;
        if (bv < 0) continue;
        outB.push(bv);
      }
    }

    // 3) Fallbacks - only if config lists were empty.
    if (!outM.length){
      // SECURITY NOTE: The following atypical spellings (e.g., "nineth", "twelveth", "thirtheenth")
      // are intentional and MUST remain as-is. They act as canaries/honeytokens matching the
      // obfuscated column aliases in the DB layer. Do not "correct" them.
      var names = ['first','second','third','fourth','fifth','sixth','seventh','eighth','nineth','tenth',
       'eleventh','twelveth','thirtheenth','fourteenth','fifteenth','sixteenth','seventeenth',
       'eighteenth','nineteenth','twentieth','twenty_first','twenty_second','twenty_third',
       'twenty_fourth','twenty_fifth'];
      names.forEach(function(k){
        if (row && row[k] != null && row[k] !== '') {
          var v3 = parseInt(row[k],10);
          if (!isFinite(v3)) return;
          if (!allowZeroMain && v3 === 0) return;
          if (v3 >= 0) outM.push(v3);
        }
      });
    }
    if (!outB.length && spec.has_extra_ball){
      ['extra','bonus','powerball','mega_ball','star1','star2','extra1','extra2'].forEach(function(k){
        if (row && row[k] != null && row[k] !== '') {
          var v4 = parseInt(row[k],10);
          if (!isFinite(v4)) return;
          if (!allowZeroExtra && v4 === 0) return;
          if (v4 >= 0) outB.push(v4);
        }
      });
    }

    // 4) ML history fallback for extras by date
    if (!outB.length && spec.has_extra_ball && row && row.date) {
      try {
        var extras     = Array.isArray(window.extraDraws) ? window.extraDraws : [];
        var targetDate = String(row.date).slice(0, 10);

        for (var k2 = 0; k2 < extras.length; k2++) {
          var ex = extras[k2];
          if (!ex || !ex.date) { continue; }
          if (String(ex.date).slice(0, 10) !== targetDate) { continue; }
          if (ex.number == null || ex.number === '') { break; }

          var ev = parseInt(ex.number, 10);
          if (!isFinite(ev)) { break; }
          if (!allowZeroExtra && ev === 0) { break; }
          if (ev < 0) { break; }

          outB.push(ev);
          break;
        }
      } catch (_){}
    }

    // Dedupe while preserving order
    function dedupeKeepOrder(arr){
      var seen = Object.create(null), out = [];
      for (var i2=0;i2<arr.length;i2++){
        var val = arr[i2]|0;
        var key = String(val);
        if (!seen[key]) { seen[key] = 1; out.push(val); }
      }
      return out;
    }
    outM = dedupeKeepOrder(outM);
    outB = dedupeKeepOrder(outB);

    // Enforce pick limits
    if (Array.isArray(outM) && spec.pick_size > 0 && outM.length > spec.pick_size) {
      outM = outM.slice(0, spec.pick_size);
    }
    if (Array.isArray(outB) && spec.extra_ball_count >= 0 && outB.length > spec.extra_ball_count) {
      outB = outB.slice(0, spec.extra_ball_count);
    }

    return { main: outM, bonus: outB };
  }


  // ====== SKIP/HIT CORE ======
  // Build per-ball last-seen and skip histograms over a slice of draws [start..end)
  function buildSkipStats(draws, start, end){
    var lastSeen = Object.create(null);   // ball ? last index seen (within slice)
    var histMain = Object.create(null);   // ball ? { skipLen ? count }
    var histBonus= Object.create(null);

    for (var i = start; i < end; i++){
      var rec = splitBalls(draws[i]);
      var main = rec.main || [];
      var bonus = rec.bonus || [];

      // mark hits and record skip lengths for main balls
      for (var mi = 0; mi < main.length; mi++){
        var b = main[mi];
        if (!isFinite(b)) continue;
        if (lastSeen['M'+b] != null) {
          var k = (i - lastSeen['M'+b] - 1) | 0; // misses between hits
          if (k < 0) k = 0;
          var h = (histMain[b] = histMain[b] || Object.create(null));
          h[k] = (h[k] | 0) + 1;
        }
        lastSeen['M'+b] = i;
      }

      // same for bonus balls
      for (var bi = 0; bi < bonus.length; bi++){
        var bb = bonus[bi];
        if (!isFinite(bb)) continue;
        if (lastSeen['B'+bb] != null) {
          var kb = (i - lastSeen['B'+bb] - 1) | 0;
          if (kb < 0) kb = 0;
          var hb = (histBonus[bb] = histBonus[bb] || Object.create(null));
          hb[kb] = (hb[kb] | 0) + 1;
        }
        lastSeen['B'+bb] = i;
      }
    }

    // compute current skips for each ball at end-1 position
    var curIdx = end - 1;
    var currentSkipMain = Object.create(null);
    var currentSkipBonus= Object.create(null);

    Object.keys(lastSeen).forEach(function(key){
      var isMain = (key.charAt(0) === 'M');
      var ball   = parseInt(key.slice(1),10);
      var ls     = lastSeen[key];
      var kNow   = (ls != null) ? ((curIdx - ls) | 0) : null;
      if (kNow != null && kNow >= 0) {
        if (isMain) currentSkipMain[ball]  = kNow;
        else        currentSkipBonus[ball] = kNow;
      }
    });

    return { histMain: histMain, histBonus: histBonus, curMain: currentSkipMain, curBonus: currentSkipBonus };
  }

  // Convert histogram ? probability P(hit | skip=k) for each ball (Laplace smoothing optional)
  function toProbTable(hist, laplaceK){
    // Hazard table:
    //   P(hit next | current skip = s) - (runs ending at s + K) / (runs of length = s + 2K)
    var out = Object.create(null);
    var K = isFinite(+laplaceK) ? +laplaceK : 0; // Laplace smoothing

    Object.keys(hist).forEach(function(ballStr){
      var ball = parseInt(ballStr,10);
      var row  = hist[ballStr] || {};

      // Collect skip lengths numeric & sorted
      var skips = Object.keys(row).map(function(k){
        return parseInt(k,10);
      }).filter(function(v){
        return isFinite(v) && v >= 0;
      });

      if (!skips.length){
        out[ball] = Object.create(null);
        return;
      }

      skips.sort(function(a,b){ return a - b; });

      // Suffix sums
      var suff = new Array(skips.length);
      var running = 0;
      for (var idx = skips.length - 1; idx >= 0; idx--){
        var kk = skips[idx];
        running += (row[kk] | 0);
        suff[idx] = running;
      }

      var probs = Object.create(null);
      for (var i = 0; i < skips.length; i++){
        var s = skips[i];
        var c = row[s] | 0;
        var denom = suff[i];
        if (denom <= 0) continue;
        probs[s] = (c + K) / (denom + 2 * K);
      }

      out[ball] = probs;
    });

    return out;
  }


  // Score a window: expected weighted hits using current skips and P(hit|skip)
  function scoreWindow(draws, w, opt){
    var n = draws.length | 0;
    if (n < 2 || w < 5) return { score: 0, winsMain:0, winsBonus:0, detail:null };

    var start = Math.max(0, n - w);
    var end   = n;

    var stats = buildSkipStats(draws, start, end);
    var Pm    = toProbTable(stats.histMain, (opt && opt.laplaceK) || 0);
    var Pb    = toProbTable(stats.histBonus,(opt && opt.laplaceK) || 0);
    var wt    = readWeights();

    var winsM = 0, winsB = 0;

    // Expected wins = sum over balls of P(hit | current skip)
    Object.keys(stats.curMain).forEach(function(bStr){
      var b = parseInt(bStr,10);
      var k = stats.curMain[b] | 0;
      var row = Pm[b] || null;
      if (row && row.hasOwnProperty(k)) winsM += row[k];
    });
    Object.keys(stats.curBonus).forEach(function(bStr){
      var b = parseInt(bStr,10);
      var k = stats.curBonus[b] | 0;
      var row = Pb[b] || null;
      if (row && row.hasOwnProperty(k)) winsB += row[k];
    });

    var score = (winsM * wt.main) + (winsB * wt.bonus);
    return { score: score, winsMain: winsM, winsBonus: winsB,
             detail: { window:w, weights:wt, curSkipMain:stats.curMain, curSkipBonus:stats.curBonus } };
  }
  
  /* ---------- Helpers for backtest ---------- */
  // Read (main, bonus) pick sizes from canonical spec; fallback to inference from last draw
  function readPickSpec(draws){
    try {
      var S = getSkaiSpec();
      var main  = (isFinite(+S.pick_size) && +S.pick_size > 0) ? (+S.pick_size|0) : 0;
      var bonus = (isFinite(+S.extra_ball_count) && +S.extra_ball_count >= 0) ? (+S.extra_ball_count|0) : 0;
      if (main > 0 || bonus > 0) return { main: main, bonus: bonus }; // CHG
    } catch(_){}
    var last = draws[draws.length - 1];
    var sp   = splitBalls(last);
    return { main: (sp.main||[]).length|0, bonus: (sp.bonus||[]).length|0 };
  }
  // Rank balls by P(hit | current skip=k_now); returns top-K list (unique ints)
function rankByProb(probTable, currentSkips, K){
    K = (isFinite(+K) && +K > 0) ? (+K|0) : 0; // CHG
    if (K === 0) return [];                   // CHG

    var rows = [];
    Object.keys(currentSkips||{}).forEach(function(bStr){
      var b = parseInt(bStr, 10);
      var k = currentSkips[b] | 0;
      var row = probTable[b] || null;
      var p = (row && Object.prototype.hasOwnProperty.call(row, k)) ? row[k] : 0;
      rows.push({ b: b, p: +p });
    });
    rows.sort(function(a,b){ return (b.p - a.p) || (a.b - b.b); });
    var out = [];
    for (var i=0;i<rows.length && out.length<K;i++){
      if (isFinite(rows[i].b)) out.push(rows[i].b|0);
    }
    return out;
  }
  // Backtest a given window W using skip-hazard predictions
  // Scoring rule:
  //   - For each draw t (t >= w), use the previous w draws to build skip stats.
  //   - From those stats, compute hazard P(hit next | skip, ball) via toProbTable.
  //   - Predict Top 20 main numbers and Top 5 extra numbers.
  //   - Count how many of the *actual* mains/extras for draw t are in those lists.
  //   - Aggregate hits across all tested draws and compute an average weighted score.
  function backtestWindow(draws, w, opt){
    opt = opt || {};
    var lapK = isFinite(+opt.laplaceK) ? +opt.laplaceK : 1;

    var HAS_PROMISE = (typeof Promise === 'function'); // CHG: defensive flag

    // Basic sanity
    if (!Array.isArray(draws) || draws.length === 0) {
      var __btEmpty__ = {
        avgScore:   0,
        mainHits:   0,
        bonusHits:  0,
        cases:      0,
        weights:    { main: 5, bonus: 2 },
        pickSpec:   { main: 0, bonus: 0 }
      };
      return HAS_PROMISE
        ? Promise.resolve(__btEmpty__)
        : { then: function(cb){ try { cb(__btEmpty__); } catch(_){} } }; // CHG
    }
    var N    = draws.length | 0;
    var spec = readPickSpec(draws);

    // Default weights
    var wt = { main: 5, bonus: 2 };
    try {
      var S = getSkaiSpec && getSkaiSpec();
      if (S && isFinite(+S.score_main_weight))  wt.main  = +S.score_main_weight;
      if (S && isFinite(+S.score_bonus_weight)) wt.bonus = +S.score_bonus_weight;
    } catch(_){}

   if (!isFinite(+w) || w <= 0 || w >= N) {
      var __btBadW__ = {
        avgScore:   0,
        mainHits:   0,
        bonusHits:  0,
        cases:      0,
        weights:    wt,
        pickSpec:   spec
      };
      return (typeof Promise === 'function')
        ? Promise.resolve(__btBadW__)
        : { then: function(cb){ try { cb(__btBadW__); } catch(_){} } }; // CHG
    }

    var mainHits  = 0;
    var bonusHits = 0;
    var cases     = 0;
    var totalScore = 0;

    // CHG: Promise-safe return for older/late-polyfill environments
    // FIX L-92: remove infinite recursion when Promise is unavailable.
    // In no-Promise environments we return a safe thenable that resolves once with a neutral result.
    if (!HAS_PROMISE) {
      var __btNoPromise__ = {
        then: function(cb){
          try {
            setTimeout(function(){
              try {
                cb({
                  avgScore:  0,
                  mainHits:  0,
                  bonusHits: 0,
                  cases:     0,
                  weights:   wt,
                  pickSpec:  spec
                });
              } catch(_){}
            }, 0);
          } catch(_){}
          return __btNoPromise__;
        }
      };
      return __btNoPromise__;
    }

    // FIX L-93: removed legacy no-Promise fallback block.
    // It was previously inside `if (!HAS_PROMISE)` and depended on __btFallback__.
    // After L-92, it would execute in Promise environments and break backtests.

    return new Promise(function(resolve){
      var t = w;

      function step(){
        if (t >= N) {
          var avgScore = cases ? (totalScore / cases) : 0;
          resolve({
            avgScore:   avgScore,
            mainHits:   mainHits,
            bonusHits:  bonusHits,
            cases:      cases,
            weights:    wt,
            pickSpec:   spec
          });
          return;
        }

        // stats from [t-w, t)
        var stats = buildSkipStats(draws, t - w, t);
        var Pm    = toProbTable(stats.histMain,  lapK);
        var Pb    = toProbTable(stats.histBonus, lapK);

        var pickM = rankByProb(Pm, stats.curMain,  20);
        var pickB = rankByProb(Pb, stats.curBonus, 5);

        var actual = splitBalls(draws[t]) || {};
        var aM = Object.create(null);
        var aB = Object.create(null);

        (actual.main||[]).forEach(function(v){ aM[String(v|0)] = 1; });
        (actual.bonus||[]).forEach(function(v){ aB[String(v|0)] = 1; });

        var hitM = 0;
        for (var i = 0; i < pickM.length; i++){
          if (aM[String(pickM[i]|0)]) hitM++;
        }

        var hitB = 0;
        for (var j = 0; j < pickB.length; j++){
          if (aB[String(pickB[j]|0)]) hitB++;
        }

        mainHits  += hitM;
        bonusHits += hitB;
        cases++;

        totalScore += (hitM * wt.main) + (hitB * wt.bonus);

        t++;
        // Yield to keep UI responsive
        setTimeout(step, 0);
      }

      step();
    });
  } // <-- end backtestWindow



  // Tests windows W = step, 2*step, ?, up to min(fullDB, maxTuneWindows*step) (but also stops at DB length)
  function emitAutotuneProgress(percent, detail){
    try{
      var d = detail || {};
      // Clamp to 0-100 and expose as .percent for the progress bar / ETA listeners
      d.percent = Math.max(0, Math.min(100, +percent || 0));

      // Use SKAI_emit when available; fall back to CustomEvent
      if (typeof window.SKAI_emit === 'function') {
        window.SKAI_emit('skai:autotune:progress', { detail: d });
      } else if (typeof window.CustomEvent === 'function') {
        window.dispatchEvent(new CustomEvent('skai:autotune:progress', { detail: d }));
      }
    }catch(_){}
  }

  function autotuneSkipHit(opts){
    // SKAI: Always allow a fresh Auto-Tune run.
    if (window.SKAI_FLAGS && window.SKAI_FLAGS.autotuneRunning) {
      window.SKAI_FLAGS.autotuneRunning = false;
    }
    if (window.SKAI_FLAGS) {
      window.SKAI_FLAGS.autotuneRunning = true;
      window.SKAI_FLAGS.autotuneDone = false;
      window.SKAI_FLAGS.autotunePct = 0;
    }

    opts = opts || {};
    var step = (isFinite(+opts.step) && +opts.step > 0) ? (+opts.step|0) : 5;
    var lapK = isFinite(+opts.laplaceK) ? +opts.laplaceK : 1;

    /* DUPLICATE helper shadowed the outer emitAutotuneProgress() and can confuse listeners.
       Keeping feature but disabling this inner copy. */
    // function emitAutotuneProgress(percent, detail){ ... }  // <-- legacy inner duplicate disabled

    var draws = getDraws();
    var N = draws.length | 0;
    if (N < Math.max(20, step*2)) {
      try { (window.setLive||function(){})('Not enough data for Auto-Tune'); } catch(_){}
      emitAutotuneProgress(100, { window:null, W:null, total:0, loss:null });
      if (window.SKAI_FLAGS) {
        window.SKAI_FLAGS.autotuneRunning = false;
        window.SKAI_FLAGS.autotuneDone = true;
      }
      return Promise.resolve(null);
    }

    // Candidate windows
    var hardMaxWindow = 20; // numeric window size cannot exceed 20 (comment aligned)
    var rawLimit = (window.SKAI_LIMITS && +window.SKAI_LIMITS.maxTuneWindows) || hardMaxWindow;
    var maxTests = Math.max(1, Math.min(hardMaxWindow, rawLimit));

    var maxW = Math.min(N, hardMaxWindow);
    var W = [];
    var startW = 5;
    if (maxW < startW) { startW = Math.max(1, maxW); }

    for (var w = startW; w <= maxW; w++){
      W.push(w);
      if (W.length >= maxTests) break;
    }
    if (W.length === 0 || W[W.length - 1] < maxW) { W.push(maxW); }

    // ES5 dedupe + sort
    W.sort(function(a,b){ return a-b; });
    var uniq = [];
    for (var ui=0; ui<W.length; ui++){
      if (ui === 0 || W[ui] !== W[ui-1]) uniq.push(W[ui]);
    }
    W = uniq;

    var best = { score: -Infinity, w: step, metric: null };

    // Sequentially backtest each candidate
    var i = 0;
    function next(){
      if (i >= W.length) return finalize();

      var wi = W[i]|0;
      // Progress will be emitted after backtest completes with actual loss value

      return backtestWindow(draws, wi, { laplaceK: lapK }).then(function(bt){

        try {
          console.log('[SKAI][BT]', 'W=' + wi,
            'cases=', bt && bt.cases,
            'mainHits=', bt && bt.mainHits,
            'bonusHits=', bt && bt.bonusHits,
            'avgScore=', bt && bt.avgScore
          );
          
          // Display in math console
          if (window.SKAI_ProgressIndicator && typeof window.SKAI_ProgressIndicator.addMathLine === 'function') {
            window.SKAI_ProgressIndicator.showMathConsole();
            var score = (bt.avgScore != null && isFinite(bt.avgScore)) ? bt.avgScore.toFixed(3) : '0.000';
            var mathLine = 'W=' + wi + ' │ cases=' + (bt.cases || 0) + ' │ mainHits=' + (bt.mainHits || 0) + 
                          ' │ bonusHits=' + (bt.bonusHits || 0) + ' │ score=' + score;
            window.SKAI_ProgressIndicator.addMathLine(mathLine, 'autotune');
          }
        } catch (_){}

        try {
          var mainAvg  = (bt.cases > 0) ? (bt.mainHits  / bt.cases) : 0;
          var bonusAvg = (bt.cases > 0) ? (bt.bonusHits / bt.cases) : 0;
          if (typeof window.CustomEvent === 'function') {
            window.dispatchEvent(new CustomEvent('skai:autotune:candidate', {
              detail:{
                window:   wi,
                avgScore: bt.avgScore,
                mainAvg:  mainAvg,
                bonusAvg: bonusAvg,
                cases:    bt.cases,
                wtMain:   bt.weights && bt.weights.main,
                wtBonus:  bt.weights && bt.weights.bonus,
                pickMain: bt.pickSpec && bt.pickSpec.main,
                pickBonus:bt.pickSpec && bt.pickSpec.bonus
              }
            }));
          }
        } catch(_){}

        // Update progress with actual loss value after backtest completes
        try {
          var raw = ((i + 1) / W.length) * 100;
          var pct = Math.min(99, Math.max(0, Math.floor(raw)));
          // Use negative avgScore as loss (higher score = lower loss)
          var loss = (bt && bt.avgScore != null && isFinite(bt.avgScore)) ? -bt.avgScore : null;
          emitAutotuneProgress(pct, { window: wi, W: wi, index: i+1, total: W.length, loss: loss });
        } catch(_){}

        if (bt.avgScore > best.score) best = { score: bt.avgScore, w: wi, metric: bt };

        i++;
        return new Promise(function(res){ setTimeout(res, 0); }).then(next);
      });
    }

    function finalize(){
      // CHG: harden against unexpected null metric
      if (!best.metric) {
        best.metric = { avgScore:0, cases:0, mainHits:0, bonusHits:0, weights:readWeights(), pickSpec:readPickSpec(draws) };
      }

      var result = {
        windowSize:  best.w,
        tunedWindow: best.w,
        usedWindow:  best.w,
        bestWindow:  best.w,
        __skipHit: {
          mode: 'backtest',
          avgScore: best.metric.avgScore,
          testedCases: best.metric.cases,
          totalMainHits: best.metric.mainHits,
          totalBonusHits: best.metric.bonusHits,
          weights: best.metric.weights,
          pickSpec: best.metric.pickSpec
        }
      };

      try {
        // ES5 merge into SKAI_SERVER (no Object.assign)
        var prevS = window.SKAI_SERVER || {};
        var S = window.SKAI_SERVER = {};
        for (var k in prevS){ if (Object.prototype.hasOwnProperty.call(prevS, k)) S[k] = prevS[k]; }
        S.tunedWindow = S.usedWindow = S.bestWindow = best.w;

        if (typeof window.CustomEvent === 'function') {
          window.dispatchEvent(new CustomEvent('skai:autotune:result', { detail: { settings: result } }));
        }

        var compat = {
          W: best.w,
          bestWWW: best.w,
          best: { W: best.w },
          table: [{
            WWW: best.w,
            n:   best.metric.cases,
            mean: best.metric.avgScore,
            std:  0
          }]
        };
        window.SKAI_AutoTuneResult = compat;
        if (typeof window.CustomEvent === 'function') {
          window.dispatchEvent(new CustomEvent('skai:autotune:done', { detail: compat }));
        }

        try {
          window.__SKAI_AUTOTUNE_DONE__ = true;
          window.__SKAI_TUNED_WINDOW__  = best.w;
        } catch(_){}

        var wt = best.metric.weights || readWeights();
        var ms = (best.metric.pickSpec && best.metric.pickSpec.main)  || 0;
        var bs = (best.metric.pickSpec && best.metric.pickSpec.bonus) || 0;
        var maxPerDraw = Math.max(1, ms * (wt.main||5) + bs * (wt.bonus||2));
        var pct = Math.max(0, Math.min(100, Math.round((best.metric.avgScore / maxPerDraw) * 100)));

        // Clean status copy (no mojibake)
        (window.setLive||function(){})('Auto-Tune (Skip & Hit) complete (W=' + best.w + ') - starting training...');

        if (typeof window.CustomEvent === 'function') {
          window.dispatchEvent(new CustomEvent('skai:confidence', { detail:{ value: pct } }));
        }

        try { if (typeof applyBestWindowToUI === 'function') applyBestWindowToUI(best.w); } catch(_){}
        
        // === RESTORE EXTRA BALL PHASE ===
        // Run extra ball ML after main ML completes, without double-starting main ML.
        try { 
            var spec = (window.SKAI_CONFIG && window.SKAI_CONFIG.lotteryConfig) || {};
            var hasExtra = !!(+spec.extra_ball_count > 0);

            // Helper: Try to start extra ball ML (one-shot)
            function tryStartExtraBall(){
                try {
                    if (window.__SKAI_EXTRA_STARTED__ === true) return; // CHG: one-shot guard
                    window.__SKAI_EXTRA_STARTED__ = true;

                    if (typeof window.SKAI_runExtra === 'function') {
                        window.SKAI_runExtra();
                    } else if (typeof window.runExtraBallML === 'function') {
                        window.runExtraBallML();
                    }
                } catch(_){}
            }

            // CHG: Avoid double-starting main ML here.
            // Main ML is already auto-started by the skai:autotune:result bridge earlier in this file.
            var autoStartLocked = !!(window.__SKAI_AUTOSTART_LOCK__ === true);
            var alreadyRunning  = !!(window.__SKAI_RUNNING__ === true);

            if (!autoStartLocked && !alreadyRunning && typeof window.SKAI_start === 'function') {
                // If for some reason the bridge is not present on a variant page, start main ML once.
                var mainPromise = window.SKAI_start();

                if (hasExtra && mainPromise && typeof mainPromise.then === 'function') {
                    mainPromise.then(function(){
                        tryStartExtraBall();
                    }).catch(function(err){
                        try { console.error('[SKAI] Main ML failed, skipping extra ball:', err); } catch(_){}
                    });
                } else if (hasExtra) {
                    var fallbackDelay = (window.SKAI_SETTINGS && window.SKAI_SETTINGS.extraFallbackDelay) || 2000;
                    setTimeout(tryStartExtraBall, fallbackDelay);
                }
            } else if (hasExtra) {
                // CHG: Normal path: wait for main ML completion event, then start extra.
                try {
                    window.addEventListener('skai:ml:done', function(){
                        tryStartExtraBall();
                    }, { once:true });
                } catch(_){
                    // ES5 fallback if {once:true} not supported
                    var _once = function(){
                        try { window.removeEventListener('skai:ml:done', _once, false); } catch(_){}
                        tryStartExtraBall();
                    };
                    window.addEventListener('skai:ml:done', _once, false);
                }
            }
        } catch(_){}
      } catch(_){}

      emitAutotuneProgress(100, { window: best.w, index: null, total: null });
      if (window.SKAI_FLAGS) { window.SKAI_FLAGS.autotuneRunning = false; window.SKAI_FLAGS.autotuneDone = true; }

      return result;
    }

    return next();
  } // <-- close function autotuneSkipHit

  // Expose public API
if (typeof window.SKAI_autotuneBySkipHit !== 'function') {
    window.SKAI_autotuneBySkipHit = function(options){ return autotuneSkipHit(options||{}); };
  }

  // Bridge generic Auto-Tune entry points to the Skip & Hit tuner
  // so older callers (SKAI_autoTuneStart / SKAI_autotune / SKAI_autoTune) all work.
  if (typeof window.SKAI_autotuneStart !== 'function') {
    window.SKAI_autotuneStart = function () {
      // If Auto-Tune is already running, do NOT start another run.
           if (window.SKAI_FLAGS && window.SKAI_FLAGS.autotuneRunning) {
        // If Promise isn't available, just return null (keeps legacy contract).
        try { return window.SKAI_autotunePromise || (window.Promise ? Promise.resolve(null) : null); }
        catch(_) { return null; }
      }


      window.SKAI_FLAGS = window.SKAI_FLAGS || {};
      window.SKAI_FLAGS.autotuneRunning = true;
      window.SKAI_FLAGS.autotuneDone = false;

      // Notify UI that Auto-Tune is starting (once)
      try {
        if (window.SKAI_AUTOTUNE && typeof window.SKAI_AUTOTUNE.emitStart === 'function') {
          var maxW =
            (window.SKAI_LIMITS && +window.SKAI_LIMITS.effectiveMaxWindow) ||
            (window.SKAI_SERVER && +window.SKAI_SERVER.rowsAvailable) ||
            0;
          window.SKAI_AUTOTUNE.emitStart(maxW);
        } else if (typeof window.SKAI_emit === 'function') {
          window.SKAI_emit('skai:autotune:begin', {});
        } else if (typeof window.CustomEvent === 'function') {
          window.dispatchEvent(new CustomEvent('skai:autotune:begin', { bubbles: true, detail: {} }));
        }
      } catch (_) {}

      var p;
      try {
        // Use the real Skip & Hit tuner
        p = autotuneSkipHit({});
      } catch (e) {
        window.SKAI_FLAGS.autotuneRunning = false;
        throw e;
      }

      if (p && typeof p.then === 'function') {
        window.SKAI_autotunePromise = p.then(function (result) {
          window.SKAI_FLAGS.autotuneRunning = false;
          window.SKAI_FLAGS.autotuneDone = true;
          return result;
        }).catch(function (err) {
          window.SKAI_FLAGS.autotuneRunning = false;
          throw err;
        });
      } else {
        window.SKAI_FLAGS.autotuneRunning = false;
        window.SKAI_FLAGS.autotuneDone = true;
        window.SKAI_autotunePromise = (window.Promise ? Promise.resolve(p) : p);
      }

      return window.SKAI_autotunePromise;
    };
  }
  // Back-compat aliases so any caller name will reach the same tuner
  if (typeof window.SKAI_autotune !== 'function') {
    window.SKAI_autotune = window.SKAI_autotuneStart;
  }
  if (typeof window.SKAI_autoTuneStart !== 'function') {
    window.SKAI_autoTuneStart = window.SKAI_autotuneStart;
  }
  if (typeof window.SKAI_autoTune !== 'function') {
    window.SKAI_autoTune = window.SKAI_autotuneStart;
  }

  // ------------------------------------------------------------
  // SKAI_getSkipHitSnapshot: current Skip & Hit ranking snapshot
  // ------------------------------------------------------------
  // Returns:
  //   {
  //     main:  [ { num: <int>, p: <hazardProb> }, ... ],
  //     extra: [ { num: <int>, p: <hazardProb> }, ... ],
  //     spec:      <lottery spec from getSkaiSpec()>,
  //     weights:   <{main,bonus}> from readWeights(),
  //     windowSize:<numeric window actually used>,
  //     laplaceK:  <K used>
  //   }
  //
  // Notes:
  //   - Uses tunedWindow / bestWindow / usedWindow if present in SKAI_SERVER.
  //   - Falls back to a safe window based on data length.
  //   - Does NOT scrape DOM; uses your existing draws[] + Skip & Hit engine.
  function skaiGetLaplaceKFromUIOrServer(defaultK) {
    var k = isFinite(+defaultK) ? +defaultK : 1;
    try {
      if (window.SKAI_SERVER && isFinite(+window.SKAI_SERVER.laplaceK)) {
        k = +window.SKAI_SERVER.laplaceK;
      } else {
        var el = document.getElementById('laplaceK_ui') || document.getElementById('laplaceK');
        if (el && isFinite(+el.value)) {
          k = +el.value;
        }
      }
    } catch (_){}
    if (!isFinite(k)) k = 1;
    if (k < 0) k = 0;
    if (k > 2) k = 2;
    return k;
  }

  function skaiGetSkipHitSnapshot(options){
    options = options || {};

    var draws = getDraws();
    var N     = draws.length | 0;
    var spec  = getSkaiSpec();
    var wt    = readWeights();

    if (N < 5) {
      return {
        main:      [],
        extra:     [],
        spec:      spec,
        weights:   wt,
        windowSize:0,
        laplaceK:  0
      };
    }

    // Determine window W from SKAI_SERVER if possible
    var W = 0;
    try {
      var S = window.SKAI_SERVER || {};
      if (isFinite(+S.tunedWindow) && +S.tunedWindow > 0) {
        W = +S.tunedWindow;
      } else if (isFinite(+S.bestWindow) && +S.bestWindow > 0) {
        W = +S.bestWindow;
      } else if (isFinite(+S.usedWindow) && +S.usedWindow > 0) {
        W = +S.usedWindow;
      }
    } catch (_){}

    if (!isFinite(W) || W <= 0) {
      var fallback = (options.windowSize && isFinite(+options.windowSize)) ? (+options.windowSize|0) : 50;
      W = Math.max(5, Math.min(N, fallback));
    }
    if (W > N) W = N;

    var lapK = isFinite(+options.laplaceK) ? +options.laplaceK : skaiGetLaplaceKFromUIOrServer(1);

    var start = Math.max(0, N - W);
    var end   = N;

    var stats = buildSkipStats(draws, start, end);
    var Pm    = toProbTable(stats.histMain,  lapK);
    var Pb    = toProbTable(stats.histBonus, lapK);

    var mainRows  = [];
    var extraRows = [];
    var key;

    // Main balls
    for (key in stats.curMain) {
      if (!Object.prototype.hasOwnProperty.call(stats.curMain, key)) continue;
      var b  = parseInt(key, 10);
      var ks = stats.curMain[key] | 0;
      var row = Pm[b] || null;
      var p   = (row && Object.prototype.hasOwnProperty.call(row, ks)) ? row[ks] : 0;
      mainRows.push({ num: b, p: +p });
    }

    // Extra balls
    for (key in stats.curBonus) {
      if (!Object.prototype.hasOwnProperty.call(stats.curBonus, key)) continue;
      var bb  = parseInt(key, 10);
      var ks2 = stats.curBonus[key] | 0;
      var rowB = Pb[bb] || null;
      var p2   = (rowB && Object.prototype.hasOwnProperty.call(rowB, ks2)) ? rowB[ks2] : 0;
      extraRows.push({ num: bb, p: +p2 });
    }

    mainRows.sort(function(a,b){ return (b.p - a.p) || (a.num - b.num); });
    extraRows.sort(function(a,b){ return (b.p - a.p) || (a.num - b.num); });

    var topMain  = (isFinite(+options.topMain)  && +options.topMain  > 0) ? (+options.topMain|0)
                   : (spec && spec.pick_size > 0 ? spec.pick_size : 20);
    var topExtra = (isFinite(+options.topExtra) && +options.topExtra > 0) ? (+options.topExtra|0)
                   : (spec && spec.extra_ball_count > 0 ? spec.extra_ball_count : 5);

    if (mainRows.length  > topMain)  mainRows  = mainRows.slice(0, topMain);
    if (extraRows.length > topExtra) extraRows = extraRows.slice(0, topExtra);

    return {
      main:      mainRows,
      extra:     extraRows,
      spec:      spec,
      weights:   wt,
      windowSize:W,
      laplaceK:  lapK
    };
  }

  // Export snapshot helper once
  if (typeof window.SKAI_getSkipHitSnapshot !== 'function') {
    window.SKAI_getSkipHitSnapshot = skaiGetSkipHitSnapshot;
  }

})(); 
</script>

<script>
;(function(){
  'use strict';

  // -----------------------------
  // Probability-based blend core
  // -----------------------------
  function skaiNormalizeSource(list){
    var map = Object.create(null);
    var sum = 0;
    if (!list || !list.length) {
      return { map: map, sum: 0 };
    }

    for (var i = 0; i < list.length; i++){
      var item = list[i];
      if (item == null) continue;

      var num = null;
      var w   = 1;

      if (typeof item === 'object') {
        if (item.num != null) {
          num = item.num;
        } else if (item.number != null) {
          num = item.number;
        } else if (item.n != null) {
          num = item.n;
        }
        if (item.p != null) {
          w = item.p;
        } else if (item.prob != null) {
          w = item.prob;
        } else if (item.weight != null) {
          w = item.weight;
        }
      } else {
        num = item;
      }

      var n = isFinite(+num) ? (+num | 0) : NaN;
      var ww = isFinite(+w) ? +w : 0;
      if (!isFinite(n) || ww <= 0) continue;

      var key = String(n);
      if (!map[key]) map[key] = 0;
      map[key] += ww;
      sum += ww;
    }

    return { map: map, sum: sum };
  }

  function skaiExtractTopFromMap(map, sum, outCount){
    var rows = [];
    var key;
    for (key in map){
      if (!Object.prototype.hasOwnProperty.call(map, key)) continue;
      var prob = (sum > 0) ? (map[key] / sum) : 0;
      rows.push({ num: parseInt(key,10), p: prob });
    }

    rows.sort(function(a,b){
      return (b.p - a.p) || (a.num - b.num);
    });

    var limit = (isFinite(+outCount) && +outCount > 0) ? (+outCount|0) : rows.length;
    var out   = [];
    for (var i = 0; i < rows.length && out.length < limit; i++){
      out.push(rows[i].num);
    }
    return out;
  }

  function skaiBlendOneDimension(mlList, skipList, ratio, outCount){
    var lambda = isFinite(+ratio) ? Math.max(0, Math.min(100, +ratio)) / 100 : 0;

    var srcML   = skaiNormalizeSource(mlList);
    var srcSkip = skaiNormalizeSource(skipList);

    // If we only have one side, ignore lambda: pure source
    if (!srcSkip.sum && srcML.sum) {
      return skaiExtractTopFromMap(srcML.map, srcML.sum, outCount);
    }
    if (!srcML.sum && srcSkip.sum) {
      return skaiExtractTopFromMap(srcSkip.map, srcSkip.sum, outCount);
    }
    if (!srcML.sum && !srcSkip.sum) {
      return [];
    }

    var keys = Object.create(null);
    var k;
    for (k in srcML.map){   if (Object.prototype.hasOwnProperty.call(srcML.map,   k)) keys[k] = 1; }
    for (k in srcSkip.map){ if (Object.prototype.hasOwnProperty.call(srcSkip.map, k)) keys[k] = 1; }

    var mlZ   = srcML.sum;
    var skipZ = srcSkip.sum;
    var rows  = [];

    for (k in keys){
      if (!Object.prototype.hasOwnProperty.call(keys, k)) continue;
      var wMl   = srcML.map[k]   || 0;
      var wSkip = srcSkip.map[k] || 0;
      var pMl   = mlZ   > 0 ? (wMl   / mlZ)   : 0;
      var pSkip = skipZ > 0 ? (wSkip / skipZ) : 0;

      var p = (1 - lambda) * pMl + lambda * pSkip;
      rows.push({ num: parseInt(k,10), p: p });
    }

    rows.sort(function(a,b){
      return (b.p - a.p) || (a.num - b.num);
    });

    var limit = (isFinite(+outCount) && +outCount > 0) ? (+outCount|0) : rows.length;
    var out   = [];
    for (var i = 0; i < rows.length && out.length < limit; i++){
      if (rows[i].p <= 0) continue;
      out.push(rows[i].num);
    }

    return out;
  }

  function skaiGetBlendRatio(){
    var r = 0;
    try {
      if (window.SKAI_SERVER && isFinite(+window.SKAI_SERVER.blendRatio)) {
        r = +window.SKAI_SERVER.blendRatio;
      } else {
        var el = document.getElementById('blendRatio_ui') || document.getElementById('blendRatio');
        if (el && isFinite(+el.value)) {
          r = +el.value;
        }
      }
    } catch (_){}
    if (!isFinite(r)) r = 0;
    if (r < 0) r = 0;
    if (r > 100) r = 100;
    return r;
  }

  function SKAI_applyBlendFromGlobals(){
    try {
      var ratio = skaiGetBlendRatio();

      // ratio = 0 → pure ML, do nothing
      if (ratio <= 0) {
        window.__SKAI_BLEND_APPLIED__ = false;
        return;
      }

      // Avoid double-apply on the same run
      if (window.__SKAI_BLEND_APPLIED__) return;

      var mlMain  = window.__SKAI_LAST_PICKS__ || [];
      var mlExtra = window.__SKAI_LAST_EXTRA__ || [];

      // If there is nothing from ML, blending is meaningless
      if ((!mlMain || !mlMain.length) && (!mlExtra || !mlExtra.length)) {
        return;
      }

      var snapshot = (typeof window.SKAI_getSkipHitSnapshot === 'function')
        ? window.SKAI_getSkipHitSnapshot({})
        : null;

      var skipMain  = snapshot && snapshot.main  ? snapshot.main  : [];
      var skipExtra = snapshot && snapshot.extra ? snapshot.extra : [];

      var outMainCount  = mlMain.length ||
        (snapshot && snapshot.spec && snapshot.spec.pick_size) || 0;
      var outExtraCount = mlExtra.length ||
        (snapshot && snapshot.spec && snapshot.spec.extra_ball_count) || 0;

      var blendedMain  = skaiBlendOneDimension(mlMain,  skipMain,  ratio, outMainCount);
      var blendedExtra = skaiBlendOneDimension(mlExtra, skipExtra, ratio, outExtraCount);

      if (blendedMain && blendedMain.length) {
        window.__SKAI_LAST_PICKS__ = blendedMain.slice();
      }
      if (blendedExtra && blendedExtra.length) {
        window.__SKAI_LAST_EXTRA__ = blendedExtra.slice();
      }

      window.__SKAI_BLEND_APPLIED__ = true;

      // Lightweight trace for debugging
      try {
        window.SKAI_BLEND_TRACE = {
          ratio:          ratio,
          outMainCount:   outMainCount,
          outExtraCount:  outExtraCount,
          windowSize:     snapshot && snapshot.windowSize,
          laplaceK:       snapshot && snapshot.laplaceK
        };
      } catch (_){}
    } catch (_){}
  }

  if (typeof window.SKAI_applyBlendFromGlobals !== 'function') {
    window.SKAI_applyBlendFromGlobals = SKAI_applyBlendFromGlobals;
  }

  // Reset flag for each new ML run
  try {
    window.addEventListener('skai:ml:start', function(){
      try { window.__SKAI_BLEND_APPLIED__ = false; } catch(_){}
    }, false);
  } catch (_){}

})();
</script>

<script>
;(function(){
  'use strict';

  // Watchdog-safe wrapper: ensure skai:analysis-stop always has a detail payload
  if (typeof window.SKAI_emit === 'function' && !window.SKAI_emit_wrapped_for_detail) {
    var __origEmit = window.SKAI_emit;

    window.SKAI_emit = function(type, detail){
      // If watchdog or any caller fires a bare analysis-stop, inject a default reason
      if (type === 'skai:analysis-stop' && (detail == null || typeof detail !== 'object')) {
        detail = { reason: 'watchdog' };
      }
      return __origEmit.call(this, type, detail);
    };

    window.SKAI_emit_wrapped_for_detail = true;
  }

  // Floating global SKAI status banner (site-wide, mirrors chip + orb messages)
  (function(){
    var wrapper   = null;
    var pill      = null;
    var textWrap  = null;
    var textMain  = null;
    var textSub   = null;
    var hideTimer = null;

    function ensure(){
      if (wrapper && pill && textWrap && textMain && textSub) {
        return;
      }

      wrapper  = document.getElementById('skai-global-status-wrapper');
      pill     = document.getElementById('skai-global-status');
      textWrap = document.getElementById('skai-global-status-text');

      if (!wrapper || !pill || !textWrap){
        // Create wrapper + pill if they do not yet exist
        wrapper = document.createElement('div');
        wrapper.id = 'skai-global-status-wrapper';

        pill = document.createElement('div');
        pill.id = 'skai-global-status';
        pill.setAttribute('role','status');
        pill.setAttribute('aria-live','polite');

        var dot = document.createElement('span');
        dot.className = 'skai-global-status-dot';
        dot.setAttribute('aria-hidden','true');

        textWrap = document.createElement('span');
        textWrap.id = 'skai-global-status-text';

        textMain = document.createElement('span');
        textMain.className = 'skai-global-status-main';

        textSub  = document.createElement('span');
        textSub.className = 'skai-global-status-sub';

        textWrap.appendChild(textMain);
        textWrap.appendChild(textSub);
        pill.appendChild(dot);
        pill.appendChild(textWrap);
        wrapper.appendChild(pill);

        (document.body || document.documentElement).appendChild(wrapper);
      } else {
        // If the wrapper exists, ensure we have references to the inner spans
        if (!textMain || !textSub){
          textMain = textWrap.querySelector('.skai-global-status-main');
          textSub  = textWrap.querySelector('.skai-global-status-sub');
          if (!textMain){
            textMain = document.createElement('span');
            textMain.className = 'skai-global-status-main';
            textWrap.appendChild(textMain);
          }
          if (!textSub){
            textSub = document.createElement('span');
            textSub.className = 'skai-global-status-sub';
            textWrap.appendChild(textSub);
          }
        }
      }
    }

    function update(text, sub){
      ensure();
      if (!wrapper || !pill || !textWrap || !textMain || !textSub) {
        return;
      }

      var main  = (text != null) ? String(text) : '';
      var extra = (sub  != null) ? String(sub)  : '';

      // If no content at all, hide the pill
      if (!main && !extra){
        pill.style.display = 'none';
        wrapper.setAttribute('aria-hidden','true');
        return;
      }

      // Main line (headline)
      if (main){
        textMain.textContent = main;
        textMain.style.display = 'block';
      } else {
        textMain.textContent = '';
        textMain.style.display = 'none';
      }

      // Sub line (detail)
      if (extra && extra !== main){
        textSub.textContent = extra;
        textSub.style.display = 'block';
      } else {
        textSub.textContent = '';
        textSub.style.display = 'none';
      }

      pill.style.display = 'flex';
      wrapper.setAttribute('aria-hidden','false');

      // Reset any previous hide timer
      if (hideTimer){
        window.clearTimeout(hideTimer);
        hideTimer = null;
      }

      // Auto-hide for terminal states so UI cleans itself up
      var combined = (main || '') + ' ' + (extra || '');
      var lower = combined.toLowerCase();
      if (lower.indexOf('complete') !== -1 ||
          lower.indexOf('ready')    !== -1 ||
          lower.indexOf('stopped')  !== -1 ||
          lower.indexOf('error')    !== -1) {
        hideTimer = window.setTimeout(function(){
          pill.style.display = 'none';
          wrapper.setAttribute('aria-hidden','true');
        }, 4000);
      }
    }

    if (typeof window.SKAI_setGlobalStatus !== 'function'){
      window.SKAI_setGlobalStatus = function(text, sub){
        update(text, sub);
      };
    }
  })();

  // SKAI orb / bubble (same behaviour as before; now it can talk to SKAI_setGlobalStatus)
  var orb        = document.getElementById('skai-progress-orb');
  var statusNode = document.getElementById('skai-progress-orb-status');
  var hideTimeout = null;

  function setVisible(show){
    if (!orb) return;
    orb.style.display = show ? 'flex' : 'none';
  }

  function setStatusText(msg){
    if (!statusNode) return;
    if (typeof msg === 'string' && msg.trim() !== '') {
      statusNode.textContent = msg;
    }
  }

  window.skaiProgress = {
    show: function(msg){
      if (hideTimeout){
        window.clearTimeout(hideTimeout);
        hideTimeout = null;
      }
      var message = msg || 'SKAI is analyzing your draw history...';
      setStatusText(message);
      setVisible(true);

      // Mirror orb status into the floating banner
      if (typeof window.SKAI_setGlobalStatus === 'function'){
        window.SKAI_setGlobalStatus('SKAI is working on this analysis', message);
      }
    },
    setStatus: function(msg){
      setStatusText(msg);
      // Keep the banner detail line in sync with incremental updates
      if (typeof window.SKAI_setGlobalStatus === 'function'){
        window.SKAI_setGlobalStatus(null, msg);
      }
    },
    done: function(msg){
      var finalMsg = msg || 'Analysis complete';
      setStatusText(finalMsg);

      // Final message also surfaced in the global banner
      if (typeof window.SKAI_setGlobalStatus === 'function'){
        window.SKAI_setGlobalStatus('Analysis complete', finalMsg);
      }

      // small delay so user can see the final message
      hideTimeout = window.setTimeout(function(){
        setVisible(false);
      }, 800);
    }
  };

})();
</script>
<script>
;(function(){
  'use strict';

  document.addEventListener('DOMContentLoaded', function(){
    try {
      // The SKAI story section with "Todays SKAI analysis for ..."
      var story  = document.querySelector('.skai-story');
      // The main SKAI Prediction Center panel
      var target = document.getElementById('skai-ai-panel');

      if (!story || !target || !target.parentNode) return;

      var parent = target.parentNode;

       // Only move if the story currently sits *after* the panel (or far below)
      // so we don't accidentally reorder if you've already placed it up top.
      var FOLLOWING = (typeof Node !== 'undefined' && Node.DOCUMENT_POSITION_FOLLOWING)
        ? Node.DOCUMENT_POSITION_FOLLOWING
        : 4; // ES5-safe fallback for old browsers
      if ((story.compareDocumentPosition(target) & FOLLOWING) === FOLLOWING) {
        parent.insertBefore(story, target); // move story just above the panel
      }

    } catch (_){}
  });
})();
</script>

<script>
;(function(){
  'use strict';

  // SKAI: Hard-disable the legacy "classic" Auto-Tune function.
  // Any call to window.runAutoTune will now be routed to the Skip & Hit tuner.
  try {
     window.runAutoTune = function () {
      // Prefer canonical Skip & Hit entrypoint if available
      if (typeof window.SKAI_autotuneStart === 'function') {
        return window.SKAI_autotuneStart();
      }
      if (typeof window.SKAI_autotuneBySkipHit === 'function') {
        return window.SKAI_autotuneBySkipHit({});
      }
      // Final fallback: keep contract if Promise exists
      try { return window.Promise ? Promise.resolve(null) : null; } catch(_) { return null; }
    };
  } catch (_){}
})();
</script>
<script>
(function(){
  'use strict';

  function closeAlert(el){
    try{
      el.style.transition = 'opacity .35s ease, transform .35s ease';
      el.style.opacity = '0';
      el.style.transform = 'translateY(6px)';
      setTimeout(function(){
        if (el && el.parentNode) el.parentNode.removeChild(el);
      }, 450);
    }catch(_){}
  }

  function sweep(){
    // Joomla 4/5 typical containers:
    var containers = document.querySelectorAll(
      '.joomla-alert, .alert, .alert-message, .system-message, ' +
      '#system-message-container .alert, #system-message-container .joomla-alert'
    );
    if (!containers || !containers.length) return;

    for (var i=0;i<containers.length;i++){
      (function(el){
        // only auto-hide success/info, leave errors visible longer
        var cls = el.className || '';
        var isError = /alert-danger|danger|error/i.test(cls);
        var delay = isError ? 9000 : 3500;
        setTimeout(function(){ closeAlert(el); }, delay);
      })(containers[i]);
    }
  }

  if (document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', sweep);
  } else {
    sweep();
  }

   // also sweep again shortly after redirects finish rendering
  setTimeout(sweep, 800);
})();
</script>

<script>
/* =====================================================================
   SKAI Production Repairs – Renderer + Progress + Run-Gate Normalizer
   Scope:
     - Fix missing main / extra picks rendering when scoring succeeded
     - Normalize UX state across bar, orb, and global banner
     - Reset run cooldown so Run button doesn’t get stuck
     - Add conservative watchdog so progress doesn’t freeze at mid %
   NOTE:
     - ES5 only (no arrow functions / Number.isFinite / Object.assign)
     - All calls are guarded with try/catch so nothing can hard-break.
   ===================================================================== */
;(function(){
  'use strict';

  /* ------------------------ 1) Progress API helper ------------------------ */

  function getProgressAPI(){
    var P = null;
    try {
      if (typeof window.SKAI_getProgress === 'function') {
        P = window.SKAI_getProgress();
      } else if (typeof window.ensureProgressAPI === 'function') {
        P = window.ensureProgressAPI();
      } else if (window.SKAI_Progress) {
        P = window.SKAI_Progress;
      }
    } catch (_){}

    if (!P) {
      P = {
        show: function(){},
        set:  function(){},
        done: function(){}
      };
    }
    return P;
  }

  /* ---------------------- 2) Unified UX state helper ---------------------- */

  function SKAI_updateUXState(state){
    try {
      state = state || {};
      var phase  = state.phase  || '';
      var msg    = state.message || '';
      var detail = state.detail || '';
      var P      = getProgressAPI();

      // Normalize bar behavior
      try {
        if (phase === 'idle') {
          P.show('Idle');
          P.set(0, 'Idle');
        } else if (phase === 'autotune') {
          P.show(msg || 'Auto-Tune');
        } else if (phase === 'training') {
          P.show(msg || 'Training model');
        } else if (phase === 'complete') {
          P.set(100, msg || 'Done');
          P.show(detail || 'Picks ready');
          try {
            if (window.skaiProgress && typeof window.skaiProgress.done === 'function') {
              window.skaiProgress.done(detail || msg || 'Analysis complete');
            }
          } catch (_){}
        } else if (phase === 'error') {
          P.set(100, msg || 'Error');
          if (P.done) P.done(msg || 'Error');
        }
      } catch (_){}

      // Global floating banner
      try {
        if (typeof window.SKAI_setGlobalStatus === 'function') {
          var main = msg || null;
          var sub  = detail || null;
          if (!main && phase === 'idle') main = 'Idle';
          window.SKAI_setGlobalStatus(main, sub);
        }
      } catch (_){}

      // Orb (only mirror key transitions, do not fight existing logic)
      try {
        if (phase === 'training') {
          if (window.skaiProgress && typeof window.skaiProgress.show === 'function') {
            window.skaiProgress.show(detail || msg || 'SKAI is analyzing your draw history...');
          }
        } else if (phase === 'idle') {
          if (window.skaiProgress && typeof window.skaiProgress.done === 'function') {
            window.skaiProgress.done('Idle');
          }
        }
      } catch (_){}
    } catch (_){}
  }

  // Export if not already provided
  if (typeof window.SKAI_updateUXState !== 'function') {
    window.SKAI_updateUXState = SKAI_updateUXState;
  }

  /* ---------------------- 3) Run-gate reset helpers ----------------------- */

  function resetRunCooldown(){
    try { window.__SKAI_RUNNING__ = false; } catch(_){}
    try { window.__SKAI_START_COOLDOWN__ = false; } catch(_){}
    try {
      if (typeof window.SKAI_setBusy === 'function') {
        window.SKAI_setBusy(false);
      }
    } catch(_){}
    try {
      document.documentElement.classList.remove('__skai-running');
      var root = document.getElementById('skai-root') || document.querySelector('[data-skai-root]');
      if (root && root.classList) root.classList.remove('is-busy');
    } catch(_){}
  }

  /* -------------------- 4) Renderer repair (main / extra) ----------------- */

  function dedupeAndSortInts(list){
    var seen = Object.create(null);
    var out  = [];
    if (!list || !list.length) return out;
    for (var i = 0; i < list.length; i++){
      var v = list[i];
      var n = isFinite(+v) ? (+v | 0) : NaN;
      if (!isFinite(n)) continue;
      var key = String(n);
      if (!seen[key]) {
        seen[key] = 1;
        out.push(n);
      }
    }
    out.sort(function(a,b){ return a - b; });
    return out;
  }

  function ensureMainRendered(){
    try {
      // Main container – this already exists in your SKAI layout
      var mainWrap = document.querySelector('.skai-ai-main');
      if (!mainWrap) return;

      // If there are already nball elements, do not touch anything
      var existing = mainWrap.querySelectorAll('.nball');
      if (existing && existing.length) return;

      // Use the captured top picks from scoring
      var picksSrc = [];
      try {
        if (window.__SKAI_LAST_PICKS__ && window.__SKAI_LAST_PICKS__.length) {
          for (var i = 0; i < window.__SKAI_LAST_PICKS__.length; i++){
            picksSrc.push(window.__SKAI_LAST_PICKS__[i]);
          }
        }
      } catch (_){}

      var nums = dedupeAndSortInts(picksSrc);
      if (!nums.length) return;

      // Create a dedicated picks row so we don't break headings/tooltips
      var row = document.createElement('div');
      row.className = 'skai-ai-main-picks';

      for (var j = 0; j < nums.length; j++){
        var span = document.createElement('span');
        span.className = 'nball';
        var v = nums[j];
        span.textContent = (v < 10 ? '0' + v : String(v));
        row.appendChild(span);
      }

      mainWrap.appendChild(row);
    } catch (_){}
  }

  function ensureExtraRendered(){
    try {
      var extraWrap = document.getElementById('aiExtraPredictionContainer');
      if (!extraWrap) return;

      var existing = extraWrap.querySelectorAll('.xball');
      if (existing && existing.length) return;

      // Try a few known globals that might hold extra picks
      var extraSrc = [];
      try {
        if (window.__SKAI_LAST_EXTRA__ && window.__SKAI_LAST_EXTRA__.length) {
          extraSrc = window.__SKAI_LAST_EXTRA__;
        } else if (window.SKAI_LAST_EXTRA && window.SKAI_LAST_EXTRA.length) {
          extraSrc = window.SKAI_LAST_EXTRA;
        }
      } catch (_){}

      var nums = dedupeAndSortInts(extraSrc);
      if (!nums.length) return;

      var row = document.createElement('div');
      row.className = 'skai-ai-extra-picks';

      for (var i = 0; i < nums.length; i++){
        var span = document.createElement('span');
        span.className = 'xball';
        var v = nums[i];
        span.textContent = (v < 10 ? '0' + v : String(v));
        row.appendChild(span);
      }

      extraWrap.appendChild(row);
    } catch (_){}
  }

  function repairRenderedPicksOnce(){
    ensureMainRendered();
    ensureExtraRendered();
  }

  // Repair when ML declares completion or legacy "done" fires
  try {
    window.addEventListener('skai:ml:done', function(){
      // Apply blend (ML ⊕ Skip & Hit) before rendering pills, if configured
      try {
        if (typeof window.SKAI_applyBlendFromGlobals === 'function') {
          window.SKAI_applyBlendFromGlobals();
        }
      } catch (_){}

      repairRenderedPicksOnce();
      SKAI_updateUXState({ phase:'complete', message:'Training complete', detail:'Picks ready' });
      resetRunCooldown();
    }, false);

    window.addEventListener('skai:done', function(){
      // Legacy completion path – safe to attempt blend here as well (no-op if not applicable)
      try {
        if (typeof window.SKAI_applyBlendFromGlobals === 'function') {
          window.SKAI_applyBlendFromGlobals();
        }
      } catch (_){}

      repairRenderedPicksOnce();
      SKAI_updateUXState({ phase:'complete', message:'Analysis complete', detail:'Picks ready' });
      resetRunCooldown();
    }, false);
  } catch (_){}

  // Fallback: if page loads with results but no events fired
  try {
    var onReadyRepair = function(){
      try {
        setTimeout(repairRenderedPicksOnce, 800);
      } catch (_){}
    };
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', onReadyRepair, false);
    } else {
      onReadyRepair();
    }
  } catch (_){}

  /* -------------------- 5) Lifecycle / error UX integration ---------------- */

  try {
    window.addEventListener('skai:ml:start', function(){
      try { window.__SKAI_ML_STARTED_AT__ = Date.now(); } catch(_){}
      try { window.__SKAI_LAST_EPOCH__ = -1; } catch(_){}
      SKAI_updateUXState({
        phase:   'training',
        message: 'Training model',
        detail:  'Training in progress'
      });
    }, false);

    window.addEventListener('skai:autotune:start', function(){
      SKAI_updateUXState({
        phase:   'autotune',
        message: 'Auto-Tune running',
        detail:  'Finding a strong Skip & Hit window'
      });
    }, false);

    window.addEventListener('skai:autotune:done', function(){
      SKAI_updateUXState({
        phase:   'training',
        message: 'Preparing training',
        detail:  'Preparing AI training with tuned window'
      });
    }, false);

    window.addEventListener('skai:analysis-stop', function(e){
      var reason = 'error';
      try {
        if (e && e.detail && e.detail.reason) {
          reason = String(e.detail.reason);
        }
      } catch (_){}
      resetRunCooldown();
      SKAI_updateUXState({
        phase:   'error',
        message: 'Analysis stopped',
        detail:  reason
      });
    }, false);
  } catch (_){}

  // When user returns to the tab, clear any stuck cooldown if not running
  try {
    document.addEventListener('visibilitychange', function(){
      try {
        if (document.visibilityState === 'visible' && window.__SKAI_RUNNING__ !== true) {
          window.__SKAI_START_COOLDOWN__ = false;
        }
      } catch (_){}
    }, false);
  } catch (_){}

  /* ---------------------- 6) Conservative progress watchdog ---------------- */

  (function(){
    var watchdogId = null;

    function clearWatchdog(){
      if (watchdogId) {
        try { clearInterval(watchdogId); } catch(_){}
        watchdogId = null;
      }
    }

    // Start watchdog when ML starts
    try {
      window.addEventListener('skai:ml:start', function(){
        clearWatchdog();

        var lastEpochSeen = (typeof window.__SKAI_LAST_EPOCH__ === 'number')
          ? window.__SKAI_LAST_EPOCH__
          : -1;
        var lastChangeAt = Date.now();

        watchdogId = setInterval(function(){
          try {
            // If run is no longer active, stop watching
            if (window.__SKAI_RUNNING__ !== true) {
              clearWatchdog();
              return;
            }

            var curEpoch = (typeof window.__SKAI_LAST_EPOCH__ === 'number')
              ? window.__SKAI_LAST_EPOCH__
              : lastEpochSeen;

            if (curEpoch !== lastEpochSeen) {
              lastEpochSeen = curEpoch;
              lastChangeAt  = Date.now();
              return;
            }

            var elapsed = Date.now() - lastChangeAt;
            // Only act if we have visible results AND epochs have been stuck
            if (elapsed > 15000) {
              var hasMain  = document.querySelectorAll('.skai-ai-main .nball').length > 0;
              var hasExtra = document.querySelectorAll('#aiExtraPredictionContainer .xball').length > 0;

              if (hasMain || hasExtra) {
                var P = getProgressAPI();
                try {
                  P.set(100, 'Training complete');
                  P.show('Picks ready');
                } catch (_){}

                try {
                  if (window.skaiProgress && typeof window.skaiProgress.done === 'function') {
                    window.skaiProgress.done('Analysis complete');
                  }
                } catch (_){}

                resetRunCooldown();
              }

              clearWatchdog();
            }
          } catch (_){}
        }, 3000);
      }, false);

      window.addEventListener('skai:ml:done', clearWatchdog, false);
      window.addEventListener('skai:analysis-stop', clearWatchdog, false);
    } catch (_){}
  })();

})();
</script>
<script>
document.addEventListener('DOMContentLoaded', function () {
  var adv  = document.getElementById('skai-advanced');
  var btn  = document.getElementById('skai-adv-toggle');
  var body = document.getElementById('skai-adv-body');

  if (!adv || !btn || !body) return;

  // CHG: Only force collapsed state if an explicit flag is set.
  // Default behavior is now driven by your HTML/CSS or other SKAI UX rules.
  if (window.SKAI_FORCE_ADV_COLLAPSE === true) {
    adv.classList.add('skai-collapsed');
    btn.setAttribute('aria-expanded', 'false');
    body.style.display = 'none';

    var carat = btn.querySelector('.carat');
    if (carat) {
      carat.style.transform = 'rotate(-90deg)';
    }
  }
});
</script>
<script>
// SKAI: disable Run Analysis for non-authorized users but keep panel visible
document.addEventListener('DOMContentLoaded', function () {
  try {
    if (window.SKAI_CAN_RUN) return; // members: normal behavior

    var btn = document.getElementById('updateButton');
    if (!btn) return;

    // Visually and semantically disable the button
    btn.setAttribute('disabled', 'disabled');
    btn.setAttribute('aria-disabled', 'true');
    btn.classList.add('skai-button-disabled');

    // One-line note under the button for guests / non-members
    var noteId = 'skai-locked-note';
    if (!document.getElementById(noteId)) {
      var note = document.createElement('p');
      note.id = noteId;
      note.className = 'skai-locked-note';
      note.textContent = 'Members only: log in to run SKAI and generate AI-ranked number sets for this lottery.';
      note.style.marginTop = '8px';
      note.style.fontSize = '0.85rem';
      note.style.lineHeight = '1.4';
      note.style.color = '#6b7280';

      if (btn.parentNode) {
        // Insert right after the button
        if (btn.nextSibling) {
          btn.parentNode.insertBefore(note, btn.nextSibling);
        } else {
          btn.parentNode.appendChild(note);
        }
      }
    }

    // Capture clicks before any other handler and redirect to signup modal
    btn.addEventListener('click', function (ev) {
      ev.preventDefault();
      ev.stopPropagation();

      var modal = document.getElementById('signupModal');
      if (modal) {
        modal.style.display = 'flex';
      }

      var title = document.getElementById('signupTitle');
      if (title) {
        title.textContent = 'Unlock SKAI Predictions';
      }
    }, true); // capture phase to preempt downstream listeners
  } catch (_){}
}); // END DOMContentLoaded

  // CHG: Rolling-origin backtest runner (ES5-safe)
  // Console usage:
  //   SKAI_runBacktest({ start: 50, end: 500, step: 1, topK: 20, keepSeries: false })
  // Returns summary metrics for tuning: avgTopKHits, avgLogLoss, avgBrier
  // CHG: Helper to return current Top-K ranked numbers + explanation (UX/debug)
  // Console usage: SKAI_getTopExplain(20)
  window.SKAI_getTopExplain = window.SKAI_getTopExplain || function(k){
    k = (k != null) ? (k|0) : 20;
    if (k < 1) k = 1;
    if (!window.SKAI_lastBlended || !window.SKAI_lastBlended.length) return [];
    var out = [];
    for (var i=0; i<k && i<window.SKAI_lastBlended.length; i++){
      out.push(window.SKAI_lastBlended[i]);
    }
    return out;
  };

  // CHG: Pretty explanation lines for UX (console now; UI later)
  // Console usage: SKAI_explainTop(20)
  window.SKAI_explainTop = window.SKAI_explainTop || function(k){
    var rows = window.SKAI_getTopExplain(k);
    var out = [];
    for (var i=0; i<rows.length; i++){
      var r = rows[i] || {};
      var e = r.explain || {};
      var num = r.num;

      // Plain-English interpretation:
      // - aiAdj: AI belief after temperature policy
      // - prior: Skip/Hit learned prior (0..1 normalized)
      // - bias: multiplicative effect from prior
      // - tsFactor: exploration factor from uncertainty
      var line =
        "Num " + num +
        " | AI=" + (isFinite(e.ai) ? e.ai.toFixed(4) : "n/a") +
        " | AI(adj)=" + (isFinite(e.aiAdj) ? e.aiAdj.toFixed(4) : "n/a") +
        " | Prior=" + (isFinite(e.prior) ? e.prior.toFixed(4) : "n/a") +
        " | Bias=" + (isFinite(e.bias) ? e.bias.toFixed(4) : "n/a") +
        " | TS=" + (isFinite(e.tsFactor) ? e.tsFactor.toFixed(4) : "n/a") +
        " | Score=" + (isFinite(r.score) ? r.score.toFixed(6) : "n/a");
      out.push(line);
    }
    return out;
  };

  window.SKAI_runBacktest = window.SKAI_runBacktest || function(opts){
    opts = opts || {};
    var startIdx = (opts.start != null) ? (opts.start|0) : 50;
    var endIdx   = (opts.end   != null) ? (opts.end|0)   : 0;
    var step     = (opts.step  != null) ? (opts.step|0)  : 1;
    var topK     = (opts.topK  != null) ? (opts.topK|0)  : 20;

    var draws = (typeof rawDraws !== 'undefined' && rawDraws) ? rawDraws : (window.SKAIRawDraws || null);
    if (!draws || !draws.length) {
      return { ok:false, error:"No draw history found (rawDraws or window.SKAIRawDraws missing)." };
    }

    if (endIdx <= 0 || endIdx > draws.length - 1) endIdx = draws.length - 1;
    if (startIdx < 5) startIdx = 5;
    if (step < 1) step = 1;
    if (topK < 1) topK = 1;

    var nSteps = 0;
    var sumTopKHits = 0;
    var sumLogLoss = 0;
    var sumBrier = 0;

    var keepSeries = !!opts.keepSeries;
    var series = keepSeries ? [] : null;

    var s = (typeof settings !== 'undefined' && settings) ? settings : (opts.settings || {});
    var numsOf = window.skaiNumsOf || function(d){
      if (Array.isArray(d)) return d;
      if (d && Array.isArray(d.nums)) return d.nums;
      if (d && Array.isArray(d.numbers)) return d.numbers;
      return [];
    };

    for (var t = startIdx; t <= endIdx; t += step){
      var hist = draws.slice(0, t);

      if (window.buildSkaiCurrentVector) {
        window.buildSkaiCurrentVector(hist, s);
      }
      if (window.buildSkaiDataset) {
        window.buildSkaiDataset(hist, s);
      }

      var probs = window.SKAI_lastProbs;
      var priorVec = window.buildSkaiCurrentVector ? window.buildSkaiCurrentVector(hist, s) : null;
      var prior = (priorVec && priorVec.skipPrior) ? priorVec.skipPrior : [];
      var dom = Math.max(prior.length, (probs && probs.length) ? probs.length : 0);
      if (!dom) continue;

      var scored = [];
      for (var i=0;i<dom;i++){
        var num = (s && s.allowZero) ? i : (i + 1);
        var p = (probs && isFinite(probs[i])) ? probs[i] : 0;
        var pr = (prior && isFinite(prior[i])) ? prior[i] : 0;
        var bias = Math.exp(((s && s.wSH != null) ? Number(s.wSH) : 1) * (pr - 0.5));
        var base = (p > 0 ? p : 1e-9) * bias;
        scored.push({num:num, score:base, p:p});
      }
      scored.sort(function(a,b){ return b.score - a.score; });

      var top = [];
      for (var k=0;k<topK && k<scored.length;k++) top.push(scored[k].num);

      var win = numsOf(draws[t]) || [];
      var hk = window.skaiTopKHits(top, win);
      sumTopKHits += hk;

      // Probabilistic proxies: treat each number as Bernoulli hit/no-hit
      if (probs){
        for (var i2=0;i2<dom;i2++){
          var num2 = (s && s.allowZero) ? i2 : (i2 + 1);
          var y = 0;
          for (var j2=0;j2<win.length;j2++){ if (String(win[j2]) === String(num2)) { y=1; break; } }
          var p2 = (probs && isFinite(probs[i2])) ? probs[i2] : 0;
          sumLogLoss += window.skaiLogLoss(p2, y);
          sumBrier   += window.skaiBrier(p2, y);
        }
      }

      nSteps++;
      if (keepSeries) series.push({t:t, topKHits:hk});
    }

    var out = {
      ok:true,
      steps:nSteps,
      avgTopKHits:(nSteps>0 ? (sumTopKHits/nSteps) : 0),
      avgLogLoss:(nSteps>0 ? (sumLogLoss/nSteps) : 0),
      avgBrier:(nSteps>0 ? (sumBrier/nSteps) : 0)
    };

    // CHG: optional calibration stats (if requested)
    if (opts && opts.calibration) {
      var binCount = (opts.binCount != null) ? (opts.binCount|0) : 10;
      var calib = window.skaiCalibBins(binCount);

      // Replay loop quickly using stored series settings (best-effort)
      // Note: This uses the same probs/prior proxy method as the backtest itself.
      for (var t2 = startIdx; t2 <= endIdx; t2 += step){
        var hist2 = draws.slice(0, t2);

        if (window.buildSkaiCurrentVector) window.buildSkaiCurrentVector(hist2, s);
        if (window.buildSkaiDataset) window.buildSkaiDataset(hist2, s);

        var probs2 = window.SKAI_lastProbs;
        if (!probs2) continue;

        var win2 = numsOf(draws[t2]) || [];
        var dom2 = probs2.length;

        for (var i3=0;i3<dom2;i3++){
          var num3 = (s && s.allowZero) ? i3 : (i3 + 1);
          var y3 = 0;
          for (var j3=0;j3<win2.length;j3++){ if (String(win2[j3]) === String(num3)) { y3=1; break; } }
          var p3 = isFinite(probs2[i3]) ? probs2[i3] : 0;
          calib.add(p3, y3);
        }
      }

      out.calibration = calib.summary();
    }

    if (keepSeries) out.series = series;
    return out;
  };


</script>